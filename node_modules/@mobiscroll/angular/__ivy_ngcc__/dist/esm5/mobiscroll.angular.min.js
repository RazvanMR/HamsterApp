/* eslint-disable */
import { Injectable, Directive, ElementRef, NgZone, Input as Input$1, Output, ViewContainerRef, EventEmitter, NgModule, ViewChild, Optional, Component, ContentChildren, ChangeDetectionStrategy, ChangeDetectorRef, ViewChildren, Injector, Inject, forwardRef, ContentChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgControl, FormsModule } from '@angular/forms';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
import * as ɵngcc2 from '@angular/common';

var _c0 = ["initElement"];
function MbscInput_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 5);
} }
function MbscInput_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.errorMessage);
} }
var _c1 = ["*"];
function MbscCalendarComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscColorComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscDateComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscTimeComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscDatetimeComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
var _c2 = ["rootElement"];
function MbscTextarea_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function MbscDropdown_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function MbscCheckbox_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function MbscSwitch_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.errorMessage);
} }
function MbscRadio_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);
} }
function MbscSegmented_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span");
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap("mbsc-ic mbsc-ic-" + ctx_r1.icon);
} }
var _c3 = ["inputElements"];
function MbscSlider_input_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 2, 3);
    ɵngcc0.ɵɵlistener("blur", function MbscSlider_input_2_Template_input_blur_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onTouch($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var v_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r0.disabled);
    ɵngcc0.ɵɵattribute("value", ctx_r0.dummyArray.length > 1 && ctx_r0.initialValue ? ctx_r0.initialValue[v_r1] : ctx_r0.initialValue)("data-step-labels", ctx_r0.dataStepLabels)("data-template", ctx_r0.valueTemplate)("data-tooltip", ctx_r0.tooltip ? "true" : null)("data-highlight", ctx_r0.highlight)("data-live", ctx_r0.live)("data-icon", ctx_r0.icon ? ctx_r0.icon : null)("data-val", ctx_r0.val ? ctx_r0.val : null)("data-label-style", ctx_r0.labelStyle)("data-input-style", ctx_r0.inputStyle)("name", ctx_r0.name)("max", ctx_r0.max !== undefined ? ctx_r0.max : null)("min", ctx_r0.min !== undefined ? ctx_r0.min : null)("step", ctx_r0.step !== undefined ? ctx_r0.step : null);
} }
var _c4 = ["itemWrapper"];
function MbscImageComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.name)("theme", ctx_r0.theme)("disabled", ctx_r0.disabled)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign)("placeholder", ctx_r0.placeholder)("controlNg", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.label, " ");
} }
function MbscMeasurementComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscTemperatureComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscDistanceComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscSpeedComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscForceComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscMassComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumberComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumpadComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumpadDecimalComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumpadDateComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumpadTimeComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscNumpadTimespanComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscRangeComponent_mbsc_input_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
var _c5 = [[["mbsc-range-start"]], [["mbsc-range-end"]], "*"];
var _c6 = ["mbsc-range-start", "mbsc-range-end", "*"];
function MbscScrollerComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscSelectComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscTimerComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscTimespanComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
function MbscTreelistComponent_mbsc_input_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mbsc-input", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx_r0.name)("theme", ctx_r0.theme)("themeVariant", ctx_r0.themeVariant)("label-style", ctx_r0.labelStyle)("input-style", ctx_r0.inputStyle)("disabled", ctx_r0.disabled)("dropdown", ctx_r0.dropdown)("placeholder", ctx_r0.placeholder)("error", ctx_r0.error)("errorMessage", ctx_r0.errorMessage)("icon", ctx_r0.inputIcon)("icon-align", ctx_r0.iconAlign);
} }
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var mobiscroll = mobiscroll || {},
    util = {},
    calendars = {};

var os,
    vers,
    majorVersion,
    minorVersion,
    version = [],
    isBrowser = typeof window !== 'undefined',
    isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
    userAgent = isBrowser ? navigator.userAgent : '',
    platform = isBrowser ? navigator.platform : '',
    maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
    isSafari = /Safari/.test(userAgent),
    device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
    raf = isBrowser && window.requestAnimationFrame || function (func) {
  return setTimeout(func, 20);
},
    rafc = isBrowser && window.cancelAnimationFrame || function (id) {
  clearTimeout(id);
};

if (/Android/i.test(device)) {
  os = 'android';
  vers = userAgent.match(/Android\s+([\d.]+)/i);

  if (vers) {
    version = vers[0].replace('Android ', '').split('.');
  }
} else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
  // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
  // so 'iPad' is no longer present in the user agent string.
  // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
  // maxTouchPoints is needed to exclude desktop Mac OS X.
  os = 'ios';
  vers = userAgent.match(/OS\s+([\d_]+)/i);

  if (vers) {
    version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
  }
} else if (/Windows Phone/i.test(device)) {
  os = 'wp';
} else if (/Windows|MSIE/i.test(device)) {
  os = 'windows';
}

majorVersion = version[0];
minorVersion = version[1];

function testProps(props) {
  var i;

  for (i in props) {
    if (mod[props[i]] !== undefined) {
      return true;
    }
  }

  return false;
}

function testPrefix() {
  var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
      p;

  for (p in prefixes) {
    if (testProps([prefixes[p] + 'Transform'])) {
      return '-' + prefixes[p].toLowerCase() + '-';
    }
  }

  return '';
}

function testTouch(e, elm) {
  if (e.type == 'touchstart') {
    elm.__mbscTouched = 1;
  } else if (elm.__mbscTouched) {
    delete elm.__mbscTouched;
    return false;
  }

  return true;
}

function getPosition(t, vertical) {
  var prefixes = ['t', 'webkitT', 'MozT', 'OT', 'msT'],
      style = getComputedStyle(t[0]),
      i = 0,
      matrix,
      px,
      v;

  while (!matrix && i < prefixes.length) {
    v = prefixes[i];

    if (style[v + 'ransform'] !== undefined) {
      matrix = style[v + 'ransform'];
    }

    i++;
  }

  matrix = matrix.split(')')[0].split(', ');
  px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];
  return px;
}

function getTextColor(color) {
  if (color) {
    // Cache calculated text colors, because it is slow
    if (textColors[color]) {
      return textColors[color];
    }

    var ctx = canvas && canvas.getContext('2d');

    if (!ctx) {
      return '#fff';
    } // Use canvas element, since it does not require DOM append


    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    var rgb = ctx.getImageData(0, 0, 1, 1).data;
    var delta = +rgb[0] * 0.299 + +rgb[1] * 0.587 + +rgb[2] * 0.114;
    var textColor = delta < 130 ? '#fff' : '#000';
    textColors[color] = textColor;
    return textColor;
  }
}

function scrollStep(el, startTime, from, to, callback) {
  var elapsed = Math.min(1, (new Date() - startTime) / 468),
      eased = 0.5 * (1 - Math.cos(Math.PI * elapsed)),
      current = from + (to - from) * eased;
  el.scrollTop = current;

  if (current !== to) {
    raf(function () {
      scrollStep(el, startTime, from, to, callback);
    });
  } else if (callback) {
    callback();
  }
}

function smoothScroll(el, to, prevAnim, callback) {
  if (prevAnim) {
    el.scrollTop = to;

    if (callback) {
      callback();
    }
  } else {
    scrollStep(el, new Date(), el.scrollTop, to, callback);
  }
}

function listen(el, event, handler, opt) {
  if (el) {
    el.addEventListener(event, handler, opt);
  }
}

function unlisten(el, event, handler, opt) {
  if (el) {
    el.removeEventListener(event, handler, opt);
  }
}

function matches(element, selector) {
  if (!selector || !element || element.nodeType !== 1) {
    return false;
  }

  var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
  return matchesSelector.call(element, selector);
}

function closest(el, target, selector) {
  while (target) {
    if (matches(target, selector)) {
      return target;
    }

    target = target !== el ? target.parentNode : null;
  }

  return null;
}

function trigger(elm, name, data) {
  var evt;

  try {
    evt = new CustomEvent(name, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
    evt.detail = data;
  }

  elm.dispatchEvent(evt);
}

function setFocusInvisible() {
  win.__mbscFocusVisible = false;
}

function setFocusVisible() {
  win.__mbscFocusVisible = true;
}

function addWindowFocus() {
  var focusCount = win.__mbscFocusCount || 0;

  if (focusCount === 0) {
    listen(win, 'mousedown', setFocusInvisible, true);
    listen(win, 'keydown', setFocusVisible, true);
  }

  win.__mbscFocusCount = ++focusCount;
}

function removeWindowFocus() {
  var focusCount = win.__mbscFocusCount || 0;
  win.__mbscFocusCount = --focusCount;

  if (win.__mbscFocusCount === 0) {
    unlisten(win, 'mousedown', setFocusInvisible);
    unlisten(win, 'keydown', setFocusVisible);
  }
}

var animEnd,
    canvas,
    mod,
    cssPrefix,
    hasGhostClick,
    hasTransition,
    isWebView,
    isWkWebView,
    jsPrefix,
    win,
    textColors = {};

if (isBrowser) {
  win = window;
  canvas = document.createElement('canvas');
  mod = document.createElement('modernizr').style;
  cssPrefix = testPrefix();
  jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
  animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
  hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
  // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
  // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
  // (keyboard appears, but the cursor is not in the input).

  isWebView = os === 'ios' && !isSafari;
  isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
  hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
}

var cssNumber = {
  'column-count': 1,
  'columns': 1,
  'font-weight': 1,
  'line-height': 1,
  'opacity': 1,
  'z-index': 1,
  'zoom': 1
},
    propMap = {
  'readonly': 'readOnly'
},
    emptyArray = [],
    _slice = Array.prototype.slice;

function isFunction(value) {
  return typeof value === "function";
}

function isObject(obj) {
  return typeof obj === "object";
}

function likeArray(obj) {
  return typeof obj.length == 'number';
}

function camelize(str) {
  return str.replace(/-+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  });
}

function extend(target, source, deep) {
  for (var key in source) {
    if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
      if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
        target[key] = {};
      }

      extend(target[key], source[key], deep);
    } else if (source[key] !== undefined) {
      target[key] = source[key];
    }
  }
}

function dasherize(str) {
  return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
}

function maybeAddPx(name, value) {
  return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
}

var Dom = function () {
  var Dom = function Dom(arr) {
    var _this = this,
        i = 0; // Create array-like object


    for (i = 0; i < arr.length; i++) {
      _this[i] = arr[i];
    }

    _this.length = arr.length; // Return collection with methods

    return $(this);
  };

  var $ = function $(selector, context) {
    var arr = [],
        i = 0;

    if (selector && !context) {
      if (selector instanceof Dom) {
        return selector;
      }
    }

    if (isFunction(selector)) {
      return $(document).ready(selector);
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els, tempParent, html;
        selector = html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i++) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [document.getElementById(selector.split('#')[1])];
          } else {
            if (context instanceof Dom) {
              context = context[0];
            } // Other selectors


            els = (context || document).querySelectorAll(selector);
          }

          for (i = 0; i < els.length; i++) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } // Node/element
      else if (selector.nodeType || selector === window || selector === document) {
          arr.push(selector);
        } //Array of elements or instance of Dom
        else if (selector.length > 0 && selector[0].nodeType) {
            for (i = 0; i < selector.length; i++) {
              arr.push(selector[i]);
            }
          } else if ($.isArray(selector)) {
            arr = selector;
          }
    }

    return new Dom(arr);
  };

  Dom.prototype = {
    ready: function ready(callback) {
      if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
        callback($);
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          callback($);
        }, false);
      }

      return this;
    },
    concat: emptyArray.concat,
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },
    // Classes and attriutes
    // NOTE: element.classList attribure is not supported on android 2.3!!!
    addClass: function addClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.add(classes[i]);
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.remove(classes[i]);
          }
        }
      }

      return this;
    },
    hasClass: function hasClass(className) {
      return this[0] ? this[0].classList.contains(className) : false;
    },
    toggleClass: function toggleClass(className) {
      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined') {
            this[j].classList.toggle(classes[i]);
          }
        }
      }

      return this;
    },
    closest: function closest(selector, context) {
      var node = this[0],
          collection = false;

      if (isObject(selector)) {
        collection = $(selector);
      }

      while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
        node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
      }

      return $(node);
    },
    attr: function attr(attrs, value) {
      var attr;

      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this.length) {
          attr = this[0].getAttribute(attrs);
          return attr || attr === '' ? attr : undefined;
        }
      } else {
        // Set attrs
        for (var i = 0; i < this.length; i++) {
          if (arguments.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      }
    },
    removeAttr: function removeAttr(attr) {
      for (var i = 0; i < this.length; i++) {
        this[i].removeAttribute(attr);
      }

      return this;
    },
    prop: function prop(props, value) {
      props = propMap[props] || props;

      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        return this[0] ? this[0][props] : undefined;
      } else {
        // Set props
        for (var i = 0; i < this.length; i++) {
          this[i][props] = value;
        }

        return this;
      }
    },
    val: function val(value) {
      if (typeof value === 'undefined') {
        if (this.length && this[0].multiple) {
          return $.map(this.find('option:checked'), function (v) {
            return v.value;
          });
        }

        return this[0] ? this[0].value : undefined;
      }

      if (this.length && this[0].multiple) {
        $.each(this[0].options, function () {
          this.selected = value.indexOf(this.value) != -1;
        });
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].value = value;
        }
      }

      return this;
    },
    //Events
    on: function on(eventName, targetSelector, listener, capture) {
      var boundListener,
          elm,
          event,
          events = eventName.split(' '),
          i,
          j;

      function handleLiveEvent(e) {
        var target = e.target;

        while (target) {
          if ($(target).is(targetSelector)) {
            listener.call(target, e);
          }

          target = target !== this ? target.parentNode : null;
        }
      }

      function handleNamespaces(el, name, listener, capture) {
        var namespace = name.split('.');

        if (!el.DomNameSpaces) {
          el.DomNameSpaces = [];
        }

        el.DomNameSpaces.push({
          namespace: namespace[1],
          event: namespace[0],
          listener: listener,
          capture: capture
        });
        el.addEventListener(namespace[0], listener, capture);
      }

      for (i = 0; i < this.length; i++) {
        elm = this[i];

        if (isFunction(targetSelector) || targetSelector === false) {
          // Usual events
          if (isFunction(targetSelector)) {
            capture = listener || false;
            listener = targetSelector;
          }

          for (j = 0; j < events.length; j++) {
            event = events[j]; // check for namespaces

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, listener, capture);
            } else {
              elm.addEventListener(event, listener, capture);
            }
          }
        } else {
          // Live events
          boundListener = handleLiveEvent.bind(elm);

          for (j = 0; j < events.length; j++) {
            event = events[j];

            if (!elm.DomLiveListeners) {
              elm.DomLiveListeners = [];
            }

            elm.DomLiveListeners.push({
              listener: listener,
              liveListener: boundListener
            });

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, boundListener, capture);
            } else {
              elm.addEventListener(event, boundListener, capture);
            }
          }
        }
      }

      return this;
    },
    off: function off(eventName, targetSelector, listener, capture) {
      var elm,
          event,
          events,
          i,
          j,
          k,
          liveListeners,
          that = this;

      function removeEvents(event) {
        var el,
            i,
            j,
            item,
            nameSpaces,
            parts = event.split('.'),
            name = parts[0],
            ns = parts[1];

        for (i = 0; i < that.length; ++i) {
          el = that[i];
          nameSpaces = el.DomNameSpaces;

          if (nameSpaces) {
            for (j = 0; j < nameSpaces.length; ++j) {
              item = nameSpaces[j];

              if (item.namespace == ns && (item.event == name || !name)) {
                el.removeEventListener(item.event, item.listener, item.capture);
                item.removed = true;
              }
            } // remove the events from the DomNameSpaces array


            for (j = nameSpaces.length - 1; j >= 0; --j) {
              if (nameSpaces[j].removed) {
                nameSpaces.splice(j, 1);
              }
            }
          }
        }
      }

      events = eventName.split(' ');

      for (i = 0; i < events.length; i++) {
        event = events[i];

        for (j = 0; j < this.length; j++) {
          elm = this[j];
          liveListeners = elm.DomLiveListeners;

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            if (event.indexOf('.') === 0) {
              // remove namespace events
              removeEvents(event.substr(1));
            } else {
              elm.removeEventListener(event, listener, capture);
            }
          } else {
            // Live event
            if (liveListeners) {
              for (k = 0; k < liveListeners.length; k++) {
                if (liveListeners[k].listener === listener) {
                  elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                }
              }
            }

            if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
              removeEvents(event);
            }
          }
        }
      }

      return this;
    },
    trigger: function trigger$1(eventName, eventData) {
      var events = eventName.split(' ');

      for (var i = 0; i < events.length; i++) {
        for (var j = 0; j < this.length; j++) {
          trigger(this[j], events[i], eventData);
        }
      }

      return this;
    },
    // Sizing/Styles
    width: function width(dim) {
      if (dim !== undefined) {
        return this.css('width', dim);
      }

      if (this[0] === window) {
        return window.innerWidth;
      } else if (this[0] === document) {
        return document.documentElement.scrollWidth;
      } else {
        return this.length > 0 ? parseFloat(this.css('width')) : null;
      }
    },
    height: function height(dim) {
      if (dim !== undefined) {
        return this.css('height', dim);
      }

      if (this[0] === window) {
        return window.innerHeight;
      } else if (this[0] === document) {
        var body = document.body,
            html = document.documentElement;
        return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      } else {
        return this.length > 0 ? parseFloat(this.css('height')) : null;
      }
    },
    innerWidth: function innerWidth() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerWidth) {
          return this[0].innerWidth;
        } else {
          var size = this[0].offsetWidth,
              sides = ['left', 'right'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    innerHeight: function innerHeight() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerHeight) {
          return this[0].innerHeight;
        } else {
          var size = this[0].offsetHeight,
              sides = ['top', 'bottom'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    offset: function offset() {
      if (this.length > 0) {
        var el = this[0],
            box = el.getBoundingClientRect(),
            doc = document.documentElement;
        return {
          top: box.top + window.pageYOffset - doc.clientTop,
          left: box.left + window.pageXOffset - doc.clientLeft
        };
      }
    },
    hide: function hide() {
      for (var i = 0; i < this.length; i++) {
        this[i].style.display = 'none';
      }

      return this;
    },
    show: function show() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].style.display == "none") {
          this[i].style.display = '';
        }

        if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
          this[i].style.display = 'block';
        }
      }

      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    styles: function styles() {
      return this[0] ? window.getComputedStyle(this[0], null) : undefined;
    },
    css: function css(property, value) {
      var i,
          key,
          element = this[0],
          css = '';

      if (arguments.length < 2) {
        if (!element) {
          return;
        }

        if (typeof property === 'string') {
          return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
        }
      }

      if (typeof property === 'string') {
        if (!value && value !== 0) {
          this.each(function () {
            this.style.removeProperty(dasherize(property));
          });
        } else {
          css = dasherize(property) + ":" + maybeAddPx(property, value);
        }
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) {
            for (i = 0; i < this.length; i++) {
              this[i].style.removeProperty(dasherize(key));
            }
          } else {
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
          }
        }
      }

      return this.each(function () {
        this.style.cssText += ';' + css;
      });
    },
    each: function each(callback) {
      for (var i = 0; i < this.length; i++) {
        if (callback.apply(this[i], [i, this[i]]) === false) {
          break;
        }
      }

      return this;
    },
    filter: function filter(callback) {
      var matchedItems = [];

      for (var i = 0; i < this.length; i++) {
        if (isFunction(callback)) {
          if (callback.call(this[i], i, this[i])) {
            matchedItems.push(this[i]);
          }
        } else if (matches(this[i], callback)) {
          matchedItems.push(this[i]);
        }
      }

      return new Dom(matchedItems);
    },
    html: function html(_html) {
      if (typeof _html === 'undefined') {
        return this[0] ? this[0].innerHTML : undefined;
      } else {
        this.empty();

        for (var i = 0; i < this.length; i++) {
          this[i].innerHTML = _html;
        }

        return this;
      }
    },
    text: function text(_text) {
      if (typeof _text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].textContent = _text;
        }

        return this;
      }
    },
    is: function is(selector) {
      return this.length > 0 && matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];

      if (isFunction(selector) && selector.call !== undefined) {
        this.each(function (idx) {
          if (!selector.call(this, idx)) {
            nodes.push(this);
          }
        });
      } else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

        if (isObject(excludes)) {
          excludes = $.map(excludes, function (el) {
            return el;
          });
        }

        this.each(function (i, el) {
          if (excludes.indexOf(el) < 0) {
            nodes.push(el);
          }
        });
      }

      return $(nodes);
    },
    indexOf: function indexOf(el) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === el) {
          return i;
        }
      }
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    eq: function eq(index) {
      if (typeof index === 'undefined') {
        return this;
      }

      var length = this.length,
          returnIndex;

      if (index > length - 1) {
        return new Dom([]);
      }

      if (index < 0) {
        returnIndex = length + index;
        return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
      }

      return new Dom([this[index]]);
    },
    append: function append(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }

      return this;
    },
    appendTo: function appendTo(parent) {
      $(parent).append(this);
      return this;
    },
    prepend: function prepend(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          } // this[i].insertAdjacentHTML('afterbegin', newChild);

        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    },
    prependTo: function prependTo(parent) {
      $(parent).prepend(this);
      return this;
    },
    insertBefore: function insertBefore(selector) {
      var before = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j++) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }

      return this;
    },
    insertAfter: function insertAfter(selector) {
      var after = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j++) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }

      return this;
    },
    next: function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].nextElementSibling) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    nextAll: function nextAll(selector) {
      var nextEls = [],
          el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.nextElementSibling) {
        var next = el.nextElementSibling;

        if (selector) {
          if ($(next).is(selector)) {
            nextEls.push(next);
          }
        } else {
          nextEls.push(next);
        }

        el = next;
      }

      return new Dom(nextEls);
    },
    prev: function prev(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].previousElementSibling) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    prevAll: function prevAll(selector) {
      var prevEls = [];
      var el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.previousElementSibling) {
        var prev = el.previousElementSibling;

        if (selector) {
          if ($(prev).is(selector)) {
            prevEls.push(prev);
          }
        } else {
          prevEls.push(prev);
        }

        el = prev;
      }

      return new Dom(prevEls);
    },
    parent: function parent(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) {
              parents.push(this[i].parentNode);
            }
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $($.unique(parents));
    },
    parents: function parents(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        var parent = this[i].parentNode;

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) {
              parents.push(parent);
            }
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $($.unique(parents));
    },
    find: function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i++) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j++) {
          foundElements.push(found[j]);
        }
      }

      return new Dom(foundElements);
    },
    children: function children(selector) {
      var children = [];

      for (var i = 0; i < this.length; i++) {
        var childNodes = this[i].childNodes;

        for (var j = 0; j < childNodes.length; j++) {
          if (!selector) {
            if (childNodes[j].nodeType === 1) {
              children.push(childNodes[j]);
            }
          } else {
            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }
      }

      return new Dom($.unique(children));
    },
    remove: function remove() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode) {
          this[i].parentNode.removeChild(this[i]);
        }
      }

      return this;
    },
    add: function add() {
      var dom = this;
      var i, j;

      for (i = 0; i < arguments.length; i++) {
        var toAdd = $(arguments[i]);

        for (j = 0; j < toAdd.length; j++) {
          dom[dom.length] = toAdd[j];
          dom.length++;
        }
      }

      return dom;
    },
    before: function before(elm) {
      $(elm).insertBefore(this);
      return this;
    },
    after: function after(elm) {
      $(elm).insertAfter(this);
      return this;
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) {
        return;
      }

      var hasScrollTop = 'scrollTop' in this[0];

      if (value === undefined) {
        return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      }

      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) {
        return;
      }

      var hasScrollLeft = 'scrollLeft' in this[0];

      if (value === undefined) {
        return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      }

      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    contents: function contents() {
      return this.map(function (i, v) {
        return _slice.call(v.childNodes);
      });
    },
    nextUntil: function nextUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !n.filter(selector).length) {
        array.push(n[0]);
        n = n.next();
      }

      return $(array);
    },
    prevUntil: function prevUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !$(n).filter(selector).length) {
        array.push(n[0]);
        n = n.prev();
      }

      return $(array);
    },
    detach: function detach() {
      return this.remove();
    }
  }; // Link to prototype

  $.fn = Dom.prototype;
  return $;
}(); // Export to local scope


var $ = Dom; // Export to mobiscroll

mobiscroll.$ = Dom; // DOM Library Utilites

$.inArray = function (elem, array, i) {
  return emptyArray.indexOf.call(array, elem, i);
};

$.extend = function (target) {
  var deep,
      args = _slice.call(arguments, 1);

  if (typeof target == 'boolean') {
    deep = target;
    target = args.shift();
  }

  target = target || {};
  args.forEach(function (arg) {
    extend(target, arg, deep);
  });
  return target;
};

$.isFunction = isFunction;

$.isArray = function (arr) {
  return Object.prototype.toString.apply(arr) === '[object Array]';
};

$.isPlainObject = function (obj) {
  return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
};

$.each = function (obj, callback) {
  var i, prop;

  if (!isObject(obj) || !callback) {
    return;
  }

  if ($.isArray(obj) || obj instanceof Dom) {
    // Array
    for (i = 0; i < obj.length; i++) {
      if (callback.call(obj[i], i, obj[i]) === false) {
        break;
      }
    }
  } else {
    // Object
    for (prop in obj) {
      // eslint-disable-next-line no-prototype-builtins
      if (obj.hasOwnProperty(prop) && prop !== 'length') {
        if (callback.call(obj[prop], prop, obj[prop]) === false) {
          break;
        }
      }
    }
  }

  return this;
};

$.unique = function (arr) {
  var unique = [];

  for (var i = 0; i < arr.length; i++) {
    if (unique.indexOf(arr[i]) === -1) {
      unique.push(arr[i]);
    }
  }

  return unique;
};

$.map = function (elements, callback) {
  var value,
      values = [],
      i,
      key;

  if (likeArray(elements)) {
    for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);

      if (value !== null) {
        values.push(value);
      }
    }
  } else {
    for (key in elements) {
      value = callback(elements[key], key);

      if (value !== null) {
        values.push(value);
      }
    }
  }

  return values.length > 0 ? $.fn.concat.apply([], values) : values;
};

function noop() {}

function objectToArray(obj) {
  var arr = [],
      i;

  for (i in obj) {
    arr.push(obj[i]);
  }

  return arr;
}

function arrayToObject(arr) {
  var obj = {},
      i;

  if (arr) {
    for (i = 0; i < arr.length; i++) {
      obj[arr[i]] = arr[i];
    }
  }

  return obj;
}

function isNumeric(a) {
  return a - parseFloat(a) >= 0;
}

function isString(s) {
  return typeof s === 'string';
}

function constrain(val, min, max) {
  return Math.max(min, Math.min(val, max));
}

function pad(num, size) {
  num = num + '';
  size = size || 2;

  while (num.length < size) {
    num = '0' + num;
  }

  return num;
}

function throttle(fn, threshhold) {
  var last, timer;
  threshhold = threshhold || 100;
  return function () {
    var context = this,
        now = +new Date(),
        args = arguments;

    if (last && now < last + threshhold) {
      clearTimeout(timer);
      timer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  };
}

function vibrate(time) {
  if ('vibrate' in navigator) {
    navigator.vibrate(time || 50);
  }
}

function getPercent(v, min, max) {
  return (v - min) * 100 / (max - min);
}

function getBoolAttr(attr, def, $elm) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v === 'true';
}

var tapped = 0;
var allowQuick;

function preventClick() {
  // Prevent ghost click
  tapped++;
  setTimeout(function () {
    tapped--;
  }, 500);
}

function triggerClick(ev, control) {
  // Prevent duplicate triggers on the same element
  // e.g. a form checkbox inside a listview item
  if (control.mbscClick) {
    return;
  }

  var touch = (ev.originalEvent || ev).changedTouches[0],
      evt = document.createEvent('MouseEvents');
  evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  evt.isMbscTap = true; // Prevent ionic to bust our click
  // This works for Ionic 1 - 3, not sure about 4

  evt.isIonicTap = true; // This will allow a click fired together with this click
  // We need this, because clicking on a label will trigger a click
  // on the associated input as well, which should not be busted

  allowQuick = true;
  control.mbscChange = true;
  control.mbscClick = true;
  control.dispatchEvent(evt);
  allowQuick = false; // Prevent ghost click

  preventClick();
  setTimeout(function () {
    delete control.mbscClick;
  });
}

function getCoord(e, c, page) {
  var ev = e.originalEvent || e,
      prop = (page ? 'page' : 'client') + c; // Multi touch support

  if (ev.targetTouches && ev.targetTouches[0]) {
    return ev.targetTouches[0][prop];
  }

  if (ev.changedTouches && ev.changedTouches[0]) {
    return ev.changedTouches[0][prop];
  }

  return e[prop];
}

function getControlType($elm) {
  var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
  var elm = $elm[0];
  var role = $elm.attr('data-role');
  var type = $elm.attr('type') || elm.nodeName.toLowerCase();

  if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
    type = role;
  } else {
    for (var i = 0; i < attrs.length; i++) {
      if ($elm.is('[mbsc-' + attrs[i] + ']')) {
        type = attrs[i];
      }
    }
  }

  return type;
}

function activateControl(control, type, ev) {
  control.focus();

  if (/(button|submit|checkbox|switch|radio)/.test(type)) {
    ev.preventDefault();
  }

  if (!/select/.test(type)) {
    triggerClick(ev, control);
  }
}

function tap(that, el, handler, prevent, tolerance, time) {
  var startX,
      startY,
      target,
      moved,
      startTime,
      $ = mobiscroll.$,
      $elm = $(el);
  tolerance = tolerance || 9;

  function onStart(ev) {
    if (!target) {
      // Can't always call preventDefault here, it kills page scroll
      // if (prevent) {
      //     ev.preventDefault();
      // }
      target = this;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      moved = false;
      startTime = new Date();
    }
  }

  function onMove(ev) {
    // If movement is more than 20px, don't fire the click event handler
    if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
      moved = true;
    }
  }

  function onEnd(ev) {
    if (target) {
      if (time && new Date() - startTime < 100 || !moved) {
        // ev.preventDefault();
        // handler.call(target, ev, that);
        triggerClick(ev, ev.target);
      } else {
        preventClick();
      }

      target = false;
    }
  }

  function onClick(ev) {
    if (prevent) {
      ev.preventDefault();
    } // If handler was not called on touchend, call it on click;


    handler.call(this, ev, that);
  }

  function onCancel() {
    target = false;
  }

  $elm.each(function (i, elm) {
    if (that.settings.tap) {
      listen(elm, 'touchstart', onStart, {
        passive: true
      });
      listen(elm, 'touchcancel', onCancel);
      listen(elm, 'touchmove', onMove, {
        passive: true
      });
      listen(elm, 'touchend', onEnd);
    }

    listen(elm, 'click', onClick);

    elm.__mbscOff = function () {
      unlisten(elm, 'touchstart', onStart, {
        passive: true
      });
      unlisten(elm, 'touchcancel', onCancel);
      unlisten(elm, 'touchmove', onMove, {
        passive: true
      });
      unlisten(elm, 'touchend', onEnd);
      unlisten(elm, 'click', onClick);
      delete elm.__mbscOff;
    };
  });
}

function tapOff($elm) {
  if ($elm && $elm[0] && $elm[0].__mbscOff) {
    $elm[0].__mbscOff();
  }
} // Prevent standard behaviour on body click


function bustClick(ev) {
  // Textarea needs the mousedown event
  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
    ev.stopPropagation();
    ev.preventDefault();
    return false;
  }
}

if (isBrowser) {
  ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
    document.addEventListener(ev, bustClick, true);
  });

  if (os == 'android' && majorVersion < 5) {
    document.addEventListener('change', function (ev) {
      if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
        ev.stopPropagation();
        ev.preventDefault();
      }

      delete ev.target.mbscChange;
    }, true);
  }
}

function adjustedDate(y, m, d, h, i, s, u) {
  var date = new Date(y, m, d, h || 0, i || 0, s || 0, u || 0);

  if (date.getHours() == 23 && (h || 0) === 0) {
    date.setHours(date.getHours() + 2);
  }

  return date;
}
/**
 * Format a date into a string value with a specified format.
 * @param {String} format Output format.
 * @param {Date} date Date to format.
 * @param {Object} [settings={}] Settings.
 * @return {String} Returns the formatted date string.
 */


function formatDate(format, date, settings) {
  if (!date) {
    return null;
  }

  var s = extend$1({}, dateTimeDefaults, settings),
      look = function look(m) {
    // Check whether a format character is doubled
    var n = 0;

    while (i + 1 < format.length && format.charAt(i + 1) == m) {
      n++;
      i++;
    }

    return n;
  },
      f1 = function f1(m, val, len) {
    // Format a number, with leading zero if necessary
    var n = '' + val;

    if (look(m)) {
      while (n.length < len) {
        n = '0' + n;
      }
    }

    return n;
  },
      f2 = function f2(m, val, s, l) {
    // Format a name, short or long as requested
    return look(m) ? l[val] : s[val];
  },
      i,
      year,
      output = '',
      literal = false;

  for (i = 0; i < format.length; i++) {
    if (literal) {
      if (format.charAt(i) == "'" && !look("'")) {
        literal = false;
      } else {
        output += format.charAt(i);
      }
    } else {
      switch (format.charAt(i)) {
        case 'd':
          output += f1('d', s.getDay(date), 2);
          break;

        case 'D':
          output += f2('D', date.getDay(), s.dayNamesShort, s.dayNames);
          break;

        case 'o':
          output += f1('o', (date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
          break;

        case 'm':
          output += f1('m', s.getMonth(date) + 1, 2);
          break;

        case 'M':
          output += f2('M', s.getMonth(date), s.monthNamesShort, s.monthNames);
          break;

        case 'y':
          year = s.getYear(date);
          output += look('y') ? year : (year % 100 < 10 ? '0' : '') + year % 100; //output += (look('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);

          break;

        case 'h':
          var h = date.getHours();
          output += f1('h', h > 12 ? h - 12 : h === 0 ? 12 : h, 2);
          break;

        case 'H':
          output += f1('H', date.getHours(), 2);
          break;

        case 'i':
          output += f1('i', date.getMinutes(), 2);
          break;

        case 's':
          output += f1('s', date.getSeconds(), 2);
          break;

        case 'a':
          output += date.getHours() > 11 ? s.pmText : s.amText;
          break;

        case 'A':
          output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();
          break;

        case "'":
          if (look("'")) {
            output += "'";
          } else {
            literal = true;
          }

          break;

        default:
          output += format.charAt(i);
      }
    }
  }

  return output;
} // --- TRIAL SERVER CODE END ---

/**
 * Extract a date from a string value with a specified format.
 * @param {String} format Input format.
 * @param {String} value String to parse.
 * @param {Object} [settings={}] Settings.
 * @return {Date} Returns the extracted date.
 */


function parseDate(format, value, settings) {
  var s = extend$1({}, dateTimeDefaults, settings),
      def = makeDate(s.defaultValue || new Date());

  if (!format || !value) {
    return def;
  } // If already a date object


  if (value.getTime) {
    return value;
  }

  value = typeof value == 'object' ? value.toString() : value + '';

  var shortYearCutoff = s.shortYearCutoff,
      year = s.getYear(def),
      month = s.getMonth(def) + 1,
      day = s.getDay(def),
      doy = -1,
      hours = def.getHours(),
      minutes = def.getMinutes(),
      seconds = 0,
      //def.getSeconds(),
  ampm = -1,
      literal = false,
      // Check whether a format character is doubled
  lookAhead = function lookAhead(match) {
    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) == match;

    if (matches) {
      iFormat++;
    }

    return matches;
  },
      getNumber = function getNumber(match) {
    // Extract a number from the string value
    lookAhead(match);
    var size = match == '@' ? 14 : match == '!' ? 20 : match == 'y' ? 4 : match == 'o' ? 3 : 2,
        digits = new RegExp('^\\d{1,' + size + '}'),
        num = value.substr(iValue).match(digits);

    if (!num) {
      return 0;
    }

    iValue += num[0].length;
    return parseInt(num[0], 10);
  },
      getName = function getName(match, s, l) {
    // Extract a name from the string value and convert to an index
    var names = lookAhead(match) ? l : s,
        i;

    for (i = 0; i < names.length; i++) {
      if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
        iValue += names[i].length;
        return i + 1;
      }
    }

    return 0;
  },
      checkLiteral = function checkLiteral() {
    iValue++;
  },
      iValue = 0,
      iFormat;

  for (iFormat = 0; iFormat < format.length; iFormat++) {
    if (literal) {
      if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
        literal = false;
      } else {
        checkLiteral();
      }
    } else {
      switch (format.charAt(iFormat)) {
        case 'd':
          day = getNumber('d');
          break;

        case 'D':
          getName('D', s.dayNamesShort, s.dayNames);
          break;

        case 'o':
          doy = getNumber('o');
          break;

        case 'm':
          month = getNumber('m');
          break;

        case 'M':
          month = getName('M', s.monthNamesShort, s.monthNames);
          break;

        case 'y':
          year = getNumber('y');
          break;

        case 'H':
          hours = getNumber('H');
          break;

        case 'h':
          hours = getNumber('h');
          break;

        case 'i':
          minutes = getNumber('i');
          break;

        case 's':
          seconds = getNumber('s');
          break;

        case 'a':
          ampm = getName('a', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;

        case 'A':
          ampm = getName('A', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;

        case "'":
          if (lookAhead("'")) {
            checkLiteral();
          } else {
            literal = true;
          }

          break;

        default:
          checkLiteral();
      }
    }
  }

  if (year < 100) {
    year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)) ? 0 : -100);
  }

  if (doy > -1) {
    month = 1;
    day = doy;

    do {
      var dim = 32 - new Date(year, month - 1, 32, 12).getDate();

      if (day > dim) {
        month++;
        day -= dim;
      }
    } while (day > dim);
  }

  hours = ampm == -1 ? hours : ampm && hours < 12 ? hours + 12 : !ampm && hours == 12 ? 0 : hours;
  var date = s.getDate(year, month - 1, day, hours, minutes, seconds);

  if (s.getYear(date) != year || s.getMonth(date) + 1 != month || s.getDay(date) != day) {
    return def; // Invalid date
  }

  return date;
}

function getDayDiff(d1, d2) {
  return Math.round((d2 - d1) / (24 * 60 * 60 * 1000));
}

function getDateOnly(d) {
  return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
}

function getDateStr(d) {
  return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();
}

function getISOString(d, parts) {
  var ret = '',
      time = '';

  if (d) {
    if (parts.h) {
      time += pad(d.getHours()) + ':' + pad(d.getMinutes());

      if (parts.s) {
        time += ':' + pad(d.getSeconds());
      }

      if (parts.u) {
        time += '.' + pad(d.getMilliseconds(), 3);
      }

      if (parts.tz) {
        time += parts.tz; // Just put what we got
      }
    }

    if (parts.y) {
      ret += d.getFullYear();

      if (parts.m) {
        ret += '-' + pad(d.getMonth() + 1);

        if (parts.d) {
          ret += '-' + pad(d.getDate());
        }

        if (parts.h) {
          ret += 'T' + time;
        }
      }
    } else if (parts.h) {
      ret = time;
    }
  }

  return ret;
}

function setISOParts(parsed, offset, parts) {
  var part,
      v,
      p = {
    y: 1,
    m: 2,
    d: 3,
    h: 4,
    i: 5,
    s: 6,
    u: 7,
    tz: 8
  };

  if (parts) {
    for (part in p) {
      v = parsed[p[part] - offset];

      if (v) {
        parts[part] = part == 'tz' ? v : 1;
      }
    }
  }
}

function returnDate(d, s, displayFormat) {
  var moment = window.moment || s.moment,
      format = s.returnFormat;

  if (d) {
    if (format == 'moment' && moment) {
      return moment(d);
    }

    if (format == 'locale') {
      return formatDate(displayFormat, d, s);
    }

    if (format == 'iso8601') {
      return getISOString(d, s.isoParts);
    }
  }

  return d;
}

function makeDate(d, format, s, parts) {
  var parse;

  if (!d) {
    return null;
  } // If already date object


  if (d.getTime) {
    return d;
  } // Moment object


  if (d.toDate) {
    return d.toDate();
  }

  if (typeof d == 'string') {
    d = d.trim();
  }

  parse = ISO_8601_TIME.exec(d); // If ISO 8601 time string

  if (parse) {
    setISOParts(parse, 2, parts);
    return new Date(1970, 0, 1, parse[2] ? +parse[2] : 0, parse[3] ? +parse[3] : 0, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0);
  }

  if (!parse) {
    parse = ISO_8601_FULL.exec(d);
  } // If ISO 8601 date string


  if (parse) {
    setISOParts(parse, 0, parts);
    return new Date(parse[1] ? +parse[1] : 1970, parse[2] ? parse[2] - 1 : 0, parse[3] ? +parse[3] : 1, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0, parse[6] ? +parse[6] : 0, parse[7] ? +parse[7] : 0);
  } // Parse date based on format


  return parseDate(format, d, s);
}

function isSameDay(d1, d2) {
  return d1.getFullYear() == d2.getFullYear() && d1.getMonth() == d2.getMonth() && d1.getDate() == d2.getDate();
}

var ISO_8601_FULL = /^(\d{4}|[+-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?((Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
var ISO_8601_TIME = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
var DAY_OF_MONTH = /^\d{1,2}(\/\d{1,2})?$/;
var DAY_OF_WEEK = /^w\d$/i;
var dateTimeDefaults = {
  shortYearCutoff: '+10',
  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  amText: 'am',
  pmText: 'pm',
  getYear: function getYear(d) {
    return d.getFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getMonth();
  },
  getDay: function getDay(d) {
    return d.getDate();
  },
  getDate: adjustedDate,
  getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
    return 32 - new Date(y, m, 32, 12).getDate();
  },
  getWeekNumber: function getWeekNumber(d) {
    // Copy date so don't modify original
    d = new Date(d);
    d.setHours(0, 0, 0); // Set to nearest Thursday: current date + 4 - current day number
    // Make Sunday's day number 7

    d.setDate(d.getDate() + 4 - (d.getDay() || 7)); // Get first day of year

    var yearStart = new Date(d.getFullYear(), 0, 1); // Calculate full weeks to nearest Thursday

    return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
  }
};
util.datetime = {
  formatDate: formatDate,
  parseDate: parseDate
};

/*!
 * Mobiscroll v4.10.9
 * http://mobiscroll.com
 *
 * Copyright 2010-2018, Acid Media
 *
 */
console.info('The trial is being authenticated with remote calls made to https://trial.mobiscroll.com. This is strictly necessary for the trial. No remote calls are made from the licensed version. More info on the trial and its limitations: http://help.mobiscroll.com/trials/what-are-the-limitations-of-the-trial');

function getWidth(el) {
  return el[0].innerWidth || el.innerWidth();
}

function getThemeName(s) {
  var themeName = s.theme,
      themeVariant = s.themeVariant;

  if (themeName == 'auto' || !themeName) {
    themeName = ms.autoTheme;
  }

  if (themeName == 'default') {
    themeName = 'mobiscroll';
  }

  if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
    themeName = themeName + '-dark';
  } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
    themeName = themeName.replace(/-dark$/, '');
  }

  return themeName;
}

function autoInit(selector, Component, hasRefresh) {
  if (isBrowser) {
    $$1(function () {
      $$1(selector).each(function () {
        new Component(this, {});
      });
      $$1(document).on('mbsc-enhance', function (ev, settings) {
        if ($$1(ev.target).is(selector)) {
          new Component(ev.target, settings || {});
        } else {
          $$1(selector, ev.target).each(function () {
            new Component(this, settings || {});
          });
        }
      });

      if (hasRefresh) {
        $$1(document).on('mbsc-refresh', function (ev) {
          var inst;

          if ($$1(ev.target).is(selector)) {
            inst = instances[ev.target.id];

            if (inst) {
              inst.refresh();
            }
          } else {
            $$1(selector, ev.target).each(function () {
              inst = instances[this.id];

              if (inst) {
                inst.refresh();
              }
            });
          }
        });
      }
    });
  }
}

var messageShow,
    ms,
    $$1 = mobiscroll.$,
    id = +new Date(),
    instances = {},
    classes = {},
    empty = {},
    breakpoints = {
  xsmall: 0,
  small: 576,
  medium: 768,
  large: 992,
  xlarge: 1200
},
    extend$1 = $$1.extend;
extend$1(util, {
  getCoord: getCoord,
  preventClick: preventClick,
  vibrate: vibrate
});
ms = extend$1(mobiscroll, {
  $: $$1,
  version: '4.10.9',
  autoTheme: 'mobiscroll',
  themes: {
    form: {},
    page: {},
    frame: {},
    scroller: {},
    listview: {},
    navigation: {},
    progress: {},
    card: {}
  },
  platform: {
    name: os,
    majorVersion: majorVersion,
    minorVersion: minorVersion
  },
  i18n: {},
  instances: instances,
  classes: classes,
  util: util,
  settings: {},
  setDefaults: function setDefaults(o) {
    extend$1(this.settings, o);
  },
  customTheme: function customTheme(name, baseTheme) {
    var i,
        themes = mobiscroll.themes,
        comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

    for (i = 0; i < comps.length; i++) {
      themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
        baseTheme: baseTheme
      });
    }
  }
});

var Base = function Base(el, settings) {
  var ctx,
      lang,
      preset,
      resp,
      s,
      theme,
      themeName,
      trigger,
      defaults,
      that = this;
  that.settings = {};
  that._getText = new Function('mobiscroll, p', function () {
    function getKey(encryptKey) {
      var a = encryptKey[0],
          i;

      for (i = 0; i < 16; ++i) {
        if (a * i % 16 == 1) {
          return [i, encryptKey[1]];
        }
      }
    }

    function affine(enc, str, a, b) {
      var alfb = '0123456789abcdef',
          newstr = '',
          len = str.length,
          i;

      for (i = 0; i < len; ++i) {
        newstr += enc ? alfb[(a * alfb.indexOf(str[i]) + b) % 16] : alfb[((a * alfb.indexOf(str[i]) - a * b) % 16 + 16) % 16];
      }

      return newstr;
    }

    function decrypt(str, encryptKey) {
      var decryptKey = getKey(encryptKey),
          decryptedStr = affine(0, str, decryptKey[0], decryptKey[1]),
          len = decryptedStr.length,
          arr = [],
          i;

      for (i = 0; i < len; i += 2) {
        arr.push(decryptedStr[i] + decryptedStr[i + 1]);
      }

      return arr;
    }

    var a = decrypt("38363537a9aba6a53faf36aba0a06281a938ae8ff9fdf736a1383136a26c89ad38ac6236ada2a8aba96c65f089ad38ac62a9ad3c6cf462f4fa603465fb63f0a8a53a643f3835a0a1f9666367aa31a2af38a5aba26ca165373aad366438f9a162a0a1a2a338ac60a26036f733aca5a0a16cf46df9f938653736f989ad38ac62aaa0abab366c89ad38ac6236ada2a8aba96c656e3865f73869f9fdf7a2f9a1173819f7a1173819f9a1173619f7a1173619f9a23936a1383136a264a1396c1763a8a53f34a0ad35fea6a0abafa76da5a934ab3638ada23863606334ab3fa538a5aba2feada63faba03138a16da5a934ab3638ada2386360633e69a5a2a8a13cfe69fd63606338ab34fef46da5a934ab3638ada238636063a0a1aa38fef46da5a934ab3638ada238636063a6ab3838aba9fef46da5a934ab3638ada23863606336a5a3ac38fef46da5a934ab3638ada238636063a9ad36a3a5a2fef46da5a934ab3638ada23863606334ada8a8a5a2a3fef46da5a934ab3638ada238636063aaaba238693fa53ea1fefc343c6da5a934ab3638ada238636063a0a5a2a169aca1a5a3ac38fefdf6343c63606338a13c3869ada0a5a3a2feafa1a238a136636063ab34adafa53835fe63676c89ad38ac62aaa0abab366c89ad38ac6236ada2a8aba96c656ef6f4656bfdf4f467f462fc6567636da5a934ab3638ada23863196562aeaba5a26c63f76365676366f21031f4f4f1f81031f4f4f1f61031f4f4f8f51031f4f4f8fd1031f4f4f8aff06ba8a53af263fe63636539afad38afac6ca1653736a1383136a264636339e", [9, 4]),
        b = '',
        l = a.length,
        c;

    for (c = 0; c < l; c++) {
      b += String.fromCharCode(parseInt(a[c], 16));
    }

    return b;
  }());
  that.element = el;
  that._init = noop;
  that._destroy = noop;
  that._processSettings = noop;

  that._checkResp = function (width) {
    if (that && that._responsive) {
      var newResp = getResponsiveSettings(width);

      if (resp !== newResp) {
        resp = newResp;
        that.init({});
        return true;
      }
    }
  };

  that._getRespCont = function () {
    return $$1(s.context == 'body' ? window : s.context);
  };

  that.init = function (newSettings, newValue) {
    var key, value; // In case of settings update save the old value

    if (newSettings && that.getVal) {
      value = that.getVal();
    } // Reset settings object


    for (key in that.settings) {
      delete that.settings[key];
    }

    s = that.settings; // Update original user settings

    extend$1(settings, newSettings); // Load user defaults

    if (that._hasDef) {
      defaults = ms.settings;
    } // Create settings object


    extend$1(s, that._defaults, defaults, settings);
    ctx = that._getRespCont();

    if (that._responsive) {
      if (!resp) {
        resp = getResponsiveSettings();
      }

      extend$1(s, resp);
    } // Get theme defaults


    if (that._hasTheme) {
      themeName = getThemeName(s);
      settings.theme = themeName;
      theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
    } // Get language defaults


    if (that._hasLang) {
      lang = ms.i18n[s.lang];
    } // Update settings object


    extend$1(s, theme, lang, defaults, settings, resp);

    that._processSettings(resp || {}); // --- REMOTE TRIAL CODE START ---


    var noRemote = {
      form: true,
      page: true,
      progress: true,
      switch: true,
      slider: true,
      stepper: true
    };

    function toDateStr(d) {
      return typeof d == 'string' ? d : getISOString(makeDate(d), {
        y: 1,
        m: 1,
        d: 1,
        h: 1,
        i: 1,
        s: 1,
        u: 1
      });
    }

    function init() {
      that._init(newSettings); // In case of settings update reset the value.
      // This is needed to adapt the value for the updated settings
      // E.g. min/max, date format, etc.


      if (newSettings && that.setVal) {
        that.setVal(newValue === undefined ? value : newValue, true);
      }

      trigger('onInit');
    }

    if (!that._class || noRemote[that._class]) {
      init();
    } else {
      if (!ms.fwv) {
        var vers;

        switch (ms.fw) {
          case 'angular':
            vers = $$1('[ng-version]').attr('ng-version');
            break;

          case 'jquery':
            vers = $$1.fn && $$1.fn.jquery;
            break;
        }

        ms.fwv = vers || 'N/A';
      }

      var config = {
        className: that._class,
        buttons: that.buttons,
        platform: ms.platform,
        v: ms.version,
        userAgent: navigator.userAgent,
        defSortHandle: $$1(el).find(s.listSelector || 'ul,ol').length ? 'left' : 'right',
        // For listview
        settings: {
          activeClass: s.activeClass,
          ampmText: s.ampmText,
          amText: s.amText,
          animateIcons: s.animateIcons,
          backText: s.backText,
          baseTheme: s.baseTheme,
          buttons: s.buttons,
          btnClass: s.btnClass,
          btnWidth: s.btnWidth,
          btnReverse: s.btnReverse,
          closeIcon: s.closeIcon,
          context: s.context == 'body' ? 'body' : '',
          controls: s.controls,
          cssClass: s.cssClass,
          dateDisplay: s.dateDisplay,
          dateFormat: s.dateFormat,
          dateWheels: s.dateWheels,
          dayNames: s.dayNames,
          dayNamesShort: s.dayNamesShort,
          daySuffix: s.daySuffix,
          display: s.display,
          dayText: s.dayText,
          endYear: s.endYear,
          fixedHeader: s.fixedHeader,
          handleClass: s.handleClass,
          handleMarkup: s.handleMarkup,
          hideText: s.hideText,
          hourText: s.hourText,
          itemNode: s.itemNode,
          itemWidth: s.itemWidth,
          lang: s.lang,
          lapIcon: s.lapIcon,
          lapText: s.lapText,
          layout: s.layout,
          leftArrowClass: s.leftArrowClass,
          max: toDateStr(s.max),
          min: toDateStr(s.min),
          minuteText: s.minuteText,
          monthNames: s.monthNames,
          monthNamesShort: s.monthNamesShort,
          monthSuffix: s.monthSuffix,
          monthText: s.monthText,
          nowIcon: s.nowIcon,
          nowText: s.nowText,
          pmText: s.pmText,
          preset: s.preset,
          resetIcon: s.resetIcon,
          resetText: s.resetText,
          rightArrowClass: s.rightArrowClass,
          rtl: s.rtl,
          secText: s.secText,
          select: s.select,
          showOverlay: s.showOverlay,
          snap: s.snap,
          sort: s.sort,
          sortable: s.sortable,
          sortHandle: s.sortHandle,
          startIcon: s.startIcon,
          startText: s.startText,
          startYear: s.startYear,
          stepHour: s.stepHour,
          stepMinute: s.stepMinute,
          stepSecond: s.stepSecond,
          steps: s.steps,
          stopIcon: s.stopIcon,
          stopText: s.stopText,
          striped: s.striped,
          theme: s.theme,
          timeFormat: s.timeFormat,
          timeWheels: s.timeWheels,
          todayText: s.todayText,
          type: s.type,
          variant: s.variant,
          wrapperClass: s.wrapperClass,
          yearSuffix: s.yearSuffix,
          yearText: s.yearText
        }
      };

      var i,
          prop,
          q = [],
          tempInst = {},
          presetFunctions = ['refresh', 'redraw', 'navigate', 'changeTab', // Calendar Base
      'getDate', 'setDate', // Datetime
      'addEvent', 'removeEvent', 'getEvents', 'setEvents', // Event calendar
      'setActiveDate', // Range
      'start', 'stop', 'reset', 'lap', 'resetlap', 'getTime', 'setTime', 'getEllapsedTime', 'setEllapsedTime' // Timer
      ],
          noProxy = {
        jsonp: 1,
        getInst: 1,
        init: 1,
        destroy: 1
      },
          proxy = function proxy(name) {
        that[name] = function () {
          q.push({
            func: name,
            args: arguments
          });
        };
      }; // Override all methods of the instance to delay execution
      // until the server side initialization is done.
      // For this we create a function which just pushes the function name
      // and arguments into a queue.


      for (prop in that) {
        if (typeof that[prop] === 'function' && !noProxy[prop]) {
          tempInst[prop] = that[prop];
          proxy(prop);
        }
      } // Proxy possible preset functions, which does not exist yet


      for (i = 0; i < presetFunctions.length; i++) {
        proxy(presetFunctions[i]);
      } // Workaround for timer buttons


      if (s.preset == 'timer' && !settings.buttons) {
        config.settings.buttons = ['resetlap', 'toggle'];

        if (s.display !== 'inline') {
          config.settings.buttons.unshift('hide');
        }
      }

      if (s.preset == 'eventcalendar' && !settings.buttons && s.display != 'inline') {
        config.settings.buttons = ['close'];
      }

      s.zone = s.zone || {
        run: function run(func) {
          func();
        },
        runOutsideAngular: function runOutsideAngular(func) {
          func();
        }
      };

      if (ms.apiKey !== 'mbscdemo') {
        logData.theme = s.theme;
        logData.components = logData.components || [];
        logData.components.push(that._class + '_' + (s.preset || ''));
        sendLog();
      }

      that.jsonp('remote', config, function (data) {
        s.zone.run(function () {
          if (!that) {
            return;
          }

          that.remote = data; // Copy back original functions in place of the proxy

          for (prop in tempInst) {
            that[prop] = tempInst[prop];
          }

          if (data.notification !== undefined && !messageShow) {
            messageShow = true;
            mobiscroll.snackbar(data.notification);
          } // Workaround for remote data updates


          var settingsCopy = extend$1({}, settings);
          delete settingsCopy.data; // --- REMOTE TRIAL CODE END ---
          // Load preset settings

          if (that._presets) {
            preset = that._presets[s.preset];

            if (preset) {
              preset = preset.call(el, that, settings);
              extend$1(s, preset, settingsCopy, resp);
            }
          }

          init(); // --- REMOTE TRIAL CODE START ---
          // Execute functions in the queue

          for (i = 0; i < q.length; i++) {
            that[q[i].func].apply(that, q[i].args);
          } // Empty temporary variables


          q = null;
          tempInst = null;
        });
      }, guid);
    } // --- REMOTE TRIAL CODE END ---

  };

  that.destroy = function () {
    if (that) {
      that._destroy();

      trigger('onDestroy'); // Delete scroller instance

      delete instances[el.id];
      that = null;
    }
  };
  /**
   * Attach tap event to the given element.
   */


  that.tap = function (el, handler, prevent, tolerance, time) {
    tap(that, el, handler, prevent, tolerance, time);
  };
  /**
   * Triggers an event
   */


  that.trigger = function (name, ev) {
    var ret,
        i,
        v,
        s = [defaults, theme, preset, settings];

    for (i = 0; i < 4; i++) {
      v = s[i];

      if (v && v[name]) {
        ret = v[name].call(el, ev || {}, that);
      }
    }

    return ret;
  };
  /**
   * Sets one ore more options.
   */


  that.option = function (opt, value, newValue) {
    var obj = {},
        // preserve settings that are possible to change runtime
    dynamic = ['data', 'invalid', 'valid', 'readonly'];

    if (/calendar|eventcalendar|range/.test(s.preset)) {
      dynamic.push('marked', 'labels', 'colors');
    }

    if (typeof opt === 'object') {
      obj = opt;
    } else {
      obj[opt] = value;
    }

    dynamic.forEach(function (v) {
      settings[v] = s[v];
    });
    that.init(obj, newValue);
  };
  /**
   * Returns the mobiscroll instance.
   */


  that.getInst = function () {
    return that;
  }; // --- REMOTE TRIAL CODE START ---


  that.jsonp = jsonp;
  var guid = 'comp_' + (el.id || ++uid); // --- REMOTE TRIAL CODE END ---

  settings = settings || {};
  trigger = that.trigger;

  function getResponsiveSettings(w) {
    var result = empty,
        width;

    if (s.responsive) {
      width = w || getWidth(ctx);
      $$1.each(s.responsive, function (key, value) {
        if (width >= (value.breakpoint || breakpoints[key])) {
          result = value;
        }
      });
    }

    return result;
  }

  function construct() {
    $$1(el).addClass('mbsc-comp'); // Autogenerate id

    if (!el.id) {
      el.id = 'mobiscroll' + ++id;
    } else if (instances[el.id]) {
      instances[el.id].destroy();
    } // Save instance


    instances[el.id] = that;
    that.__ready = true;
  }

  if (!that.__ready) {
    construct();
  }
}; // --- REMOTE TRIAL CODE START ---


var uid = 0;
var logData = {};
var logTimer;

function sendError() {
  var sessionID = document.cookie.replace(/(?:(?:^|.*;\s*)ASP.NET_SessionId\s*=\s*([^;]*).*$)|^.*$/, "$1");
  document.cookie = 'mobiscrollClientError=1; expires=' + new Date(new Date().getTime() + 1000 * 60 * 60 * 24).toUTCString() + '; path=/'; // Workaround for file protocoll

  try {
    window.name = (window.name || '') + ';mobiscrollClientError';
  } catch (e) {// Make eslint happy
  }

  jsonp('error', {
    trialCode: ms.apiKey,
    sessionID: sessionID
  }, function () {
    document.cookie = 'mobiscrollClientError=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/';

    try {
      window.name = (window.name || '').replace(/;mobiscrollClientError/g, '');
    } catch (e) {// Make eslint happy
    }
  });
}

function sendLog() {
  clearTimeout(logTimer);
  logTimer = setTimeout(function () {
    extend$1(logData, {
      trialCode: ms.apiKey,
      fw: ms.fw + (window.Ionic || window.ionic ? '-ionic' : ''),
      fwv: ms.fwv,
      demo: !!window.isMbscDemo,
      v: ms.version
    });
    jsonp('log', logData, function () {
      logData = {};
    });
  }, 5000);
}

function jsonp(method, data, callback, uniqueId, attempts) {
  var timer,
      script = document.createElement('script'),
      unique = 'mbsc_jsonp_' + (uniqueId ? uniqueId : ++id);
  attempts = attempts || 1;

  function onError() {
    if (window[unique]) {
      window[unique]();
    }

    if (method === 'remote') {
      if (attempts < 4) {
        jsonp(method, data, callback, uniqueId, attempts + 1);
      } else if (!ms.trialError) {
        ms.trialError = true;
        sendError();

        if (ms.apiKey != 'mbscdemo') {
          alert('Mobiscroll trial not loaded. Please check your connection. If the problem persists, contact us at support@mobiscroll.com');
        }
      }
    }
  }

  window[unique] = function (data) {
    clearTimeout(timer);
    script.parentNode.removeChild(script);
    delete window[unique];
    callback(data ? JSON.parse(data, function (key, value) {
      if (typeof value != 'string') {
        return value;
      }

      if (value.substring(0, 8) === 'function') {
        return window.eval('(' + value + ')');
      }

      if (value.match(ISO_8601_FULL)) {
        return makeDate(value);
      }

      return value;
    }) : {});
  };

  timer = setTimeout(onError, 6000);
  script.onerror = onError;
  script.src = ms.apiUrl + ms.apiKey + '/' + method + '?callback=' + unique + '&data=' + encodeURIComponent(JSON.stringify(data));
  document.body.appendChild(script);
}

if (isBrowser) {
  $$1(function () {
    if (document.cookie.replace(/(?:(?:^|.*;\s*)mobiscrollClientError\s*=\s*([^;]*).*$)|^.*$/, "$1") || /mobiscrollClientError/.test(window.name || '')) {
      sendError();
    }
  });
} // --- REMOTE TRIAL CODE END ---

var Observable = function () {
  function Observable() {
    this.keyCount = 0;
    this.subscribers = new Map();
  }

  Observable.prototype.subscribe = function (handler) {
    var key = this.keyCount++;
    this.subscribers.set(key, handler);
    return key;
  };

  Observable.prototype.unsubscribe = function (handler) {
    if (typeof handler === 'number') {
      this.subscribers.delete(handler);
    } else {
      var foundKey_1 = null;
      this.subscribers.forEach(function (fn, key) {
        if (fn === handler) {
          foundKey_1 = key;
        }
      });
      this.subscribers.delete(foundKey_1);
    }
  };

  Observable.prototype.next = function (value) {
    this.subscribers.forEach(function (handler) {
      handler(value);
    });
  };

  return Observable;
}();

var MbscRouterToken = (function () {
    function MbscRouterToken() {
    }
    return MbscRouterToken;
}());
var MbscOptionsService = (function () {
    function MbscOptionsService() {
    }
    Object.defineProperty(MbscOptionsService.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (o) {
            this._options = o;
        },
        enumerable: true,
        configurable: true
    });
    MbscOptionsService.ctorParameters = function () { return []; };
MbscOptionsService.ɵfac = function MbscOptionsService_Factory(t) { return new (t || MbscOptionsService)(); };
MbscOptionsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscOptionsService, factory: function (t) { return MbscOptionsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscOptionsService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscOptionsService;
}());
var MbscInputService = (function () {
    function MbscInputService() {
        this._controlSet = false;
        this._componentRef = undefined;
    }
    Object.defineProperty(MbscInputService.prototype, "isControlSet", {
        get: function () {
            return this._controlSet;
        },
        set: function (v) {
            this._controlSet = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscInputService.prototype, "input", {
        get: function () {
            return this._componentRef;
        },
        set: function (v) {
            this._componentRef = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscInputService.ctorParameters = function () { return []; };
MbscInputService.ɵfac = function MbscInputService_Factory(t) { return new (t || MbscInputService)(); };
MbscInputService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscInputService, factory: function (t) { return MbscInputService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscInputService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscInputService;
}());
var MbscListService = (function () {
    function MbscListService() {
        this.addRemoveObservable = new Observable();
    }
    MbscListService.prototype.notifyAddRemove = function (item) {
        this.addRemoveObservable.next(item);
    };
    MbscListService.prototype.onAddRemove = function () {
        return this.addRemoveObservable;
    };
    MbscListService.ctorParameters = function () { return []; };
MbscListService.ɵfac = function MbscListService_Factory(t) { return new (t || MbscListService)(); };
MbscListService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscListService, factory: function (t) { return MbscListService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscListService;
}());
var MbscBase = (function () {
    function MbscBase(initialElem, zone) {
        this.initialElem = initialElem;
        this.zone = zone;
        this.options = {};
        this.onInit = new EventEmitter();
        this.onDestroy = new EventEmitter();
        this.inlineOptionsObj = {};
        this.pendingValue = undefined;
        this.themeClassesSet = false;
        this.instance = null;
        this.element = null;
        this.inlineOptionsObj.zone = zone;
    }
    MbscBase.prototype.getInlineEvents = function () {
        var _this = this;
        var _loop_1 = function (prop) {
            if (this_1[prop] instanceof (EventEmitter) && (!this_1.options || !(this_1.options[prop]))) {
                this_1.inlineOptionsObj[prop] = function (event, inst) {
                    event.inst = inst;
                    _this[prop].emit(event);
                };
            }
        };
        var this_1 = this;
        for (var prop in this) {
            _loop_1(prop);
        }
    };
    MbscBase.prototype.setThemeClasses = function () {
        $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());
        this.themeClassesSet = true;
    };
    MbscBase.prototype.clearThemeClasses = function () {
        $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());
    };
    MbscBase.prototype.getThemeClasses = function () {
        var s = this.instance.settings;
        return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');
    };
    MbscBase.prototype.setElement = function () {
        this.element = this.initialElem.nativeElement;
        var contentInput = $$1('input', this.initialElem.nativeElement);
        if (contentInput.length) {
            this.element = contentInput[0];
        }
    };
    MbscBase.prototype.ngAfterViewInit = function () {
        this.setElement();
        this.startInit();
    };
    MbscBase.prototype.startInit = function () {
        var _this = this;
        this.getInlineEvents();
        var ionInput = this.getIonInput();
        if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== "INPUT") {
            if (ionInput.getInputElement) {
                ionInput.getInputElement().then(function (inp) {
                    _this.setElement();
                    _this.initControl();
                });
            }
            else {
                ionInput.then(function (ionInpComponent) {
                    ionInpComponent
                        .getInputElement()
                        .then(function (inp) {
                        _this.setElement();
                        _this.initControl();
                    });
                });
            }
        }
        else if (!this.instance) {
            this.initControl();
        }
    };
    MbscBase.prototype.getIonInput = function () {
        var v = this._view;
        var native = this.initialElem.nativeElement;
        var ionInputNode = native.nodeName === "ION-INPUT";
        var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;
        var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();
        return inp1 || inp2;
    };
    MbscBase.prototype.initControl = function () { };
    MbscBase.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {
        var _this = this;
        if (optionChanged || invalidChanged) {
            setTimeout(function () {
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.clearThemeClasses();
                }
                _this.instance.option(newOptions, undefined, _this.pendingValue);
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.setThemeClasses();
                }
            });
        }
        else if (dataChanged) {
            this.refreshData(this.data);
        }
        else if (this.instance.redraw) {
            this.instance.redraw();
        }
    };
    MbscBase.prototype.ngOnChanges = function (changes) {
        var optionChange = false, cloneChange = false, invalidChange = false, dataChange = false, newOptions = {};
        for (var prop in changes) {
            if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {
                if (this.cloneDictionary && this.cloneDictionary[prop]) {
                    this.makeClone(prop, changes[prop].currentValue);
                    if (this.instance) {
                        this.instance.settings[prop] = changes[prop].currentValue;
                    }
                    if (prop == 'invalid') {
                        invalidChange = true;
                    }
                    if (prop == 'data') {
                        dataChange = true;
                    }
                    cloneChange = true;
                }
                else {
                    newOptions[prop] = changes[prop].currentValue;
                    optionChange = true;
                }
            }
            else if (!changes[prop].firstChange && prop !== 'value') {
                newOptions = extend$1(changes[prop].currentValue, newOptions);
                optionChange = true;
            }
            else if (changes[prop].firstChange) {
                if (prop !== 'options' && prop !== 'value') {
                    this.inlineOptionsObj[prop] = changes[prop].currentValue;
                }
            }
        }
        if (cloneChange) {
            extend$1(newOptions, this.cloneDictionary);
        }
        if (optionChange || cloneChange) {
            this.updateOptions(newOptions, optionChange, invalidChange, dataChange);
        }
    };
    MbscBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    MbscBase.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'cssClass': [{ type: Input$1 },],
        'theme': [{ type: Input$1 },],
        'themeVariant': [{ type: Input$1 },],
        'lang': [{ type: Input$1 },],
        'rtl': [{ type: Input$1 },],
        'responsive': [{ type: Input$1 },],
        'onInit': [{ type: Output },],
        'onDestroy': [{ type: Output },],
    };
MbscBase.ɵfac = function MbscBase_Factory(t) { return new (t || MbscBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscBase, selectors: [["", "mbsc-b", ""]], inputs: { options: ["mbsc-options", "options"], cssClass: "cssClass", theme: "theme", themeVariant: "themeVariant", lang: "lang", rtl: "rtl", responsive: "responsive" }, outputs: { onInit: "onInit", onDestroy: "onDestroy" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onInit: [{
            type: Output
        }], onDestroy: [{
            type: Output
        }], cssClass: [{
            type: Input$1
        }], theme: [{
            type: Input$1
        }], themeVariant: [{
            type: Input$1
        }], lang: [{
            type: Input$1
        }], rtl: [{
            type: Input$1
        }], responsive: [{
            type: Input$1
        }] }); })();
    return MbscBase;
}());
var MbscValueBase = (function (_super) {
    __extends(MbscValueBase, _super);
    function MbscValueBase(initialElem, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.initialValue = undefined;
        return _this;
    }
    MbscValueBase.prototype.setNewValue = function (v) { };
    MbscValueBase.prototype.setNewValueProxy = function (v) {
        if (!this.instance) {
            this.initialValue = v;
        }
        this.setNewValue(v);
    };
    MbscValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
MbscValueBase.ɵfac = function MbscValueBase_Factory(t) { return new (t || MbscValueBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscValueBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscValueBase, selectors: [["", "mbsc-v-b", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscValueBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-v-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return MbscValueBase;
}(MbscBase));
var MbscCloneBase = (function (_super) {
    __extends(MbscCloneBase, _super);
    function MbscCloneBase(initElem, zone) {
        var _this = _super.call(this, initElem, zone) || this;
        _this.cloneDictionary = {};
        return _this;
    }
    MbscCloneBase.prototype.makeClone = function (setting, value) {
        if (value) {
            this.cloneDictionary[setting] = [];
            for (var i = 0; i < value.length; i++) {
                this.cloneDictionary[setting].push(value[i]);
            }
        }
        else {
            this.cloneDictionary[setting] = value;
        }
    };
    MbscCloneBase.prototype.ngDoCheck = function () {
        var changed = false, data = false, invalid = false;
        for (var key in this.cloneDictionary) {
            if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {
                this.makeClone(key, this[key]);
                this.instance.settings[key] = this[key];
                changed = true;
                if (key == 'invalid') {
                    invalid = true;
                }
                if (key == 'data') {
                    data = true;
                }
            }
        }
        if (changed && this.instance) {
            this.updateOptions(this.cloneDictionary, false, invalid, data);
        }
    };
    MbscCloneBase.prototype.ngOnInit = function () {
        for (var key in this.cloneDictionary) {
            this.makeClone(key, this[key]);
        }
    };
    MbscCloneBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
MbscCloneBase.ɵfac = function MbscCloneBase_Factory(t) { return new (t || MbscCloneBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscCloneBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscCloneBase, selectors: [["", "mbsc-c-b", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCloneBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-c-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
    return MbscCloneBase;
}(MbscValueBase));
var MbscControlBase = (function (_super) {
    __extends(MbscControlBase, _super);
    function MbscControlBase(initialElement, zone, control, _inputService, _view) {
        var _this = _super.call(this, initialElement, zone) || this;
        _this.control = control;
        _this._inputService = _inputService;
        _this._view = _view;
        _this._needsTimeout = true;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.onChangeEmitter = new EventEmitter();
        _this.oldAccessor = null;
        _this.overwriteAccessor();
        if (_inputService) {
            _inputService.isControlSet = true;
        }
        return _this;
    }
    Object.defineProperty(MbscControlBase.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (_this.oldAccessor) {
                        _this.oldAccessor.writeValue(event.valueText);
                    }
                    else {
                        var ionInput = _this.getIonInput();
                        if (ionInput) {
                            ionInput.value = event.valueText;
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscControlBase.prototype, "enableManualEdit", {
        get: function () {
            var nsf = this.showOnFocus === false || this.options.showOnFocus === false, nst = this.showOnTap === false || this.options.showOnTap === false;
            return nsf && nst;
        },
        enumerable: true,
        configurable: true
    });
    MbscControlBase.prototype.handleChange = function (element) {
        var that = this;
        $$1(element || this.element).on('change', function () {
            that.zone.run(function () {
                var elmValue = that.element.value;
                var instValue = that.instance._value;
                if (elmValue !== instValue && (instValue !== null || elmValue !== '') && that.enableManualEdit) {
                    that.instance.setVal(elmValue, true, true);
                }
                else {
                    var value = that.instance.getVal();
                    if (that.control) {
                        if (!valueEquals(value, that.control.model)) {
                            that.onChange(value);
                            that.control.control.patchValue(value);
                        }
                    }
                    else {
                        that.onChangeEmitter.emit(value);
                    }
                }
            });
        });
        function valueEquals(v1, v2) {
            if (v1 === v2) {
                return true;
            }
            if (v1 instanceof Date && v2 instanceof Date) {
                return (+v1) === (+v2);
            }
            return false;
        }
    };
    MbscControlBase.prototype.overwriteAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscControlBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.handleChange();
        this.overwriteAccessor();
        if (this.control && this.control._setUpControl) {
            this.control._setUpControl();
        }
    };
    MbscControlBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscControlBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscControlBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
        if (this.instance && this.instance.disable && this.instance.enable) {
            if (isDisabled) {
                this.instance.disable();
            }
            else {
                this.instance.enable();
            }
        }
    };
    MbscControlBase.prototype.writeValue = function (v) {
        var _this = this;
        if (this._needsTimeout) {
            this.pendingValue = v;
            setTimeout(function () {
                _this.pendingValue = undefined;
                _this.setNewValueProxy(v);
            });
        }
        else {
            this.setNewValueProxy(v);
        }
    };
    MbscControlBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscControlBase.propDecorators = {
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'showOnFocus': [{ type: Input$1 },],
        'showOnTap': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
    };
MbscControlBase.ɵfac = function MbscControlBase_Factory(t) { return new (t || MbscControlBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscControlBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscControlBase, selectors: [["", "mbsc-cc-b", ""]], inputs: { disabled: "disabled", labelStyle: ["label-style", "labelStyle"], inputStyle: ["input-style", "inputStyle"], showOnFocus: "showOnFocus", showOnTap: "showOnTap" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscControlBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-cc-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: ɵngcc0.ViewContainerRef }]; }, { disabled: [{
            type: Input$1
        }], labelStyle: [{
            type: Input$1,
            args: ['label-style']
        }], inputStyle: [{
            type: Input$1,
            args: ['input-style']
        }], showOnFocus: [{
            type: Input$1
        }], showOnTap: [{
            type: Input$1
        }] }); })();
    return MbscControlBase;
}(MbscCloneBase));
var MbscFrameBase = (function (_super) {
    __extends(MbscFrameBase, _super);
    function MbscFrameBase(initialElem, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscFrameBase.prototype, "inline", {
        get: function () {
            return (this.display || (this.options && this.options.display)) === 'inline';
        },
        enumerable: true,
        configurable: true
    });
    MbscFrameBase.prototype.ngOnInit = function () {
        this.cloneDictionary.invalid = [];
        this.cloneDictionary.valid = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscFrameBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscFrameBase.propDecorators = {
        'options': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
        'anchor': [{ type: Input$1 },],
        'animate': [{ type: Input$1 },],
        'buttons': [{ type: Input$1 },],
        'closeOnOverlayTap': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'display': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'focusOnClose': [{ type: Input$1 },],
        'focusTrap': [{ type: Input$1 },],
        'headerText': [{ type: Input$1 },],
        'scrollLock': [{ type: Input$1 },],
        'touchUi': [{ type: Input$1 },],
        'onBeforeClose': [{ type: Output },],
        'onBeforeShow': [{ type: Output },],
        'onCancel': [{ type: Output },],
        'onClose': [{ type: Output },],
        'onFill': [{ type: Output },],
        'onMarkupReady': [{ type: Output },],
        'onPosition': [{ type: Output },],
        'onShow': [{ type: Output },],
    };
MbscFrameBase.ɵfac = function MbscFrameBase_Factory(t) { return new (t || MbscFrameBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscFrameBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscFrameBase, selectors: [["", "mbsc-fr-b", ""]], inputs: { options: "options", dropdown: "dropdown", anchor: "anchor", animate: "animate", buttons: "buttons", closeOnOverlayTap: "closeOnOverlayTap", context: "context", display: "display", showInput: "showInput", focusOnClose: "focusOnClose", focusTrap: "focusTrap", headerText: "headerText", scrollLock: "scrollLock", touchUi: "touchUi" }, outputs: { onBeforeClose: "onBeforeClose", onBeforeShow: "onBeforeShow", onCancel: "onCancel", onClose: "onClose", onFill: "onFill", onMarkupReady: "onMarkupReady", onPosition: "onPosition", onShow: "onShow" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFrameBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-fr-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: ɵngcc0.ViewContainerRef }]; }, { options: [{
            type: Input$1
        }], dropdown: [{
            type: Input$1
        }], anchor: [{
            type: Input$1
        }], animate: [{
            type: Input$1
        }], buttons: [{
            type: Input$1
        }], closeOnOverlayTap: [{
            type: Input$1
        }], context: [{
            type: Input$1
        }], display: [{
            type: Input$1
        }], showInput: [{
            type: Input$1
        }], focusOnClose: [{
            type: Input$1
        }], focusTrap: [{
            type: Input$1
        }], headerText: [{
            type: Input$1
        }], scrollLock: [{
            type: Input$1
        }], touchUi: [{
            type: Input$1
        }], onBeforeClose: [{
            type: Output
        }], onBeforeShow: [{
            type: Output
        }], onCancel: [{
            type: Output
        }], onClose: [{
            type: Output
        }], onFill: [{
            type: Output
        }], onMarkupReady: [{
            type: Output
        }], onPosition: [{
            type: Output
        }], onShow: [{
            type: Output
        }] }); })();
    return MbscFrameBase;
}(MbscControlBase));
var MbscScrollerBase = (function (_super) {
    __extends(MbscScrollerBase, _super);
    function MbscScrollerBase(initialElement, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;
        _this.onWheelChange = new EventEmitter();
        _this.onSet = new EventEmitter();
        _this.onItemTap = new EventEmitter();
        _this.onClear = new EventEmitter();
        return _this;
    }
    MbscScrollerBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscScrollerBase.propDecorators = {
        'circular': [{ type: Input$1 },],
        'height': [{ type: Input$1 },],
        'layout': [{ type: Input$1 },],
        'maxWidth': [{ type: Input$1 },],
        'minWidth': [{ type: Input$1 },],
        'multiline': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'rows': [{ type: Input$1 },],
        'showLabel': [{ type: Input$1 },],
        'showScrollArrows': [{ type: Input$1 },],
        'wheels': [{ type: Input$1 },],
        'width': [{ type: Input$1 },],
        'validate': [{ type: Input$1 },],
        'cancelText': [{ type: Input$1 },],
        'clearText': [{ type: Input$1 },],
        'selectedText': [{ type: Input$1 },],
        'setText': [{ type: Input$1 },],
        'formatValue': [{ type: Input$1 },],
        'parseValue': [{ type: Input$1 },],
        'onWheelChange': [{ type: Output, args: ['onChange',] },],
        'onSet': [{ type: Output },],
        'onItemTap': [{ type: Output },],
        'onClear': [{ type: Output },],
    };
MbscScrollerBase.ɵfac = function MbscScrollerBase_Factory(t) { return new (t || MbscScrollerBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscScrollerBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScrollerBase, selectors: [["", "mbsc-s-b", ""]], inputs: { circular: "circular", height: "height", layout: "layout", maxWidth: "maxWidth", minWidth: "minWidth", multiline: "multiline", readonly: "readonly", rows: "rows", showLabel: "showLabel", showScrollArrows: "showScrollArrows", wheels: "wheels", width: "width", validate: "validate", cancelText: "cancelText", clearText: "clearText", selectedText: "selectedText", setText: "setText", formatValue: "formatValue", parseValue: "parseValue" }, outputs: { onWheelChange: "onChange", onSet: "onSet", onItemTap: "onItemTap", onClear: "onClear" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollerBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-s-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: ɵngcc0.ViewContainerRef }]; }, { circular: [{
            type: Input$1
        }], height: [{
            type: Input$1
        }], layout: [{
            type: Input$1
        }], maxWidth: [{
            type: Input$1
        }], minWidth: [{
            type: Input$1
        }], multiline: [{
            type: Input$1
        }], readonly: [{
            type: Input$1
        }], rows: [{
            type: Input$1
        }], showLabel: [{
            type: Input$1
        }], showScrollArrows: [{
            type: Input$1
        }], wheels: [{
            type: Input$1
        }], width: [{
            type: Input$1
        }], validate: [{
            type: Input$1
        }], cancelText: [{
            type: Input$1
        }], clearText: [{
            type: Input$1
        }], selectedText: [{
            type: Input$1
        }], setText: [{
            type: Input$1
        }], formatValue: [{
            type: Input$1
        }], parseValue: [{
            type: Input$1
        }], onWheelChange: [{
            type: Output,
            args: ['onChange']
        }], onSet: [{
            type: Output
        }], onItemTap: [{
            type: Output
        }], onClear: [{
            type: Output
        }] }); })();
    return MbscScrollerBase;
}(MbscFrameBase));
var MbscBaseModule = (function () {
    function MbscBaseModule() {
    }
    MbscBaseModule.ctorParameters = function () { return []; };
MbscBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscBaseModule });
MbscBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscBaseModule_Factory(t) { return new (t || MbscBaseModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscBaseModule, { declarations: function () { return [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase]; }, imports: function () { return [CommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase]
            }]
    }], function () { return []; }, null); })();
    return MbscBaseModule;
}());
var MbscFrameBaseModule = (function () {
    function MbscFrameBaseModule() {
    }
    MbscFrameBaseModule.ctorParameters = function () { return []; };
MbscFrameBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscFrameBaseModule });
MbscFrameBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscFrameBaseModule_Factory(t) { return new (t || MbscFrameBaseModule)(); }, imports: [[CommonModule, MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscFrameBaseModule, { declarations: function () { return [MbscFrameBase]; }, imports: function () { return [CommonModule, MbscBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFrameBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscBaseModule],
                declarations: [MbscFrameBase]
            }]
    }], function () { return []; }, null); })();
    return MbscFrameBaseModule;
}());
var MbscScrollerBaseModule = (function () {
    function MbscScrollerBaseModule() {
    }
    MbscScrollerBaseModule.ctorParameters = function () { return []; };
MbscScrollerBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscScrollerBaseModule });
MbscScrollerBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscScrollerBaseModule_Factory(t) { return new (t || MbscScrollerBaseModule)(); }, imports: [[CommonModule, MbscFrameBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollerBaseModule, { declarations: function () { return [MbscScrollerBase]; }, imports: function () { return [CommonModule, MbscFrameBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollerBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscFrameBaseModule],
                declarations: [MbscScrollerBase]
            }]
    }], function () { return []; }, null); })();
    return MbscScrollerBaseModule;
}());
function deepEqualsArray(a1, a2) {
    if (a1 === a2) {
        return true;
    }
    else if (!a1 || !a2 || a1.length !== a2.length) {
        return false;
    }
    else {
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
}
function isDateEqual(d1, d2) {
    if ((d1 && !d2) || (d2 && !d1)) {
        return false;
    }
    else if (!d1 && !d2) {
        return true;
    }
    else {
        return d1 && d2 && d1.toString() === d2.toString();
    }
}
function emptyOrTrue(val) {
    return (typeof (val) === 'string' && (val === 'true' || val === '')) || !!val;
}
var INPUT_TEMPLATE = "<mbsc-input *ngIf=\"!inline || showInput\"\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [themeVariant]=\"themeVariant\" [label-style]=\"labelStyle\" [input-style]=\"inputStyle\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\"\n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var wrapClass = 'mbsc-input-wrap';
var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
var defaults = {
  tap: hasGhostClick
};
var $active;

function addIcon($control, ic) {
  var icons = {},
      control = $control[0],
      $parent = $control.parent(),
      errorMsg = $parent.find('.mbsc-err-msg'),
      align = $control.attr('data-icon-align') || 'left',
      icon = $control.attr('data-icon');

  if ($parent.hasClass(wrapClass)) {
    $parent = $parent.parent();
  } else {
    // Wrap input
    $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
  }

  if (errorMsg) {
    $parent.find('.' + wrapClass).append(errorMsg);
  }

  if (icon) {
    if (icon.indexOf('{') !== -1) {
      icons = JSON.parse(icon);
    } else {
      icons[align] = icon;
    }
  }

  if (control.type == 'file') {
    // Set icon
    icons.right = $control.attr('data-icon-upload') || 'upload';
  }

  if (icon || ic) {
    extend$1(icons, ic);
    $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
  }
}

function addIconToggle(that, $parent, $control) {
  var icons = {},
      control = $control[0],
      toggle = $control.attr('data-password-toggle'),
      iconShow = $control.attr('data-icon-show') || 'eye',
      iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

  if (toggle) {
    icons.right = control.type == 'password' ? iconShow : iconHide;
  }

  addIcon($control, icons);

  if (toggle) {
    tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
      if (control.type == "text") {
        control.type = "password";
        $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
      } else {
        control.type = "text";
        $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
      }
    });
  }
}

function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
  // Wrap non-empty text nodes in span with mbsc-label class
  if (type == 'segmented') {
    $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
  } else if (type != 'button' && type != 'submit') {
    $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
      $$1(v).attr('title', $$1(v).text());
    });
    $parent.contents().filter(function () {
      return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
    }).each(function () {
      $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
    });
  }
}

function getRipple(theme) {
  var ripple = mobiscroll.themes.form[theme];
  return ripple && ripple.addRipple ? ripple : null;
}

function getAttr($elm, attr, def) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v;
}

function getCssClass(s) {
  var theme = getThemeName(s);
  var baseTheme = mobiscroll.themes.form[theme].baseTheme;
  return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
}

var FormControl =
/*#__PURE__*/
function () {
  function FormControl(elm, settings) {
    var _this = this;

    var s = extend$1({}, defaults, mobiscroll.settings, settings);
    var $elm = $$1(elm);
    var $p = $elm.parent();
    var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

    var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
    var type = getControlType($elm);
    var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
    var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

    if (elm.mbscInst) {
      elm.mbscInst.destroy();
    }

    if ($frame) {
      $frame.insertAfter($parent);
    }

    s.theme = getThemeName(s);

    if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
      s.rtl = mobiscroll.i18n[s.lang].rtl;
    }

    wrapLabel($parent, type, inputStyle, labelStyle, elm);
    $elm.addClass('mbsc-control'); // Attach events

    this._handle = this._handle.bind(this); // Prevent 300ms click latency

    events.forEach(function (ev) {
      $elm.on(ev, _this._handle);
    }); // Touch events are added separately, needs to be passive listener

    listen(elm, 'touchstart', this._handle, {
      passive: true
    });
    listen(elm, 'touchmove', this._handle, {
      passive: true
    });
    this.settings = s;
    this._type = type;
    this._elm = elm;
    this._$elm = $elm;
    this._$parent = $parent;
    this._$frame = $frame;
    this._ripple = getRipple(s.theme);
    this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
    this.cssClass = getCssClass(s);
    this.getClassElm().addClass(this.cssClass);
    elm.mbscInst = this;
  }

  var _proto = FormControl.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$parent;
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    var $elm = this._$elm;
    var elm = this._elm;
    $elm.removeClass('mbsc-control');
    this.getClassElm().removeClass(this.cssClass);
    events.forEach(function (ev) {
      $elm.off(ev, _this2._handle);
    });
    unlisten(elm, 'touchstart', this._handle, {
      passive: true
    });
    unlisten(elm, 'touchmove', this._handle, {
      passive: true
    });
    delete elm.mbscInst;
  };

  _proto.option = function option(s) {
    extend$1(this.settings, s);
    var classElm = this.getClassElm();

    if (this.cssClass) {
      classElm.removeClass(this.cssClass);
    }

    this.cssClass = getCssClass(this.settings);
    classElm.addClass(this.cssClass);
    this._ripple = getRipple(this.settings.theme);
  };

  _proto._handle = function _handle(ev) {
    switch (ev.type) {
      case 'touchstart':
      case 'mousedown':
        this._onStart(ev);

        break;

      case 'touchmove':
      case 'mousemove':
        this._onMove(ev);

        break;

      case 'touchend':
      case 'touchcancel':
      case 'mouseup':
      case 'mouseleave':
        this._onEnd(ev);

        break;
    }
  };

  _proto._addRipple = function _addRipple(ev) {
    if (this._ripple && this._$rippleElm) {
      this._ripple.addRipple(this._$rippleElm, ev);
    }
  };

  _proto._removeRipple = function _removeRipple() {
    if (this._ripple && this._$rippleElm) {
      this._ripple.removeRipple();
    }
  };

  _proto._onStart = function _onStart(ev) {
    var elm = this._elm;

    if (testTouch(ev, elm)) {
      this._startX = getCoord(ev, 'X');
      this._startY = getCoord(ev, 'Y');

      if ($active) {
        $active.removeClass('mbsc-active');
      }

      if (!elm.disabled) {
        this._isActive = true;
        $active = this._$elm;
        $active.addClass('mbsc-active');

        this._addRipple(ev);
      }
    }

    if (ev.type == 'touchstart') {
      this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }
  };

  _proto._onMove = function _onMove(ev) {
    // If movement is more than 9px, don't fire the click event handler
    if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
      this._$elm.removeClass('mbsc-active');

      this._removeRipple();

      this._isActive = false;
    }
  };

  _proto._onEnd = function _onEnd(ev) {
    var _this3 = this;

    var control = this._elm;
    var type = this._type;

    if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
      activateControl(control, type, ev);
    }

    if (this._isActive) {
      setTimeout(function () {
        _this3._$elm.removeClass('mbsc-active');

        _this3._removeRipple();
      }, 100);
    }

    this._isActive = false;
    $active = null;
  };

  return FormControl;
}();
mobiscroll.themes.form.mobiscroll = {};

var events$1 = ['focus', 'change', 'blur', 'animationstart'];
var Input =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Input, _FormControl);

  function Input(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
    addIconToggle(_assertThisInitialized(_this), $parent, $elm);
    _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
    _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));

    if (elm.type == 'file') {
      // Copy attributes and create dummy input
      var $existing = $parent.find('.mbsc-file-input');
      _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

      $elm.on('change', _this._setText);
    }

    $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

    events$1.forEach(function (ev) {
      $elm.on(ev, _this._checkLabel);
    }); // Move the dummy input after the element for correct styling

    if ($dummy.length) {
      $elm.after($dummy);

      if ($dummy.hasClass('mbsc-select-input')) {
        _this._delm = $dummy[0];

        _this.refresh();
      }
    }

    return _this;
  }

  var _proto = Input.prototype;

  _proto._setText = function _setText(ev) {
    var files = ev.target.files;
    var names = [];

    for (var i = 0; i < files.length; ++i) {
      names.push(files[i].name);
    }

    this._$input.val(names);
  };

  _proto._checkLabel = function _checkLabel(ev) {
    if (this._isFloating) {
      // In case of select we need to check the dummy element
      var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
      // due to the empty animation added in the css,
      // because there's no other event in case of the initial autofill

      if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
        this._$parent.addClass('mbsc-label-floating-active');
      } else {
        this._$parent.removeClass('mbsc-label-floating-active');
      }
    }
  };

  _proto._mouseDown = function _mouseDown(ev) {
    // Will prevent floating label animation when loosing focus only for a brief moment
    if (document.activeElement === this._elm && ev.target !== this._elm) {
      ev.preventDefault();
    }
  };

  _proto.refresh = function refresh() {
    this._checkLabel();
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    _FormControl.prototype.destroy.call(this);

    this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

    this._$parent.find('.mbsc-input-fill').remove();

    events$1.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._checkLabel);
    });

    this._$elm.off('change', this._setText);
  };

  return Input;
}(FormControl); // Init mbsc-input elements on page load

autoInit('[mbsc-input]', Input);

var MbscFormBase = (function (_super) {
    __extends(MbscFormBase, _super);
    function MbscFormBase(hostElem, _formService, zone) {
        var _this = _super.call(this, hostElem, zone) || this;
        _this._formService = _formService;
        _this.disabled = false;
        return _this;
    }
    MbscFormBase.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
    };
    MbscFormBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscFormBase.propDecorators = {
        'color': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
MbscFormBase.ɵfac = function MbscFormBase_Factory(t) { return new (t || MbscFormBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscFormBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscFormBase, selectors: [["", "mbsc-f-b", ""]], viewQuery: function MbscFormBase_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);
    } }, inputs: { color: "color", options: "options", disabled: "disabled", name: "name" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-f-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService }, { type: ɵngcc0.NgZone }]; }, { color: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], name: [{
            type: Input$1
        }], _initElem: [{
            type: ViewChild,
            args: ['initElement', { static: false }]
        }] }); })();
    return MbscFormBase;
}(MbscBase));
var MbscFormValueBase = (function (_super) {
    __extends(MbscFormValueBase, _super);
    function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, hostElem, _formService, zone) || this;
        _this._control = _control;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.errorMessage = '';
        _this.valueChangeEmitter = new EventEmitter();
        if (_control && (!_inputService || !_inputService.isControlSet)) {
            if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {
                _control.valueAccessor.oldAccessor = _this;
            }
            else {
                _control.valueAccessor = _this;
            }
        }
        return _this;
    }
    Object.defineProperty(MbscFormValueBase.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "innerValue", {
        get: function () {
            return this._value;
        },
        set: function (v) {
            this._value = v;
            this.onChange(v);
            this.valueChangeEmitter.emit(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this.refresh();
        },
        enumerable: true,
        configurable: true
    });
    MbscFormValueBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscFormValueBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    MbscFormValueBase.prototype.writeValue = function (v) {
        this._value = v;
        this.refresh();
    };
    MbscFormValueBase.prototype.refresh = function () {
        var _this = this;
        if (this.instance && this.instance.refresh) {
            setTimeout(function () {
                _this.instance.refresh();
            });
        }
        else {
            this._needRefresh = true;
        }
    };
    MbscFormValueBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this._needRefresh) {
            this.refresh();
        }
    };
    MbscFormValueBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscFormValueBase.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'valueChangeEmitter': [{ type: Output, args: ['valueChange',] },],
    };
MbscFormValueBase.ɵfac = function MbscFormValueBase_Factory(t) { return new (t || MbscFormValueBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscFormValueBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscFormValueBase, selectors: [["", "mbsc-fv-b", ""]], inputs: { readonly: "readonly", value: "value", error: "error", errorMessage: "errorMessage" }, outputs: { valueChangeEmitter: "valueChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormValueBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-fv-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl }, { type: ɵngcc0.NgZone }]; }, { readonly: [{
            type: Input$1
        }], value: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], valueChangeEmitter: [{
            type: Output,
            args: ['valueChange']
        }] }); })();
    return MbscFormValueBase;
}(MbscFormBase));
var MbscInputBase = (function (_super) {
    __extends(MbscInputBase, _super);
    function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this.type = 'text';
        _this.placeholder = '';
        return _this;
    }
    MbscInputBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscInputBase.propDecorators = {
        'autocomplete': [{ type: Input$1 },],
        'autocapitalize': [{ type: Input$1 },],
        'autocorrect': [{ type: Input$1 },],
        'spellcheck': [{ type: Input$1 },],
        'autofocus': [{ type: Input$1 },],
        'minlength': [{ type: Input$1 },],
        'maxlength': [{ type: Input$1 },],
        'required': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'type': [{ type: Input$1 },],
        'passwordToggle': [{ type: Input$1, args: ['password-toggle',] },],
        'iconShow': [{ type: Input$1, args: ['icon-show',] },],
        'iconHide': [{ type: Input$1, args: ['icon-hide',] },],
        'iconUpload': [{ type: Input$1, args: ['icon-upload',] },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'placeholder': [{ type: Input$1 },],
    };
MbscInputBase.ɵfac = function MbscInputBase_Factory(t) { return new (t || MbscInputBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscInputBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscInputBase, selectors: [["", "mbsc-i-b", ""]], inputs: { autocomplete: "autocomplete", autocapitalize: "autocapitalize", autocorrect: "autocorrect", spellcheck: "spellcheck", autofocus: "autofocus", minlength: "minlength", maxlength: "maxlength", required: "required", icon: "icon", iconAlign: ["icon-align", "iconAlign"], type: "type", passwordToggle: ["password-toggle", "passwordToggle"], iconShow: ["icon-show", "iconShow"], iconHide: ["icon-hide", "iconHide"], iconUpload: ["icon-upload", "iconUpload"], inputStyle: ["input-style", "inputStyle"], labelStyle: ["label-style", "labelStyle"], placeholder: "placeholder" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscInputBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-i-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl }, { type: ɵngcc0.NgZone }]; }, { autocomplete: [{
            type: Input$1
        }], autocapitalize: [{
            type: Input$1
        }], autocorrect: [{
            type: Input$1
        }], spellcheck: [{
            type: Input$1
        }], autofocus: [{
            type: Input$1
        }], minlength: [{
            type: Input$1
        }], maxlength: [{
            type: Input$1
        }], required: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], type: [{
            type: Input$1
        }], passwordToggle: [{
            type: Input$1,
            args: ['password-toggle']
        }], iconShow: [{
            type: Input$1,
            args: ['icon-show']
        }], iconHide: [{
            type: Input$1,
            args: ['icon-hide']
        }], iconUpload: [{
            type: Input$1,
            args: ['icon-upload']
        }], inputStyle: [{
            type: Input$1,
            args: ['input-style']
        }], labelStyle: [{
            type: Input$1,
            args: ['label-style']
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscInputBase;
}(MbscFormValueBase));
var MbscInput = (function (_super) {
    __extends(MbscInput, _super);
    function MbscInput(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _this.controlNg = true;
        _this.dropdown = false;
        _inputService.input = _this;
        return _this;
    }
    MbscInput.prototype.initControl = function () {
        var _this = this;
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Input(this._initElem.nativeElement, options);
        setTimeout(function () {
            _this.instance.refresh();
        });
    };
    MbscInput.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscInput.propDecorators = {
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'pattern': [{ type: Input$1 },],
        'accept': [{ type: Input$1 },],
        'multiple': [{ type: Input$1 },],
        'controlNg': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
    };
MbscInput.ɵfac = function MbscInput_Factory(t) { return new (t || MbscInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscInput.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscInput, selectors: [["mbsc-input"]], hostVars: 4, hostBindings: function MbscInput_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-control-ng", ctx.controlNg)("mbsc-err", ctx.error);
    } }, inputs: { min: "min", max: "max", step: "step", pattern: "pattern", accept: "accept", multiple: "multiple", controlNg: "controlNg", dropdown: "dropdown" }, features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 7, vars: 42, consts: [[1, "mbsc-input-wrap"], [3, "type", "placeholder", "ngModel", "disabled", "readonly", "ngModelChange", "blur"], ["initElement", ""], ["class", "mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5", 4, "ngIf"], ["class", "mbsc-err-msg", 4, "ngIf"], [1, "mbsc-select-ic", "mbsc-ic", "mbsc-ic-arrow-down5"], [1, "mbsc-err-msg"]], template: function MbscInput_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵelementStart(3, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MbscInput_Template_input_ngModelChange_3_listener($event) { return ctx.innerValue = $event; })("blur", function MbscInput_Template_input_blur_3_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, MbscInput_span_5_Template, 1, 0, "span", 3);
        ɵngcc0.ɵɵtemplate(6, MbscInput_span_6_Template, 2, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-err", ctx.error)("mbsc-select", ctx.dropdown)("mbsc-input-box", ctx.inputStyle == "box")("mbsc-input-outline", ctx.inputStyle == "outline")("mbsc-label-stacked", ctx.labelStyle == "stacked")("mbsc-label-inline", ctx.labelStyle == "inline")("mbsc-label-floating", ctx.labelStyle == "floating");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("type", ctx.type)("placeholder", ctx.placeholder)("ngModel", ctx.innerValue)("disabled", ctx.disabled)("readonly", ctx._readonly);
        ɵngcc0.ɵɵattribute("name", ctx.name)("data-icon", ctx.icon ? ctx.icon : null)("data-icon-align", ctx.iconAlign ? ctx.iconAlign : null)("data-password-toggle", ctx.passwordToggle ? "true" : null)("data-icon-show", ctx.iconShow ? ctx.iconShow : null)("data-icon-hide", ctx.iconHide ? ctx.iconHide : null)("data-icon-upload", ctx.iconUpload ? ctx.iconUpload : null)("min", ctx.min)("max", ctx.max)("minlength", ctx.minlength)("maxlength", ctx.maxlength)("autocomplete", ctx.autocomplete)("autocapitalize", ctx.autocapitalize)("autocorrect", ctx.autocorrect)("spellcheck", ctx.spellcheck)("autofocus", ctx.autofocus)("step", ctx.step)("pattern", ctx.pattern)("required", ctx.required)("accept", ctx.accept)("multiple", ctx.multiple);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.dropdown);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
    } }, directives: [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc1.MinLengthValidator, ɵngcc1.MaxLengthValidator, ɵngcc1.PatternValidator, ɵngcc1.RequiredValidator, ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscInput, [{
        type: Component,
        args: [{
                selector: 'mbsc-input',
                host: {
                    '[class.mbsc-control-ng]': 'controlNg',
                    '[class.mbsc-err]': 'error'
                },
                template: "\n        <label\n            [class.mbsc-err]=\"error\" [class.mbsc-select]=\"dropdown\"\n            [class.mbsc-input-box]=\"inputStyle == 'box'\"\n            [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n            [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n            [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n            [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n        >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <input #initElement [type]=\"type\" [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [attr.data-password-toggle]=\"passwordToggle ? 'true': null\"\n                    [attr.data-icon-show]=\"iconShow ? iconShow : null\"\n                    [attr.data-icon-hide]=\"iconHide ? iconHide : null\"\n                    [attr.data-icon-upload]=\"iconUpload ? iconUpload : null\"\n                    [attr.min]=\"min\"\n                    [attr.max]=\"max\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\"\n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.step]=\"step\"\n                    [attr.pattern]=\"pattern\"\n                    [attr.required]=\"required\"\n                    [attr.accept]=\"accept\"\n                    [attr.multiple]=\"multiple\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\" />\n                <span *ngIf=\"dropdown\" class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                providers: [MbscInputService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], pattern: [{
            type: Input$1
        }], accept: [{
            type: Input$1
        }], multiple: [{
            type: Input$1
        }], controlNg: [{
            type: Input$1
        }], dropdown: [{
            type: Input$1
        }] }); })();
    return MbscInput;
}(MbscInputBase));
var MbscInputModule = (function () {
    function MbscInputModule() {
    }
    MbscInputModule.ctorParameters = function () { return []; };
MbscInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscInputModule });
MbscInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscInputModule_Factory(t) { return new (t || MbscInputModule)(); }, imports: [[FormsModule, CommonModule, MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscInputModule, { declarations: function () { return [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase]; }, imports: function () { return [FormsModule, CommonModule, MbscBaseModule]; }, exports: function () { return [MbscInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscInputModule, [{
        type: NgModule,
        args: [{
                imports: [FormsModule, CommonModule, MbscBaseModule],
                declarations: [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase],
                exports: [MbscInput]
            }]
    }], function () { return []; }, null); })();
    return MbscInputModule;
}());

function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
  var $btn,
      changed,
      index,
      running,
      source,
      startX,
      startY,
      step,
      timer,
      check = isReadOnly || noop;

  function onBtnStart(ev) {
    var proceed;
    $btn = $$1(ev.currentTarget);
    step = +$btn.attr('data-step');
    index = +$btn.attr('data-index');
    changed = true;

    if (stopProp) {
      ev.stopPropagation();
    }

    if (ev.type == 'touchstart') {
      $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }

    if (ev.type == 'mousedown') {
      // Prevent focus
      ev.preventDefault();
    }

    if (ev.type != 'keydown') {
      //e.preventDefault();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      proceed = testTouch(ev, this);
    } else {
      proceed = ev.keyCode === 32;
    }

    if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
      if (start(index, step, ev)) {
        $btn.addClass('mbsc-active');

        if (ripple) {
          ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
        }
      }

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
      }
    }
  }

  function onBtnMove(ev) {
    if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
      changed = true;
      stop();
    }
  }

  function onBtnEnd(ev) {
    if (ev.type == 'touchend') {
      // Prevents iOS scroll on double tap
      ev.preventDefault();
    }

    stop();

    if (ev.type == 'mouseup') {
      $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
    }
  }

  function stop() {
    running = false;
    clearInterval(timer);

    if ($btn) {
      $btn.removeClass('mbsc-active');

      if (ripple) {
        setTimeout(function () {
          ripple.removeRipple();
        }, 100);
      }
    }
  }

  function start(i, st, ev) {
    if (!running && !check(i)) {
      index = i;
      step = st;
      source = ev;
      running = true;
      changed = false;
      setTimeout(tick, 100);
    }

    return running;
  }

  function tick() {
    if ($btn && $btn.hasClass('mbsc-disabled')) {
      stop();
      return;
    }

    if (running || !changed) {
      changed = true;
      action(index, step, source, tick);
    }

    if (running && delay) {
      clearInterval(timer);
      timer = setInterval(function () {
        action(index, step, source);
      }, delay);
    }
  }

  function destroy() {
    $elm.each(function (i, el) {
      unlisten(el, 'touchstart', onBtnStart, {
        passive: true
      });
      unlisten(el, 'mousedown', onBtnStart);
      unlisten(el, 'keydown', onBtnStart);
      unlisten(el, 'touchmove', onBtnMove, {
        passive: true
      });
      unlisten(el, 'touchend', onBtnEnd);
      unlisten(el, 'touchcancel', onBtnEnd);
      unlisten(el, 'keyup', onBtnEnd);
    });
  }

  $elm.each(function (i, el) {
    listen(el, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(el, 'mousedown', onBtnStart);
    listen(el, 'keydown', onBtnStart);
    listen(el, 'touchmove', onBtnMove, {
      passive: true
    });
    listen(el, 'touchend', onBtnEnd);
    listen(el, 'touchcancel', onBtnEnd);
    listen(el, 'keyup', onBtnEnd);
  });
  return {
    start: start,
    stop: stop,
    destroy: destroy
  };
}

var innerStyle = 'position:absolute;left:0;top:0;';
var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
var observer;
var count = 0;
function resizeObserver(el, callback, zone) {
  function reset() {
    expandChild.style.width = '100000px';
    expandChild.style.height = '100000px';
    expand.scrollLeft = 100000;
    expand.scrollTop = 100000;
    shrink.scrollLeft = 100000;
    shrink.scrollTop = 100000;
  }

  function checkHidden() {
    var now = new Date();
    hiddenRafId = 0;

    if (!stopCheck) {
      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
        lastCheck = now;
        reset();
      }

      if (!hiddenRafId) {
        hiddenRafId = raf(checkHidden);
      }
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = raf(onResize);
    }
  }

  function onResize() {
    rafId = 0;
    reset();
    callback();
  }

  var expand;
  var expandChild;
  var helper;
  var hiddenRafId;
  var rafId;
  var shrink;
  var stopCheck;
  var lastCheck = 0; //let isHidden = true;

  if (window.ResizeObserver) {
    if (!observer) {
      observer = new ResizeObserver(function (entries) {
        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var entry = _ref;

          entry.target.__mbscResize();
        }
      });
    }

    count++;
    el.__mbscResize = callback;
    observer.observe(el);
  } else {
    helper = document.createElement('div');
    helper.innerHTML = markup;
    helper.dir = 'ltr'; // Need this to work in rtl as well;

    shrink = helper.childNodes[1];
    expand = helper.childNodes[0];
    expandChild = expand.childNodes[0];
    el.appendChild(helper);
    expand.addEventListener('scroll', onScroll);
    shrink.addEventListener('scroll', onScroll);

    if (zone) {
      zone.runOutsideAngular(function () {
        raf(checkHidden);
      });
    } else {
      raf(checkHidden);
    }
  }

  return {
    detach: function detach() {
      if (observer) {
        count--;
        observer.unobserve(el);

        if (!count) {
          observer = null;
        }
      } else {
        el.removeChild(helper);
        stopCheck = true;
      }
    }
  };
}

var $activeElm,
    preventShow,
    themes = mobiscroll.themes,
    needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
    isAndroid = os == 'android',
    isIOS = os == 'ios',
    isIOS8 = isIOS && majorVersion == 8,
    halfBorder = isIOS && majorVersion > 7,
    prevdef = function prevdef(ev) {
  ev.preventDefault();
};

var EDITABLE = 'input,select,textarea,button';
var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
var Frame = function Frame(el, settings, inherit) {
  var //$ariaDiv,
  $ctx,
      $header,
      $lock,
      $markup,
      $overlay,
      $persp,
      $popup,
      $wnd,
      $wrapper,
      buttons,
      btn,
      ctx,
      doAnim,
      hasContext,
      isModal,
      isInserted,
      isPointer,
      markup,
      modalWidth,
      modalHeight,
      needsDimensions,
      needsLock,
      observer,
      overlay,
      popup,
      posDebounce,
      prevInst,
      s,
      scrollLock,
      touched,
      trigger,
      wndWidth,
      wndHeight,
      that = this,
      $elm = $$1(el),
      elmList = [],
      lastFocus = new Date();

  function onBtnStart(ev) {
    // Need this to prevent opening of sidemenus or similar
    if (s.stopProp) {
      ev.stopPropagation();
    }

    var b = closest(this, ev.target, '.mbsc-fr-btn-e');

    if (!b) {
      return;
    } // Can't call preventDefault here, it kills page scroll


    if (btn) {
      btn.removeClass('mbsc-active');
    }

    btn = $$1(b); // Active button

    if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
      btn.addClass('mbsc-active');
    }

    if (ev.type === 'mousedown') {
      $$1(document).on('mouseup', onBtnEnd);
    }
  }

  function onBtnEnd(ev) {
    if (btn) {
      btn.removeClass('mbsc-active');
      btn = null;
    }

    if (ev.type === 'mouseup') {
      $$1(document).off('mouseup', onBtnEnd);
    }
  }

  function onScroll(ev) {
    if (scrollLock && markup.contains(ev.target)) {
      ev.preventDefault();
    }
  }

  function onWndKeyDown(ev) {
    if (mobiscroll.activeInstance == that) {
      if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
        that.select();
      } else if (ev.keyCode == 27) {
        that.cancel();
      }
    }
  }

  function onShow(prevFocus) {
    if (!prevFocus && !isAndroid && that._activeElm) {
      //overlay.focus();
      lastFocus = new Date();

      that._activeElm.focus();
    } //that.ariaMessage(s.ariaMessage);

  }

  function onHide(prevAnim) {
    var $activeEl = $activeElm,
        focus = s.focusOnClose;

    that._markupRemove();

    $markup.remove();

    if (isModal) {
      ctx.mbscModals--;

      if (s.scrollLock) {
        ctx.mbscLock--;
      }

      if (!ctx.mbscLock) {
        $lock.removeClass('mbsc-fr-lock');
      }

      if (needsLock) {
        ctx.mbscIOSLock--;

        if (!ctx.mbscIOSLock) {
          $lock.removeClass('mbsc-fr-lock-ios');
          $ctx.css({
            top: '',
            left: ''
          });
          $wnd.scrollLeft(ctx.mbscScrollLeft);
          $wnd.scrollTop(ctx.mbscScrollTop);
        }
      } // The follwing should be done only if no other
      // instance was opened during the hide animation


      if (!ctx.mbscModals) {
        $lock.removeClass('mbsc-fr-lock-ctx');
      }

      if (!ctx.mbscModals || prevInst) {
        // Put focus back to the last active element
        if (!prevAnim) {
          if (!$activeEl) {
            $activeEl = $elm;
          }

          setTimeout(function () {
            if (focus === undefined || focus === true) {
              preventShow = true;
              $activeEl[0].focus();
            } else if (focus) {
              $$1(focus)[0].focus();
            }
          }, 200);
        }
      }
    }

    prevInst = undefined;
    isInserted = false;
    trigger('onHide');
  }

  function onPosition() {
    clearTimeout(posDebounce);
    posDebounce = setTimeout(function () {
      if (that.position(true)) {
        // Trigger reflow, needed on iOS safari, when orientation is changed
        popup.style.visibility = 'hidden';
        popup.offsetHeight;
        popup.style.visibility = '';
      }
    }, 200);
  }

  function onFocus(ev) {
    if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
      lastFocus = new Date();

      that._activeElm.focus();
    }
  }

  function insertMarkup(prevAnim, prevFocus) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
      onShow(prevFocus);
    }

    function onOverlayStart(ev) {
      if (!target && ev.target == overlay) {
        target = true;
        moved = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
      }
    }

    function onOverlayMove(ev) {
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
        moved = true;
      }
    } // Might be not visible if immediately hidden


    if (!that._isVisible) {
      return;
    } // Show


    if (isModal) {
      $markup.appendTo($ctx);
    } else if ($elm.is('div') && !that._hasContent) {
      // Insert inside the element on which was initialized
      $elm.empty().append($markup);
    } else {
      // Insert after the element
      if ($elm.hasClass('mbsc-control')) {
        var $wrap = $elm.closest('.mbsc-control-w');
        $markup.insertAfter($wrap);

        if ($wrap.hasClass('mbsc-select')) {
          $wrap.addClass('mbsc-select-inline');
        }
      } else {
        $markup.insertAfter($elm);
      }
    }

    isInserted = true;

    that._markupInserted($markup);

    trigger('onMarkupInserted', {
      target: markup
    });

    if (isModal && s.closeOnOverlayTap) {
      var moved, target, startX, startY;
      listen(overlay, 'touchstart', onOverlayStart, {
        passive: true
      });
      listen(overlay, 'touchmove', onOverlayMove, {
        passive: true
      });
      $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
        target = false;
      }).on('touchend click', function (ev) {
        if (target && !moved) {
          that.cancel();

          if (ev.type == 'touchend') {
            preventClick();
          }
        }

        target = false;
      });
    }

    $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
      if (ev.keyCode == 32) {
        // Space
        ev.preventDefault();
        ev.stopPropagation();
        this.click();
      }
    }).on('keydown', function (ev) {
      // Trap focus inside modal
      if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
        // Prevent page scroll on space press
        ev.preventDefault();
      } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
        // Tab
        var $focusable = $markup.find(FOCUSABLE).filter(function () {
          return this.offsetWidth > 0 || this.offsetHeight > 0;
        }),
            index = $focusable.index($$1(':focus', $markup)),
            i = $focusable.length - 1,
            target = 0;

        if (ev.shiftKey) {
          i = 0;
          target = -1;
        }

        if (index === i) {
          $focusable.eq(target)[0].focus();
          ev.preventDefault();
        }
      }
    }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
    listen(markup, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(markup, 'mousedown', onBtnStart); // Need event capture for this

    listen(markup, 'touchstart', function () {
      if (!touched) {
        touched = true;
        $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    }, {
      passive: true,
      capture: true
    }); // Init buttons

    $$1.each(buttons, function (i, b) {
      that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
        b = isString(b) ? that.buttons[b] : b;
        (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
      }, true);
    });

    that._attachEvents($markup); // Set position


    if (that.position() === false) {
      return;
    }

    if (isModal || that._checkSize) {
      observer = resizeObserver(markup, onPosition, s.zone);
    }

    if (isModal) {
      $markup.removeClass('mbsc-fr-pos');

      if (doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onShow(prevFocus);
      }
    }

    trigger('onShow', {
      target: markup,
      valueText: that._tempValue
    });
  }

  function show(beforeShow, $elm) {
    if (that._isVisible) {
      return;
    }

    if (beforeShow) {
      beforeShow();
    }

    if (that.show() !== false) {
      $activeElm = $elm;
    }
  }

  function set() {
    that._fillValue();

    trigger('onSet', {
      valueText: that._value
    });
  }

  function cancel() {
    trigger('onCancel', {
      valueText: that._value
    });
  }

  function clear() {
    that.setVal(null, true);
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  /**
   * Positions the scroller on the screen.
   */

  that.position = function (check) {
    var anchor,
        anchorWidth,
        anchorHeight,
        anchorPos,
        anchorTop,
        anchorLeft,
        arrow,
        arrowWidth,
        arrowHeight,
        docHeight,
        docWidth,
        isWrapped,
        newHeight,
        newWidth,
        oldHeight,
        oldWidth,
        width,
        top,
        left,
        css = {},
        scrollLeft = 0,
        scrollTop = 0,
        minWidth = 0,
        totalWidth = 0;

    if (!isInserted) {
      return false;
    }

    oldWidth = wndWidth;
    oldHeight = wndHeight;
    newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
    newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

    if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
      return;
    }

    if (that._checkResp(newWidth)) {
      return false;
    }

    wndWidth = newWidth;
    wndHeight = newHeight;

    if (that._isFullScreen || /top|bottom/.test(s.display)) {
      // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
      $popup.width(newWidth);
    } else if (isModal) {
      // Reset width
      $wrapper.width('');
    }

    that._position($markup); // Call position for nested mobiscroll components
    // $('.mbsc-comp', $markup).each(function () {
    //     var inst = instances[this.id];
    //     if (inst && inst !== that && inst.position) {
    //         inst.position();
    //     }
    // });


    if (!that._isFullScreen && /center|bubble/.test(s.display)) {
      $$1('.mbsc-w-p', $markup).each(function () {
        // Need fractional values here, so offsetWidth is not ok
        width = this.getBoundingClientRect().width;
        totalWidth += width;
        minWidth = width > minWidth ? width : minWidth;
      });
      isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
      $wrapper.css({
        'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
        'white-space': isWrapped ? '' : 'nowrap'
      });
    }

    if (trigger('onPosition', {
      target: markup,
      popup: popup,
      hasTabs: isWrapped,
      oldWidth: oldWidth,
      oldHeight: oldHeight,
      windowWidth: newWidth,
      windowHeight: newHeight
    }) === false || !isModal) {
      return;
    }

    if (needsDimensions) {
      scrollLeft = $wnd.scrollLeft();
      scrollTop = $wnd.scrollTop();

      if (wndWidth) {
        $persp.css({
          width: '',
          height: ''
        });
      }
    }

    modalWidth = popup.offsetWidth;
    modalHeight = popup.offsetHeight;
    scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

    if (s.display == 'center') {
      left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
      top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
    } else if (s.display == 'bubble') {
      anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
      arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
      anchorPos = anchor.offset();
      anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
      anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
      anchorWidth = anchor[0].offsetWidth;
      anchorHeight = anchor[0].offsetHeight;
      arrowWidth = arrow.offsetWidth;
      arrowHeight = arrow.offsetHeight; // Horizontal positioning

      left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
      // Below the input

      top = anchorTop + anchorHeight + arrowHeight / 2;

      if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
        $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

        top = anchorTop - modalHeight - arrowHeight / 2;
      } else {
        $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
      } // Set arrow position


      $$1('.mbsc-fr-arr', $markup).css({
        left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
      }); // Lock scroll only if popup is entirely in the viewport

      scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
    } else {
      left = scrollLeft;
      top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
    }

    if (needsDimensions) {
      // If top + modal height > doc height, increase doc height
      docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
      docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
      $persp.css({
        width: docWidth,
        height: docHeight
      }); // Check if scroll needed

      if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
        $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
      }
    }

    css.top = Math.floor(top);
    css.left = Math.floor(left);
    $popup.css(css);
    return true;
  };
  /**
   * Show mobiscroll on focus and click event of the parameter.
   * @param {HTMLElement} elm - Events will be attached to this element.
   * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
   */


  that.attachShow = function (elm, beforeShow) {
    var $label,
        $elm = $$1(elm).off('.mbsc'),
        readOnly = $elm.prop('readonly');
    tapOff($elm);

    if (s.display !== 'inline') {
      if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
        $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
          // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
          ev.preventDefault();
        }).on('focus.mbsc', function () {
          if (that._isVisible) {
            // Don't allow input focus if mobiscroll is being opened
            this.blur();
          }
        });
        $label = $$1('label[for="' + $elm.attr('id') + '"]');

        if (!$label.length) {
          $label = $elm.closest('label');
        }
      }

      if (!$elm.is('select')) {
        if (s.showOnFocus) {
          $elm.on('focus.mbsc', function () {
            if (!preventShow) {
              show(beforeShow, $elm);
            } else {
              preventShow = false;
            }
          });
        }

        if (s.showOnTap) {
          $elm.on('keydown.mbsc', function (ev) {
            if (ev.keyCode == 32 || ev.keyCode == 13) {
              // Space or Enter
              ev.preventDefault();
              ev.stopPropagation();
              show(beforeShow, $elm);
            }
          });
          that.tap($elm, function (ev) {
            if (ev.isMbscTap) {
              touched = true;
            }

            show(beforeShow, $elm);
          });

          if ($label && $label.length) {
            tapOff($label);
            that.tap($label, function (ev) {
              ev.preventDefault();

              if (ev.target !== $elm[0]) {
                show(beforeShow, $elm);
              }
            });
          }
        }
      }

      elmList.push({
        readOnly: readOnly,
        el: $elm,
        lbl: $label
      });
    }
  };
  /**
   * Set button handler.
   */


  that.select = function () {
    if (isModal) {
      that.hide(false, 'set', false, set);
    } else {
      set();
    }
  };
  /**
   * Cancel and hide the scroller instance.
   */


  that.cancel = function () {
    if (isModal) {
      that.hide(false, 'cancel', false, cancel);
    } else {
      cancel();
    }
  };
  /**
   * Clear button handler.
   */


  that.clear = function () {
    that._clearValue();

    trigger('onClear');

    if (isModal && that._isVisible && !that.live) {
      that.hide(false, 'clear', false, clear);
    } else {
      clear();
    }
  };
  /**
   * Enables the scroller and the associated input.
   */


  that.enable = function () {
    s.disabled = false;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = false;
      }
    });
  };
  /**
   * Disables the scroller and the associated input.
   */


  that.disable = function () {
    s.disabled = true;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = true;
      }
    });
  };
  /**
   * Shows the scroller instance.
   * @param {Boolean} prevAnim - Prevent animation if true
   * @param {Boolean} prevFocus - Prevent focusing if true
   */


  that.show = function (prevAnim, prevFocus) {
    var hasButtons, html, scrollLeft, scrollTop;

    if (s.disabled || that._isVisible) {
      return;
    } // Parse value from input


    that._readValue();

    if (trigger('onBeforeShow') === false) {
      return false;
    }

    $activeElm = null;
    doAnim = s.animate;
    buttons = s.buttons || [];
    needsDimensions = hasContext || s.display == 'bubble';
    needsLock = needsFixed && !needsDimensions && s.scrollLock;
    hasButtons = buttons.length > 0; //touched = false;

    if (doAnim !== false) {
      if (s.display == 'top') {
        doAnim = doAnim || 'slidedown';
      } else if (s.display == 'bottom') {
        doAnim = doAnim || 'slideup';
      } else if (s.display == 'center' || s.display == 'bubble') {
        doAnim = doAnim || 'pop';
      }
    }

    if (isModal) {
      wndWidth = 0;
      wndHeight = 0;

      if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
        //$lock.scrollTop(0);
        ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
        ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
        $ctx.css({
          top: -scrollTop + 'px',
          left: -scrollLeft + 'px'
        });
      }

      $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

      if ($$1(document.activeElement).is('input,textarea')) {
        document.activeElement.blur();
      } // Save active instance to previous


      prevInst = mobiscroll.activeInstance; // Set active instance

      mobiscroll.activeInstance = that; // Keep track of modals opened per context

      ctx.mbscModals = (ctx.mbscModals || 0) + 1;

      if (needsLock) {
        ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
      }

      if (s.scrollLock) {
        ctx.mbscLock = (ctx.mbscLock || 0) + 1;
      }
    }
    /*
    // Create wheels containers
    html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme +
        (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' +
        (s.cssClass || '') + ' ' +
        (s.compClass || '') +
        (that._isLiquid ? ' mbsc-fr-liq' : '') +
        (isModal ? ' mbsc-fr-pos' + ((s.showOverlay ? '' : ' mbsc-fr-no-overlay')) : '') +
        (isPointer ? ' mbsc-fr-pointer' : '') +
        (halfBorder ? ' mbsc-fr-hb' : '') +
        (touched ? '' : ' mbsc-no-touch') +
        (needsLock ? ' mbsc-platform-ios' : '') +
        (hasButtons ? (buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '') : ' mbsc-fr-nobtn') + '">' +
        (isModal ? '<div class="mbsc-fr-persp">' +
            (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
            '<div role="dialog" class="mbsc-fr-scroll">' : '') +
        '<div class="mbsc-fr-popup' +
        (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') +
        (s.headerText ? ' mbsc-fr-has-hdr' : '') +
        '">' + // Popup
        (s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + // Bubble arrow
        (isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') +
        '<div class="mbsc-fr-w">' + // Popup content
        //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
        (s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
        '<div class="mbsc-fr-c">'; // Wheel group container
    */
    // --- REMOTE TRIAL CODE START ---


    html = that.remote.html1.replace('mbsc-no-touch', '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + that.remote.html2 + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
    s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + // Bubble arrow
    that.remote.html3 + (s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
    '<div class="mbsc-fr-c">'; // Wheel group container
    // --- REMOTE TRIAL CODE END ---

    html += that._generateContent(); // --- REMOTE TRIAL CODE START ---

    html += that.remote.html4; // --- REMOTE TRIAL CODE END ---

    /*
    html += '</div>';
     if (hasButtons) {
        var b,
            i,
            j,
            l = buttons.length;
         html += '<div class="mbsc-fr-btn-cont">';
        for (i = 0; i < buttons.length; i++) {
            j = s.btnReverse ? l - i - 1 : i;
            b = buttons[j];
            b = isString(b) ? that.buttons[b] : b;
             if (b.handler === 'set') {
                b.parentClass = 'mbsc-fr-btn-s';
            }
             if (b.handler === 'cancel') {
                b.parentClass = 'mbsc-fr-btn-c';
            }
             html += '<div' + (s.btnWidth ? ' style="width:' + (100 / buttons.length) + '%"' : '') +
                ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' +
                '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' +
                (b.cssClass === undefined ? s.btnClass : b.cssClass) +
                (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
        }
        html += '</div>';
    }
    html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
    */

    $markup = $$1(html);
    $persp = $$1('.mbsc-fr-persp', $markup);
    $overlay = $$1('.mbsc-fr-scroll', $markup);
    $wrapper = $$1('.mbsc-fr-w', $markup);
    $popup = $$1('.mbsc-fr-popup', $markup);
    $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

    markup = $markup[0];
    overlay = $overlay[0];
    popup = $popup[0];
    that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
    that._markup = $markup;
    that._isVisible = true;
    that.markup = markup;

    that._markupReady($markup);

    trigger('onMarkupReady', {
      target: markup
    }); // Attach events

    if (isModal) {
      // Enter / ESC
      $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

      if (s.scrollLock) {
        listen(document, 'touchmove', onScroll, {
          passive: false
        });
        listen(document, 'mousewheel', onScroll, {
          passive: false
        });
        listen(document, 'wheel', onScroll, {
          passive: false
        });
      }

      if (s.focusTrap) {
        $wnd.on('focusin', onFocus);
      }
    }

    if (isModal) {
      // Wait for the toolbar and addressbar to appear on iOS
      setTimeout(function () {
        insertMarkup(prevAnim, prevFocus);
      }, needsLock ? 100 : 0);
    } else {
      insertMarkup(prevAnim, prevFocus);
    }
  };
  /**
   * Hides the scroller instance.
   */


  that.hide = function (prevAnim, btn, force, callback) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd);
      onHide(prevAnim);
    } // If onClose handler returns false, prevent hide


    if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
      valueText: that._tempValue,
      button: btn
    }) === false) {
      return false;
    }

    that._isVisible = false;

    if (observer) {
      observer.detach();
      observer = null;
    }

    if (isModal) {
      if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
        document.activeElement.blur();
      }

      if (mobiscroll.activeInstance == that) {
        mobiscroll.activeInstance = prevInst;
      }

      $$1(window).off('keydown', onWndKeyDown);
      $wnd.off('focusin', onFocus);
      unlisten(document, 'touchmove', onScroll, {
        passive: false
      });
      unlisten(document, 'mousewheel', onScroll, {
        passive: false
      });
      unlisten(document, 'wheel', onScroll, {
        passive: false
      });
    } // Hide wheels and overlay


    if ($markup) {
      if (isModal && isInserted && doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onHide(prevAnim);
      }

      that._detachEvents($markup);
    }

    if (callback) {
      callback();
    } // For validation


    $elm.trigger('blur');
    trigger('onClose', {
      valueText: that._value
    });
  }; // that.ariaMessage = function (txt) {
  //     $ariaDiv.html('');
  //     setTimeout(function () {
  //         $ariaDiv.html(txt);
  //     }, 100);
  // };

  /**
   * Return true if the scroller is currently visible.
   */


  that.isVisible = function () {
    return that._isVisible;
  }; // Protected functions to override


  that.setVal = noop;
  that.getVal = noop;
  that._generateContent = noop;
  that._attachEvents = noop;
  that._detachEvents = noop;
  that._readValue = noop;
  that._clearValue = noop;
  that._fillValue = noop;
  that._markupReady = noop;
  that._markupInserted = noop;
  that._markupRemove = noop;
  that._position = noop;
  that.__processSettings = noop;
  that.__init = noop;
  that.__destroy = noop; // Generic frame functions

  /**
   * Destroys the mobiscroll instance.
   */

  that._destroy = function () {
    // Force hide without animation
    that.hide(true, false, true);
    $elm.off('.mbsc');
    tapOff($elm); // Remove all events from elements

    $$1.each(elmList, function (i, v) {
      v.el.off('.mbsc').prop('readonly', v.readOnly);
      tapOff(v.el);

      if (v.lbl) {
        v.lbl.off('.mbsc');
        tapOff(v.lbl);
      }
    });

    that.__destroy();
  };

  that._updateHeader = function () {
    var t = s.headerText,
        txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
    $header.html(txt || '&nbsp;');
  };

  that._getRespCont = function () {
    hasContext = s.context != 'body';
    $wnd = $$1(hasContext ? s.context : window);
    return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
  };

  that._processSettings = function (resp) {
    var b, i;

    that.__processSettings(resp);

    isPointer = !s.touchUi;

    if (isPointer) {
      s.display = resp.display || settings.display || 'bubble';
      s.buttons = resp.buttons || settings.buttons || [];
      s.showOverlay = resp.showOverlay || settings.showOverlay || false;
    } // Add default buttons


    s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

    s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
    buttons = s.buttons || [];
    isModal = s.display !== 'inline';
    $ctx = $$1(s.context);
    $lock = hasContext ? $ctx : $$1('body,html');
    ctx = $ctx[0];
    that.live = true; // If no set button is found, live mode is activated

    for (i = 0; i < buttons.length; i++) {
      b = buttons[i];

      if (b == 'ok' || b == 'set' || b.handler == 'set') {
        that.live = false;
      }
    }

    that.buttons.set = {
      text: s.setText,
      icon: s.setIcon,
      handler: 'set'
    };
    that.buttons.cancel = {
      text: s.cancelText,
      icon: s.cancelIcon,
      handler: 'cancel'
    };
    that.buttons.close = {
      text: s.closeText,
      icon: s.closeIcon,
      handler: 'cancel'
    };
    that.buttons.clear = {
      text: s.clearText,
      icon: s.clearIcon,
      handler: 'clear'
    };
    that._isInput = $elm.is('input');
  };
  /**
   * Scroller initialization.
   */


  that._init = function (newSettings) {
    var wasVisible = that._isVisible,
        wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

    if (wasVisible) {
      that.hide(true, false, true);
    } // Unbind all events (if re-init)


    $elm.off('.mbsc');
    tapOff($elm);

    that.__init(newSettings);

    that._isLiquid = s.layout == 'liquid';

    if (isModal) {
      that._readValue();

      if (!that._hasContent && !s.skipShow) {
        that.attachShow($elm);
      }

      if (wasVisible) {
        that.show(wasReady);
      }
    } else {
      that.show();
    }

    $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
      if (!that._preventChange) {
        that.setVal($elm.val(), true, false);
      }

      that._preventChange = false;
    });
  };

  that.buttons = {};
  that.handlers = {
    set: that.select,
    cancel: that.cancel,
    clear: that.clear
  };
  that._value = null;
  that._isValid = true;
  that._isVisible = false; // Constructor

  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
Frame.prototype._defaults = {
  // Localization
  lang: 'en',
  setText: 'Set',
  selectedText: '{count} selected',
  closeText: 'Close',
  cancelText: 'Cancel',
  clearText: 'Clear',
  // Options
  context: 'body',
  maxPopupWidth: 600,
  disabled: false,
  closeOnOverlayTap: true,
  showOnFocus: isAndroid || isIOS,
  // Needed for ion-input
  showOnTap: true,
  display: 'center',
  scroll: true,
  scrollLock: true,
  showOverlay: true,
  tap: true,
  touchUi: true,
  btnClass: 'mbsc-fr-btn',
  btnWidth: true,
  focusTrap: true,
  focusOnClose: !isIOS8 // Temporary for iOS8

};
classes.Frame = Frame;
themes.frame.mobiscroll = {
  headerText: false,
  btnWidth: false
};
themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
  rows: 5,
  showLabel: false,
  selectedLineBorder: 1,
  weekDays: 'min',
  checkIcon: 'ion-ios7-checkmark-empty',
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
});

if (isBrowser) {
  // Prevent re-show on window focus
  $$1(window).on('focus', function () {
    if ($activeElm) {
      preventShow = true;
    }
  });
}

// eslint-disable-next-line no-unused-vars
var isIOS$1 = os == 'ios';
var ScrollViewBase = function ScrollViewBase(el, settings, inherit) {
  var $btn,
      $scrollbar,
      $scrollbarTrack,
      btnTimer,
      contSize,
      diffX,
      diffY,
      diff,
      dir,
      easing,
      elastic,
      endX,
      endY,
      eventObj,
      isBtn,
      isInfinite,
      maxScroll,
      maxSnapScroll,
      minScroll,
      move,
      moving,
      nativeScroll,
      rafID,
      //rafMoveID,
  rafRunning,
      scrollbar,
      scrollbarHeight,
      scrollbarOffset,
      scrollbarTrack,
      scrolled,
      scrollDebounce,
      scrollSnap,
      scrollTimer,
      snap,
      snapPoints,
      startPos,
      startTime,
      startX,
      startY,
      style,
      target,
      transTimer,
      threshold,
      trigger,
      vertical,
      that = this,
      currPos,
      currSnap = 0,
      currSnapDir = 1,
      s = settings,
      $elm = $$1(el);

  function onStart(ev) {
    trigger('onStart', {
      domEvent: ev
    }); // Better performance if there are tap events on document

    if (s.stopProp) {
      ev.stopPropagation();
    } //if (s.prevDef || ev.type == 'mousedown') {


    if (s.prevDef && ev.type == 'mousedown') {
      // Prevent touch highlight and focus
      ev.preventDefault();
    }

    if (s.readonly || s.lock && moving) {
      return;
    }

    if (testTouch(ev, this) && !move && mobiscroll.EmtjC) {
      if ($btn) {
        $btn.removeClass('mbsc-active');
      } // Highlight button


      isBtn = false;

      if (!moving) {
        $btn = $$1(ev.target).closest('.mbsc-btn-e', this);

        if ($btn.length && !$btn.hasClass('mbsc-disabled')) {
          isBtn = true;
          btnTimer = setTimeout(function () {
            $btn.addClass('mbsc-active');
          }, 100);
        }
      }

      move = true;
      scrolled = false;
      nativeScroll = false;
      that.scrolled = moving;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      endX = startX;
      diffX = 0;
      diffY = 0;
      diff = 0;
      startTime = new Date();
      startPos = +getPosition(target, vertical) || 0; // Stop scrolling animation, 1ms is needed for Android 4.0

      if (moving) {
        scroll(startPos, isIOS$1 ? 0 : 1);
      }

      if (ev.type === 'mousedown') {
        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
      }
    }
  }

  function onMove(ev) {
    if (move) {
      if (s.stopProp) {
        ev.stopPropagation();
      }

      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;
      diff = vertical ? diffY : diffX;

      if (isBtn && (Math.abs(diffY) > s.thresholdY || Math.abs(diffX) > s.thresholdX)) {
        clearTimeout(btnTimer);
        $btn.removeClass('mbsc-active');
        isBtn = false;
      }

      if (that.scrolled || !nativeScroll && Math.abs(diff) > threshold) {
        if (!scrolled) {
          trigger('onGestureStart', eventObj);
        }

        that.scrolled = scrolled = true;

        if (!rafRunning) {
          rafRunning = true;
          rafID = raf(onMoving);
        }
      }

      if (vertical || s.scrollLock) {
        // Always prevent native scroll, if vertical
        ev.preventDefault();
      } else {
        if (that.scrolled) {
          // Prevent native scroll
          ev.preventDefault();
        } else if (Math.abs(diffY) > 7) {
          nativeScroll = true;
          that.scrolled = true;
          onEnd();
        }
      }
    }
  }

  function onMoving() {
    //var time = new Date();
    if (maxSnapScroll) {
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    }

    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic)); //if (s.momentum) {
    //    startTime = time;
    //    lastX = endX;
    //}

    rafRunning = false;
  }

  function onEnd(ev) {
    if (move) {
      var speed,
          time = new Date() - startTime; // Better performance if there are tap events on document

      if (s.stopProp && ev) {
        ev.stopPropagation();
      }

      rafc(rafID);
      rafRunning = false;

      if (!nativeScroll && that.scrolled) {
        // Calculate momentum distance
        if (s.momentum && time < 300) {
          speed = diff / time; //speed = Math.abs(lastX - endX) / time;

          diff = Math.max(Math.abs(diff), speed * speed / s.speedUnit) * (diff < 0 ? -1 : 1);
        }

        finalize(diff);
      }

      if (isBtn) {
        clearTimeout(btnTimer);
        $btn.addClass('mbsc-active');
        setTimeout(function () {
          $btn.removeClass('mbsc-active');
        }, 100);

        if (!nativeScroll && !that.scrolled) {
          trigger('onBtnTap', {
            target: $btn[0],
            domEvent: ev
          });
        }
      } // Detach document events


      if (ev && ev.type == 'mouseup') {
        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      move = false;
    }
  }

  function onClick(ev) {
    if (that.scrolled) {
      that.scrolled = false;
      ev.stopPropagation();
      ev.preventDefault();
    }
  }

  function onScroll(ev) {
    if (!el.contains(ev.target)) {
      return;
    }

    ev = ev.originalEvent || ev;
    diff = vertical ? ev.deltaY == undefined ? ev.wheelDelta || ev.detail : ev.deltaY : ev.deltaX;
    trigger('onStart', {
      domEvent: ev
    });

    if (s.stopProp) {
      ev.stopPropagation();
    }

    if (diff && mobiscroll.EmtjC) {
      ev.preventDefault(); //diff = diff < 0 ? 20 : -20;

      if (ev.deltaMode && ev.deltaMode == 1) {
        diff *= 15;
      }

      diff = constrain(-diff, -scrollSnap, scrollSnap);
      startPos = currPos;

      if (s.readonly) {
        return;
      }

      if (!scrolled) {
        gestureStart();
      }

      if (startPos + diff < minScroll) {
        startPos = minScroll;
        diff = 0;
      }

      if (startPos + diff > maxScroll) {
        startPos = maxScroll;
        diff = 0;
      }

      if (!rafRunning) {
        rafRunning = true;
        rafID = raf(onMoving);
      }

      if (!diff && scrolled) {
        return;
      }

      scrolled = true;
      clearTimeout(scrollDebounce);
      scrollDebounce = setTimeout(function () {
        rafc(rafID);
        rafRunning = false;
        scrolled = false;
        finalize(diff);
      }, 200);
    }
  }

  function onScrollBarStart(ev) {
    trigger('onStart', {
      domEvent: ev
    });

    if (s.readonly) {
      return;
    }

    ev.stopPropagation();
    startPos = currPos;
    scrolled = false;

    if (ev.target == scrollbar) {
      startY = getCoord(ev, 'Y', true);
      $$1(document).on('mousemove', onScrollBarMove).on('mouseup', onScrollBarEnd);
    } else {
      startY = $scrollbar.offset().top;
      onScrollBarMove(ev);
      onScrollBarEnd();
    }
  }

  function onScrollBarMove(ev) {
    var percent = (getCoord(ev, 'Y', true) - startY) / contSize;

    if (isInfinite) {
      diff = -(maxSnapScroll * snap * 2 + contSize) * percent;
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    } else {
      diff = (minScroll - maxScroll - contSize) * percent;
    }

    if (!scrolled) {
      gestureStart();
    }

    scrolled = true;
    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic));
  }

  function onScrollBarEnd() {
    startPos = currPos;
    finalize(0);
    $$1(document).off('mousemove', onScrollBarMove).off('mouseup', onScrollBarEnd);
  }

  function onScrollBarClick(ev) {
    ev.stopPropagation();
  }

  function gestureStart() {
    eventObj = {
      posX: vertical ? 0 : currPos,
      posY: vertical ? currPos : 0,
      originX: vertical ? 0 : startPos,
      originY: vertical ? startPos : 0,
      direction: diff > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
    };
    trigger('onGestureStart', eventObj);
  }

  function finalize(diff) {
    var i, time, newPos; // Limit scroll to snap size

    if (maxSnapScroll) {
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    } // Calculate snap and limit between min and max


    newPos = constrain(Math.round((startPos + diff) / snap) * snap, minScroll, maxScroll); // Snap to nearest element

    if (snapPoints) {
      if (diff < 0) {
        for (i = snapPoints.length - 1; i >= 0; i--) {
          if (Math.abs(newPos) + contSize >= snapPoints[i].breakpoint) {
            currSnap = i;
            currSnapDir = 2;
            newPos = snapPoints[i].snap2;
            break;
          }
        }
      } else if (diff >= 0) {
        for (i = 0; i < snapPoints.length; i++) {
          if (Math.abs(newPos) <= snapPoints[i].breakpoint) {
            currSnap = i;
            currSnapDir = 1;
            newPos = snapPoints[i].snap1;
            break;
          }
        }
      }

      newPos = constrain(newPos, minScroll, maxScroll);
    }

    time = s.time || (currPos < minScroll || currPos > maxScroll ? 1000 : Math.max(1000, Math.abs(newPos - currPos) * s.timeUnit));
    eventObj.destinationX = vertical ? 0 : newPos;
    eventObj.destinationY = vertical ? newPos : 0;
    eventObj.duration = time;
    eventObj.transitionTiming = easing;
    trigger('onGestureEnd', eventObj); // Scroll to the calculated position

    that.scroll(newPos, time);
  }

  function scroll(pos, time, tap, callback) {
    var percent,
        changed = pos != currPos,
        anim = time > 1,
        timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '',
        done = function done() {
      clearInterval(scrollTimer);
      clearTimeout(transTimer); //rafc(rafMoveID);

      moving = false;
      currPos = pos;
      eventObj.posX = vertical ? 0 : pos;
      eventObj.posY = vertical ? pos : 0;

      if (changed) {
        trigger('onMove', eventObj);
      }

      if (anim) {
        //that.scrolled = false;
        trigger('onAnimationEnd', eventObj);
      }

      if (callback) {
        callback();
      }
    };

    eventObj = {
      posX: vertical ? 0 : currPos,
      posY: vertical ? currPos : 0,
      originX: vertical ? 0 : startPos,
      originY: vertical ? startPos : 0,
      direction: pos - currPos > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
    };
    currPos = pos;

    if (anim) {
      eventObj.destinationX = vertical ? 0 : pos;
      eventObj.destinationY = vertical ? pos : 0;
      eventObj.duration = time;
      eventObj.transitionTiming = easing;
      trigger('onAnimationStart', eventObj);
    }

    style[jsPrefix + 'Transition'] = timing;
    style[jsPrefix + 'Transform'] = 'translate3d(' + (vertical ? '0,' + pos + 'px,' : pos + 'px,' + '0,') + '0)';

    if (scrollbar && scrollbarHeight) {
      percent = isInfinite ? (scrollbarOffset - pos) / (maxSnapScroll * snap * 2) : (pos - maxScroll) / (minScroll - maxScroll);
      scrollbar.style[jsPrefix + 'Transition'] = timing;
      scrollbar.style[jsPrefix + 'Transform'] = 'translate3d(0,' + Math.max(0, Math.min((contSize - scrollbarHeight) * percent, contSize - scrollbarHeight)) + 'px,0)';
    }

    if (!changed && !moving || !time || time <= 1) {
      done();
    } else if (time) {
      moving = !tap;
      clearInterval(scrollTimer);
      scrollTimer = setInterval(function () {
        //rafMoveID = raf(function () {
        var p = +getPosition(target, vertical) || 0;
        eventObj.posX = vertical ? 0 : p;
        eventObj.posY = vertical ? p : 0;
        trigger('onMove', eventObj); // Trigger done if close to the end

        if (Math.abs(p - pos) < 2) {
          done();
        } //});

      }, 100);
      clearTimeout(transTimer);
      transTimer = setTimeout(function () {
        done(); //style[pr + 'Transition'] = '';
      }, time); // target.off(transEnd).on(transEnd, function (e) {
      //     if (e.target === target[0]) {
      //         target.off(transEnd);
      //         style[pr + 'Transition'] = '';
      //         done();
      //     }
      // });
    }

    if (s.sync) {
      s.sync(pos, time, easing);
    }
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  that.scrolled = false;
  /**
   * Scroll to the given position or element
   */

  that.scroll = function (pos, time, tap, callback) {
    // If position is not numeric, scroll to element
    if (!isNumeric(pos)) {
      pos = Math.ceil(($$1(pos, el).length ? Math.round(target.offset()[dir] - $$1(pos, el).offset()[dir]) : currPos) / snap) * snap;
    } else {
      pos = Math.round(pos / snap) * snap;
    }

    pos = constrain(pos, minScroll, maxScroll);
    currSnap = Math.round(pos / snap);
    startPos = currPos;
    scrollbarOffset = maxSnapScroll * snap + pos;
    scroll(pos, time, tap, callback);
  };

  that.refresh = function (noScroll) {
    var tempScroll;
    contSize = (s.contSize === undefined ? vertical ? $elm.height() : $elm.width() : s.contSize) || 0;
    maxScroll = (s.maxScroll === undefined ? 0 : s.maxScroll) || 0;
    minScroll = Math.min(maxScroll, s.minScroll === undefined ? Math.min(0, vertical ? contSize - target.height() : contSize - target.width()) : s.minScroll) || 0;
    snapPoints = null;

    if (!vertical && s.rtl) {
      tempScroll = maxScroll;
      maxScroll = -minScroll;
      minScroll = -tempScroll;
    }

    if (isString(s.snap)) {
      snapPoints = [];
      target.find(s.snap).each(function () {
        var offset = vertical ? this.offsetTop : this.offsetLeft,
            size = vertical ? this.offsetHeight : this.offsetWidth;
        snapPoints.push({
          breakpoint: offset + size / 2,
          snap1: -offset,
          snap2: contSize - offset - size
        });
      });
    }

    snap = isNumeric(s.snap) ? s.snap : 1;
    maxSnapScroll = s.snap ? s.maxSnapScroll : 0;
    easing = s.easing;
    elastic = s.elastic ? isNumeric(s.snap) ? snap : isNumeric(s.elastic) ? s.elastic : 0 : 0; // && s.snap ? snap : 0;

    scrollSnap = snap;

    while (scrollSnap > 44) {
      scrollSnap /= 2;
    }

    scrollSnap = Math.round(44 / scrollSnap) * scrollSnap;

    if (scrollbar) {
      isInfinite = minScroll == -Infinity || maxScroll == Infinity;
      scrollbarHeight = minScroll < maxScroll ? Math.max(20, contSize * contSize / (maxScroll - minScroll + contSize)) : 0;
      scrollbar.style.height = scrollbarHeight + 'px';
      scrollbarTrack.style.height = scrollbarHeight ? '' : 0;
    }

    if (currPos === undefined) {
      currPos = s.initialPos;
      currSnap = Math.round(currPos / snap);
    }

    if (!noScroll) {
      that.scroll(s.snap ? snapPoints && snapPoints[currSnap] ? snapPoints[currSnap]['snap' + currSnapDir] : currSnap * snap : currPos);
    }
  };

  that._processSettings = function () {
    vertical = s.axis == 'Y';
    dir = vertical ? 'top' : 'left';
    target = s.moveElement || $elm.children().eq(0);
    style = target[0].style;
    threshold = vertical ? s.thresholdY : s.thresholdX;

    if (s.scrollbar) {
      $scrollbarTrack = s.scrollbar;
      $scrollbar = $scrollbarTrack.find('.mbsc-sc-bar');
      scrollbar = $scrollbar[0];
      scrollbarTrack = $scrollbarTrack[0];
    }
  };

  that._init = function () {
    that.refresh();
    listen(el, 'mousedown', onStart);
    listen(el, 'touchstart', onStart, {
      passive: true
    });
    listen(el, 'touchend', onEnd);
    listen(el, 'touchcancel', onEnd);
    listen(el, 'click', onClick, true);
    listen(document, 'touchmove', onMove, {
      passive: false
    });

    if (s.mousewheel) {
      listen(document, 'wheel', onScroll, {
        passive: false,
        capture: true
      });
      listen(document, 'mousewheel', onScroll, {
        passive: false,
        capture: true
      });
    }

    if (scrollbar) {
      $scrollbarTrack.on('mousedown', onScrollBarStart).on('click', onScrollBarClick);
    } //el.addEventListener('touchend', function (ev) {
    //    if (scrolled) {
    //        ev.stopPropagation();
    //    }
    //}, true);

  };
  /**
   * Destroy
   */


  that._destroy = function () {
    clearInterval(scrollTimer);
    unlisten(el, 'mousedown', onStart);
    unlisten(el, 'touchstart', onStart, {
      passive: true
    });
    unlisten(el, 'touchend', onEnd);
    unlisten(el, 'touchcancel', onEnd);
    unlisten(el, 'click', onClick, true);
    unlisten(document, 'touchmove', onMove, {
      passive: false
    });
    unlisten(document, 'wheel', onScroll, {
      passive: false,
      capture: true
    });
    unlisten(document, 'mousewheel', onScroll, {
      passive: false,
      capture: true
    });

    if (scrollbar) {
      $scrollbarTrack.off('mousedown', onScrollBarStart).off('click', onScrollBarClick);
    }
  }; // Constructor


  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
ScrollViewBase.prototype = {
  _defaults: {
    speedUnit: 0.0022,
    //timeUnit: 0.8,
    timeUnit: 3,
    initialPos: 0,
    axis: 'Y',
    thresholdX: 10,
    thresholdY: 5,
    //easing: 'ease-out',
    easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
    stopProp: true,
    momentum: true,
    mousewheel: true,
    elastic: true
  }
};

// eslint-disable-next-line no-unused-vars
var presets = {},
    css = isBrowser ? window.CSS : null,
    has3d = css && css.supports && css.supports("(transform-style: preserve-3d)");

function sanitize(str) {
  return (str + '').replace(/"/g, '___');
}
var Scroller = function Scroller(el, settings, inherit) {
  var $markup,
      batchSize3d,
      batchSize = 40,
      animTime = 1000,
      scroll3dAngle,
      scroll3d,
      selectedClass,
      showScrollArrows,
      stepper,
      tempWheelArray,
      itemHeight,
      itemHeight3d,
      isPointer,
      isValidating,
      s,
      trigger,
      lines,
      wheels,
      wheelsMap,
      that = this,
      $elm = $$1(el); // Event handlers

  function onKeyDown(ev) {
    var i = +$$1(this).attr('data-index'),
        handle,
        direction;

    if (ev.keyCode == 38) {
      // Up
      handle = true;
      direction = -1;
    } else if (ev.keyCode == 40) {
      // Down
      handle = true;
      direction = 1;
    } else if (ev.keyCode == 32) {
      // Space
      handle = true;
      onItemTap(i, $$1(ev.target));
    }

    if (handle) {
      ev.stopPropagation();
      ev.preventDefault();

      if (direction) {
        stepper.start(i, direction, ev);
      }
    }
  }

  function onKeyUp() {
    stepper.stop();
  }

  function onItemTap(i, $item) {
    var wheel = wheels[i],
        idx = +$item.attr('data-index'),
        val = getValue(wheel, idx),
        selected = that._tempSelected[i],
        maxSelect = isNumeric(wheel.multiple) ? wheel.multiple : Infinity;

    if (trigger('onItemTap', {
      target: $item[0],
      index: i,
      value: val,
      selected: $item.hasClass('mbsc-sc-itm-sel')
    }) !== false && !that._prevItemTap) {
      // Select item on tap
      if (wheel.multiple && !wheel._disabled[val]) {
        if (selected[val] !== undefined) {
          $item.removeClass(selectedClass).removeAttr('aria-selected');
          delete selected[val];
        } else {
          if (maxSelect == 1) {
            that._tempSelected[i] = selected = {};

            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
          }

          if (objectToArray(selected).length < maxSelect) {
            $item.addClass(selectedClass).attr('aria-selected', 'true');
            selected[val] = val;
          }
        }
      }

      setWheelValue(wheel, i, idx, animTime, wheel._index < idx ? 1 : 2, true, wheel.multiple);

      if (that.live && (!wheel.multiple || wheel.multiple === 1 && s.tapSelect) && (s.setOnTap === true || s.setOnTap[i])) {
        setTimeout(function () {
          that.select();
        }, s.tapSelect ? 0 : 200);
      }
    }

    that._prevItemTap = false;
  } // Private functions


  function shouldSet(i, noscroll) {
    var wheel = wheels[i];
    return wheel && (!wheel.multiple || wheel.multiple !== 1 && noscroll && (s.setOnTap === true || s.setOnTap[i]));
  }

  function getMin(wheel) {
    return -(wheel.max - wheel._offset - (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
  }

  function getMax(wheel) {
    return -(wheel.min - wheel._offset + (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
  }

  function getIndex(wheel, val) {
    return (wheel._array ? wheel._map[val] : +wheel.getIndex(val, that)) || 0;
  }

  function getItem(wheel, i) {
    var data = wheel.data;

    if (i >= wheel.min && i <= wheel.max) {
      return wheel._array ? wheel.circular ? $$1(data).get(i % wheel._length) : data[i] : $$1.isFunction(data) ? data(i, that) : '';
    }
  }

  function getItemValue(item) {
    return $$1.isPlainObject(item) ? item.value !== undefined ? item.value : item.display : item;
  }

  function getItemText(item) {
    var text = $$1.isPlainObject(item) ? item.display : item;
    return text === undefined ? '' : text + that._getText(mobiscroll, 0.2);
  }

  function getValue(wheel, i) {
    return getItemValue(getItem(wheel, i));
  }

  function step(index, direction, ev) {
    var wheel = wheels[index];
    setWheelValue(wheel, index, wheel._index + direction, s.delay + 100, direction == 1 ? 1 : 2, false, false, ev.type == 'keydown');
  }

  function isReadOnly(i) {
    return $$1.isArray(s.readonly) ? s.readonly[i] : s.readonly;
  }

  function initWheel(ww, l, keep) {
    // Create a copy of the wheel, in case if same option object is used for multiple scroller instances
    var w = extend$1(wheels[l] || {}, ww);
    var index = w._index - w._batch;
    w.data = w.data || [];
    w.key = w.key !== undefined ? w.key : l;
    w.label = w.label !== undefined ? w.label : l;
    w._map = {};
    w._array = $$1.isArray(w.data); // Map keys to index

    if (w._array) {
      w._length = w.data.length;
      $$1.each(w.data, function (i, v) {
        w._map[getItemValue(v)] = i;
      });
    }

    w.circular = s.circular === undefined ? w.circular === undefined ? w._array && w._length > s.rows : w.circular : $$1.isArray(s.circular) ? s.circular[l] : s.circular;
    w.min = w._array ? w.circular ? -Infinity : 0 : w.min === undefined ? -Infinity : w.min;
    w.max = w._array ? w.circular ? Infinity : w._length - 1 : w.max === undefined ? Infinity : w.max;
    w._nr = l;
    w._index = getIndex(w, tempWheelArray[l]);
    w._disabled = {};
    w._batch = 0;
    w._current = w._index;
    w._first = w._index - batchSize; //Math.max(w.min, w._current - batchSize);

    w._last = w._index + batchSize; //Math.min(w.max, w._first + 2 * batchSize);

    w._offset = w._first;

    if (keep) {
      w._offset -= w._margin / itemHeight + (w._index - index);
      w._margin += (w._index - index) * itemHeight;
    } else {
      w._margin = 0; //w._first * itemHeight;
    }

    w._refresh = function (noScroll) {
      extend$1(w._scroller.settings, {
        minScroll: getMin(w),
        maxScroll: getMax(w)
      });

      w._scroller.refresh(noScroll);
    };

    wheelsMap[w.key] = w;
    return w;
  }

  function generateItems(wheel, index, start, end, is3d) {
    var i,
        css,
        item,
        value,
        text,
        lbl,
        invalid,
        selected,
        html = '',
        checked = that._tempSelected[index],
        disabled = wheel._disabled || {};

    for (i = start; i <= end; i++) {
      item = getItem(wheel, i);
      text = getItemText(item);
      value = getItemValue(item);
      css = item && item.cssClass !== undefined ? item.cssClass : '';
      lbl = item && item.label !== undefined ? item.label : '';
      invalid = item && item.invalid;
      selected = value !== undefined && value == tempWheelArray[index] && !wheel.multiple; // TODO: don't generate items with no value (use margin or placeholder instead)

      html += '<div role="option" tabindex="-1" aria-selected="' + (checked[value] ? true : false) + '" class="mbsc-sc-itm ' + (is3d ? 'mbsc-sc-itm-3d ' : '') + css + ' ' + (selected ? 'mbsc-sc-itm-sel ' : '') + (checked[value] ? selectedClass : '') + (value === undefined ? ' mbsc-sc-itm-ph' : ' mbsc-btn-e') + (invalid ? ' mbsc-sc-itm-inv-h mbsc-disabled' : '') + (disabled[value] ? ' mbsc-sc-itm-inv mbsc-disabled' : '') + '" data-index="' + i + '" data-val="' + sanitize(value) + '"' + (lbl ? ' aria-label="' + lbl + '"' : '') + (selected ? ' aria-selected="true"' : '') + ' style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;' + (is3d ? cssPrefix + 'transform:rotateX(' + (wheel._offset - i) * scroll3dAngle % 360 + 'deg) translateZ(' + itemHeight * s.rows / 2 + 'px);' : '') + '">' + (lines > 1 ? '<div class="mbsc-sc-itm-ml" style="line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;">' : '') + text + (lines > 1 ? '</div>' : '') + '</div>';
    }

    return html;
  }

  function infinite(wheel, i, pos) {
    var index = Math.round(-pos / itemHeight) + wheel._offset,
        diff = index - wheel._current,
        first = wheel._first,
        last = wheel._last,
        first3d = first + batchSize - batchSize3d + 1,
        last3d = last - batchSize + batchSize3d;

    if (diff) {
      wheel._first += diff;
      wheel._last += diff;
      wheel._current = index; // Generate items
      //setTimeout(function () {

      if (diff > 0) {
        wheel._$scroller.append(generateItems(wheel, i, Math.max(last + 1, first + diff), last + diff));

        $$1('.mbsc-sc-itm', wheel._$scroller).slice(0, Math.min(diff, last - first + 1)).remove(); // 3D

        if (scroll3d) {
          wheel._$3d.append(generateItems(wheel, i, Math.max(last3d + 1, first3d + diff), last3d + diff, true));

          $$1('.mbsc-sc-itm', wheel._$3d).slice(0, Math.min(diff, last3d - first3d + 1)).attr('class', 'mbsc-sc-itm-del');
        }
      } else if (diff < 0) {
        wheel._$scroller.prepend(generateItems(wheel, i, first + diff, Math.min(first - 1, last + diff)));

        $$1('.mbsc-sc-itm', wheel._$scroller).slice(Math.max(diff, first - last - 1)).remove(); // 3D

        if (scroll3d) {
          wheel._$3d.prepend(generateItems(wheel, i, first3d + diff, Math.min(first3d - 1, last3d + diff), true));

          $$1('.mbsc-sc-itm', wheel._$3d).slice(Math.max(diff, first3d - last3d - 1)).attr('class', 'mbsc-sc-itm-del');
        }
      }

      wheel._margin += diff * itemHeight;

      wheel._$scroller.css('margin-top', wheel._margin + 'px'); //}, 10);

    }
  }

  function getValid(index, v, dir, dis) {
    var counter,
        wheel = wheels[index],
        disabled = dis || wheel._disabled,
        idx = getIndex(wheel, v),
        val = getValue(wheel, idx),
        v1 = val,
        v2 = val,
        dist1 = 0,
        dist2 = 0; // TODO: what if all items are invalid

    if (disabled[val] === true) {
      counter = 0;

      while (idx - dist1 >= wheel.min && disabled[v1] && counter < 100) {
        counter++;
        dist1++;
        v1 = getValue(wheel, idx - dist1);
      }

      counter = 0;

      while (idx + dist2 < wheel.max && disabled[v2] && counter < 100) {
        counter++;
        dist2++;
        v2 = getValue(wheel, idx + dist2);
      } // If we have direction (+/- or mouse wheel), the distance does not count


      if ((dist2 < dist1 && dist2 && dir !== 2 || !dist1 || idx - dist1 < 0 || dir == 1) && !disabled[v2]) {
        val = v2;
      } else {
        val = v1;
      }
    }

    return val;
  }

  function scrollToPos(time, index, dir, manual, tap, noscroll, shouldFocus) {
    var diff,
        idx,
        offset,
        ret,
        isVisible = that._isVisible;
    isValidating = true;
    ret = s.validate.call(el, {
      values: tempWheelArray.slice(0),
      index: index,
      direction: dir
    }, that) || {};
    isValidating = false;

    if (ret.valid) {
      that._tempWheelArray = tempWheelArray = ret.valid.slice(0);
    }

    if (!noscroll) {
      $$1.each(wheels, function (i, wheel) {
        if (isVisible) {
          // Enable all items
          wheel._$markup.find('.mbsc-sc-itm-inv').removeClass('mbsc-sc-itm-inv mbsc-disabled');
        }

        wheel._disabled = {}; // Disable invalid items

        if (ret.disabled && ret.disabled[i]) {
          $$1.each(ret.disabled[i], function (j, v) {
            wheel._disabled[v] = true;

            if (isVisible) {
              wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass('mbsc-sc-itm-inv mbsc-disabled');
            }
          });
        } // Get closest valid value


        tempWheelArray[i] = wheel.multiple ? tempWheelArray[i] : getValid(i, tempWheelArray[i], dir);

        if (isVisible) {
          if (!wheel.multiple || index === undefined) {
            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
          } // Get index of valid value


          idx = getIndex(wheel, tempWheelArray[i]);
          diff = idx - wheel._index + wheel._batch;

          if (Math.abs(diff) > 2 * batchSize + 1) {
            offset = diff + (2 * batchSize + 1) * (diff > 0 ? -1 : 1);
            wheel._offset += offset;
            wheel._margin -= offset * itemHeight;

            wheel._refresh();
          }

          wheel._index = idx + wheel._batch;

          if (wheel.multiple) {
            // Add selected styling to selected elements in case of multiselect
            if (index === undefined) {
              for (var v in that._tempSelected[i]) {
                wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass(selectedClass).attr('aria-selected', 'true');
              }
            }
          } else {
            // Mark element as aria selected
            wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(tempWheelArray[i]) + '"]').addClass('mbsc-sc-itm-sel').attr('aria-selected', 'true');
          }

          if (wheel._$active) {
            wheel._$active.attr('tabindex', -1);
          }

          wheel._$active = wheel._$markup.find('.mbsc-sc-itm[data-index="' + wheel._index + '"]').eq(scroll3d && wheel.multiple ? 1 : 0).attr('tabindex', 0);

          if (shouldFocus && index === i && wheel._$active.length) {
            wheel._$active[0].focus();

            wheel._$scroller.parent().scrollTop(0);
          } // Scroll to valid value


          wheel._scroller.scroll(-(idx - wheel._offset + wheel._batch) * itemHeight, index === i || index === undefined ? time : animTime, tap);
        }
      });
    }

    trigger('onValidated', {
      index: index,
      time: time
    }); // Get formatted value

    that._tempValue = s.formatValue.call(el, tempWheelArray, that);

    if (isVisible) {
      that._updateHeader();
    } // If in live mode, set and fill value on every move


    if (that.live && shouldSet(index, noscroll)) {
      that._hasValue = manual || that._hasValue;
      setValue(manual, manual, 0, true);

      if (manual) {
        trigger('onSet', {
          valueText: that._value
        });
      }
    }

    if (manual) {
      trigger('onChange', {
        index: index,
        valueText: that._tempValue
      });
    }
  }

  function setWheelValue(wheel, i, idx, time, dir, tap, noscroll, shouldFocus) {
    // Get the value at the given index
    var value = getValue(wheel, idx);

    if (value !== undefined) {
      tempWheelArray[i] = value; // In case of circular wheels calculate the offset of the current batch

      wheel._batch = wheel._array ? Math.floor(idx / wheel._length) * wheel._length : 0;
      wheel._index = idx;
      setTimeout(function () {
        scrollToPos(time, i, dir, true, tap, noscroll, shouldFocus);
      }, 10);
    }
  }

  function setValue(fill, change, time, noscroll, temp) {
    if (!noscroll) {
      scrollToPos(time);
    } else {
      that._tempValue = s.formatValue.call(el, that._tempWheelArray, that);
    }

    if (!temp) {
      that._wheelArray = [];

      for (var i = 0; i < tempWheelArray.length; i++) {
        // In case of multiple select wheel take the first selected value,
        that._wheelArray[i] = wheels[i] && wheels[i].multiple ? Object.keys(that._tempSelected[i] || {})[0] : tempWheelArray[i];
      }

      that._value = that._hasValue ? that._tempValue : null;
      that._selected = extend$1(true, {}, that._tempSelected);
    }

    if (fill) {
      if (that._isInput) {
        $elm.val(that._hasValue ? that._tempValue : '');
      }

      trigger('onFill', {
        valueText: that._hasValue ? that._tempValue : '',
        change: change
      });

      if (change) {
        that._preventChange = true;
        $elm.trigger('change');
      }
    }
  } // Call the parent constructor


  Frame.call(this, el, settings, true); // Public functions

  /**
   * Sets the value of the scroller.
   * @param {Array} val - New value.
   * @param {Boolean} [fill=false] - Set the value of the associated input element.
   * @param {Boolean} [change=false] - Trigger change on the input element.
   * @param {Boolean} [temp=false] - If true, then only set the temporary value (only scroll there but not set the value).
   * @param {Number} [time=0] - Animation time in milliseconds.
   */

  that.setVal = that._setVal = function (val, fill, change, temp, time) {
    that._hasValue = val !== null && val !== undefined;
    that._tempWheelArray = tempWheelArray = $$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that) || [];
    setValue(fill, change === undefined ? fill : change, time, false, temp);
  };
  /**
   * Returns the selected value.
   */


  that.getVal = that._getVal = function (temp) {
    var val = that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
    return isNumeric(val) ? +val : val;
  };
  /*
   * Sets the wheel values (passed as an array).
   */


  that.setArrayVal = that.setVal;
  /*
   * Returns the selected wheel values as an array.
   */

  that.getArrayVal = function (temp) {
    return temp ? that._tempWheelArray : that._wheelArray;
  };

  that.changeWheel = function (whls, time, manual) {
    var i, w, ww;
    $$1.each(whls, function (key, wheel) {
      ww = wheelsMap[key]; // Check if wheel exists

      if (ww) {
        i = ww._nr;
        w = initWheel(wheel, i, true);

        if (that._isVisible) {
          if (scroll3d) {
            w._$3d.html(generateItems(w, i, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true));
          }

          w._$scroller.html(generateItems(w, i, w._first, w._last)).css('margin-top', w._margin + 'px');

          w._refresh(isValidating);
        }
      }
    });

    if (that._isVisible && !that._isLiquid && !isValidating) {
      that.position();
    }

    if (!isValidating) {
      scrollToPos(time, undefined, undefined, manual);
    }
  };
  /**
   * Returns the closest valid value.
   */


  that.getValidValue = getValid; // Protected overrides 

  that._generateContent = function () {
    var lbl,
        maxPopupWidth = 0,
        html = '',
        style = scroll3d ? cssPrefix + 'transform: translateZ(' + (itemHeight * s.rows / 2 + 3) + 'px);' : '',
        highlight = '<div class="mbsc-sc-whl-l" style="' + style + 'height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;"></div>',
        l = 0;
    $$1.each(s.wheels, function (i, wg) {
      html += '<div class="mbsc-w-p mbsc-sc-whl-gr-c' + (scroll3d ? ' mbsc-sc-whl-gr-3d-c' : '') + (s.showLabel ? ' mbsc-sc-lbl-v' : '') + '">' + highlight + '<div class="mbsc-sc-whl-gr' + (scroll3d ? ' mbsc-sc-whl-gr-3d' : '') + (showScrollArrows ? ' mbsc-sc-cp' : '') + (s.width || s.maxWidth ? '"' : '" style="max-width:' + s.maxPopupWidth + 'px;"') + '>';
      $$1.each(wg, function (j, ww) {
        // Wheels
        that._tempSelected[l] = extend$1({}, that._selected[l]); // TODO: this should be done on initialization, not on show

        var w = initWheel(ww, l);
        var topMargin = !isPointer || s.rows % 2 ? itemHeight3d / 2 : 0;
        wheels[l] = w;
        maxPopupWidth += s.maxWidth ? s.maxWidth[l] || s.maxWidth : s.width ? s.width[l] || s.width : 0;
        lbl = w.label !== undefined ? w.label : j;
        html += '<div class="mbsc-sc-whl-w ' + (w.cssClass || '') + (w.multiple ? ' mbsc-sc-whl-multi' : '') + '" style="' + (s.width ? 'width:' + (s.width[l] || s.width) + 'px;' : (s.minWidth ? 'min-width:' + (s.minWidth[l] || s.minWidth) + 'px;' : '') + (s.maxWidth ? 'max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;' : '')) + '">' + (isPointer ? '<div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div>' : '') + // Scrollbar
        '<div class="mbsc-sc-whl-o" style="' + style + '"></div>' + highlight + '<div aria-live="off" aria-label="' + lbl + '"' + (w.multiple ? ' aria-multiselectable="true"' : '') + ' role="listbox" data-index="' + l + '" class="mbsc-sc-whl"' + ' style="' + 'height:' + s.rows * itemHeight * (scroll3d ? 1.1 : 1) + 'px;">' + (showScrollArrows ? '<div data-index="' + l + '" data-step="1" class="mbsc-sc-btn mbsc-sc-btn-plus ' + (s.btnPlusClass || '') + '"></div>' + // + button
        '<div data-index="' + l + '" data-step="-1" class="mbsc-sc-btn mbsc-sc-btn-minus ' + (s.btnMinusClass || '') + '"></div>' : '') + // - button
        '<div class="mbsc-sc-lbl">' + lbl + '</div>' + // Wheel label
        '<div class="mbsc-sc-whl-c"' + ' style="height:' + itemHeight3d + 'px;margin-top:-' + (topMargin + 1) + 'px;' + style + '">' + '<div class="mbsc-sc-whl-sc" style="top:' + (itemHeight3d - itemHeight) / 2 + 'px;">'; // Create wheel values

        html += generateItems(w, l, w._first, w._last) + '</div></div>';

        if (scroll3d) {
          html += '<div class="mbsc-sc-whl-3d" style="height:' + itemHeight + 'px;margin-top:-' + itemHeight / 2 + 'px;">';
          html += generateItems(w, l, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true);
          html += '</div>';
        }

        html += '</div></div>';
        l++;
      });
      html += '</div></div>';
    });

    if (maxPopupWidth) {
      s.maxPopupWidth = maxPopupWidth;
    }

    return html;
  };

  that._attachEvents = function ($markup) {
    stepper = createStepper($$1('.mbsc-sc-btn', $markup), step, s.delay, isReadOnly, true);
    $$1('.mbsc-sc-whl', $markup).on('keydown', onKeyDown).on('keyup', onKeyUp);
  };

  that._detachEvents = function () {
    if (stepper) {
      stepper.stop();
    }

    for (var i = 0; i < wheels.length; i++) {
      wheels[i]._scroller.destroy();
    }
  };

  that._markupReady = function ($m) {
    $markup = $m;
    $$1('.mbsc-sc-whl-w', $markup).each(function (i) {
      var idx,
          $wh = $$1(this),
          wheel = wheels[i];
      wheel._$markup = $wh;
      wheel._$scroller = $$1('.mbsc-sc-whl-sc', this);
      wheel._$3d = $$1('.mbsc-sc-whl-3d', this);
      wheel._scroller = new ScrollViewBase(this, {
        mousewheel: s.mousewheel,
        moveElement: wheel._$scroller,
        scrollbar: $$1('.mbsc-sc-bar-c', this),
        initialPos: (wheel._first - wheel._index) * itemHeight,
        contSize: s.rows * itemHeight,
        snap: itemHeight,
        minScroll: getMin(wheel),
        maxScroll: getMax(wheel),
        maxSnapScroll: batchSize,
        prevDef: true,
        stopProp: true,
        timeUnit: 3,
        easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
        sync: function sync(pos, time, easing) {
          var timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';

          if (scroll3d) {
            wheel._$3d[0].style[jsPrefix + 'Transition'] = timing;
            wheel._$3d[0].style[jsPrefix + 'Transform'] = 'rotateX(' + -pos / itemHeight * scroll3dAngle + 'deg)';
          }
        },
        onStart: function onStart(ev, inst) {
          inst.settings.readonly = isReadOnly(i);
        },
        onGestureStart: function onGestureStart() {
          $wh.addClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
          trigger('onWheelGestureStart', {
            index: i
          });
        },
        onGestureEnd: function onGestureEnd(ev) {
          var dir = ev.direction == 90 ? 1 : 2,
              time = ev.duration,
              pos = ev.destinationY;
          idx = Math.round(-pos / itemHeight) + wheel._offset;
          setWheelValue(wheel, i, idx, time, dir);
        },
        onAnimationStart: function onAnimationStart() {
          $wh.addClass('mbsc-sc-whl-anim');
        },
        onAnimationEnd: function onAnimationEnd() {
          $wh.removeClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
          trigger('onWheelAnimationEnd', {
            index: i
          });

          wheel._$3d.find('.mbsc-sc-itm-del').remove();
        },
        onMove: function onMove(ev) {
          infinite(wheel, i, ev.posY);
        },
        onBtnTap: function onBtnTap(ev) {
          onItemTap(i, $$1(ev.target));
        }
      });
    });
    scrollToPos();
  };

  that._fillValue = function () {
    that._hasValue = true;
    setValue(true, true, 0, true);
  };

  that._clearValue = function () {
    $$1('.mbsc-sc-whl-multi .mbsc-sc-itm-sel', $markup).removeClass(selectedClass).removeAttr('aria-selected');
  };

  that._readValue = function () {
    var v = $elm.val() || '',
        l = 0;

    if (v !== '') {
      that._hasValue = true;
    }

    that._tempWheelArray = tempWheelArray = that._hasValue && that._wheelArray ? that._wheelArray.slice(0) : s.parseValue.call(el, v, that) || [];
    that._tempSelected = extend$1(true, {}, that._selected);
    $$1.each(s.wheels, function (i, wg) {
      $$1.each(wg, function (j, w) {
        // Wheels
        wheels[l] = initWheel(w, l);
        l++;
      });
    });
    setValue(false, false, 0, true);
    trigger('onRead');
  };

  that.__processSettings = function (resp) {
    s = that.settings;
    trigger = that.trigger;
    lines = s.multiline;
    selectedClass = 'mbsc-sc-itm-sel mbsc-ic mbsc-ic-' + s.checkIcon;
    isPointer = !s.touchUi;

    if (isPointer) {
      // Settings that might be needed by the scroller preset as well
      s.tapSelect = true;
      s.circular = false;
      s.rows = resp.rows || settings.rows || 7;
    }
  };

  that.__init = function (newSettings) {
    if (newSettings) {
      // Reset wheel array in case of setting change,
      // since it might affect the number of wheels
      that._wheelArray = null;
    }

    wheels = [];
    wheelsMap = {};
    showScrollArrows = s.showScrollArrows;
    scroll3d = s.scroll3d && has3d && !showScrollArrows && !isPointer && (s.theme == 'ios' || s.baseTheme == 'ios');
    itemHeight = s.height;
    itemHeight3d = scroll3d ? Math.round((itemHeight - (itemHeight * s.rows / 2 + 3) * 0.03) / 2) * 2 : itemHeight;
    batchSize3d = Math.round(s.rows * 1.8);
    scroll3dAngle = 360 / (batchSize3d * 2); // Ensure a minimum number of 3 items if clickpick buttons present

    if (showScrollArrows) {
      s.rows = Math.max(3, s.rows);
    }
  };

  that._getItemValue = getItemValue; // Properties

  that._tempSelected = {};
  that._selected = {}; // Constructor

  if (!inherit) {
    that.init();
  }
}; // Extend defaults

Scroller.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _class: 'scroller',
  _presets: presets,
  _defaults: extend$1({}, Frame.prototype._defaults, {
    // Options
    minWidth: 80,
    height: 40,
    rows: 3,
    multiline: 1,
    delay: 200,
    readonly: false,
    showLabel: true,
    setOnTap: false,
    wheels: [],
    preset: '',
    speedUnit: 0.0012,
    timeUnit: 0.08,
    checkIcon: 'checkmark',
    compClass: 'mbsc-sc',
    validate: function validate() {},
    formatValue: function formatValue(d) {
      return d.join(' ');
    },
    parseValue: function parseValue(value, inst) {
      var val = [],
          ret = [],
          i = 0,
          found,
          data;

      if (value !== null && value !== undefined) {
        val = (value + '').split(' ');
      }

      $$1.each(inst.settings.wheels, function (j, wg) {
        $$1.each(wg, function (k, w) {
          data = w.data; // Default to first wheel value if not found

          found = inst._getItemValue(data[0]);
          $$1.each(data, function (l, item) {
            // Don't do strict comparison
            if (val[i] == inst._getItemValue(item)) {
              found = inst._getItemValue(item);
              return false;
            }
          });
          ret.push(found);
          i++;
        });
      });
      return ret;
    }
  })
};
classes.Scroller = Scroller;

var defaults$1 = {
  separator: ' ',
  // Localization
  dateFormat: 'mm/dd/yy',
  dateDisplay: 'MMddyy',
  timeFormat: 'h:ii A',
  dayText: 'Day',
  monthText: 'Month',
  yearText: 'Year',
  hourText: 'Hours',
  minuteText: 'Minutes',
  ampmText: '&nbsp;',
  secText: 'Seconds',
  nowText: 'Now',
  todayText: 'Today'
}; // --- TRIAL SERVER CODE END ---

var DateTime = function DateTime(inst) {
  function convertRanges(arr) {
    var i,
        v,
        start,
        end,
        ret = [];

    if (arr) {
      for (i = 0; i < arr.length; i++) {
        v = arr[i]; // Check if it's a range, but skip time-only ranges

        if (v.start && v.end && !ISO_8601_TIME.test(v.start)) {
          start = new Date(makeDate(v.start, format, s));
          end = new Date(makeDate(v.end, format, s));

          while (start <= end) {
            ret.push(adjustedDate(start.getFullYear(), start.getMonth(), start.getDate()));
            start.setDate(start.getDate() + 1);
          }
        } else {
          ret.push(v);
        }
      }

      return ret;
    }

    return arr;
  }

  function step(v, st, min, max) {
    return Math.min(max, Math.floor(v / st) * st + min);
  }

  function getMax(step, min, max) {
    return Math.floor((max - min) / step) * step + min;
  }

  function getYear(d) {
    return s.getYear(d);
  }

  function getMonth(d) {
    return s.getMonth(d);
  }

  function getDay(d) {
    return s.getDay(d);
  }

  function getHours(d) {
    var hour = d.getHours();
    hour = hasAmPm && hour >= 12 ? hour - 12 : hour;
    return step(hour, stepHour, minHour, maxHour);
  }

  function getMinutes(d) {
    return step(d.getMinutes(), stepMinute, minMinute, maxMinute);
  }

  function getSeconds(d) {
    return step(d.getSeconds(), stepSecond, minSecond, maxSecond);
  }

  function getMilliseconds(d) {
    return d.getMilliseconds();
  }

  function getAmPm(d) {
    return d.getHours() > 11 ? 1 : 0;
  } // --- TRIAL SERVER CODE START ---


  function getFullDate(d) {
    return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate());
  } // --- TRIAL SERVER CODE END ---


  function getFullTime(d) {
    return step(Math.round((d.getTime() - new Date(d).setHours(0, 0, 0, 0)) / 1000), timeStep || 1, 0, 86400);
  }

  function getArrayPart(data, part, d, def) {
    var ret;

    if (wheelOrder[part] !== undefined) {
      ret = +data[wheelOrder[part]];

      if (!isNaN(ret)) {
        return ret;
      }
    }

    if (d) {
      return getDatePart[part](d);
    }

    if (innerValues[part] !== undefined) {
      return innerValues[part];
    }

    return getDatePart[part](def);
  }

  function getDate(data) {
    var d,
        def = new Date(new Date().setHours(0, 0, 0, 0));

    if (data === null) {
      return data;
    }

    if (wheelOrder.dd !== undefined) {
      d = data[wheelOrder.dd].split('-');
      d = new Date(d[0], d[1] - 1, d[2]);
    }

    if (wheelOrder.tt !== undefined) {
      d = d || def;
      d = new Date(d.getTime() + data[wheelOrder.tt] % 86400 * 1000);
    }

    var year = getArrayPart(data, 'y', d, def),
        month = getArrayPart(data, 'm', d, def),
        day = Math.min(getArrayPart(data, 'd', d, def), s.getMaxDayOfMonth(year, month)),
        hour = getArrayPart(data, 'h', d, def);
    return s.getDate(year, month, day, hasAmPm && getArrayPart(data, 'a', d, def) ? hour + 12 : hour, getArrayPart(data, 'i', d, def), getArrayPart(data, 's', d, def), getArrayPart(data, 'u', d, def));
  }

  function getArray(d, fillInner) {
    var i,
        part,
        parts = ['y', 'm', 'd', 'a', 'h', 'i', 's', 'u', 'dd', 'tt'],
        ret = [];

    if (d === null || d === undefined) {
      return d;
    }

    for (i = 0; i < parts.length; i++) {
      part = parts[i];

      if (wheelOrder[part] !== undefined) {
        ret[wheelOrder[part]] = getDatePart[part](d);
      }

      if (fillInner) {
        innerValues[part] = getDatePart[part](d);
      }
    }

    return ret;
  } // --- TRIAL SERVER CODE START ---


  function getDateIndex(d, hasDay) {
    return hasDay ? // Number of days since 1970-01-01
    Math.floor(new Date(d) / 8.64e7) : // Number of month since 1970-01-01
    d.getMonth() + 12 * (d.getFullYear() - 1970);
  }
  /*
  function getYearValue(i) {
      return {
          value: i,
          display: (/yy/i.test(dateDisplay) ? i : (i + '').substr(2, 2)) + (s.yearSuffix || '')
      };
  }
   function getYearIndex(v) {
      return v;
  }
   function getDateWheel(template) {
      var hasDay = /d/i.test(template);
      return {
          label: '',
          cssClass: 'mbsc-dt-whl-date',
          min: minDate ? getDateIndex(getFullDate(minDate), hasDay) : undefined,
          max: maxDate ? getDateIndex(getFullDate(maxDate), hasDay) : undefined,
          data: function (i) {
              var today = new Date(new Date().setHours(0, 0, 0, 0)),
                  d = hasDay ? new Date(i * 8.64e7) : new Date(1970, i, 1);
               if (hasDay) {
                  d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
              }
               return {
                  invalid: hasDay && !isValid(d, true),
                  value: getFullDate(d),
                  display: today.getTime() == d.getTime() ? s.todayText : formatDate(template, d, s)
              };
          },
          getIndex: function (v) {
              return getDateIndex(v, hasDay);
          }
      };
  }
   function getTimeWheel(template) {
      var i,
          step,
          time,
          values = [];
       if (/s/i.test(template)) {
          step = stepSecond;
      } else if (/i/i.test(template)) {
          step = stepMinute * 60;
      } else if (/h/i.test(template)) {
          step = stepHour * 3600;
      }
       timeStep = steps.tt = step;
       for (i = 0; i < 86400; i += step) {
          time = new Date(new Date().setHours(0, 0, 0, 0) + i * 1000);
          values.push({
              value: i,
              display: formatDate(template, time, s)
          });
      }
       return {
          label: '',
          cssClass: 'mbsc-dt-whl-time',
          data: values
      };
  }
   function getWheels() {
      var dateParts,
          timeParts,
          template,
          i,
          j,
          types,
          values,
          monthStr,
          nr = 0,
          wheels = [],
          dateGroup = [],
          timeGroup = [];
       if (/date/i.test(preset)) {
          dateParts = dateWheels.split(/\|/.test(dateWheels) ? '|' : '');
           for (i = 0; i < dateParts.length; i++) {
              template = dateParts[i];
              types = 0;
              if (template.length) {
                  // If contains different characters
                  if (/y/i.test(template)) {
                      isoParts.y = 1;
                      types++;
                  }
                   if (/m/i.test(template)) {
                      isoParts.y = 1;
                      isoParts.m = 1;
                      types++;
                  }
                   if (/d/i.test(template)) {
                      isoParts.y = 1;
                      isoParts.m = 1;
                      isoParts.d = 1;
                      types++;
                  }
                   if (types > 1 && wheelOrder.dd === undefined) {
                      wheelOrder.dd = nr;
                      nr++;
                      dateGroup.push(getDateWheel(template));
                      timeGroup = dateGroup; // TODO ???
                      oneDateWheel = true;
                  } else if (/y/i.test(template) && wheelOrder.y === undefined) {
                      wheelOrder.y = nr;
                      nr++;
                       // Year wheel
                      dateGroup.push({
                          cssClass: 'mbsc-dt-whl-y',
                          label: s.yearText,
                          min: minDate ? s.getYear(minDate) : undefined,
                          max: maxDate ? s.getYear(maxDate) : undefined,
                          data: getYearValue,
                          getIndex: getYearIndex
                      });
                  } else if (/m/i.test(template) && wheelOrder.m === undefined) {
                      // Month wheel
                      wheelOrder.m = nr;
                      values = [];
                      nr++;
                       for (j = 0; j < 12; j++) {
                          monthStr = dateDisplay
                              .replace(/[dy|]/gi, '')
                              .replace(/mm/, pad(j + 1) + (s.monthSuffix || ''))
                              .replace(/m/, j + 1 + (s.monthSuffix || ''));
                           values.push({
                              value: j,
                              display: /MM/.test(monthStr) ?
                                  monthStr.replace(/MM/, '<span class="mbsc-dt-month">' + s.monthNames[j] + '</span>') : monthStr.replace(/M/, '<span class="mbsc-dt-month">' + s.monthNamesShort[j] + '</span>')
                          });
                      }
                       dateGroup.push({
                          cssClass: 'mbsc-dt-whl-m',
                          label: s.monthText,
                          data: values
                      });
                  } else if (/d/i.test(template) && wheelOrder.d === undefined) {
                      // Day wheel
                      wheelOrder.d = nr;
                      values = [];
                      nr++;
                       for (j = 1; j < 32; j++) {
                          values.push({
                              value: j,
                              display: (/dd/i.test(dateDisplay) ? pad(j) : j) + (s.daySuffix || '')
                          });
                      }
                       dateGroup.push({
                          cssClass: 'mbsc-dt-whl-d',
                          label: s.dayText,
                          data: values
                      });
                  }
              }
          }
           wheels.push(dateGroup);
      }
       if (/time/i.test(preset)) {
          timeParts = timeWheels.split(/\|/.test(timeWheels) ? '|' : '');
           for (i = 0; i < timeParts.length; i++) {
              template = timeParts[i];
              types = 0;
              if (template.length) {
                  // If contains different characters
                  if (/h/i.test(template)) {
                      isoParts.h = 1;
                      types++;
                  }
                   if (/i/i.test(template)) {
                      isoParts.i = 1;
                      types++;
                  }
                   if (/s/i.test(template)) {
                      isoParts.s = 1;
                      types++;
                  }
                   if (/a/i.test(template)) {
                      types++;
                  }
              }
               if (types > 1 && wheelOrder.tt === undefined) {
                  wheelOrder.tt = nr;
                  nr++;
                  timeGroup.push(getTimeWheel(template));
              } else if (/h/i.test(template) && wheelOrder.h === undefined) {
                  // Hours wheel
                  values = [];
                  wheelOrder.h = nr;
                  isoParts.h = 1;
                  nr++;
                   for (j = minHour; j < (hasAmPm ? 12 : 24); j += stepHour) {
                      values.push({
                          value: j,
                          display: hasAmPm && j === 0 ? 12 : /hh/i.test(timeDisplay) ? pad(j) : j
                      });
                  }
                   timeGroup.push({
                      cssClass: 'mbsc-dt-whl-h',
                      label: s.hourText,
                      data: values
                  });
              } else if (/i/i.test(template) && wheelOrder.i === undefined) {
                  // Minutes wheel
                  values = [];
                  wheelOrder.i = nr;
                  isoParts.i = 1;
                  nr++;
                   for (j = minMinute; j < 60; j += stepMinute) {
                      values.push({
                          value: j,
                          display: /ii/i.test(timeDisplay) ? pad(j) : j
                      });
                  }
                   timeGroup.push({
                      cssClass: 'mbsc-dt-whl-i',
                      label: s.minuteText,
                      data: values
                  });
              } else if (/s/i.test(template) && wheelOrder.s === undefined) {
                  // Seconds wheel
                  values = [];
                  wheelOrder.s = nr;
                  isoParts.s = 1;
                  nr++;
                   for (j = minSecond; j < 60; j += stepSecond) {
                      values.push({
                          value: j,
                          display: /ss/i.test(timeDisplay) ? pad(j) : j
                      });
                  }
                   timeGroup.push({
                      cssClass: 'mbsc-dt-whl-s',
                      label: s.secText,
                      data: values
                  });
              } else if (/a/i.test(template) && wheelOrder.a === undefined) {
                  wheelOrder.a = nr;
                  nr++;
                   timeGroup.push({
                      cssClass: 'mbsc-dt-whl-a',
                      label: s.ampmText,
                      data: /A/.test(template) ? [{
                          value: 0,
                          display: s.amText.toUpperCase()
                      }, {
                          value: 1,
                          display: s.pmText.toUpperCase()
                      }] : [{
                          value: 0,
                          display: s.amText
                      }, {
                          value: 1,
                          display: s.pmText
                      }]
                  });
              }
          }
           if (timeGroup != dateGroup) {
              wheels.push(timeGroup);
          }
      }
       return wheels;
  }
  */


  function getHtml5Options($elm) {
    var format,
        min,
        max,
        ret = {}; // Force format for html5 date inputs (experimental)

    if ($elm.is('input')) {
      switch ($elm.attr('type')) {
        case 'date':
          format = 'yy-mm-dd';
          break;

        case 'datetime':
          format = 'yy-mm-ddTHH:ii:ssZ';
          break;

        case 'datetime-local':
          format = 'yy-mm-ddTHH:ii:ss';
          break;

        case 'month':
          format = 'yy-mm';
          ret.dateOrder = 'mmyy';
          break;

        case 'time':
          format = 'HH:ii:ss';
          break;
      }

      ret.format = format; // Check for min/max attributes

      min = $elm.attr('min');
      max = $elm.attr('max');

      if (min && min != 'undefined') {
        ret.min = parseDate(format, min);
      }

      if (max && max != 'undefined') {
        ret.max = parseDate(format, max);
      }
    }

    return ret;
  }

  function getClosestValidDate(d, dir) {
    var next,
        prev,
        nextValid = false,
        prevValid = false,
        up = 0,
        down = 0,
        // Normalize min and max dates for comparing later (set default values where there are no values from wheels)
    mind = minDate ? getDate(getArray(minDate)) : -Infinity,
        maxd = maxDate ? getDate(getArray(maxDate)) : Infinity;

    if (isValid(d)) {
      return d;
    }

    if (d < mind) {
      d = mind;
    }

    if (d > maxd) {
      d = maxd;
    }

    next = d;
    prev = d;

    if (dir !== 2) {
      nextValid = isValid(next, true);

      while (!nextValid && next < maxd && up < 100) {
        next = new Date(next.getTime() + 1000 * 60 * 60 * 24);
        nextValid = isValid(next, true);
        up++;
      }
    }

    if (dir !== 1) {
      prevValid = isValid(prev, true);

      while (!prevValid && prev > mind && down < 100) {
        prev = new Date(prev.getTime() - 1000 * 60 * 60 * 24);
        prevValid = isValid(prev, true);
        down++;
      }
    }

    if (dir === 1 && nextValid) {
      return next;
    }

    if (dir === 2 && prevValid) {
      return prev;
    }

    if (isSameMonth(d, next)) {
      return next;
    }

    if (isSameMonth(d, prev)) {
      return prev;
    }

    return down <= up && prevValid ? prev : next;
  }

  function isSameMonth(d1, d2) {
    return s.getYear(d1) === s.getYear(d2) && s.getMonth(d1) === s.getMonth(d2);
  }

  function isValid(d, skip) {
    if (!skip && d < minDate) {
      return false;
    }

    if (!skip && d > maxDate) {
      return false;
    }

    if (isInObj(d, valid)) {
      return true;
    }

    if (isInObj(d, invalid)) {
      return false;
    }

    return true;
  }

  function isInObj(d, obj) {
    var curr, j, v, val;

    if (obj) {
      for (j = 0; j < obj.length; j++) {
        curr = obj[j];
        val = curr.d || curr;
        v = val + '';

        if (!curr.start) {
          if (DAY_OF_WEEK.test(v)) {
            // Day of week
            v = +v.replace('w', '');

            if (v == d.getDay()) {
              return true;
            }
          } else if (DAY_OF_MONTH.test(v)) {
            // Day of month: '2' or '12/24'
            v = v.split('/');

            if (v[1]) {
              if (v[0] - 1 == d.getMonth() && v[1] == d.getDate()) {
                return true;
              }
            } else if (v[0] == d.getDate()) {
              return true;
            }
          } else {
            // Exact date
            curr = makeDate(val, format, s);

            if (d.getFullYear() == curr.getFullYear() && d.getMonth() == curr.getMonth() && d.getDate() == curr.getDate()) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  function validateDates(obj, y, m, first, maxdays, invalids, val) {
    var d, dd, j, k, v;

    if (obj) {
      for (j = 0; j < obj.length; j++) {
        d = obj[j];
        dd = d.d || d;
        v = dd + '';

        if (!d.start) {
          if (DAY_OF_WEEK.test(v)) {
            // Day of week
            v = +v.replace('w', '');

            for (k = v - first; k < maxdays; k += 7) {
              if (k >= 0) {
                invalids[k + 1] = val;
              }
            }
          } else if (DAY_OF_MONTH.test(v)) {
            // Day of month: '2' or '12/24'
            v = v.split('/');

            if (v[1]) {
              if (v[0] - 1 == m) {
                invalids[v[1]] = val;
              }
            } else {
              invalids[v[0]] = val;
            }
          } else {
            // Exact date
            d = makeDate(dd, format, s);

            if (s.getYear(d) == y && s.getMonth(d) == m) {
              invalids[s.getDay(d)] = val;
            }
          }
        }
      }
    }
  }

  function validateTimes(vobj, index, v, y, m, d, invalids, valid) {
    var add,
        all,
        dd,
        hours1,
        hours2,
        hours3,
        i,
        i1,
        i2,
        j,
        obj,
        parts1,
        parts2,
        prop1,
        prop2,
        remove,
        ss,
        str,
        v1,
        v2,
        spec = {},
        day = s.getDate(y, m, d),
        w = ['a', 'h', 'i', 's'];

    if (vobj) {
      // Check if rules apply to the selected date
      for (i = 0; i < vobj.length; i++) {
        obj = vobj[i];

        if (obj.start) {
          obj.apply = false;
          dd = obj.d;
          ss = dd + '';
          str = ss.split('/');

          if (dd && (dd.getTime && y == s.getYear(dd) && m == s.getMonth(dd) && d == s.getDay(dd) || // Exact date
          !DAY_OF_WEEK.test(ss) && (str[1] && d == str[1] && m == str[0] - 1 || !str[1] && d == str[0]) || // Day of month
          DAY_OF_WEEK.test(ss) && day.getDay() == +ss.replace('w', '') // Day of week
          )) {
            obj.apply = true;
            spec[day] = true; // Prevent applying generic rule on day, if specific exists
          }
        }
      } // Apply rules


      for (i = 0; i < vobj.length; i++) {
        obj = vobj[i];
        add = 0;
        remove = 0;
        i1 = mins[v];
        i2 = maxs[v];
        prop1 = true;
        prop2 = true;
        all = false;

        if (obj.start && (obj.apply || !obj.d && !spec[day])) {
          // Define time parts
          parts1 = obj.start.split(':');
          parts2 = obj.end.split(':');

          for (j = 0; j < 3; j++) {
            if (parts1[j] === undefined) {
              parts1[j] = 0;
            }

            if (parts2[j] === undefined) {
              parts2[j] = 59;
            }

            parts1[j] = +parts1[j];
            parts2[j] = +parts2[j];
          }

          if (v == 'tt') {
            // Wheel containing full time
            i1 = step(Math.round((new Date(day).setHours(parts1[0], parts1[1], parts1[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
            i2 = step(Math.round((new Date(day).setHours(parts2[0], parts2[1], parts2[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
          } else {
            parts1.unshift(parts1[0] > 11 ? 1 : 0);
            parts2.unshift(parts2[0] > 11 ? 1 : 0);

            if (hasAmPm) {
              if (parts1[1] >= 12) {
                parts1[1] = parts1[1] - 12;
              }

              if (parts2[1] >= 12) {
                parts2[1] = parts2[1] - 12;
              }
            } // Look behind


            for (j = 0; j < index; j++) {
              if (validValues[j] !== undefined) {
                v1 = step(parts1[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                v2 = step(parts2[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                hours1 = 0;
                hours2 = 0;
                hours3 = 0;

                if (hasAmPm && j == 1) {
                  hours1 = parts1[0] ? 12 : 0;
                  hours2 = parts2[0] ? 12 : 0;
                  hours3 = validValues[0] ? 12 : 0;
                }

                if (!prop1) {
                  v1 = 0;
                }

                if (!prop2) {
                  v2 = maxs[w[j]];
                }

                if ((prop1 || prop2) && v1 + hours1 < validValues[j] + hours3 && validValues[j] + hours3 < v2 + hours2) {
                  all = true;
                }

                if (validValues[j] != v1) {
                  prop1 = false;
                }

                if (validValues[j] != v2) {
                  prop2 = false;
                }
              }
            } // Look ahead


            if (!valid) {
              for (j = index + 1; j < 4; j++) {
                if (parts1[j] > 0) {
                  add = steps[v];
                }

                if (parts2[j] < maxs[w[j]]) {
                  remove = steps[v];
                }
              }
            }

            if (!all) {
              // Calculate min and max values
              v1 = step(parts1[index], steps[v], mins[v], maxs[v]) + add;
              v2 = step(parts2[index], steps[v], mins[v], maxs[v]) - remove;

              if (prop1) {
                i1 = v1;
              }

              if (prop2) {
                i2 = v2;
              }
            }
          } // Disable values


          if (prop1 || prop2 || all) {
            for (j = i1; j <= i2; j += steps[v]) {
              invalids[j] = !valid;
            }
          }
        }
      }
    }
  } // --- TRIAL SERVER CODE START ---


  var timeStep,
      oneDateWheel,
      wheels,
      wheelOrder = {},
      innerValues = {},
      isoParts = {},
      validValues = [],
      html5def = getHtml5Options($$1(this)),
      orig = extend$1({}, inst.settings),
      calendarSystem = calendars[orig.calendarSystem],
      s = extend$1(inst.settings, dateTimeDefaults, calendarSystem, defaults$1, html5def, orig),
      preset = s.preset,
      displayFormat = preset == 'datetime' ? s.dateFormat + s.separator + s.timeFormat : preset == 'time' ? s.timeFormat : s.dateFormat,
      format = html5def.format || displayFormat,
      dateWheels = s.dateWheels || s.dateFormat,
      timeWheels = s.timeWheels || s.timeFormat,
      //dateWheels = '|D M d|', // TODO settings
  //timeWheels = '|h|ii|A|',
  dateDisplay = s.dateWheels || s.dateDisplay,
      timeDisplay = timeWheels,
      baseTheme = s.baseTheme || s.theme,
      invalid = convertRanges(s.invalid),
      valid = convertRanges(s.valid),
      minDate = makeDate(s.min, format, s),
      maxDate = makeDate(s.max, format, s),
      hasTime = /time/i.test(preset),
      hasAmPm = /h/.test(timeDisplay),
      genDayNames = /D/.test(dateDisplay),
      stepParts = s.steps || {},
      stepHour = stepParts.hour || s.stepHour || 1,
      stepMinute = stepParts.minute || s.stepMinute || 1,
      stepSecond = stepParts.second || s.stepSecond || 1,
      zeroBased = stepParts.zeroBased,
      minHour = zeroBased || !minDate ? 0 : minDate.getHours() % stepHour,
      minMinute = zeroBased || !minDate ? 0 : minDate.getMinutes() % stepMinute,
      minSecond = zeroBased || !minDate ? 0 : minDate.getSeconds() % stepSecond,
      maxHour = getMax(stepHour, minHour, hasAmPm ? 11 : 23),
      maxMinute = getMax(stepMinute, minMinute, 59),
      maxSecond = getMax(stepMinute, minMinute, 59),
      mins = {
    y: minDate ? minDate.getFullYear() : -Infinity,
    m: 0,
    d: 1,
    h: minHour,
    i: minMinute,
    s: minSecond,
    a: 0,
    tt: 0
  },
      maxs = {
    y: maxDate ? maxDate.getFullYear() : Infinity,
    m: 11,
    d: 31,
    h: maxHour,
    i: maxMinute,
    s: maxSecond,
    a: 1,
    tt: 86400
  },
      steps = {
    y: 1,
    m: 1,
    d: 1,
    h: stepHour,
    i: stepMinute,
    s: stepSecond,
    a: 1,
    tt: 1
  },
      widths = {
    bootstrap: 46,
    ios: 50,
    material: 46,
    mobiscroll: 46,
    windows: 50
  },
      getDatePart = {
    y: getYear,
    m: getMonth,
    d: getDay,
    h: getHours,
    i: getMinutes,
    s: getSeconds,
    u: getMilliseconds,
    a: getAmPm,
    dd: getFullDate,
    tt: getFullTime
  }; // --- TRIAL SERVER CODE END ---
  // Extended methods
  // ---

  inst.getVal = function (temp) {
    return inst._hasValue || temp ? returnDate(getDate(inst.getArrayVal(temp)), s, format) : null;
  };
  /**
   * Returns the selected date.
   *
   * @param {Boolean} [temp=false] If true, return the currently shown date on the picker, otherwise the last selected one.
   * @return {Date}
   */


  inst.getDate = function (temp) {
    return inst._hasValue || temp ? getDate(inst.getArrayVal(temp)) : null;
  };
  /**
   * Sets the selected date
   *
   * @param {Date} d Date to select.
   * @param {Boolean} [fill=false] Also set the value of the associated input element. Default is true.
   * @param {Number} [time=0] Animation time to scroll to the selected date.
   * @param {Boolean} [temp=false] Set temporary value only.
   * @param {Boolean} [change=fill] Trigger change on input element.
   */


  inst.setDate = function (d, fill, time, temp, change) {
    inst.setArrayVal(getArray(d, true), fill, change, temp, time);
  }; // ---
  // Initializations
  // ---

  /*
  wheels = getWheels();
   s.isoParts = isoParts;
  */
  // --- REMOTE TRIAL CODE START ---


  wheelOrder = inst.remote.datetime.wheelOrder;
  oneDateWheel = inst.remote.datetime.oneDateWheel;
  timeStep = inst.remote.datetime.timeStep;
  wheels = inst.remote.datetime.wheels;
  s.isoParts = isoParts = inst.remote.datetime.isoParts;
  s.dateDisplay = dateDisplay;
  inst.remote.datetime.isValid = isValid;
  inst.remote.datetime.getFullDate = getFullDate;
  inst.remote.datetime.getDateIndex = getDateIndex;
  inst.remote.datetime.datetime = {
    formatDate: formatDate
  }; // --- REMOTE TRIAL CODE END ---

  inst._format = displayFormat;
  inst._order = wheelOrder;

  inst.handlers.now = function () {
    inst.setDate(new Date(), inst.live, 1000, true, true);
  };

  inst.buttons.now = {
    text: s.nowText,
    icon: s.nowIcon,
    handler: 'now'
  }; // ---

  return {
    minWidth: oneDateWheel && hasTime ? widths[baseTheme] : undefined,
    compClass: 'mbsc-dt mbsc-sc',
    wheels: wheels,
    headerText: s.headerText ? function () {
      return formatDate(displayFormat, getDate(inst.getArrayVal(true)), s);
    } : false,
    formatValue: function formatValue(d) {
      return formatDate(format, getDate(d), s);
    },
    parseValue: function parseValue(val) {
      if (!val) {
        innerValues = {};
        inst._hasValue = false;
      }

      return getArray(makeDate(val || s.defaultValue || new Date(), format, s, isoParts), !!val);
    },
    validate: function validate(data) {
      var i,
          j,
          dayStr,
          weekDay,
          values = data.values,
          index = data.index,
          dir = data.direction,
          dayWheel = s.wheels[0][wheelOrder.d],
          validated = getClosestValidDate(getDate(values), dir),
          temp = getArray(validated),
          disabled = [],
          wheels = {},
          y = getDatePart.y(validated),
          //get(temp, 'y'),
      m = getDatePart.m(validated),
          //get(temp, 'm'),
      maxdays = s.getMaxDayOfMonth(y, m),
          minprop = true,
          maxprop = true;
      $$1.each(['dd', 'y', 'm', 'd', 'tt', 'a', 'h', 'i', 's'], function (x, i) {
        var min = mins[i],
            max = maxs[i],
            val = getDatePart[i](validated);
        disabled[wheelOrder[i]] = [];

        if (minprop && minDate) {
          min = getDatePart[i](minDate);
        }

        if (maxprop && maxDate) {
          max = getDatePart[i](maxDate);
        }

        if (val < min) {
          val = min;
        }

        if (val > max) {
          val = max;
        }

        if (i !== 'dd' && i !== 'tt') {
          if (minprop) {
            minprop = val == min;
          }

          if (maxprop) {
            maxprop = val == max;
          }
        }

        if (wheelOrder[i] !== undefined) {
          if (i != 'y' && i != 'dd') {
            for (j = mins[i]; j <= maxs[i]; j += steps[i]) {
              if (j < min || j > max) {
                disabled[wheelOrder[i]].push(j);
              }
            }
          } // Disable some days


          if (i == 'd') {
            var first = s.getDate(y, m, 1).getDay(),
                invalids = {}; // Set invalid indexes

            validateDates(invalid, y, m, first, maxdays, invalids, 1); // Delete indexes which are valid

            validateDates(valid, y, m, first, maxdays, invalids, 0);
            $$1.each(invalids, function (j, v) {
              if (v) {
                disabled[wheelOrder[i]].push(j);
              }
            });
          }
        }
      }); // Invalid times

      if (hasTime) {
        $$1.each(['a', 'h', 'i', 's', 'tt'], function (i, v) {
          var val = getDatePart[v](validated),
              d = getDatePart.d(validated),
              invalids = {};

          if (wheelOrder[v] !== undefined) {
            validateTimes(invalid, i, v, y, m, d, invalids, 0);
            validateTimes(valid, i, v, y, m, d, invalids, 1);
            $$1.each(invalids, function (j, x) {
              if (x) {
                disabled[wheelOrder[v]].push(j);
              }
            }); // Get valid value

            validValues[i] = inst.getValidValue(wheelOrder[v], val, dir, invalids);
          }
        });
      } // Regenerate day wheel if number of days in month changes
      // or if day names needs to be regenerated


      if (dayWheel && (dayWheel.data.length !== maxdays || genDayNames && (index === undefined || index === wheelOrder.y || index === wheelOrder.m))) {
        wheels[wheelOrder.d] = dayWheel;
        dayWheel.data = [];

        for (i = 1; i <= maxdays; i++) {
          weekDay = s.getDate(y, m, i).getDay();
          dayStr = dateDisplay.replace(/[my|]/gi, '').replace(/dd/, (i < 10 ? '0' + i : i) + (s.daySuffix || '')).replace(/d/, i + (s.daySuffix || ''));
          dayWheel.data.push({
            value: i,
            display: /DD/.test(dayStr) ? dayStr.replace(/DD/, '<span class="mbsc-dt-day">' + s.dayNames[weekDay] + '</span>') : dayStr.replace(/D/, '<span class="mbsc-dt-day">' + s.dayNamesShort[weekDay] + '</span>')
          });
        } // Need to update day value, if out of month


        inst._tempWheelArray[wheelOrder.d] = temp[wheelOrder.d];
        inst.changeWheel(wheels);
      }

      return {
        disabled: disabled,
        valid: temp
      };
    }
  };
};

var id$1 = 0;

function jsonp$1(url, callback) {
  var script = document.createElement('script'),
      unique = 'mbscjsonp' + ++id$1;

  window[unique] = function (data) {
    script.parentNode.removeChild(script);
    delete window[unique];

    if (!data) {
      return;
    }

    callback(data);
  };

  script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + unique;
  document.body.appendChild(script);
}

function ajaxGet(url, callback) {
  var request = new XMLHttpRequest();
  request.open('GET', url, true);

  request.onload = function () {
    if (this.status >= 200 && this.status < 400) {
      // Success!
      callback(JSON.parse(this.response));
    } //else {
    // We reached our target server, but it returned an error
    //}

  };

  request.onerror = function () {// There was a connection error of some sort
  };

  request.send();
}

function getJson(url, callback, type) {
  if (type == 'jsonp') {
    jsonp$1(url, callback);
  } else {
    ajaxGet(url, callback);
  }
}

util.getJson = getJson;

// eslint-disable-next-line no-unused-vars

var defaults$2 = {
  controls: ['calendar'],
  firstDay: 0,
  weekDays: 'short',
  maxMonthWidth: 170,
  breakPointMd: 768,
  months: 1,
  pageBuffer: 1,
  weeks: 6,
  highlight: true,
  outerMonthChange: true,
  quickNav: true,
  yearChange: true,
  tabs: 'auto',
  // CSS classes
  todayClass: 'mbsc-cal-today',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left6',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right6',
  // Localization
  dateText: 'Date',
  timeText: 'Time',
  todayText: 'Today',
  fromText: 'Start',
  toText: 'End',
  moreEventsText: '{count} more',
  prevMonthText: 'Previous Month',
  nextMonthText: 'Next Month',
  prevYearText: 'Previous Year',
  nextYearText: 'Next Year'
}; // --- TRIAL SERVER CODE END ---

var CalendarBase = function CalendarBase(inst) {
  var $calendar,
      $markup,
      $monthHdr,
      $monthPicker,
      $tabPaneCont,
      $tabPanes,
      $yearHdr,
      $yearPicker,
      activeDate,
      base,
      calRows,
      calSize,
      calWidth,
      context,
      controls,
      controlsArray,
      cssDisabled,
      cssSelected,
      cssSelectedTab,
      currFirstDay,
      dayLabels,
      dayProps,
      dayScroll,
      displayFormat,
      firstWeekDay,
      hasCal,
      hasLabels,
      hasMarks,
      hasTabs,
      // hasText,
  hasQuickNav,
      hoverTimer,
      invalidObj,
      isCellHover,
      isDayClick,
      isLiquid,
      isMonthView,
      isPageMove,
      isRTL,
      isVertical,
      labelsObj,
      markedObj,
      colorsObj,
      maxDate,
      maxFirstYear,
      maxLabels,
      maxMonth,
      maxYear,
      minDate,
      minFirstYear,
      minMonth,
      minYear,
      monthIndex,
      monthNames,
      monthScroll,
      needsSlide,
      needsRefresh,
      pageBuffer,
      pageNr,
      pageOffset,
      pageTotal,
      rtl,
      s,
      selectedDate,
      showOuterDays,
      trigger,
      validObj,
      visibleTab,
      wasTouched,
      weekCounter,
      weekDays,
      yearChange,
      yearIndex,
      yearScroll,
      yearSuffix,
      labelIdx = 1,
      elm = this;

  function showCont($cont) {
    if ($cont.hasClass('mbsc-cal-h')) {
      $cont.removeClass('mbsc-cal-h');
    }
  }

  function hideCont($cont) {
    if (!$cont.hasClass('mbsc-cal-h')) {
      $cont.addClass('mbsc-cal-h');
    }
  }

  function toggleCont($cont) {
    if ($cont.hasClass('mbsc-cal-h')) {
      showCont($cont);
    } else {
      hideCont($cont);
    }
  }

  function preProcessSettings() {
    var ctrls, layout, orig;
    controls = {};
    controlsArray = [];
    dayLabels = {};
    trigger = inst.trigger;
    orig = extend$1({}, inst.settings);
    s = extend$1(inst.settings, defaults$2, orig);
    ctrls = s.controls.join(',');
    firstWeekDay = s.firstDay;
    isRTL = s.rtl;
    pageBuffer = s.pageBuffer;
    weekCounter = s.weekCounter;
    calRows = s.weeks;
    isMonthView = calRows == 6;
    isVertical = s.calendarScroll == 'vertical';
    context = inst._getRespCont();
    weekDays = s.weekDays == 'full' ? '' : s.weekDays == 'min' ? 'Min' : 'Short';
    layout = s.layout || (s.display == 'inline' || /top|bottom/.test(s.display) && s.touchUi ? 'liquid' : '');
    isLiquid = layout == 'liquid'; // && s.display !== 'bubble';

    calWidth = isLiquid ? null : s.calendarWidth;
    rtl = isRTL && !isVertical ? -1 : 1;
    cssDisabled = 'mbsc-disabled ' + (s.disabledClass || '');
    cssSelectedTab = 'mbsc-selected ' + (s.selectedTabClass || '');
    cssSelected = 'mbsc-selected ' + (s.selectedClass || '');
    maxLabels = Math.max(1, Math.floor(((s.calendarHeight || 0) / calRows - 45) / 18));

    if (ctrls.match(/calendar/)) {
      controls.calendar = 1;
      hasCal = true;
    } // Allow date scroller only if calendar not present


    if (ctrls.match(/date/) && !hasCal) {
      controls.date = 1;
    }

    if (ctrls.match(/time/)) {
      controls.time = 1;
    }

    s.controls.forEach(function (v) {
      if (controls[v]) {
        controlsArray.push(v);
      }
    }); // Disable quick nav for week view

    hasQuickNav = s.quickNav && hasCal && isMonthView; // Disable year change for week view

    yearChange = s.yearChange && isMonthView; // Fullscreen mode

    if (isLiquid && hasCal && s.display == 'center') {
      inst._isFullScreen = true;
    }

    s.layout = layout; // Pass back to core if set to liquid

    s.preset = (controls.date || hasCal ? 'date' : '') + (controls.time ? 'time' : '');
  }

  function postProcessSettings() {
    monthNames = yearChange ? s.monthNamesShort : s.monthNames;
    yearSuffix = s.yearSuffix || '';
    monthIndex = (s.dateWheels || s.dateFormat).search(/m/i);
    yearIndex = (s.dateWheels || s.dateFormat).search(/y/i);
    displayFormat = inst._format;

    if (s.min) {
      minDate = getDateOnly(makeDate(s.min, displayFormat, s));
      minYear = s.getYear(minDate);
      minMonth = s.getMonth(minDate);
      minFirstYear = s.getDate(Math.floor(minYear / 12) * 12, 0, 1);
    }

    if (s.max) {
      maxDate = getDateOnly(makeDate(s.max, displayFormat, s));
      maxYear = s.getYear(maxDate);
      maxMonth = s.getMonth(maxDate);
      maxFirstYear = s.getDate(Math.floor(maxYear / 12) * 12, 0, 1);
    }

    inst._minDate = minDate;
    inst._maxDate = maxDate;
  }

  function addToList(obj, d, ev) {
    obj[d] = obj[d] || [];
    obj[d].push(ev);
  }

  function prepareObj(list, start, end) {
    var d,
        v,
        year,
        month,
        day,
        maxDays,
        endTime,
        startTime,
        getDate = s.getDate,
        getYear = s.getYear,
        getMonth = s.getMonth,
        getDay = s.getDay,
        getMaxDayOfMonth = s.getMaxDayOfMonth,
        startYear = getYear(start),
        startMonth = getMonth(start),
        obj = {};

    if (list) {
      $$1.each(list, function (i, ev) {
        d = ev.d || ev.start || ev;
        v = d + '';

        if (ev.start && ev.end) {
          startTime = getDateOnly(makeDate(ev.start, displayFormat, s));
          endTime = getDateOnly(makeDate(ev.end, displayFormat, s));

          while (startTime <= endTime) {
            addToList(obj, startTime, ev);
            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 1);
          }
        } else if (DAY_OF_WEEK.test(v)) {
          // Day of week
          startTime = getFirstDay(start, false, +v.replace('w', ''));

          while (startTime <= end) {
            addToList(obj, startTime, ev);
            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 7);
          }
        } else if (DAY_OF_MONTH.test(v)) {
          // Day of month: '2' or '12/24'
          v = v.split('/');
          var hasMonth = !!v[1],
              yearInc = hasMonth ? 1 : 0,
              monthInc = hasMonth ? 0 : 1,
              vMonth = hasMonth ? v[0] - 1 : startMonth,
              vDay = hasMonth ? +v[1] : +v[0];
          maxDays = getMaxDayOfMonth(startYear, vMonth);
          startTime = getDate(startYear, vMonth, Math.min(vDay, maxDays));

          while (startTime <= end) {
            year = getYear(startTime);
            month = getMonth(startTime);
            day = getDay(startTime);

            if (day === vDay) {
              addToList(obj, startTime, ev);
            }

            maxDays = getMaxDayOfMonth(year + yearInc, month + monthInc);
            startTime = getDate(year + yearInc, month + monthInc, Math.min(vDay, maxDays));
          }
        } else {
          // Exact date
          addToList(obj, getDateOnly(makeDate(d, displayFormat, s)), ev);
        }
      });
    }

    return obj;
  }

  function isValidDate(d) {
    if (d < minDate) {
      return false;
    }

    if (d > maxDate) {
      return false;
    }

    return invalidObj[d] === undefined || validObj[d] !== undefined;
  }

  function getDayProps(d) {
    var i,
        mark,
        markedMarkup,
        props,
        marked = markedObj[d] ? markedObj[d] : false,
        colors = colorsObj[d] ? colorsObj[d] : false,
        background = colors && colors[0].background ? colors[0].background : marked && marked[0].background,
        cssClass = '';

    if (colors) {
      for (i = 0; i < colors.length; i++) {
        cssClass += (colors[i].cssClass || '') + ' ';
      }
    }

    if (marked) {
      // Marks
      markedMarkup = '<div class="mbsc-cal-marks">';

      for (i = 0; i < marked.length; i++) {
        mark = marked[i];
        cssClass += (mark.cssClass || '') + ' ';
        markedMarkup += '<div class="mbsc-cal-mark"' + (mark.color ? ' style="background:' + mark.color + ';"' : '') + '></div>';
      }

      markedMarkup += '</div>';
    }

    props = {
      marked: marked,
      background: background,
      cssClass: cssClass,
      // ariaLabel: hasText ? txt : '',
      markup: dayLabels[d] ? dayLabels[d].join('') : hasMarks ? markedMarkup : ''
    };
    return extend$1(props, inst._getDayProps(d, props));
  }

  function getOffsetStyle(offset) {
    return ' style="' + (isVertical ? 'transform: translateY(' + offset * 100 + '%)' : 'left:' + offset * 100 * rtl + '%') + '"';
  }

  function calcMonthNr() {
    // Calculate pageNr
    pageNr = s.months == 'auto' ? // Exact month number from setting
    Math.max(1, // Min 1 month
    Math.min(3, // Max 3 months
    Math.floor((calWidth || getWidth(context)) / 280))) : +s.months;
    pageTotal = pageNr + 2 * pageBuffer;
    pageOffset = 0; //Math.round(pageNr / 2) - 1;
    // Don't allow vertical scroll with multiple months

    isVertical = isVertical && pageNr < 2; // Don't show outer days by default for multiple months or vertical scroll

    showOuterDays = s.showOuterDays === undefined ? pageNr < 2 && !isVertical || !isMonthView : s.showOuterDays;
  }

  function constrain(d) {
    if (getPageDay(d, pageNr - 1) > maxDate) {
      d = getPageDay(maxDate, 1 - pageNr);
    }

    if (d < minDate) {
      d = minDate;
    }

    return d;
  }

  function getLabelMarkup(event, i, showText) {
    var noBg = event.background === 'none';
    var color = noBg ? 'none' : event.color;
    var txtColor = noBg ? event.color : getTextColor(color);
    var txt = event.text;
    return '<div data-id="' + event._id + '" data-index="' + i + '" class="mbsc-cal-txt' + (noBg ? ' mbsc-cal-txt-only' : '') + '" title="' + $$1('<div>' + txt + '</div>').text() + '"' + (color ? ' style="background:' + color + (showText && txtColor ? ';color:' + txtColor : '') + ';"' : '') + '>' + (showText ? txt : '') + '</div>';
  }

  function compareEvents(a, b) {
    var start1 = a.start ? makeDate(a.start) : null,
        start2 = b.start ? makeDate(b.start) : null,
        end1 = a.end ? makeDate(a.end) : null,
        end2 = b.end ? makeDate(b.end) : null,
        isRepeating1 = DAY_OF_WEEK.test(a.d) || DAY_OF_MONTH.test(a.d),
        isRepeating2 = DAY_OF_WEEK.test(b.d) || DAY_OF_MONTH.test(b.d),
        dt1 = a.d ? isRepeating1 ? a.d : makeDate(a.d) : start1,
        dt2 = b.d ? isRepeating2 ? b.d : makeDate(b.d) : start2,
        weight1 = !dt1.getTime ? 0 : a.allDay ? 1 : dt1.getTime(),
        weight2 = !dt2.getTime ? 0 : b.allDay ? 1 : dt2.getTime();

    if (weight1 == weight2) {
      return a.text > b.text ? 1 : -1;
    }

    return weight1 - weight2;
  }

  function sortEvents(events) {
    return events.slice(0).sort(s.eventOrder);
  }

  function onGenMonth(d) {
    var start = getFirstDay(getPageDay(d, -pageOffset - pageBuffer), false);
    var end = getFirstDay(getPageDay(d, -pageOffset + pageNr + pageBuffer - 1), false);
    end = s.getDate(s.getYear(end), s.getMonth(end), s.getDay(end) + calRows * 7);

    inst._onGenMonth(start, end);

    invalidObj = prepareObj(s.invalid, start, end);
    validObj = prepareObj(s.valid, start, end);
    markedObj = prepareObj(s.labels || s.events || s.marked, start, end);
    colorsObj = prepareObj(s.colors, start, end);
    labelsObj = inst._labels || markedObj || colorsObj;
    hasLabels = s.labels || inst._labels; // Multiple labels

    if (hasLabels) {
      (function () {
        dayLabels = {};
        var eventRows = {};
        var day = start;

        var _loop = function _loop() {
          if (day.getDay() == firstWeekDay) {
            eventRows = {};
          }

          var maxRows = maxLabels;
          var events = sortEvents(labelsObj[day] || []);
          var eventsNr = events.length;
          var labels = [];
          var prevEvent = void 0;
          var prevIndex = void 0;
          var row = 0;
          var displayed = 0;
          var i = 0;
          var width = void 0;

          while (row < maxRows) {
            prevEvent = null; // Check  if there are any events already in this row

            events.forEach(function (ev, j) {
              if (eventRows[row] == ev) {
                prevEvent = ev;
                prevIndex = j;
              }
            });

            if (row == maxRows - 1 && (displayed < eventsNr - 1 || eventsNr && i == eventsNr && !prevEvent)) {
              var nr = eventsNr - displayed;
              var txt = (nr > 1 ? s.moreEventsPluralText || s.moreEventsText : s.moreEventsText).replace(/{count}/, nr);

              if (nr) {
                labels.push('<div class="mbsc-cal-txt-more">' + txt + '</div>');
              } // Remove event from previous days and replace it with more label


              if (prevEvent) {
                eventRows[row] = null;

                prevEvent._days.forEach(function (d) {
                  dayLabels[d][row] = '<div class="mbsc-cal-txt-more">' + s.moreEventsText.replace(/{count}/, 1) + '</div>';
                });
              }

              displayed++;
              row++;
            } else if (prevEvent) {
              if (prevIndex == i) {
                i++;
              }

              if (isSameDay(day, makeDate(prevEvent.end))) {
                eventRows[row] = null;
              }

              labels.push(getLabelMarkup(prevEvent, prevIndex));
              row++;
              displayed++;

              prevEvent._days.push(day);
            } else if (i < eventsNr) {
              var event = events[i];
              var startTime = event.start && makeDate(event.start);
              var endTime = event.end && makeDate(event.end);
              var weekDay = day.getDay();
              var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
              var multiDay = endTime && !isSameDay(startTime, endTime);

              if (!startTime || // all day event
              isSameDay(day, startTime) || // event start day
              weekDay == firstWeekDay // first day of week (if event continues from prev week))
              ) {
                  if (event._id === undefined) {
                    event._id = labelIdx++;
                  }

                  if (multiDay) {
                    eventRows[row] = event;
                  }

                  event._days = [day];
                  width = multiDay ? Math.min(getDayDiff(day, getDateOnly(endTime)) + 1, 7 + firstWeekDay - weekDay - offset) * 100 : 100;
                  labels.push(multiDay ? '<div class="mbsc-cal-txt-w" style="width:' + width + '%">' + getLabelMarkup(event, i, true) + '</div>' + getLabelMarkup(event, i) : getLabelMarkup(event, i, true));
                  row++;
                  displayed++;
                }

              i++;
            } else {
              labels.push('<div class="mbsc-cal-txt-ph"></div>');
              row++;
            }
          }

          dayLabels[day] = labels;
          day = s.getDate(s.getYear(day), s.getMonth(day), s.getDay(day) + 1);
        };

        while (day < end) {
          _loop();
        }
      })();
    }
  }

  function onBeforeMonthChange(d) {
    var y = s.getYear(d),
        m = s.getMonth(d);
    currFirstDay = d;
    activeDate = d;
    setTitle(d);
    trigger('onMonthChange', {
      year: y,
      month: m
    });
    trigger('onMonthLoading', {
      year: y,
      month: m
    });
    trigger('onPageChange', {
      firstDay: d
    });
    trigger('onPageLoading', {
      firstDay: d
    });
    onGenMonth(d);
  }

  function onAfterMonthChange(d) {
    var y = s.getYear(d),
        m = s.getMonth(d);

    if (needsRefresh === undefined) {
      onPageLoaded(d, y, m);
    } else {
      genAllMonths(d, needsRefresh, true);
    }

    focusDate(activeDate, dayScroll.focus);
    dayScroll.focus = false;
  }

  function onPageLoaded(d, y, m) {
    var $scroller = dayScroll.$scroller;
    $$1('.mbsc-cal-slide', $scroller).removeClass('mbsc-cal-slide-a');
    $$1('.mbsc-cal-slide', $scroller).slice(pageBuffer, pageBuffer + pageNr).addClass('mbsc-cal-slide-a');
    $$1('.mbsc-cal-slide-a .mbsc-cal-day', $scroller).on('mouseenter', function () {
      var $cell = $$1(this);

      if (!wasTouched && !isPageMove) {
        hoverTimer = setTimeout(function () {
          isCellHover = true;
          trigger('onCellHoverIn', getDayInfo($cell));
        }, 150);
      }
    }).on('mouseleave', function () {
      clearTimeout(hoverTimer);

      if (!wasTouched && isCellHover) {
        isCellHover = false;
        trigger('onCellHoverOut', getDayInfo($$1(this)));
      }
    });

    if (hasLabels) {
      $$1('.mbsc-cal-slide-a .mbsc-cal-txt', $scroller).on('mouseenter', function () {
        var id = $$1(this).attr('data-id');
        $$1('.mbsc-cal-txt[data-id="' + id + '"]', $scroller).addClass('mbsc-hover');
      }).on('mouseleave', function () {
        $$1('.mbsc-cal-txt.mbsc-hover', $scroller).removeClass('mbsc-hover');
      });
    }

    trigger('onMonthLoaded', {
      year: y,
      month: m
    });
    trigger('onPageLoaded', {
      firstDay: d
    });
  }

  function genTabMarkup() {
    var html, tabText;
    html = '<div class="mbsc-cal-tabs-c"><div class="mbsc-cal-tabs" role="tablist">';
    controlsArray.forEach(function (v, i) {
      tabText = s[(v == 'calendar' ? 'date' : v) + 'Text'];
      html += '<div role="tab" aria-controls="' + (elm.id + '-mbsc-pnl-' + i) + '" class="mbsc-cal-tab mbsc-fr-btn-e ' + (i ? '' : cssSelectedTab) + '" data-control="' + v + '"' + (s.tabLink ? '><a href="#">' + tabText + '</a>' : ' tabindex="0">' + tabText) + '</div>';
    });
    html += '</div></div>';
    return html;
  }

  function genCalMarkup() {
    var html,
        i,
        j,
        k,
        monthBtns,
        monthsMarkup,
        yearBtns = '',
        btnPrevClass = isRTL ? s.btnCalNextClass : s.btnCalPrevClass,
        btnNextClass = isRTL ? s.btnCalPrevClass : s.btnCalNextClass; // Generate month buttons

    monthBtns = '<div class="mbsc-cal-btn-w"><div data-step="-1" role="button" tabindex="0" aria-label="' + s.prevMonthText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>';

    for (i = 0; i < (calRows ? pageNr : 1); i++) {
      monthBtns += '<div role="button" class="mbsc-cal-month"></div>';
    }

    monthBtns += '<div data-step="1" role="button" tabindex="0" aria-label="' + s.nextMonthText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>'; // Generate year buttons

    if (yearChange) {
      yearBtns = '<div class="mbsc-cal-btn-w"><div data-step="-12" role="button" tabindex="0" aria-label="' + s.prevYearText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>' + '<div role="button" class="mbsc-cal-year"></div>' + '<div data-step="12" role="button" tabindex="0" aria-label="' + s.nextYearText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>';
    }

    if (calRows) {
      monthsMarkup = genAllMonths(currFirstDay);
    }

    html = '<div class="mbsc-w-p mbsc-cal-c"><div class="mbsc-cal ' + (isMonthView ? '' : ' mbsc-cal-week-view') + (pageNr > 1 ? ' mbsc-cal-multi ' : '') + (weekCounter ? ' mbsc-cal-weeks ' : '') + (isVertical ? ' mbsc-cal-vertical' : '') + (hasMarks ? ' mbsc-cal-has-marks' : '') + (hasLabels ? ' mbsc-cal-has-labels' : '') + ( // (hasText ? ' mbsc-cal-has-txt' : '') +
    showOuterDays ? '' : ' mbsc-cal-hide-diff ') + (s.calendarClass || '') + '"' + (!isLiquid ? ' style="width:' + (calWidth || 280 * pageNr) + 'px;"' : '') + '>' + '<div class="mbsc-cal-hdr">' + (yearIndex < monthIndex || pageNr > 1 ? yearBtns + monthBtns : monthBtns + yearBtns) + '</div>';

    if (calRows) {
      html += '<div class="mbsc-cal-body"><div class="mbsc-cal-day-picker"><div class="mbsc-cal-days-c">';

      for (j = 0; j < pageNr; j++) {
        // Generate week days
        html += '<div class="mbsc-cal-days">';

        for (i = 0; i < 7; i++) {
          k = (i + firstWeekDay) % 7;
          html += '<div class="mbsc-cal-week-day' + k + '" aria-label="' + s.dayNames[k] + '">' + s['dayNames' + weekDays][k] + '</div>';
        }

        html += '</div>';
      }

      html += '</div>' + '<div class="mbsc-cal-scroll-c mbsc-cal-day-scroll-c ' + (s.calendarClass || '') + '"' + (s.calendarHeight ? ' style="height:' + s.calendarHeight + 'px"' : '') + '>' + '<div class="mbsc-cal-scroll" style="width:' + 100 / pageNr + '%' + '">' + monthsMarkup + '</div></div>';
    }

    html += '</div>';

    if (hasQuickNav) {
      // Generate month picker
      html += '<div class="mbsc-cal-month-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

      for (i = 0; i < 3; i++) {
        html += '<div class="mbsc-cal-slide"' + getOffsetStyle(i - 1) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

        for (j = 0; j < 12; j++) {
          if (j && j % 3 === 0) {
            html += '</div><div role="row" class="mbsc-cal-row">';
          }

          html += '<div role="gridcell"' + (i == 1 ? ' tabindex="-1" aria-label="' + s.monthNames[j] + '" data-val="' + j + '"' : '') + ' class="mbsc-cal-cell' + (i == 1 ? ' mbsc-btn-e' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + (i == 1 ? s.monthNamesShort[j] : '&nbsp;') + '</div></div>';
        }

        html += '</div></div></div>';
      }

      html += '</div></div></div>'; // Generate year picker

      html += '<div class="mbsc-cal-year-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

      for (i = -1; i < 2; i++) {
        html += genYears(getPageYear(currFirstDay, i), i);
      }

      html += '</div></div></div>';
    } // Closing


    html += '</div></div></div>';
    return html;
  }

  function genYears(d, off) {
    var i,
        year = s.getYear(d),
        html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

    for (i = 0; i < 12; i++) {
      if (i && i % 3 === 0) {
        html += '</div><div role="row" class="mbsc-cal-row">';
      }

      html += '<div role="gridcell" tabindex="-1" aria-label="' + year + '" data-val="' + year + '"' + ' class="mbsc-cal-cell mbsc-btn-e ' + (year < minYear || year > maxYear ? ' mbsc-disabled ' : '') + (year == s.getYear(currFirstDay) ? cssSelected : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + year + yearSuffix + '</div></div>';
      year++;
    }

    html += '</div></div></div>';
    return html;
  }

  function genMonth(firstDay, off) {
    var bg,
        curr,
        cssClass,
        y,
        m,
        d,
        displayMonth,
        displayDate,
        fullDate,
        props,
        isValid,
        isSelected,
        isToday,
        isOuterDay,
        maxDays,
        i,
        j,
        k = 1,
        year = s.getYear(firstDay),
        month = s.getMonth(firstDay),
        day = s.getDay(firstDay),
        selected = s.defaultValue === null && !inst._hasValue ? null : inst.getDate(true),
        weekDay = s.getDate(year, month, day).getDay(),
        // Get the weekday of the month
    offset = firstWeekDay - weekDay > 0 ? 7 : 0,
        html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

    for (j = 0; j < 7 * calRows; j++) {
      i = j + firstWeekDay - offset;
      curr = s.getDate(year, month, i - weekDay + day);
      y = curr.getFullYear();
      m = curr.getMonth();
      d = curr.getDate();
      displayMonth = s.getMonth(curr);
      displayDate = s.getDay(curr);
      maxDays = s.getMaxDayOfMonth(y, m);
      fullDate = y + '-' + (m + 1) + '-' + d;
      props = extend$1({
        valid: isValidDate(curr),
        selected: selected && isSameDay(selected, curr)
      }, getDayProps(curr));
      bg = props.background === 'none' ? false : props.background;
      isValid = props.valid;
      isSelected = props.selected;
      cssClass = props.cssClass; // Compare dates at noon, in some timezones 0:00 doesn't exists on daylight saving day

      isToday = new Date(curr).setHours(12, 0, 0, 0) === new Date().setHours(12, 0, 0, 0);
      isOuterDay = displayMonth !== month; // Day is from another month

      dayProps[fullDate] = props;

      if (j && j % 7 === 0) {
        html += '</div><div role="row" class="mbsc-cal-row">';
      }

      if (weekCounter && j % 7 === 0) {
        // If displaying days from next month, reset month counter
        if (weekCounter == 'month' && isOuterDay && k > 1) {
          k = d == 1 ? 1 : 2;
        } else if (weekCounter == 'year') {
          k = s.getWeekNumber(s.getDate(y, m, d + (7 - firstWeekDay + 1) % 7));
        }

        html += '<div role="gridcell" class="mbsc-cal-cell mbsc-cal-week-nr">' + k + '</div>';
        k++;
      }

      html += '<div role="gridcell"' + // Aria attributes
      ' aria-label="' + (isToday ? s.todayText + ', ' : '') + s.dayNames[curr.getDay()] + ', ' + s.monthNames[displayMonth] + ' ' + displayDate + ' ' + (props.ariaLabel ? ', ' + props.ariaLabel : '') + '"' + (isOuterDay && !showOuterDays ? ' aria-hidden="true"' : ' data-full="' + fullDate + '"') + (isOuterDay || !isValid ? ' aria-disabled="true"' : '') + (isSelected ? ' aria-selected="true"' : '') + (isValid ? ' tabindex="-1"' : '') + // Classes
      ' class="mbsc-cal-cell mbsc-cal-day mbsc-cal-day' + i % 7 + ' ' + (s.dayClass || '') + ' ' + (isSelected ? cssSelected : '') + (isToday ? ' ' + s.todayClass : '') + (cssClass ? ' ' + cssClass : '') + (displayDate == 1 ? ' mbsc-cal-day-first' : '') + (displayDate == maxDays ? ' mbsc-cal-day-last' : '') + (isOuterDay ? ' mbsc-cal-day-diff' : '') + (isValid ? ' mbsc-btn-e' : ' mbsc-disabled') + (props.marked ? ' mbsc-cal-day-marked' : '') + (bg ? ' mbsc-cal-day-colored' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-day-i"><div class="mbsc-cal-day-date mbsc-cal-cell-txt"' + (bg ? ' style="background:' + bg + ';color:' + getTextColor(bg) + '"' : '') + '>' + displayDate + '</div>' + inst._getText(mobiscroll, 0.06) + ( // Extra markup (extra div is needed in RTL mode for Chrome, otherwise labels and marks appear at the top of the cell)
      props.markup ? '<div class="mbsc-cal-day-markup">' + props.markup + '</div>' : '') + '</div></div>';
    }

    html += '</div></div></div>';
    return html;
  }

  function genAllMonths(firstDay, render, insert) {
    var i,
        y = s.getYear(firstDay),
        m = s.getMonth(firstDay),
        pos = dayScroll ? dayScroll.pos : 0,
        html = '';
    dayProps = {};

    if (calRows) {
      if (!render) {
        trigger('onMonthLoading', {
          year: y,
          month: m
        });
        trigger('onPageLoading', {
          firstDay: firstDay
        });
      }

      onGenMonth(firstDay);

      for (i = 0; i < pageTotal; i++) {
        html += genMonth(getPageDay(firstDay, i - pageOffset - pageBuffer), pos * rtl + i - pageBuffer);
      }
    } //activateMonth(); // TODO: ???


    needsRefresh = undefined;

    if (insert && dayScroll) {
      dayScroll.$active = null;
      dayScroll.$scroller.html(html);
      onPageLoaded(firstDay, y, m);
    }

    return html;
  }

  function focusDate(d, focus) {
    if (dayScroll) {
      var $active = dayScroll.$active;

      if ($active && $active.length) {
        $active[0].blur();

        if ($active.hasClass('mbsc-disabled')) {
          $active.removeAttr('tabindex');
        } else {
          $active.attr('tabindex', '-1');
        }
      }

      dayScroll.$active = $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', dayScroll.$scroller).attr('tabindex', '0');

      if (focus && dayScroll.$active.length) {
        dayScroll.$active[0].focus();
      }
    }
  }

  function highlightDate(d) {
    var $ctx = dayScroll && dayScroll.$scroller;

    if (s.highlight && dayScroll) {
      $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');

      if (s.defaultValue !== null || inst._hasValue) {
        $$1('.mbsc-cal-day[data-full="' + getDateStr(d) + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
      }
    }
  }

  function highlightSelected(v, $ctx) {
    $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');
    $$1('.mbsc-cal-cell[data-val="' + v + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
  }

  function setDate(d, nav, anim, focus) {
    var diff, newFirstDay;

    if (!visibleTab) {
      return;
    }

    if (d < minDate) {
      d = minDate;
    }

    if (d > maxDate) {
      d = maxDate;
    }

    if (visibleTab === 'calendar' || !hasTabs || nav) {
      inst._isSetDate = !nav;

      if (hasCal && calRows) {
        newFirstDay = getFirstDay(constrain(d), isMonthView);

        if (needsSlide && (d < getPageDay(currFirstDay, -pageOffset) || d >= getPageDay(currFirstDay, pageNr - pageOffset))) {
          diff = isMonthView ? s.getMonth(newFirstDay) - s.getMonth(currFirstDay) + (s.getYear(newFirstDay) - s.getYear(currFirstDay)) * 12 : Math.floor(getDayDiff(currFirstDay, newFirstDay) / (7 * calRows));

          if (diff) {
            // Clear queue to navigate immediately
            dayScroll.queue = [];
            dayScroll.focus = focus && anim;
            changePageQueue(dayScroll, diff, anim);
          }
        }

        if (!diff || !anim) {
          focusDate(d, focus);
        }

        if (!nav) {
          highlightDate(d);
        }

        if (!isMonthView && !diff) {
          setTitle(currFirstDay, true);
        }

        activeDate = d;
        needsSlide = true;
      }

      inst._onSetDate(d, diff);

      inst._isSetDate = false;
    }
  }

  function setTitle(d, skipButtons) {
    var i,
        year,
        month,
        dd,
        y = s.getYear(d),
        m = s.getMonth(d),
        yy = y + yearSuffix;

    if (hasQuickNav) {
      // Highlight month
      highlightSelected(m, monthScroll.$scroller); // Highlight year

      highlightSelected(y, yearScroll.$scroller); // Scroll to selected year

      changePageQueue(yearScroll, Math.floor(y / 12) - Math.floor(s.getYear(yearScroll.first) / 12), true); // Disable out of range months

      $$1('.mbsc-cal-cell', monthScroll.$scroller).removeClass('mbsc-disabled');

      if (y === minYear) {
        for (i = 0; i < minMonth; i++) {
          $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
        }
      }

      if (y === maxYear) {
        for (i = maxMonth + 1; i <= 12; i++) {
          $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
        }
      }
    }

    if (!skipButtons) {
      // Disable/enable prev/next buttons
      checkBtn($$1('.mbsc-cal-prev-m', $markup), getPageDay(d, -pageOffset) <= minDate);
      checkBtn($$1('.mbsc-cal-next-m', $markup), getPageDay(d, pageNr - pageOffset) > maxDate);
      checkBtn($$1('.mbsc-cal-prev-y', $markup), s.getDate(y - 1, m + 1, 1) <= minDate);
      checkBtn($$1('.mbsc-cal-next-y', $markup), s.getDate(y + 1, m, 1) > maxDate);
    } // Update year in header


    $yearHdr.attr('aria-label', y).html(yy); // Update month in header

    for (i = 0; i < pageNr; i++) {
      dd = getPageDay(d, i - pageOffset);

      if (selectedDate >= dd && selectedDate < getPageDay(dd, 1)) {
        dd = selectedDate;
      }

      year = s.getYear(dd);
      month = s.getMonth(dd);
      yy = year + yearSuffix;
      $monthHdr.eq(i).attr('aria-label', s.monthNames[month] + (yearChange ? '' : ' ' + y)).html((!yearChange && yearIndex < monthIndex ? yy + ' ' : '') + monthNames[month] + (!yearChange && yearIndex > monthIndex ? ' ' + yy : ''));
    }
  }

  function checkBtn($btn, disable) {
    if (disable) {
      $btn.addClass(cssDisabled).attr('aria-disabled', 'true');
    } else {
      $btn.removeClass(cssDisabled).removeAttr('aria-disabled');
    }
  }

  function getDayInfo($day) {
    var day = $day[0],
        full = $day.attr('data-full'),
        parts = full ? full.split('-') : [],
        d = adjustedDate(parts[0], parts[1] - 1, parts[2]),
        selected = $day.hasClass('mbsc-selected');
    return extend$1(dayProps ? dayProps[full] : {}, {
      date: d,
      target: day,
      selected: selected
    });
  }

  function selectDay($day, ev) {
    var curr = inst.getDate(true),
        props = getDayInfo($day),
        day = $day[0],
        d = props.date,
        dtime = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate(), curr.getHours(), curr.getMinutes(), curr.getSeconds()),
        $target = $$1(ev.target),
        target = $target[0];

    if (!dayProps || !showOuterDays && $day.hasClass('mbsc-cal-day-diff')) {
      return;
    }

    props.date = dtime; // Check if a label was tapped

    if (hasLabels && day.contains(target)) {
      while (target != day) {
        if ($target.hasClass('mbsc-cal-txt') || $target.hasClass('mbsc-cal-txt-more')) {
          var index = $target.attr('data-index');
          var labels = labelsObj[d];

          if (trigger('onLabelTap', {
            date: dtime,
            domEvent: ev,
            target: $target[0],
            labels: labels,
            label: labels[index]
          }) === false) {
            return;
          }

          break;
        }

        $target = $target.parent();
        target = $target[0];
      }
    }

    if (trigger('onDayChange', props) !== false && !s.readonly && !$day.hasClass('mbsc-disabled')) {
      inst._selectDay($day, d, dtime, props.selected);
    }
  }

  function selectMonth($month) {
    hideCont($monthPicker);
    setDate(s.getDate(s.getYear(dayScroll.first), $month.attr('data-val'), 1), true, true);
  }

  function selectYear($year) {
    hideCont($yearPicker);
    setDate(s.getDate($year.attr('data-val'), s.getMonth(dayScroll.first), 1), true, true);
  }

  function getFirstDay(d, isMonth, w) {
    var y = s.getYear(d),
        m = s.getMonth(d),
        weekDay = d.getDay(),
        offset = firstWeekDay - weekDay > 0 ? 7 : 0;
    return isMonth ? s.getDate(y, m, 1) : s.getDate(y, m, (w === undefined ? firstWeekDay : w) - offset - weekDay + s.getDay(d));
  }

  function getPageDay(d, diff) {
    var year = s.getYear(d),
        month = s.getMonth(d),
        day = s.getDay(d);
    return isMonthView ? s.getDate(year, month + diff, 1) : s.getDate(year, month, day + diff * calRows * 7);
  }

  function getPageYear(d, diff) {
    var year = Math.floor(s.getYear(d) / 12) * 12;
    return s.getDate(year + diff * 12, 0, 1);
  }

  function changePageQueue(props, diff, anim, callback) {
    if (!diff || !inst._isVisible) {
      return;
    }

    props.queue.push(arguments);

    if (props.queue.length == 1) {
      changePage(props, diff, anim, callback);
    }
  }

  function changePage(props, diff, anim, callback) {
    var i,
        inc,
        html = '',
        $scroller = props.$scroller,
        pageBuffer = props.buffer,
        pageOffset = props.offset,
        pageNr = props.pages,
        pageTotal = props.total,
        firstDay = props.first,
        genPage = props.genPage,
        getFirst = props.getFirst,
        move = diff > 0 ? Math.min(diff, pageBuffer) : Math.max(diff, -pageBuffer),
        pos = props.pos * rtl + move - diff + pageOffset,
        load = Math.abs(diff) > pageBuffer; // Call any pending callback

    if (props.callback) {
      props.load();
      props.callback(true);
    }

    props.first = getFirst(firstDay, diff);
    props.pos += move * rtl;
    props.changing = true;

    props.load = function () {
      if (load) {
        for (i = 0; i < pageNr; i++) {
          inc = diff + i - pageOffset; // ???

          html += genPage(getFirst(firstDay, inc), pos + inc);
        }

        if (diff > 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(-pageNr).remove();
          $scroller.append(html);
        } else if (diff < 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(0, pageNr).remove();
          $scroller.prepend(html);
        }
      }
    };

    props.callback = function (forceStop) {
      var nr = Math.abs(move),
          html = '';

      if (!inst._isVisible) {
        return;
      }

      for (i = 0; i < nr; i++) {
        inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? pageTotal - nr : 0); // ???

        html += genPage(getFirst(firstDay, inc), pos + inc);
      }

      if (diff > 0) {
        $scroller.append(html);
        $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
      } else if (diff < 0) {
        $scroller.prepend(html);
        $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
      }

      if (load) {
        html = '';

        for (i = 0; i < nr; i++) {
          inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? 0 : pageTotal - nr); // ???

          html += genPage(getFirst(firstDay, inc), pos + inc);
        }

        if (diff > 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
          $scroller.prepend(html);
        } else if (diff < 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
          $scroller.append(html);
        }
      }

      refreshScroller(props);

      if (callback && !forceStop) {
        callback();
      }

      props.callback = null;
      props.load = null;
      props.queue.shift();
      load = false;

      if (props.queue.length) {
        changePage.apply(this, props.queue[0]);
      } else {
        props.changing = false;
        props.onAfterChange(props.first);
      }
    };

    props.onBeforeChange(props.first);

    if (props.load) {
      props.load();
      props.scroller.scroll(-props.pos * props.size, anim ? 200 : 0, false, props.callback);
    }
  }

  function createScroller(cont, min, max, buffer, offset, pages, total, first, onTap, onBeforeChange, onAfterChange, genPage, getFirst) {
    var axis = isVertical ? 'Y' : 'X',
        props = {
      $scroller: $$1('.mbsc-cal-scroll', cont),
      queue: [],
      buffer: buffer,
      offset: offset,
      pages: pages,
      first: first,
      total: total,
      pos: 0,
      min: min,
      max: max,
      genPage: genPage,
      getFirst: getFirst,
      onBeforeChange: onBeforeChange,
      onAfterChange: onAfterChange
    };
    props.scroller = new ScrollViewBase(cont, {
      axis: axis,
      easing: '',
      contSize: 0,
      maxSnapScroll: buffer,
      mousewheel: s.mousewheel === undefined ? isVertical : s.mousewheel,
      time: 200,
      lock: true,
      rtl: isRTL,
      stopProp: false,
      minScroll: 0,
      maxScroll: 0,
      onBtnTap: function onBtnTap(ev) {
        if (ev.domEvent.type == 'touchend') {
          preventClick();
        }

        onTap($$1(ev.target), ev.domEvent);
      },
      onStart: function onStart() {
        clearTimeout(hoverTimer);
      },
      onGestureStart: function onGestureStart() {
        isPageMove = true;
      },
      onAnimationStart: function onAnimationStart() {
        props.changing = true;
      },
      onAnimationEnd: function onAnimationEnd(ev) {
        isPageMove = false;

        if (genPage) {
          changePageQueue(props, Math.round((-props.pos * props.size - ev['pos' + axis]) / props.size) * rtl);
        }
      }
    });

    inst._scrollers.push(props.scroller);

    return props;
  }

  function refreshScroller(props, check) {
    var size,
        plus = 0,
        minus = 0,
        firstDay = props.first;

    if (props.changing && check) {
      return;
    }

    if (props.getFirst) {
      plus = props.buffer;
      minus = props.buffer; //while (minus && s.getDate(y, m + minus + monthNr - moveMonth - 1, 1) > maxDate) { ???

      while (minus && props.getFirst(firstDay, minus + props.pages - props.offset - 1) > props.max) {
        minus--;
      } //while (plus && s.getDate(y, m - plus - moveMonth, 1) < minDate) { ???


      while (plus && props.getFirst(firstDay, 1 - plus - props.offset) <= props.min) {
        plus--;
      }
    }

    size = Math.round(calSize / props.pages); // Page size might be a fractional value in case of multiple months
    // so we need to explicitly set the rounded value

    if (isLiquid && size && props.size != size) {
      props.$scroller[isVertical ? 'height' : 'width'](size);
    }

    extend$1(props.scroller.settings, {
      snap: size,
      minScroll: (-props.pos * rtl - minus) * size,
      maxScroll: (-props.pos * rtl + plus) * size
    });
    props.size = size;
    props.scroller.refresh();
  }

  function refresh(render) {
    inst._onRefresh(render);

    if (inst._isVisible && hasCal && calRows) {
      if (dayScroll && dayScroll.changing) {
        needsRefresh = render;
      } else {
        genAllMonths(currFirstDay, render, true);
        focusDate(activeDate);
      }
    }
  }

  function onTouchStart(ev) {
    wasTouched = ev.type === 'touchstart';
  }

  function attachEvents() {
    if (hasCal && calRows) {
      var $scrollers = $$1('.mbsc-cal-scroll-c', $markup); // Day selector

      dayScroll = createScroller($scrollers[0], minDate, maxDate, pageBuffer, pageOffset, pageNr, pageTotal, currFirstDay, selectDay, onBeforeMonthChange, onAfterMonthChange, genMonth, getPageDay);

      if (hasQuickNav) {
        // Month selector
        monthScroll = createScroller($scrollers[1], null, null, 1, 0, 1, 3, currFirstDay, selectMonth); // Year selector

        yearScroll = createScroller($scrollers[2], minFirstYear, maxFirstYear, 1, 0, 1, 3, currFirstDay, selectYear, noop, noop, genYears, getPageYear); // Show / hide month picker

        inst.tap($monthHdr, function () {
          toggleCont($monthPicker);
          hideCont($yearPicker);
        }); // Show / hide year picker

        inst.tap($yearHdr, function () {
          toggleCont($yearPicker);
          hideCont($monthPicker);
        });
      } // Init navigation arrows


      createStepper($$1('.mbsc-cal-btn', $markup), function (i, diff, ev, next) {
        changePageQueue(dayScroll, diff, true, next);
      }); // Triggers onMonthLoaded on initial render

      onAfterMonthChange(currFirstDay); // Focus on the selected date on show

      if ((s.defaultValue !== null || inst._hasValue) && !inst._multiple) {
        inst._activeElm = dayScroll.$active[0];
      }

      listen($calendar[0], 'touchstart', onTouchStart, {
        passive: true
      });
      listen($calendar[0], 'mousedown', onTouchStart);
      $calendar // Keyboard navigation
      .on('keydown', function (ev) {
        var year = s.getYear(activeDate),
            month = s.getMonth(activeDate),
            day = s.getDay(activeDate),
            newDate;

        switch (ev.keyCode) {
          case 32:
            //SPACE
            selectDay(dayScroll.$active, ev);
            break;

          case 37:
            //LEFT_ARROW:
            newDate = s.getDate(year, month, day - 1 * rtl);
            break;

          case 39:
            //RIGHT_ARROW:
            newDate = s.getDate(year, month, day + 1 * rtl);
            break;

          case 38:
            //UP_ARROW:
            newDate = s.getDate(year, month, day - 7);
            break;

          case 40:
            //DOWN_ARROW:
            newDate = s.getDate(year, month, day + 7);
            break;

          case 36:
            //HOME:
            newDate = s.getDate(year, month, 1);
            break;

          case 35:
            //END:
            newDate = s.getDate(year, month + 1, 0);
            break;

          case 33:
            //PAGE_UP:
            newDate = ev.altKey ? s.getDate(year - 1, month, day) : isMonthView ? s.getDate(year, month - 1, day) : s.getDate(year, month, day - calRows * 7);
            break;

          case 34:
            //PAGE_DOWN:
            newDate = ev.altKey ? s.getDate(year + 1, month, day) : isMonthView ? s.getDate(year, month + 1, day) : s.getDate(year, month, day + calRows * 7);
            break;
        }

        if (newDate) {
          ev.preventDefault();
          setDate(newDate, true, false, true);
        }
      });
    } // Tabs


    inst.tap($$1('.mbsc-cal-tab', $markup), function () {
      inst.changeTab($$1(this).attr('data-control'));
    });
  }

  preProcessSettings();
  base = DateTime.call(this, inst);
  postProcessSettings(); // Public functions
  // ---

  inst.refresh = function () {
    refresh(false);
  };

  inst.redraw = function () {
    refresh(true);
  };

  inst.navigate = function (d, anim) {
    setDate(makeDate(d, displayFormat, s), true, anim);
  };

  inst.changeTab = function (tab) {
    if (!inst._isVisible || !controls[tab] || visibleTab == tab) {
      return;
    }

    visibleTab = tab;
    $$1('.mbsc-cal-tab', $markup).removeClass(cssSelectedTab).removeAttr('aria-selected');
    $$1('.mbsc-cal-tab[data-control="' + tab + '"]', $markup).addClass(cssSelectedTab).attr('aria-selected', 'true');

    if (hasTabs) {
      $tabPanes.addClass('mbsc-cal-h');
      controls[visibleTab].removeClass('mbsc-cal-h');
    }

    if (visibleTab == 'calendar') {
      // Set the date of the calendar if date changed from the scroller
      setDate(inst.getDate(true), false, true);
    } // Hide


    inst._showDayPicker();

    inst.trigger('onTabChange', {
      tab: visibleTab
    });
  }; // ---
  // Protected functions
  // ---


  inst._checkSize = true;
  inst._onGenMonth = noop;
  inst._onSetDate = noop;
  inst._onRefresh = noop;
  inst._getDayProps = noop;
  inst._prepareObj = prepareObj;

  inst._showDayPicker = function () {
    if (hasQuickNav) {
      hideCont($yearPicker);
      hideCont($monthPicker);
    }
  };

  inst._selectDay = inst.__selectDay = function ($day, d, dtime) {
    var fill = inst.live; // Prevents month slide in setDate

    needsSlide = s.outerMonthChange;
    isDayClick = true; // Set date on scroller

    inst.setDate(dtime, fill, 1000, !fill, true);

    if (fill) {
      trigger('onSet', {
        valueText: inst._value
      });
    }
  };

  inst._checkBtn = checkBtn; // ---

  return extend$1(base, {
    labels: null,
    // Overrides labels coming from language files
    compClass: 'mbsc-calendar mbsc-dt mbsc-sc',
    eventOrder: compareEvents,
    onMarkupReady: function onMarkupReady(ev) {
      var j = 0;
      $markup = $$1(ev.target);
      $tabPaneCont = $$1('.mbsc-fr-c', $markup);
      activeDate = inst.getDate(true);
      calSize = 0;

      if (hasCal) {
        hasMarks = !!(s.marked || s.data) && !s.labels && !s.multiLabel && !s.showEventCount; // hasText = s.showEventCount || !!(s.events || s.labels);

        needsSlide = true;
        visibleTab = 'calendar';
        calcMonthNr();
        currFirstDay = getFirstDay(constrain(activeDate), isMonthView);
        $tabPaneCont.append(genCalMarkup());
        $monthHdr = $$1('.mbsc-cal-month', $markup);
        $yearHdr = $$1('.mbsc-cal-year', $markup);
        $calendar = $$1('.mbsc-cal-day-scroll-c', $markup);
      }

      if (hasQuickNav) {
        $yearPicker = $$1('.mbsc-cal-year-picker', $markup);
        $monthPicker = $$1('.mbsc-cal-month-picker', $markup);
      }

      $tabPanes = $$1('.mbsc-w-p', $markup); // Insert tab markup

      if (controlsArray.length > 1) {
        $tabPaneCont.before(genTabMarkup());
      } // Find markup for controls


      ['date', 'time', 'calendar'].forEach(function (v) {
        if (controls[v]) {
          controls[v] = $tabPanes.eq(j);
          j++;
        } else if (v == 'date' && !controls.date && hasCal) {
          $tabPanes.eq(j).remove();
          j++;
        }
      }); // Insert controls in correct order

      controlsArray.forEach(function (v) {
        $tabPaneCont.append(controls[v]);
      }); // TODO: this is an ugly solution

      if (!hasCal && controls.date) {
        controls.date.css('position', 'relative');
      }

      inst._scrollers = [];
      attachEvents();
    },
    onShow: function onShow() {
      if (hasCal && calRows) {
        setTitle(currFirstDay);
      }
    },
    onHide: function onHide() {
      clearTimeout(hoverTimer);

      inst._scrollers.forEach(function (v) {
        v.destroy();
      });

      dayProps = null;
      dayScroll = null;
      monthScroll = null;
      yearScroll = null;
      visibleTab = null;
    },
    onValidated: function onValidated(ev) {
      var ctrl,
          d,
          i = ev.index,
          order = inst._order;
      d = inst.getDate(true);
      selectedDate = d; // Find out on which control was the selection made

      if (isDayClick) {
        ctrl = 'calendar';
      } else if (i !== undefined) {
        ctrl = order.dd == i || order.d == i || order.m == i || order.y == i ? 'date' : 'time';
      }

      trigger('onSetDate', {
        date: d,
        control: ctrl
      }); // Set date on calendar

      if (ctrl !== 'time') {
        setDate(d, false, !!ev.time, isDayClick && !inst._multiple);
      }

      isDayClick = false;
    },
    onPosition: function onPosition(ev) {
      var i,
          y,
          m,
          doRefresh,
          modalHeight,
          newCalSize,
          availableHeight,
          oldHeight = ev.oldHeight,
          windowHeight = ev.windowHeight;
      hasTabs = (ev.hasTabs || s.tabs === true || s.tabs !== false && isLiquid) && controlsArray.length > 1;

      if (isLiquid) {
        if (ev.windowWidth >= s.breakPointMd) {
          $$1(ev.target).addClass('mbsc-fr-md');
        } else {
          $$1(ev.target).removeClass('mbsc-fr-md');
        }
      } // Show/hide tabs


      if (hasTabs) {
        $markup.addClass('mbsc-cal-tabbed');
        visibleTab = $$1('.mbsc-cal-tab.mbsc-selected', $markup).attr('data-control');
        $tabPanes.addClass('mbsc-cal-h');
        controls[visibleTab].removeClass('mbsc-cal-h');
      } else {
        // visibleTab = 'calendar';
        $markup.removeClass('mbsc-cal-tabbed');
        $tabPanes.removeClass('mbsc-cal-h');
      } // Full screen mode


      if (inst._isFullScreen) {
        // Reset height
        $calendar.height('');
        modalHeight = ev.popup.offsetHeight; // Get available height

        availableHeight = windowHeight - modalHeight + $calendar[0].offsetHeight; // Only set fixed height if calendar height is bigger than viewport height

        if (windowHeight >= modalHeight) {
          $calendar.height(availableHeight);
        }
      }

      if (hasLabels && calRows && windowHeight != oldHeight) {
        // Check how many labels can we display on a day
        var calHeight = availableHeight || $calendar[0].offsetHeight;
        var ph = $calendar.find('.mbsc-cal-txt,.mbsc-cal-txt-ph')[0];
        var numberHeight = ph.offsetTop;
        var txtHeight = ph.offsetHeight;
        var newMaxLabels = Math.max(1, Math.floor((calHeight / calRows - numberHeight) / (txtHeight + 2))); // Redraw the calendar, if max labels changed

        if (maxLabels != newMaxLabels) {
          maxLabels = newMaxLabels;
          inst.redraw();
        }
      } // Refresh scrollviews


      if (hasCal && calRows) {
        // Need to calculate size
        if (isLiquid || isVertical || hasTabs) {
          newCalSize = $calendar[0][isVertical ? 'offsetHeight' : 'offsetWidth'];
        } else {
          newCalSize = calWidth || pageNr * 280;
        }

        doRefresh = newCalSize != calSize;
        calSize = newCalSize; // Use long or short month names

        if (isLiquid && doRefresh) {
          if (yearChange) {
            monthNames = s.maxMonthWidth > $monthHdr[0].offsetWidth ? s.monthNamesShort : s.monthNames;
            y = s.getYear(currFirstDay);
            m = s.getMonth(currFirstDay);

            for (i = 0; i < pageNr; i++) {
              $monthHdr.eq(i).text(monthNames[s.getMonth(s.getDate(y, m - pageOffset + i, 1))]);
            }
          }
        }

        if (doRefresh) {
          refreshScroller(dayScroll, true);
        }
      }

      if (hasQuickNav && doRefresh) {
        refreshScroller(monthScroll, true);
        refreshScroller(yearScroll, true);
      }
    }
  });
};

var Calendar = Scroller;
var defaults$3 = {};

presets.calendar = function (inst) {
  function getDateOnly(d) {
    return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
  }

  function setValues(values) {
    var d,
        i,
        first = null;
    selectedValues = {};

    if (values && values.length) {
      for (i = 0; i < values.length; i++) {
        d = makeDate(values[i], displayFormat, s, s.isoParts);
        first = first || d;
        selectedValues[getDateOnly(d)] = d;
      }
    }

    return first;
  }

  function redraw() {
    inst.redraw();
  } // ---


  var base,
      ctx,
      displayFormat,
      firstSelectDay,
      origValues,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$3, orig),
      cssSelected = 'mbsc-selected ' + (s.selectedClass || ''),
      defaultValue = s.defaultValue,
      multi = s.select == 'multiple' || s.select > 1 || s.selectType == 'week',
      maxSelect = isNumeric(s.select) ? s.select : Infinity,
      selectedValues = {};
  base = CalendarBase.call(this, inst);
  firstSelectDay = s.firstSelectDay === undefined ? s.firstDay : s.firstSelectDay;
  displayFormat = inst._format;

  if (multi) {
    setValues(defaultValue);
  } // Extended methods
  // ---


  inst._multiple = multi;

  inst._getDayProps = function (d) {
    return {
      selected: multi ? selectedValues[d] !== undefined : undefined
    };
  };

  inst._selectDay = function ($day, d, dtime, selected) {
    var isSingleSelect = s.select == 'single' || s.select == 1 || s.select === undefined; // Single select with instant close

    if (s.setOnDayTap && isSingleSelect && s.display != 'inline') {
      inst.setDate(dtime);
      inst.select();
      return;
    }

    if (multi) {
      // Multiple day selection
      if (s.selectType == 'week') {
        // Select whole week
        var i,
            sel,
            diff = d.getDay() - firstSelectDay;
        diff = diff < 0 ? 7 + diff : diff;

        if (isSingleSelect) {
          // Only one week can be selected
          selectedValues = {};
        }

        for (i = 0; i < 7; i++) {
          sel = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate() - diff + i);

          if (selected) {
            delete selectedValues[sel];
          } else if (objectToArray(selectedValues).length / 7 < maxSelect) {
            selectedValues[sel] = sel;
          }
        }

        redraw();
      } else {
        // Select day only
        var days = $$1('.mbsc-cal-day[data-full="' + $day.attr('data-full') + '"]', ctx);

        if (selected) {
          days.removeClass(cssSelected).removeAttr('aria-selected');
          delete selectedValues[d];
        } else if (objectToArray(selectedValues).length < maxSelect) {
          days.addClass(cssSelected).attr('aria-selected', 'true');
          selectedValues[d] = d;
        }
      }
    } // Standard selection


    inst.__selectDay($day, d, dtime);
  };

  inst.setVal = function (val, fill, change, temp, time) {
    if (multi) {
      val = setValues(val);
    }

    inst._setVal(val, fill, change, temp, time);

    if (multi) {
      redraw();
    }
  };

  inst.getVal = function (temp) {
    var i,
        ret = [];

    if (multi) {
      for (i in selectedValues) {
        ret.push(returnDate(selectedValues[i], s, displayFormat));
      }

      return ret;
    }

    return returnDate(inst.getDate(temp), s, displayFormat);
  }; // ---


  return extend$1({}, base, {
    highlight: !multi,
    outerMonthChange: !multi,
    parseValue: function parseValue(v) {
      if (multi && v && typeof v === 'string') {
        v = setValues(v.split(','));
      }

      if (multi && defaultValue && defaultValue.length) {
        s.defaultValue = defaultValue[0];
      }

      return base.parseValue.call(this, v);
    },
    formatValue: function formatValue(d) {
      var i,
          ret = [];

      if (multi) {
        for (i in selectedValues) {
          ret.push(formatDate(displayFormat, selectedValues[i], s));
        }

        return ret.join(', ');
      }

      return base.formatValue.call(this, d, inst);
    },
    onClear: function onClear() {
      if (multi) {
        selectedValues = {};
        redraw();
      }
    },
    onBeforeShow: function onBeforeShow() {
      if (s.setOnDayTap === undefined && (!s.buttons || !s.buttons.length) && s.controls.length == 1) {
        s.setOnDayTap = true;
      }

      if (s.setOnDayTap && s.display != 'inline') {
        s.outerMonthChange = false;
      }

      if (s.counter && multi) {
        s.headerText = function () {
          var length = 0,
              w = s.selectType == 'week' ? 7 : 1;
          $$1.each(selectedValues, function () {
            length++;
          });
          length = Math.round(length / w);
          return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);
        };
      }
    },
    onMarkupReady: function onMarkupReady(ev) {
      base.onMarkupReady.call(this, ev);
      ctx = $$1(ev.target);

      if (multi) {
        $$1('.mbsc-fr-hdr', ctx).attr('aria-live', 'off');
        origValues = extend$1({}, selectedValues);
      }
    },
    onCancel: function onCancel() {
      if (!inst.live && multi) {
        selectedValues = extend$1({}, origValues);
      }
    }
  });
};

var MbscDatetimeBase = (function (_super) {
    __extends(MbscDatetimeBase, _super);
    function MbscDatetimeBase(initialElem, zone, control, inputService, view) {
        return _super.call(this, initialElem, zone, control, inputService, view) || this;
    }
    MbscDatetimeBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscDatetimeBase.propDecorators = {
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'returnFormat': [{ type: Input$1 },],
        'steps': [{ type: Input$1 },],
        'valid': [{ type: Input$1 },],
        'calendarSystem': [{ type: Input$1 },],
        'ampmText': [{ type: Input$1 },],
        'amText': [{ type: Input$1 },],
        'dateFormat': [{ type: Input$1 },],
        'dateWheels': [{ type: Input$1 },],
        'dayNames': [{ type: Input$1 },],
        'dayNamesShort': [{ type: Input$1 },],
        'dayText': [{ type: Input$1 },],
        'hourText': [{ type: Input$1 },],
        'minuteText': [{ type: Input$1 },],
        'monthNames': [{ type: Input$1 },],
        'monthNamesShort': [{ type: Input$1 },],
        'monthSuffix': [{ type: Input$1 },],
        'monthText': [{ type: Input$1 },],
        'nowText': [{ type: Input$1 },],
        'pmText': [{ type: Input$1 },],
        'secText': [{ type: Input$1 },],
        'timeFormat': [{ type: Input$1 },],
        'timeWheels': [{ type: Input$1 },],
        'yearSuffix': [{ type: Input$1 },],
        'yearText': [{ type: Input$1 },],
    };
MbscDatetimeBase.ɵfac = function MbscDatetimeBase_Factory(t) { return new (t || MbscDatetimeBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscDatetimeBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscDatetimeBase, selectors: [["mbsc-dt-b"]], inputs: { defaultValue: "defaultValue", invalid: "invalid", max: "max", min: "min", returnFormat: "returnFormat", steps: "steps", valid: "valid", calendarSystem: "calendarSystem", ampmText: "ampmText", amText: "amText", dateFormat: "dateFormat", dateWheels: "dateWheels", dayNames: "dayNames", dayNamesShort: "dayNamesShort", dayText: "dayText", hourText: "hourText", minuteText: "minuteText", monthNames: "monthNames", monthNamesShort: "monthNamesShort", monthSuffix: "monthSuffix", monthText: "monthText", nowText: "nowText", pmText: "pmText", secText: "secText", timeFormat: "timeFormat", timeWheels: "timeWheels", yearSuffix: "yearSuffix", yearText: "yearText" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDatetimeBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-dt-b' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: ɵngcc0.ViewContainerRef }]; }, { defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], returnFormat: [{
            type: Input$1
        }], steps: [{
            type: Input$1
        }], valid: [{
            type: Input$1
        }], calendarSystem: [{
            type: Input$1
        }], ampmText: [{
            type: Input$1
        }], amText: [{
            type: Input$1
        }], dateFormat: [{
            type: Input$1
        }], dateWheels: [{
            type: Input$1
        }], dayNames: [{
            type: Input$1
        }], dayNamesShort: [{
            type: Input$1
        }], dayText: [{
            type: Input$1
        }], hourText: [{
            type: Input$1
        }], minuteText: [{
            type: Input$1
        }], monthNames: [{
            type: Input$1
        }], monthNamesShort: [{
            type: Input$1
        }], monthSuffix: [{
            type: Input$1
        }], monthText: [{
            type: Input$1
        }], nowText: [{
            type: Input$1
        }], pmText: [{
            type: Input$1
        }], secText: [{
            type: Input$1
        }], timeFormat: [{
            type: Input$1
        }], timeWheels: [{
            type: Input$1
        }], yearSuffix: [{
            type: Input$1
        }], yearText: [{
            type: Input$1
        }] }); })();
    return MbscDatetimeBase;
}(MbscScrollerBase));
var MbscDatetimeBaseModule = (function () {
    function MbscDatetimeBaseModule() {
    }
    MbscDatetimeBaseModule.ctorParameters = function () { return []; };
MbscDatetimeBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscDatetimeBaseModule });
MbscDatetimeBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscDatetimeBaseModule_Factory(t) { return new (t || MbscDatetimeBaseModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscDatetimeBaseModule, { declarations: function () { return [MbscDatetimeBase]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDatetimeBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule],
                declarations: [MbscDatetimeBase]
            }]
    }], function () { return []; }, null); })();
    return MbscDatetimeBaseModule;
}());

var MbscCalBase = (function (_super) {
    __extends(MbscCalBase, _super);
    function MbscCalBase(initialElem, zone, control, inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.onTabChange = new EventEmitter();
        _this.onLabelTap = new EventEmitter();
        _this.onMonthChange = new EventEmitter();
        _this.onMonthLoading = new EventEmitter();
        _this.onMonthLoaded = new EventEmitter();
        _this.onPageChange = new EventEmitter();
        _this.onPageLoaded = new EventEmitter();
        _this.onPageLoading = new EventEmitter();
        return _this;
    }
    MbscCalBase.prototype.ngOnInit = function () {
        this.cloneDictionary.colors = [];
        this.cloneDictionary.labels = [];
        this.cloneDictionary.marked = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscCalBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: ViewContainerRef, },
    ]; };
    MbscCalBase.propDecorators = {
        'calendarHeight': [{ type: Input$1 },],
        'calendarWidth': [{ type: Input$1 },],
        'calendarScroll': [{ type: Input$1 },],
        'colors': [{ type: Input$1 },],
        'counter': [{ type: Input$1 },],
        'defaultValue': [{ type: Input$1 },],
        'events': [{ type: Input$1 },],
        'eventOrder': [{ type: Input$1 },],
        'labels': [{ type: Input$1 },],
        'marked': [{ type: Input$1 },],
        'months': [{ type: Input$1 },],
        'mousewheel': [{ type: Input$1 },],
        'outerMonthChange': [{ type: Input$1 },],
        'showOuterDays': [{ type: Input$1 },],
        'tabs': [{ type: Input$1 },],
        'weekCounter': [{ type: Input$1 },],
        'weekDays': [{ type: Input$1 },],
        'weeks': [{ type: Input$1 },],
        'yearChange': [{ type: Input$1 },],
        'dateText': [{ type: Input$1 },],
        'dayNamesMin': [{ type: Input$1 },],
        'firstDay': [{ type: Input$1 },],
        'timeText': [{ type: Input$1 },],
        'moreEventsPluralText': [{ type: Input$1 },],
        'moreEventsText': [{ type: Input$1 },],
        'onTabChange': [{ type: Output },],
        'onLabelTap': [{ type: Output },],
        'onMonthChange': [{ type: Output },],
        'onMonthLoading': [{ type: Output },],
        'onMonthLoaded': [{ type: Output },],
        'onPageChange': [{ type: Output },],
        'onPageLoaded': [{ type: Output },],
        'onPageLoading': [{ type: Output },],
    };
MbscCalBase.ɵfac = function MbscCalBase_Factory(t) { return new (t || MbscCalBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscCalBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscCalBase, selectors: [["mbsc-cal-b"]], inputs: { calendarHeight: "calendarHeight", calendarWidth: "calendarWidth", calendarScroll: "calendarScroll", colors: "colors", counter: "counter", defaultValue: "defaultValue", events: "events", eventOrder: "eventOrder", labels: "labels", marked: "marked", months: "months", mousewheel: "mousewheel", outerMonthChange: "outerMonthChange", showOuterDays: "showOuterDays", tabs: "tabs", weekCounter: "weekCounter", weekDays: "weekDays", weeks: "weeks", yearChange: "yearChange", dateText: "dateText", dayNamesMin: "dayNamesMin", firstDay: "firstDay", timeText: "timeText", moreEventsPluralText: "moreEventsPluralText", moreEventsText: "moreEventsText" }, outputs: { onTabChange: "onTabChange", onLabelTap: "onLabelTap", onMonthChange: "onMonthChange", onMonthLoading: "onMonthLoading", onMonthLoaded: "onMonthLoaded", onPageChange: "onPageChange", onPageLoaded: "onPageLoaded", onPageLoading: "onPageLoading" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCalBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-cal-b' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: ɵngcc0.ViewContainerRef }]; }, { calendarHeight: [{
            type: Input$1
        }], calendarWidth: [{
            type: Input$1
        }], calendarScroll: [{
            type: Input$1
        }], colors: [{
            type: Input$1
        }], counter: [{
            type: Input$1
        }], defaultValue: [{
            type: Input$1
        }], events: [{
            type: Input$1
        }], eventOrder: [{
            type: Input$1
        }], labels: [{
            type: Input$1
        }], marked: [{
            type: Input$1
        }], months: [{
            type: Input$1
        }], mousewheel: [{
            type: Input$1
        }], outerMonthChange: [{
            type: Input$1
        }], showOuterDays: [{
            type: Input$1
        }], tabs: [{
            type: Input$1
        }], weekCounter: [{
            type: Input$1
        }], weekDays: [{
            type: Input$1
        }], weeks: [{
            type: Input$1
        }], yearChange: [{
            type: Input$1
        }], dateText: [{
            type: Input$1
        }], dayNamesMin: [{
            type: Input$1
        }], firstDay: [{
            type: Input$1
        }], timeText: [{
            type: Input$1
        }], moreEventsPluralText: [{
            type: Input$1
        }], moreEventsText: [{
            type: Input$1
        }], onTabChange: [{
            type: Output
        }], onLabelTap: [{
            type: Output
        }], onMonthChange: [{
            type: Output
        }], onMonthLoading: [{
            type: Output
        }], onMonthLoaded: [{
            type: Output
        }], onPageChange: [{
            type: Output
        }], onPageLoaded: [{
            type: Output
        }], onPageLoading: [{
            type: Output
        }] }); })();
    return MbscCalBase;
}(MbscDatetimeBase));
var MbscCalBaseModule = (function () {
    function MbscCalBaseModule() {
    }
    MbscCalBaseModule.ctorParameters = function () { return []; };
MbscCalBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscCalBaseModule });
MbscCalBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscCalBaseModule_Factory(t) { return new (t || MbscCalBaseModule)(); }, imports: [[CommonModule, MbscDatetimeBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCalBaseModule, { declarations: function () { return [MbscCalBase]; }, imports: function () { return [CommonModule, MbscDatetimeBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCalBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscDatetimeBaseModule],
                declarations: [MbscCalBase]
            }]
    }], function () { return []; }, null); })();
    return MbscCalBaseModule;
}());

var MbscCalendar = (function (_super) {
    __extends(MbscCalendar, _super);
    function MbscCalendar(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onSetDate = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.options = {};
        _this.isMulti = undefined;
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscCalendar.prototype, "value", {
        set: function (v) {
            if (!this.control) {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscCalendar.prototype.setNewValue = function (v) {
        if (this.instance) {
            var changed = void 0;
            if (this.isMulti) {
                changed = !deepEqualsArray(v, this.instance.getVal());
            }
            else {
                var innerValue = this.instance.getVal();
                changed = ((!innerValue && v) ||
                    (innerValue && !v) ||
                    (innerValue && v && innerValue.toString() !== v.toString()));
            }
            if (changed) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscCalendar.prototype.initControl = function () {
        var options = extend$1({ preset: 'calendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Calendar(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscCalendar.prototype.ngOnInit = function () {
        this.isMulti = this.options && ((this.options.select && this.options.select !== 'single') || (this.options.selectType == 'week'));
        this.cloneDictionary.marked = [];
        this.cloneDictionary.invalid = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscCalendar.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscCalendar.propDecorators = {
        'controls': [{ type: Input$1 },],
        'firstSelectDay': [{ type: Input$1 },],
        'selectType': [{ type: Input$1 },],
        'select': [{ type: Input$1 },],
        'setOnDayTap': [{ type: Input$1 },],
        'onSetDate': [{ type: Output },],
        'onCellHoverIn': [{ type: Output },],
        'onCellHoverOut': [{ type: Output },],
        'onDayChange': [{ type: Output },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-calendar',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-calendarChange',] },],
    };
MbscCalendar.ɵfac = function MbscCalendar_Factory(t) { return new (t || MbscCalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscCalendar.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscCalendar, selectors: [["", "mbsc-calendar", ""]], inputs: { value: ["mbsc-calendar", "value"], controls: "controls", firstSelectDay: "firstSelectDay", selectType: "selectType", select: "select", setOnDayTap: "setOnDayTap", options: ["mbsc-options", "options"] }, outputs: { onSetDate: "onSetDate", onCellHoverIn: "onCellHoverIn", onCellHoverOut: "onCellHoverOut", onDayChange: "onDayChange", onChangeEmitter: "mbsc-calendarChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCalendar, [{
        type: Directive,
        args: [{
                selector: '[mbsc-calendar]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-calendar']
        }], controls: [{
            type: Input$1
        }], firstSelectDay: [{
            type: Input$1
        }], selectType: [{
            type: Input$1
        }], select: [{
            type: Input$1
        }], setOnDayTap: [{
            type: Input$1
        }], onSetDate: [{
            type: Output
        }], onCellHoverIn: [{
            type: Output
        }], onCellHoverOut: [{
            type: Output
        }], onDayChange: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-calendarChange']
        }] }); })();
    return MbscCalendar;
}(MbscCalBase));
var MbscCalendarComponent = (function (_super) {
    __extends(MbscCalendarComponent, _super);
    function MbscCalendarComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.placeholder = '';
        _this.errorMessage = '';
        return _this;
    }
    MbscCalendarComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscCalendarComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscCalendarComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
    };
MbscCalendarComponent.ɵfac = function MbscCalendarComponent_Factory(t) { return new (t || MbscCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCalendarComponent, selectors: [["mbsc-calendar"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", placeholder: "placeholder", error: "error", errorMessage: "errorMessage", options: "options" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscCalendarComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCalendarComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-calendar',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }] }); })();
    return MbscCalendarComponent;
}(MbscCalendar));
var MbscCalendarModule = (function () {
    function MbscCalendarModule() {
    }
    MbscCalendarModule.ctorParameters = function () { return []; };
MbscCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscCalendarModule });
MbscCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscCalendarModule_Factory(t) { return new (t || MbscCalendarModule)(); }, imports: [[CommonModule, MbscCalBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCalendarModule, { declarations: function () { return [MbscCalendar, MbscCalendarComponent]; }, imports: function () { return [CommonModule, MbscCalBaseModule, MbscInputModule]; }, exports: function () { return [MbscCalendar, MbscCalendarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCalendarModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscCalBaseModule, MbscInputModule],
                declarations: [MbscCalendar, MbscCalendarComponent],
                exports: [MbscCalendar, MbscCalendarComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscCalendarModule;
}());

var Button =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Button, _FormControl);

  function Button(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var hasIcon = $elm.attr('data-icon');
    $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

    if (hasIcon) {
      $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');

      if ($elm.text() === "") {
        $elm.addClass('mbsc-btn-icon-only');
      }
    }

    _this._$rippleElm = $elm;
    return _this;
  }

  var _proto = Button.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm;
  };

  return Button;
}(FormControl); // Init mbsc-button elements on page load

autoInit('[mbsc-button]', Button);

var CheckBox =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(CheckBox, _FormControl);

  function CheckBox(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

    _this._$elm.after('<span class="mbsc-checkbox-box"></span>');

    return _this;
  }

  return CheckBox;
}(FormControl); // Init mbsc-checkbox elements on page load

autoInit('[mbsc-checkbox]', CheckBox);

var Radio =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Radio, _FormControl);

  function Radio(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

    _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');

    return _this;
  }

  return Radio;
}(FormControl); // Init mbsc-radio elements on page load

autoInit('[mbsc-radio]', Radio);

var Select =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(Select, _Input);

  function Select(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $existing = $parent.find('.mbsc-select-input');
    var $input = $existing.length ? $existing : $$1('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');
    _this._$input = $input;
    _this._delm = $input[0];
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));
    $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));
    $elm.after($input);
    $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>'); // Update dummy input text on change

    $elm.on('change', _this._setText);

    _this._setText();

    return _this;
  }

  var _proto = Select.prototype;

  _proto.destroy = function destroy() {
    _Input.prototype.destroy.call(this);

    this._$parent.find('.mbsc-select-ic').remove();

    this._$elm.off('change', this._setText);
  };

  _proto._setText = function _setText() {
    var elm = this._elm;
    var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized

    if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
      this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
    } // Check floating label


    this.refresh();
  };

  return Select;
}(Input); // Init mbsc-select elements on page load

autoInit('[mbsc-dropdown]', Select);

var events$2 = ['change', 'keydown', 'input', 'scroll'];
var sizeDebounce;

function sizeTextAreas() {
  clearTimeout(sizeDebounce);
  sizeDebounce = setTimeout(function () {
    $$1('textarea.mbsc-control').each(function () {
      sizeTextArea(this);
    });
  }, 100);
}

function sizeTextArea(control) {
  var height,
      lineNr,
      line,
      rowNr = $$1(control).attr('rows') || 6;

  if (control.offsetHeight) {
    control.style.height = '';
    line = control.scrollHeight - control.offsetHeight;
    height = control.offsetHeight + (line > 0 ? line : 0);
    lineNr = Math.round(height / 24);

    if (lineNr > rowNr) {
      //control.scrollTop = height;
      height = 24 * rowNr + (height - lineNr * 24);
      $$1(control).addClass('mbsc-textarea-scroll');
    } else {
      $$1(control).removeClass('mbsc-textarea-scroll');
    }

    if (height) {
      control.style.height = height + 'px';
    }
  }
}

function scrollTextArea(elm) {
  var $elm = $$1(elm);

  if (!$elm.hasClass('mbsc-textarea-scroll')) {
    var line = elm.scrollHeight - elm.offsetHeight,
        height = elm.offsetHeight + line,
        lineNr = Math.round(height / 24),
        rowNr = $elm.attr('rows') || 6;

    if (lineNr <= rowNr) {
      elm.scrollTop = 0;
      elm.style.height = height + 'px';
    }
  }
}

if (isBrowser) {
  // Set height of textareas on viewport size changes
  $$1(window).on('resize orientationchange', sizeTextAreas);
}

var TextArea =
/*#__PURE__*/
function (_Input) {
  _inheritsLoose(TextArea, _Input);

  function TextArea(elm, settings) {
    var _this;

    _this = _Input.call(this, elm, settings) || this;

    _this._$parent.addClass('mbsc-textarea');

    events$2.forEach(function (ev) {
      _this._$elm.on(ev, _this._handle);
    });
    sizeTextArea(elm);
    return _this;
  }

  var _proto = TextArea.prototype;

  _proto.destroy = function destroy() {
    var _this2 = this;

    _Input.prototype.destroy.call(this);

    events$2.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._handle);
    });
  };

  _proto.refresh = function refresh() {
    _Input.prototype.refresh.call(this);

    clearTimeout(this._debounce);
    sizeTextArea(this._elm);
  };

  _proto._handle = function _handle(ev) {
    _Input.prototype._handle.call(this, ev);

    switch (ev.type) {
      case 'change':
        sizeTextArea(this._elm);
        break;

      case 'keydown':
      case 'input':
        this._onInput(ev);

        break;

      case 'scroll':
        scrollTextArea(this._elm);
    }
  };

  _proto._onInput = function _onInput() {
    var _this3 = this;

    clearTimeout(this._debounce);
    this._debounce = setTimeout(function () {
      sizeTextArea(_this3._elm);
    }, 100);
  };

  return TextArea;
}(Input);

autoInit('[mbsc-textarea]', TextArea);

var SegmentedItem =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(SegmentedItem, _FormControl);

  function SegmentedItem(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $segmentCont;
    var $segment;
    var $elm = _this._$elm;
    var $parent = _this._$parent;

    if (!$parent.hasClass('mbsc-segmented-item-ready')) {
      $segmentCont = $$1('<div class="mbsc-segmented mbsc-segmented-group mbsc-no-touch"></div>');
      $parent.after($segmentCont);
      $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
        var $input = $$1(this);
        $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');
        $$1('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);
        $segment.prepend($input);
        $segmentCont.append($segment);
      });
    }

    _this._$rippleElm = $elm.next();
    return _this;
  }

  var _proto = SegmentedItem.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$elm.closest('.mbsc-segmented');
  };

  return SegmentedItem;
}(FormControl); // Init mbsc-segmented elements on page load

autoInit('[mbsc-segmented]', SegmentedItem);

var Stepper = function Stepper(control, settings) {
  var $btnPlus,
      $btnMinus,
      $controls,
      cssClass = '',
      displayValue,
      max,
      min,
      inputStyle,
      ripple,
      scale,
      step,
      stepper,
      s,
      theme,
      val,
      that = this,
      $control = $$1(control),
      ready,
      $parent,
      old = val;

  function onChange() {
    var v;

    if (!control.disabled) {
      v = parseFloat($$1(this).val());
      setValue(isNaN(v) ? val : v);
    }
  }

  function checkDisabled() {
    return control.disabled;
  }

  function stepValue(index, dir) {
    setValue(val + dir * step);
  }

  function setValue(v, fill, change) {
    old = val;

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    val = round(v);
    $controls.removeClass('mbsc-disabled');

    if (fill) {
      $control.val(val);
    }

    if (val == min) {
      $btnMinus.addClass('mbsc-disabled');
    }

    if (val == max) {
      $btnPlus.addClass('mbsc-disabled');
    }

    if (val !== old && change) {
      $control.trigger('change');
    }
  }

  function getAttr(attr, def, str) {
    var v = $control.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function round(v) {
    return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
  } // Call the parent constructor


  Base.call(this, control, settings, true);
  /* TRIALFUNC */

  that.getVal = function () {
    var v = parseFloat($control.val());
    v = isNaN(v) ? val : v;
    return round(v);
  };

  that.setVal = function (v, fill, change) {
    v = parseFloat(v);
    setValue(isNaN(v) ? val : v, fill, change);
  };

  that._init = function () {
    ready = $control.parent().hasClass('mbsc-stepper');
    $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();
    s = that.settings;
    min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
    scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    displayValue = $control.attr('data-val') || s.val;
    val = round(+control.value || 0);
    theme = mobiscroll.themes.form[s.theme];
    ripple = theme && theme.addRipple ? theme : null;

    if (!ready) {
      $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
    }

    if (cssClass) {
      $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);
    }

    cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);
    $btnMinus = $$1('.mbsc-stepper-minus', $parent);
    $btnPlus = $$1('.mbsc-stepper-plus', $parent);
    $controls = $$1('.mbsc-stepper-control', $parent);

    if (!ready) {
      if (displayValue == 'left') {
        $parent.addClass('mbsc-stepper-val-left');
        $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else if (displayValue == 'right') {
        $parent.addClass('mbsc-stepper-val-right');
        $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
      } else {
        $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
      }
    }

    if (!stepper) {
      $control.on('change', onChange);
      stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
    }

    $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');
    control.mbscInst = that;
  };

  that._destroy = function () {
    $control.removeClass('mbsc-control').off('change', onChange);
    stepper.destroy();
    delete control.mbscInst;
  };

  that.init();
};
Stepper.prototype = {
  _class: 'stepper',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _defaults: {
    min: 0,
    max: 100,
    step: 1
  }
};
classes.Stepper = Stepper; // Init mbsc-stepper elements on page load

autoInit('[mbsc-stepper]', Stepper);

var ProgressBase = function ProgressBase(elm, settings, inherit) {
  var $elm,
      $parent,
      cssClass,
      s,
      that = this; // Call the parent constructor

  Base.call(this, elm, settings, true);
  that.__init = noop;
  that.__destroy = noop;

  that._init = function () {
    var wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = $elm.parent();
    $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;
    that._$parent = $parent;

    if (cssClass) {
      $parent.removeClass(cssClass);
    }

    cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);
    $parent.addClass(cssClass);
    $elm.addClass('mbsc-control');

    that.__init();

    if (!wasInit) {
      that._attachChange();
    } // Show initial value


    that.refresh();
    elm.mbscInst = that;
  };

  that._destroy = function () {
    that.__destroy();

    $parent.removeClass(cssClass);
    $elm.removeClass('mbsc-control');
    delete elm.mbscInst;
  };

  if (!inherit) {
    that.init();
  }
};

var SliderBase = function SliderBase(elm, settings, inherit) {
  var $elm,
      $handle,
      $handleCont,
      $handles,
      $listeners,
      $parent,
      $track,
      action,
      base,
      changed,
      diffX,
      diffY,
      diff,
      endX,
      endY,
      handleIndex,
      isHover,
      isPressed,
      isRtl,
      live,
      max,
      min,
      moved,
      multiple,
      oldValue,
      step,
      s,
      scale,
      startX,
      startY,
      stepDecimal,
      timer,
      totalWidth,
      value,
      that = this,
      lastUpdate = new Date();

  function onStart(ev) {
    if (ev.type === 'mousedown') {
      ev.preventDefault();
    }

    if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly
    /* TRIALCOND */
    ) {
        if (s.stopProp) {
          ev.stopPropagation();
        }

        action = true;
        moved = false;
        changed = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        endX = startX;
        $track.removeClass('mbsc-progress-anim');
        $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;

        if ($handleCont) {
          $handleCont.removeClass('mbsc-handle-curr');
        }

        $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
        $elm.addClass('mbsc-active');
        handleIndex = +$handle.attr('data-index');
        totalWidth = $track[0].offsetWidth;
        diff = $track[0].getBoundingClientRect().left;

        if (ev.type === 'mousedown') {
          isPressed = true;
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }

        if (ev.type === 'mouseenter') {
          isHover = true;
          $$1(document).on('mousemove', onMove);
        }
      }
  }

  function onMove(ev) {
    if (action) {
      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;

      if (Math.abs(diffX) > 5) {
        moved = true;
      }

      if (moved || isPressed || isHover) {
        if (Math.abs(lastUpdate - new Date()) > 50) {
          lastUpdate = new Date();
          updateSlider(endX, s.round, live && (!isHover || isPressed));
        }
      }

      if (moved) {
        ev.preventDefault();
      } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
        cleanUp();
      }
    }
  }

  function onEnd(ev) {
    if (action) {
      ev.preventDefault();

      if (!multiple) {
        $track.addClass('mbsc-progress-anim');
      }

      if (isHover && !isPressed) {
        updateValue(value[handleIndex], handleIndex, false, false, true);
      } else {
        updateSlider(endX, true, true);
      }

      if (!moved && !changed) {
        if (ev.type == 'touchend') {
          // Prevent ghost click
          preventClick();
        }

        that._onTap(value[handleIndex]);
      }

      if (ev.type == 'mouseup') {
        isPressed = false;
      }

      if (ev.type == 'mouseleave') {
        isHover = false;
      }

      if (!isHover) {
        cleanUp();
      }
    }
  }

  function onCancel() {
    if (action) {
      cleanUp();
    }
  }

  function onChange() {
    var v = that._readValue($$1(this)),
        i = +$$1(this).attr('data-index');

    if (v !== value[i]) {
      value[i] = v;
      oldValue[i] = v;
      updateValue(v, i);
    }
  }

  function onClick(ev) {
    // Prevent propagating click to label
    ev.stopPropagation();
  }

  function onLabelClick(ev) {
    // Prevent change on label click for swithes
    ev.preventDefault();
  }

  function onKeyDown(ev) {
    var dir;

    if (!elm.disabled) {
      switch (ev.keyCode) {
        case 38:
        case 39:
          dir = 1;
          break;

        case 40:
        case 37:
          dir = -1;
          break;
      }

      if (dir) {
        ev.preventDefault();

        if (!timer) {
          handleIndex = +$$1(this).attr('data-index');
          updateValue(value[handleIndex] + step * dir, handleIndex, true);
          timer = setInterval(function () {
            updateValue(value[handleIndex] + step * dir, handleIndex, true);
          }, 200);
        }
      }
    }
  }

  function onKeyUp(ev) {
    ev.preventDefault();
    clearInterval(timer);
    timer = null;
  }

  function cleanUp() {
    action = false;
    $handleCont.removeClass('mbsc-active');
    $elm.removeClass('mbsc-active'); // Detach document events

    $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
  }

  function updateSlider(pos, round, fill) {
    var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

    if (isRtl) {
      percent = 100 - percent;
    }

    updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
  }

  function updateValue(v, index, fill, percent, refresh, change) {
    var $handle = $handles.eq(index),
        $handleCont = $handle.parent();
    v = Math.min(max, Math.max(v, min));

    if (change === undefined) {
      change = fill;
    }

    if (that._update) {
      v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
    } else {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    }

    if (v > min) {
      $handleCont.removeClass('mbsc-slider-start');
    } else if (value[index] > min || refresh) {
      $handleCont.addClass('mbsc-slider-start');
    } // Store new value


    if (fill) {
      value[index] = v;
    } // Check if value changed


    if (fill && oldValue[index] != v) {
      changed = true;
      oldValue[index] = v; // Set new value to the input

      that._fillValue(v, index, change);
    }

    $handle.attr('aria-valuenow', v);
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);
  that._onTap = noop;
  that.___init = noop;
  that.___destroy = noop;

  that._attachChange = function () {
    $elm.on(s.changeEvent, onChange);
  };

  that.__init = function () {
    var wasInit;

    if ($handles) {
      wasInit = true;
      $handles.parent().remove();
    }

    that.___init();

    $parent = that._$parent;
    $track = that._$track;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    base = that._base || 0;
    step = that._step;
    live = that._live;
    stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
    scale = 100 / (max - min + base) || 100;
    multiple = $elm.length > 1;
    isRtl = s.rtl;
    value = [];
    oldValue = []; // Read values

    $elm.each(function (i) {
      value[i] = that._readValue($$1(this));
      $$1(this).attr('data-index', i);
    });
    $handles = $parent.find('.mbsc-slider-handle');
    $listeners = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont'); // Attach events

    $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      listen(listener, 'touchstart', onStart, {
        passive: true
      });
      listen(listener, 'mousedown', onStart);
      listen(listener, 'touchend', onEnd);
      listen(listener, 'touchcancel', onEnd);
      listen(listener, 'pointercancel', onCancel);

      if (s.hover) {
        listen(listener, 'mouseenter', onStart);
        listen(listener, 'mouseleave', onEnd);
      }
    });

    if (!wasInit) {
      $elm.on('click', onClick);
      $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings

      listen(document, 'touchmove', onMove, {
        passive: false
      });
    }
  };

  that.__destroy = function () {
    $parent.off('click', onLabelClick);
    $elm.off(s.changeEvent, onChange).off('click', onClick);
    $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);
    $listeners.each(function (i, listener) {
      unlisten(listener, 'touchstart', onStart, {
        passive: true
      });
      unlisten(listener, 'mousedown', onStart);
      unlisten(listener, 'touchend', onEnd);
      unlisten(listener, 'touchcancel', onEnd);
      unlisten(listener, 'pointercancel', onCancel);
      unlisten(listener, 'mouseenter', onStart);
      unlisten(listener, 'mouseleave', onEnd);
      unlisten(document, 'touchmove', onMove, {
        passive: false
      });
    });

    that.___destroy();
  };

  that.refresh = function () {
    $elm.each(function (i) {
      updateValue(that._readValue($$1(this)), i, true, false, true, false);
    });
  };

  that.getVal = function () {
    return multiple ? value.slice(0) : value[0];
  };

  that.setVal = that._setVal = function (val, fill, change) {
    if (!$$1.isArray(val)) {
      val = [val];
    }

    $$1.each(val, function (i, v) {
      value[i] = v;
    });
    $$1.each(val, function (i, v) {
      updateValue(v, i, true, false, true, change);
    });
  };

  if (!inherit) {
    that.init();
  }
};

var Switch = function Switch(elm, settings) {
  var $elm,
      $parent,
      s,
      formControl,
      that = this;
  settings = settings || {};
  extend$1(settings, {
    changeEvent: 'click',
    round: false
  }); // Call the parent constructor

  SliderBase.call(this, elm, settings, true);

  that._readValue = function () {
    return elm.checked ? 1 : 0;
  };

  that._fillValue = function (v, index, change) {
    $elm.prop('checked', !!v);

    if (change) {
      $elm.trigger('change');
    }
  };

  that._onTap = function (v) {
    that._setVal(v ? 0 : 1);
  };

  that.___init = function () {
    s = that.settings;
    $elm = $$1(elm);
    $parent = $elm.parent();
    $parent.find('.mbsc-switch-track').remove();
    $parent.prepend($elm);
    $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

    if (formControl) {
      formControl.destroy();
    }

    formControl = new FormControl(elm, s);
    that._$track = $parent.find('.mbsc-progress-track');
    that._min = 0;
    that._max = 1;
    that._step = 1;
  };

  that.___destroy = function () {
    formControl.destroy();
  };

  that.getVal = function () {
    return elm.checked;
  };

  that.setVal = function (val, fill, change) {
    that._setVal(val ? 1 : 0, fill, change);
  };

  that.init();
};
Switch.prototype = {
  _class: 'switch',
  _css: 'mbsc-switch',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    stopProp: true,
    offText: 'Off',
    onText: 'On'
  }
};
classes.Switch = Switch; // Init mbsc-switch elements on page load

autoInit('[mbsc-switch]', Switch);

// eslint-disable-next-line no-unused-vars
var Progress = function Progress(elm, settings, inherit) {
  var $display,
      $elm,
      $parent,
      $progress,
      $target,
      $track,
      min,
      max,
      inputStyle,
      labelStyle,
      s,
      template,
      value,
      valueText,
      that = this;

  function onChange() {
    var v = getAttr('value', min);

    if (v !== value) {
      updateValue(v);
    }
  }

  function getAttr(attr, def, str) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : str ? v : +v;
  }

  function updateValue(v, refresh, fill, change) {
    v =
    /* TRIALCONDREV */
    Math.min(max, Math.max(v, min));
    $progress.css('width', (v - min) * 100 / (max - min) + '%');

    if (fill === undefined) {
      fill = true;
    }

    if (change === undefined) {
      change = fill;
    }

    if (v !== value || refresh) {
      // Display value
      that._display(v);
    }

    if (v !== value) {
      // Set new value
      value = v; // Put new value in the progress element

      if (fill) {
        $elm.attr('value', value);
      } // Trigger change on the element


      if (change) {
        $elm.trigger('change');
      }
    }
  } // Call the parent constructor


  ProgressBase.call(this, elm, settings, true);

  that._display = function (v) {
    valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

    if ($target) {
      $target.html(valueText);
    }

    if ($display) {
      $display.html(valueText);
    }
  };

  that._attachChange = function () {
    $elm.on('change', onChange);
  };

  that.__init = function () {
    var displayValue, i, stepLabels, wasInit;
    s = that.settings;
    $elm = $$1(elm); // Check if the element was already initialized

    wasInit = !!$parent;
    $parent = that._$parent; // Read settings from data attributes or settings object

    min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
    max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
    labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
    value = getAttr('value', min);
    displayValue = $elm.attr('data-val') || s.val;
    stepLabels = $elm.attr('data-step-labels');
    stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
    template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

    if (!wasInit) {
      wrapLabel($parent, null, inputStyle, labelStyle, elm);
      addIcon($elm); // Generate track and progress

      $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');
      $progress = that._$progress = $parent.find('.mbsc-progress-bar');
      $track = that._$track = $parent.find('.mbsc-progress-track');
    } else {
      if (displayValue) {
        $display.remove();
        $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
      }

      if (stepLabels) {
        $$1('.mbsc-progress-step-label', $track).remove();
      }
    } // Set attributes


    $elm.attr('min', min).attr('max', max); // Generate value container on left or right side

    if (displayValue) {
      $display = $$1('<span class="mbsc-progress-value"></span>');
      $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
    } // Generate step labels


    if (stepLabels) {
      for (i = 0; i < stepLabels.length; ++i) {
        $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
      }
    }

    $target = $$1($elm.attr('data-target') || s.target);
  };

  that.__destroy = function () {
    $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();
    $parent.find('.mbsc-input-ic').remove();
    $elm.off('change', onChange);
  };

  that.refresh = function () {
    updateValue(getAttr('value', min), true, false);
  };

  that.getVal = function () {
    return value;
  };

  that.setVal = function (v, fill, change) {
    updateValue(v, true, fill, change);
  };

  if (!inherit) {
    that.init();
  }
};
Progress.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    min: 0,
    max: 100,
    returnAffix: true
  }
};
classes.Progress = Progress; // Init mbsc-progress elements on page load

autoInit('[mbsc-progress]', Progress);

var Slider = function Slider(elm, settings, inherit) {
  var $elm,
      $parent,
      $progress,
      $tooltips,
      $track,
      hasProgress,
      hasTooltip,
      isRange,
      isRtl,
      max,
      min,
      step,
      s,
      that = this; // Call the parent constructor

  Progress.call(this, elm, settings, true);
  var progressInit = that.__init,
      progressDestroy = that.__destroy;
  SliderBase.call(this, elm, settings, true);
  var sliderInit = that.__init,
      sliderDestroy = that.__destroy; // ---

  that.__init = function () {
    progressInit();
    sliderInit();
  };

  that.__destroy = function () {
    progressDestroy();
    sliderDestroy();
  };

  that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
    if (isRange) {
      if (index === 0) {
        v = Math.min(v, value[1]);
        $progress.css({
          width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
          left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
          right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
        });
      } else {
        v = Math.max(v, value[0]);
        $progress.css({
          width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
        });
      }
    } else if (multiple || !hasProgress) {
      $handleCont.css({
        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
      });
    } else {
      $progress.css('width', (percent || getPercent(v, min, max)) + '%');
    }

    if (hasTooltip) {
      $tooltips.eq(index).html(v);
    } // Display value in the specified container(s)


    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._readValue = function ($elm) {
    return +$elm.val();
  };

  that._fillValue = function (v, index, change) {
    $elm.eq(index).val(v);

    if (change) {
      $elm.eq(index).trigger('change');
    }
  };

  that._markupReady = function () {
    var i, stepNr;

    if (hasTooltip) {
      $parent.addClass('mbsc-slider-has-tooltip');
    } // Generate step marks


    if (step != 1) {
      stepNr = (max - min) / step;

      for (i = 0; i <= stepNr; ++i) {
        $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
      }
    } // Generate slider handles


    $elm.each(function (i, elm) {
      var value = +elm.value;

      if (elm.type == 'range') {
        // Set min / max / step properties for all inputs
        $$1(elm).attr('min', min).attr('max', max).attr('step', step);
      }

      (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + (isRange && !i && value > (max - min) / 2 ? ' mbsc-handle-curr' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
    });
    $tooltips = $parent.find('.mbsc-slider-tooltip');
  };

  that.___init = function () {
    if ($parent) {
      $parent.removeClass('mbsc-slider-has-tooltip');

      if (step != 1) {
        $$1('.mbsc-slider-step', $track).remove();
      }
    }

    $parent = that._$parent;
    $track = that._$track;
    $progress = that._$progress;
    $elm = $parent.find('input');
    s = that.settings;
    min = that._min;
    max = that._max;
    that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
    that._live = getBoolAttr('data-live', s.live, $elm);
    hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
    hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
    isRange = hasProgress && $elm.length == 2;
    isRtl = s.rtl;

    that._markupReady();
  };

  if (!inherit) {
    that.init();
  }
};
Slider.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-slider',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 0,
    max: 100,
    step: 1,
    live: true,
    highlight: true,
    round: true,
    returnAffix: true
  }
};
classes.Slider = Slider; // Init mbsc-slider elements on page load

autoInit('[mbsc-slider]', Slider);

var Rating = function Rating(elm, settings, inherit) {
  var $progress,
      $track,
      max,
      min,
      empty,
      filled,
      s,
      that = this,
      $elm = $$1(elm); // Call the parent constructor

  Slider.call(this, elm, settings, true);

  that._update = function (v, value, index, percent, multiple, refresh) {
    $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)

    if (!multiple && (value[index] != v || refresh)) {
      that._display(v);
    } // Return validated value


    return v;
  };

  that._markupReady = function () {
    var i,
        emptyString = '',
        filledString = '';
    $track = that._$track;
    $progress = that._$progress;
    s = that.settings;
    min = that._min;
    max = that._max;
    that._base = min;
    that._rounding = s.rtl ? 'floor' : 'ceil';
    empty = $elm.attr('data-empty') || s.empty;
    filled = $elm.attr('data-filled') || s.filled;

    for (i = 0; i < max; ++i) {
      emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
      filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
    }

    $track.html(emptyString);
    $track.append($progress);
    $progress.html(filledString);
    $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
  };

  if (!inherit) {
    that.init();
  }
};
Rating.prototype = {
  _class: 'progress',
  _css: 'mbsc-progress mbsc-rating',
  _hasTheme: true,
  _hasLang: true,
  _hasDef: true,
  _defaults: {
    changeEvent: 'change',
    stopProp: true,
    min: 1,
    max: 5,
    step: 1,
    live: true,
    round: true,
    hover: true,
    highlight: true,
    returnAffix: true,
    empty: 'star',
    filled: 'star3'
  }
};
classes.Rating = Rating; // Init mbsc-rating elements on page load

autoInit('[mbsc-rating]', Rating);

var nr = 1;
var CollapsibleBase =
/*#__PURE__*/
function () {
  function CollapsibleBase(elm, settings) {
    var _this = this;

    var content;
    var $header;
    var $content;
    var $elm = $$1(elm);
    this.settings = settings;
    this._isOpen = settings.isOpen || false;
    $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

    if ($elm.hasClass('mbsc-card')) {
      // card enhance
      $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
    } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
      // form group enhance
      $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
      $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
    } else {
      // if it is used independently
      $header = $elm.find('.mbsc-collapsible-header').eq(0);
      $content = $elm.find('.mbsc-collapsible-content').eq(0);
    }

    content = $content[0];

    if (content && !content.id) {
      content.id = 'mbsc-collapsible-' + nr++;
    }

    if ($header.length && content) {
      var $collapsibleIcon = $$1('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');
      tap(this, $header, function () {
        _this.collapse();
      });
      $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', this.onMouseDown).on('keydown', this.onKeyDown).append($collapsibleIcon);
    }

    elm.mbscInst = this;
    this._$header = $header;
    this._$content = $content;
    this._$elm = $elm;
    this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.toggle = this.toggle.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
  }

  var _proto = CollapsibleBase.prototype;

  _proto.collapse = function collapse(show) {
    var $elm = this._$elm;
    var $content = this._$content;

    var removeHeight = function removeHeight() {
      $content.off('transitionend', removeHeight).css('height', '');
    };

    if (show === undefined) {
      show = !this._isOpen;
    }

    if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
      return;
    }

    if (show) {
      if (hasTransition) {
        $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
      }

      $elm.addClass('mbsc-collapsible-open');
    } else {
      if (hasTransition) {
        $content.css('height', getComputedStyle($content[0]).height);
      }

      setTimeout(function () {
        $content.css('height', 0);
        $elm.removeClass('mbsc-collapsible-open');
      }, 50);
    }

    if (show && this._$accordionParent) {
      this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
        if (this !== $elm[0]) {
          this.mbscInst.hide();
        }
      });
    }

    this._isOpen = show;

    this._$header.attr('aria-expanded', this._isOpen);
  };

  _proto.show = function show() {
    this.collapse(true);
  };

  _proto.hide = function hide() {
    this.collapse(false);
  };

  _proto.toggle = function toggle() {
    this.collapse();
  };

  _proto.destroy = function destroy() {
    this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');

    this._$content.removeClass('mbsc-collapsible-content');

    this._$header.removeClass('mbsc-collapsible-header').off('mousedown', this.onMouseDown).off('keydown', this.onKeyDown).find('.mbsc-collapsible-icon').remove();

    tapOff(this._$header);
  };

  _proto.onKeyDown = function onKeyDown(ev) {
    if (ev.which === 32 || ev.keyCode == 13) {
      //space or enter 
      ev.preventDefault();
      this.collapse();
    }
  };

  _proto.onMouseDown = function onMouseDown(ev) {
    // prevent focus on mouse down
    ev.preventDefault();
  };

  return CollapsibleBase;
}();
classes.CollapsibleBase = CollapsibleBase;

var id$2 = 0;

function initControls($ctx, controls, s, shallow) {
  $$1('input,select,textarea,progress,button', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        //$parent = $control.parent(),
    type = getControlType($control); // Skip elements with data-enhance="false"

    if ($control.attr('data-enhance') != 'false'
    /* TRIALCOND */
    ) {
        if ($control.hasClass('mbsc-control')) {
          if (control.mbscInst) {
            control.mbscInst.option({
              theme: s.theme,
              lang: s.lang,
              rtl: s.rtl,
              onText: s.onText,
              offText: s.offText,
              stopProp: s.stopProp
            });
          }
        } else {
          if (!control.id) {
            control.id = 'mbsc-form-control-' + ++id$2;
          }

          switch (type) {
            case 'button':
            case 'submit':
              controls[control.id] = new Button(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap
              });
              break;

            case 'switch':
              controls[control.id] = new Switch(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                tap: s.tap,
                onText: s.onText,
                offText: s.offText,
                stopProp: s.stopProp
              });
              break;

            case 'checkbox':
              controls[control.id] = new CheckBox(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'range':
              if (!$$1(control).parent().hasClass('mbsc-slider')) {
                controls[control.id] = new Slider(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  stopProp: s.stopProp,
                  labelStyle: s.labelStyle
                });
              }

              break;

            case 'rating':
              controls[control.id] = new Rating(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                stopProp: s.stopProp
              });
              break;

            case 'progress':
              controls[control.id] = new Progress(control, {
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                labelStyle: s.labelStyle
              });
              break;

            case 'radio':
              controls[control.id] = new Radio(control, {
                tap: s.tap,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'select':
            case 'select-one':
            case 'select-multiple':
              controls[control.id] = new Select(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'textarea':
              controls[control.id] = new TextArea(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'segmented':
              controls[control.id] = new SegmentedItem(control, {
                theme: s.theme,
                rtl: s.rtl,
                tap: s.tap,
                inputStyle: s.inputStyle
              });
              break;

            case 'stepper':
              controls[control.id] = new Stepper(control, {
                theme: s.theme,
                rtl: s.rtl
              });
              break;

            case 'hidden':
              return;

            default:
              controls[control.id] = new Input(control, {
                tap: s.tap,
                inputStyle: s.inputStyle,
                labelStyle: s.labelStyle,
                theme: s.theme,
                rtl: s.rtl
              });
              break;
          }
        }
      }
  });
  $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
    var control = this,
        $control = $$1(control),
        isOpen = $control.attr('data-open');

    if (!control.id) {
      control.id = 'mbsc-form-control-' + ++id$2;
    }

    controls[control.id] = new CollapsibleBase(control, {
      isOpen: isOpen !== undefined && isOpen != 'false'
    });
    instances[control.id] = controls[control.id];
  }); // Set initial height for textareas

  if (!shallow) {
    sizeTextAreas();
  }
}

// eslint-disable-next-line no-unused-vars
var Card = function Card(el, settings) {
  var s,
      collapsibleInst,
      cssClass = '',
      $elm = $$1(el),
      controls = {},
      that = this;

  function touched() {
    $elm.removeClass('mbsc-no-touch');
  } // Call the parent constructor


  Base.call(this, el, settings, true);

  that.refresh = function (shallow) {
    initControls($elm, controls, s, shallow);
  };
  /**
   * Card initialization.
   */


  that._init = function () {
    var isCollapsible = s.collapsible !== undefined || $elm.attr('data-collapsible') !== undefined;

    if (!$elm.hasClass('mbsc-card')) {
      $elm.show();
      listen(el, 'touchstart', touched, {
        passive: true
      });
    }

    if (cssClass) {
      $elm.removeClass(cssClass);
    }
    /*
    cssClass = 'mbsc-card mbsc-form mbsc-no-touch mbsc-' + s.theme +
        (halfBorder ? ' mbsc-form-hb' : '') +
        (s.baseTheme ? ' mbsc-' + s.baseTheme : '') +
        (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    */
    // --- REMOTE TRIAL CODE START ---


    cssClass = that.remote.cards.cssClass; // --- REMOTE TRIAL CODE END ---

    $elm.addClass(cssClass).removeClass('mbsc-cloak');

    if (isCollapsible && !collapsibleInst) {
      var isOpen = $elm.attr('data-open');
      collapsibleInst = new CollapsibleBase(el, {
        isOpen: isOpen !== undefined && isOpen != 'false' || s.collapsible === true
      });
    }

    $elm.append(that._getText(mobiscroll, 0.5));
    that.refresh();
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $elm.removeClass(cssClass);
    unlisten(el, 'touchstart', touched, {
      passive: true
    });

    for (var id in controls) {
      controls[id].destroy();
    }

    if (collapsibleInst) {
      collapsibleInst.destroy();
    }
  };

  that.toggle = function () {
    if (collapsibleInst) {
      collapsibleInst.toggle();
    }
  };

  that.hide = function () {
    if (collapsibleInst) {
      collapsibleInst.hide();
    }
  };

  that.show = function () {
    if (collapsibleInst) {
      collapsibleInst.show();
    }
  }; // Constructor


  s = that.settings;
  that.init();
}; // Extend defaults

Card.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'card',
  _defaults: {
    tap: hasGhostClick,
    stopProp: true,
    rtl: false
  }
};
classes.Card = Card; // Init mbsc-card elements on page load or when mbsc-enhance event is triggeres

autoInit('[mbsc-card]', Card, true);

var SELECTED_CLASS = 'mbsc-selected';
var ACTIVE_CLASS = 'mbsc-lv-item-active';
var confirms,
    guid = 1,
    transp = 'transparent';
var ListView = function ListView(elem, settings) {
  var action,
      actionWidth,
      activeTimer,
      animPos,
      cancel,
      confirmItem,
      confirmIndex,
      cont,
      cont0,
      currIndex,
      currList,
      currPh,
      currParent,
      currSiblings,
      currStage,
      currStageIdx,
      debounce,
      demoMode,
      disabled,
      diffX,
      diffY,
      dropDown,
      dropUp,
      dragged,
      dummyCont,
      endTimer,
      endX,
      endY,
      event,
      fill,
      found,
      groupHeader,
      hadEnhance,
      handlePos,
      hasContext,
      handleDiv,
      hoverDir,
      hoverItem,
      hoverItemOpened,
      hoverTime,
      hoverTimeout,
      hoverTimer,
      htmlLeft,
      htmlRight,
      icon,
      iconc,
      stagec,
      isClick,
      isLoading,
      isTouch,
      itemw,
      item,
      itemHeight,
      itemIndex,
      itemNode,
      itemSelector,
      itemTop,
      listNode,
      listSelector,
      loading,
      maxDrag,
      minDrag,
      multic,
      multiple,
      nextItem,
      nextOffset,
      nextStage,
      nextItems,
      onScrollThrottle,
      onScrollDebounce,
      prevClick,
      preventHover,
      preventTimer,
      prevItems,
      placeholder,
      prevItem,
      prevOffset,
      prevStage,
      quickSwipe,
      rafID,
      rafRunning,
      s,
      scroll,
      selectable,
      simulating,
      slideCont,
      stageNr,
      stages,
      startPos,
      startTime,
      startX,
      startY,
      style,
      swipe,
      swipeInterval,
      swipeTimeout,
      tapHighlight,
      text,
      timer,
      type,
      types,
      undoRef,
      undoAnim,
      wnd,
      wnd0,
      wndHeight,
      wndScroll,
      wndTop,
      that = this,
      e = elem,
      elm = $$1(e),
      transition = 0,
      slideLevel = 0,
      startTop = 0,
      stageObj = {},
      actionQueue = {},
      treeMap = {};

  function onActionStart() {
    quickSwipe = false;
    prevClick = false;
    animPos = 0;
    startPos = 0;
    startTime = new Date();
    itemw = currList.width();
    currSiblings = getChildren(currList);
    itemIndex = currSiblings.index(item);
    itemHeight = item[0].offsetHeight;
    startTop = item[0].offsetTop;
    type = types[item.attr('data-type') || 'defaults'];
    stages = type.stages;
  }

  function onStart(ev) {
    var itm;
    var target = closest(cont0, ev.target, '.mbsc-lv-item');

    if (!target || !cont0.contains(target)) {
      return;
    }

    if (ev.type === 'touchstart') {
      cont.removeClass('mbsc-no-touch');
      preventHover = true;
      clearTimeout(preventTimer);
    }

    if (testTouch(ev, target) && !action && !transition && !confirms && !undoing && mobiscroll.EmtjC) {
      action = true;
      cancel = true;
      isClick = false;
      isTouch = ev.type === 'touchstart';
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      diffX = 0;
      diffY = 0;
      item = $$1(target);
      itm = item; // Local reference

      onActionStart();
      tapHighlight = type.actionable || item.hasClass('mbsc-lv-parent') || item.hasClass('mbsc-lv-back');
      itemTop = item.offset().top;

      if (tapHighlight) {
        activeTimer = setTimeout(function () {
          itm.addClass(isTouch ? ACTIVE_CLASS : '');
          event('onItemActivate', {
            target: itm[0],
            domEvent: ev
          });
        }, 120);
      }

      if (that.sortable && !item.hasClass('mbsc-lv-back')) {
        if (!that.sortable.group) {
          nextItems = item.nextUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
          prevItems = item.prevUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
        }

        minDrag = (!that.sortable.group ? prevItems.length ? prevItems.eq(-1) : item : currList.children(itemSelector).eq(0))[0].offsetTop - startTop;
        maxDrag = (!that.sortable.group ? nextItems.length ? nextItems.eq(-1) : item : currList.children(itemSelector).eq(-1))[0].offsetTop - startTop;

        if (that.sortable.handle) {
          if ($$1(ev.target).hasClass('mbsc-lv-handle')) {
            clearTimeout(activeTimer);
            timer = setTimeout(function () {
              onSortStart();
            }, 100);
          }
        } else {
          timer = setTimeout(function () {
            fill.appendTo(item);
            fill[0].style[jsPrefix + 'Animation'] = 'mbsc-lv-fill ' + (s.sortDelay - 100) + 'ms linear';
            clearTimeout(endTimer);
            clearTimeout(activeTimer);
            cancel = false;
            timer = setTimeout(function () {
              fill[0].style[jsPrefix + 'Animation'] = '';
              onSortStart();
            }, s.sortDelay - 80);
          }, 80);
        }
      }

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
      }
    }
  }

  function onMove(ev) {
    var sortChange = false,
        dropChange = true,
        prevPos = animPos;

    if (action) {
      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;
      clearTimeout(endTimer);

      if (!dragged && !swipe && !scroll && !item.hasClass('mbsc-lv-back')) {
        if (Math.abs(diffY) > 10) {
          // It's a scroll
          scroll = true;
          onEnd(extend$1({}, ev, {
            type: ev.type == 'mousemove' ? 'mouseup' : 'touchend'
          }));
          clearTimeout(activeTimer);
        } else if (Math.abs(diffX) > 7) {
          // It's a swipe
          onSwipeStart();
        }
      }

      if (swipe) {
        ev.preventDefault();
        animPos = diffX / itemw * 100;
        onSwipeMove(prevPos);
      } else if (dragged) {
        ev.preventDefault();
        var scrolled,
            st = wnd.scrollTop(),
            diff = Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag)),
            top = hasContext ? itemTop - wndTop + st - wndScroll : itemTop; // Check if scroll is needed

        if (wndHeight + st < top + diff + itemHeight) {
          wnd.scrollTop(top + diff - wndHeight + itemHeight);
          scrolled = true;
        } else if (top + diff < st) {
          wnd.scrollTop(top + diff);
          scrolled = true;
        } // Update scroll values if window was scrolled


        if (scrolled) {
          wndScroll += wnd.scrollTop() - st;
        } // Check overlap with next item


        if (nextOffset) {
          // If subtree exists, drop element on subtree at 1/4, change sort order at 3/4 overlap
          if (that.sortable.multiLevel && nextItem.hasClass('mbsc-lv-parent')) {
            if (startTop + itemHeight / 4 + diff > nextOffset) {
              sortChange = true;
            } else if (startTop + itemHeight - itemHeight / 4 + diff > nextOffset) {
              dropDown = nextItem.addClass('mbsc-lv-item-hl');
              dropChange = false;
            } // Check 1/2 overlap

          } else if (startTop + itemHeight / 2 + diff > nextOffset) {
            // If over back button, highlight to drop to parent level
            if (nextItem.hasClass('mbsc-lv-back')) {
              if (that.sortable.multiLevel) {
                dropUp = nextItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              }
            } else {
              sortChange = true;
            }
          }

          if (sortChange) {
            placeholder.insertAfter(nextItem);
            prevItem = nextItem;
            nextItem = getNextPrev(nextItem, 'next');
            prevOffset = nextOffset;
            nextOffset = nextItem.length && nextItem[0].offsetTop;
            currIndex++;
          }
        } // Check overlap with prev item


        if (!sortChange && prevOffset) {
          // If subtree exists, drop element on subtree at 1/3, change sort order at 2/3 overlap
          if (that.sortable.multiLevel && prevItem.hasClass('mbsc-lv-parent')) {
            if (startTop + itemHeight - itemHeight / 4 + diff < prevOffset) {
              sortChange = true;
            } else if (startTop + itemHeight / 4 + diff < prevOffset) {
              dropDown = prevItem.addClass('mbsc-lv-item-hl');
              dropChange = false;
            } // Check 1/2 overlap

          } else if (startTop + itemHeight / 2 + diff < prevOffset) {
            // If over back button, highlight to drop to parent level
            if (prevItem.hasClass('mbsc-lv-back')) {
              if (that.sortable.multiLevel) {
                dropUp = prevItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              }
            } else {
              sortChange = true;
            }
          }

          if (sortChange) {
            placeholder.insertBefore(prevItem);
            nextItem = prevItem;
            prevItem = getNextPrev(prevItem, 'prev');
            nextOffset = prevOffset;
            prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
            currIndex--;
          }
        }

        if (dropChange) {
          if (dropDown) {
            dropDown.removeClass('mbsc-lv-item-hl');
            dropDown = false;
          }

          if (dropUp) {
            dropUp.removeClass('mbsc-lv-item-hl');
            dropUp = false;
          }
        }

        if (sortChange) {
          event('onSortChange', {
            target: item[0],
            index: currIndex
          });
        }

        drag(item, diff);
        event('onSort', {
          target: item[0],
          index: currIndex
        });
      } else if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
        // Cancel dragstart if movement is > 5px
        stopTimer();
      }
    }
  }

  function onEnd(ev) {
    var dist,
        map,
        parent,
        itm = item;

    if (action) {
      action = false;
      stopTimer();

      if (ev.type == 'mouseup') {
        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      if (!scroll) {
        preventTimer = setTimeout(function () {
          preventHover = false;
        }, 300);
      }

      if (swipe || scroll || dragged) {
        prevClick = true;
      }

      if (swipe) {
        onSwipeEnd();
      } else if (dragged) {
        // Sort end
        parent = currList;

        if (dropDown) {
          resetItem(item.detach());
          map = treeMap[dropDown.attr('data-ref')];
          currIndex = getChildren(map.child).length;
          dropDown.removeClass('mbsc-lv-item-hl');

          if (s.navigateOnDrop) {
            navigate(dropDown, function () {
              that.add(null, item, null, null, dropDown, true);
              scrollToItem(item);
              onSortEnd(item, itemIndex, parent, true);
            });
          } else {
            that.add(null, item, null, null, dropDown, true);
            onSortEnd(item, itemIndex, parent, true);
          }
        } else if (dropUp) {
          resetItem(item.detach());
          map = treeMap[dropUp.attr('data-back')];
          currIndex = getChildren(map.parent).index(map.item) + 1;
          dropUp.removeClass('mbsc-lv-item-hl');

          if (s.navigateOnDrop) {
            navigate(dropUp, function () {
              that.add(null, item, currIndex, null, currList, true);
              scrollToItem(item);
              onSortEnd(item, itemIndex, parent, true);
            });
          } else {
            that.add(null, item, currIndex, null, map.parent, true);
            onSortEnd(item, itemIndex, parent, true);
          }
        } else {
          dist = placeholder[0].offsetTop - startTop; // Animate item to its place

          drag(item, dist, Math.abs(dist - Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag))) * 6, function () {
            resetItem(item);
            item.insertBefore(placeholder);
            onSortEnd(item, itemIndex, parent, currIndex !== itemIndex);
          });
        }

        dragged = false;
      } else if (!scroll && Math.abs(diffX) < 5 && Math.abs(diffY) < 5) {
        // Tap
        isClick = true; // Trigger click and activate target, if it's a form control

        if (ev.type === 'touchend' && s.tap) {
          activateControl(ev.target, getControlType($$1(ev.target)), ev);
        }
      }

      clearTimeout(activeTimer);
      setTimeout(function () {
        itm.removeClass(ACTIVE_CLASS);
        event('onItemDeactivate', {
          target: itm[0]
        });
      }, 100);
      scroll = false;
      currStage = null;
    }
  }

  function onClick(ev) {
    var isSelected, ret;

    if (isClick) {
      isSelected = item.attr('data-selected') == 'true';

      if (type.tap) {
        ret = type.tap.call(e, {
          target: item,
          index: itemIndex,
          domEvent: ev
        }, that);
      }

      if (tapHighlight && !item.hasClass(ACTIVE_CLASS)) {
        item.addClass(isTouch ? ACTIVE_CLASS : '');
        event('onItemActivate', {
          target: item[0],
          domEvent: ev
        });
      } // select or deselect item on tap


      if (selectable) {
        if (multiple) {
          if (isSelected) {
            deselectItem(item);
          } else {
            selectItem(item);
          }
        } else {
          deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
          selectItem(item);
        }
      }

      ret = event('onItemTap', {
        target: item[0],
        index: itemIndex,
        domEvent: ev,
        selected: isSelected
      });

      if (ret !== false) {
        navigate(item);
      }
    }
  }

  function onIconStart(ev) {
    var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

    if (!target) {
      return;
    }

    if (!demoMode) {
      ev.stopPropagation();
      ev.preventDefault();
    }

    startX = getCoord(ev, 'X');
    startY = getCoord(ev, 'Y');
  }

  function onSwipeStart() {
    swipe = valueOrFunc(type.swipe, {
      target: item[0],
      index: itemIndex,
      direction: diffX > 0 ? 'right' : 'left'
    });

    if (swipe) {
      stopTimer();
      clearTimeout(activeTimer);

      if (type.actions) {
        // Get the width of the action menu from settings
        // Numeric values are converted to string, because 0 is also accepted, we convert back to number at the end
        actionWidth = getActionWidth(type, diffX); // Show action icons and set width

        multic.html(type.icons).show().children().css('width', actionWidth + '%'); // Hide stage icons

        iconc.hide(); // Set disabled actions

        $$1('.mbsc-lv-ic-m', stagec).removeClass('mbsc-lv-ic-disabled');
        $$1(type.leftMenu).each(disableActions);
        $$1(type.rightMenu).each(disableActions);
      } else {
        iconc.show();
        multic.hide();
        currStageIdx = type.start;
        currStage = stages[currStageIdx];
        prevStage = stages[currStageIdx - 1];
        nextStage = stages[currStageIdx + 1];
      }

      item.addClass('mbsc-lv-item-swiping').removeClass(ACTIVE_CLASS);
      text.css('line-height', itemHeight + 'px');
      stagec.css({
        top: startTop,
        height: itemHeight,
        backgroundColor: getFirstColor(diffX)
      }).addClass('mbsc-lv-stage-c-v').appendTo(currList.parent());

      if (s.iconSlide) {
        item.append(iconc);
      }

      event('onSlideStart', {
        target: item[0],
        index: itemIndex
      });
    }
  }

  function onSwipeMove(prevPos) {
    var stageChanged = false;

    if (!rafRunning) {
      if (type.actions) {
        stagec.attr('class', 'mbsc-lv-stage-c-v mbsc-lv-stage-c mbsc-lv-' + (animPos < 0 ? 'right' : 'left'));
      } else {
        if (prevStage && (animPos < 0 ? animPos <= prevStage.percent : animPos < currStage.percent)) {
          currStageIdx--;
          nextStage = currStage;
          currStage = prevStage;
          prevStage = stages[currStageIdx - 1];
          stageChanged = true;
        } else if (nextStage && (animPos < 0 ? animPos > currStage.percent : animPos >= nextStage.percent)) {
          currStageIdx++;
          prevStage = currStage;
          currStage = nextStage;
          nextStage = stages[currStageIdx + 1];
          stageChanged = true;
        }

        if (currStage) {
          if (stageChanged || animPos > 0 == prevPos <= 0) {
            // Also need to update stage background if swipe direction changed
            setStageProps(currStage, s.iconSlide);
          }

          if (stageChanged) {
            event('onStageChange', {
              target: item[0],
              index: itemIndex,
              stage: currStage
            });
          }
        }
      }

      if (!simulating) {
        rafRunning = true;
        rafID = raf(slideMove);
      }
    }
  }

  function onSwipeEnd(callback) {
    function onCloseActions(ev) {
      var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

      if (!target) {
        ev.preventDefault();
        slideEnd(item, true, callback);
      }
    }

    var quickSwipeLeft,
        quickSwipeRight,
        timeDiff,
        itm = item[0],
        pending = false,
        revert = true;
    rafc(rafID);
    rafRunning = false; // We need an additional call to set the position in case when
    // requestAnimationFrame did not call it at least once
    // E.g. in a case of a quick swipe animation frame is
    // cancelled before the first call

    if (!simulating) {
      slideMove();
    }

    if (type.actions) {
      if (Math.abs(animPos) > 10 && actionWidth) {
        slide(item, animPos < 0 ? -actionWidth : actionWidth, 200);
        pending = true;
        confirms = true;
        confirmItem = item;
        confirmIndex = itemIndex;

        if (itm.__mbscOff) {
          itm.__mbscOff();
        }

        listen(document, 'touchstart', onCloseActions, {
          passive: false
        });
        listen(document, 'mousedown', onCloseActions);

        itm.__mbscOff = function () {
          unlisten(document, 'touchstart', onCloseActions, {
            passive: false
          });
          unlisten(document, 'mousedown', onCloseActions);
          delete itm.__mbscOff;
        };
      }
    } else if (animPos) {
      if (s.quickSwipe && !simulating) {
        timeDiff = new Date() - startTime;
        quickSwipeLeft = timeDiff < 300 && diffX < -50;
        quickSwipeRight = timeDiff < 300 && diffX > 50;

        if (quickSwipeLeft) {
          quickSwipe = true;
          currStage = type.left;
          setStageProps(currStage, s.iconSlide);
        } else if (quickSwipeRight) {
          quickSwipe = true;
          currStage = type.right;
          setStageProps(currStage, s.iconSlide);
        }
      }

      if (currStage && currStage.action) {
        disabled = valueOrFunc(currStage.disabled, {
          target: item[0],
          index: itemIndex
        });

        if (!disabled) {
          pending = true;
          confirms = simulating || valueOrFunc(currStage.confirm, {
            target: item[0],
            index: itemIndex
          });

          if (confirms) {
            // Slide to text + icon width
            slide(item, (animPos < 0 ? -1 : 1) * iconc[0].offsetWidth * 100 / itemw, 200, true); // Tap to confirm

            setConfirm(currStage, item, itemIndex, false, callback);
          } else {
            runAction(currStage, item, itemIndex, callback);
          }
        }
      }
    }

    if (!pending) {
      slideEnd(item, revert, callback);
    }

    swipe = false;
  }

  function onSortStart() {
    dragged = true;
    dropDown = false;
    dropUp = false;
    wndScroll = 0;
    currIndex = itemIndex;

    if (s.vibrate) {
      vibrate();
    }

    nextItem = getNextPrev(item, 'next');
    nextOffset = nextItem.length && nextItem[0].offsetTop;
    prevItem = getNextPrev(item, 'prev');
    prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
    placeholder.height(itemHeight).insertAfter(item); // Item is removed from original list, otherwise messes up striped layout

    item.css({
      top: startTop
    }).addClass('mbsc-lv-item-dragging').removeClass(ACTIVE_CLASS).appendTo(dummyCont);
    event('onSortStart', {
      target: item[0],
      index: currIndex
    });
  }

  function onSortEnd(item, itemIndex, parent, update) {
    item.removeClass('mbsc-lv-item-dragging');
    placeholder.remove();
    event('onSortEnd', {
      target: item[0],
      index: currIndex
    });

    if (s.vibrate) {
      vibrate();
    }

    if (update) {
      that.addUndoAction(function (next) {
        that.move(item, itemIndex, null, next, parent, true);
      }, true);
      event('onSortUpdate', {
        target: item[0],
        index: currIndex
      });
    }
  }

  function onMouseLeave() {
    if (!preventHover) {
      clearTimeout(hoverTimer);

      if (confirms) {
        trigger(document, 'touchstart');
      }

      if (hoverItemOpened) {
        that.close(hoverItem, hoverTime);
        hoverItemOpened = false;
        hoverItem = null;
      }
    }
  }

  function onResize() {
    clearTimeout(debounce);
    debounce = setTimeout(function () {
      wndHeight = wnd0.innerHeight || wnd.innerHeight();
      wndTop = hasContext ? wnd.offset().top : 0;

      if (action) {
        // Reposition stage background, icon and text
        startTop = item[0].offsetTop;
        itemHeight = item[0].offsetHeight;
        stagec.css({
          top: startTop,
          height: itemHeight
        });
      }
    }, 200);
  }

  function onListClick(ev) {
    if (prevClick) {
      ev.stopPropagation();
      ev.preventDefault();
      prevClick = false;
    }
  }

  function onScrollBottom() {
    if (!isLoading) {
      clearTimeout(onScrollDebounce);
      onScrollDebounce = setTimeout(function () {
        var height = hasContext ? wnd0.getBoundingClientRect().top + wnd.innerHeight() : window.innerHeight,
            reachedBottom = loading[0].getBoundingClientRect().top - 3 < height;

        if (!isLoading && reachedBottom) {
          event('onListEnd');
        }
      }, 250);
    }
  }

  function onScroll() {
    if (dragged || !action) {
      var group,
          st = wnd.scrollTop(),
          elmTop = elm.offset().top,
          elmHeight = elm[0].offsetHeight,
          wndTop = hasContext ? wnd.offset().top : st;
      $$1('.mbsc-lv-gr-title', elm).each(function (i, v) {
        if ($$1(v).offset().top < wndTop) {
          group = v;
        }
      });

      if (elmTop < wndTop && elmTop + elmHeight > wndTop) {
        groupHeader.show().empty().append($$1(group).clone());
      } else {
        groupHeader.hide();
      }
    }
  }

  function disableActions(i, v) {
    if (valueOrFunc(v.disabled, {
      target: item[0],
      index: itemIndex
    })) {
      $$1('.mbsc-ic-' + v.icon, stagec).addClass('mbsc-lv-ic-disabled');
    }
  }

  function runAction(stage, item, index, callback) {
    var revert,
        undoStage = {
      icon: 'undo2',
      text: s.undoText,
      action: function action() {
        that.undo();
      }
    };

    if (stage.undo) {
      that.startActionTrack(); // Add user defined undo

      if ($$1.isFunction(stage.undo)) {
        that.addUndoAction(function () {
          stage.undo.call(e, {
            target: item[0],
            index: index
          }, that);
        });
      } // Remember the item where the undo is displayed


      undoRef = item.attr('data-ref');
    }

    revert = stage.action.call(e, {
      target: item[0],
      index: index
    }, that);

    if (stage.undo) {
      that.endActionTrack();

      if (revert !== false) {
        slide(item, +item.attr('data-pos') < 0 ? -100 : 100, 200);
      }

      placeholder.height(itemHeight).insertAfter(item);
      item.css('top', startTop).addClass('mbsc-lv-item-undo');
      multic.hide();
      iconc.show();
      stagec.append(iconc);
      setStageProps(undoStage);
      setConfirm(undoStage, item, index, true, callback);
    } else {
      slideEnd(item, revert, callback);
    }
  }

  function setConfirm(stage, item, index, ph, callback) {
    function onActionCancel(ev) {
      ev.preventDefault();

      if (ph) {
        cleanUndo(item);
      }

      slideEnd(item, true, callback);
    }

    function onActionConfirmStart(ev) {
      ev.stopPropagation();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
    }

    function onActionConfirmEnd(ev) {
      ev.preventDefault();

      if (ev.type === 'touchend') {
        preventClick();
      } // If movement is less than 10px, it's a tap


      if (Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
        runAction(stage, item, index, callback);

        if (ph) {
          undoAnim = null;
          cleanUndo(item);
        }
      }
    }

    var startX,
        startY,
        itm = item[0];
    confirms = true;

    if (itm.__mbscOff) {
      itm.__mbscOff();
    }

    listen(document, 'touchstart', onActionCancel, {
      passive: false
    });
    listen(document, 'mousedown', onActionCancel);

    if (!demoMode) {
      listen(iconc[0], 'touchstart', onActionConfirmStart, {
        passive: true
      });
      listen(iconc[0], 'mousedown', onActionConfirmStart);
      listen(iconc[0], 'touchend', onActionConfirmEnd);
      listen(iconc[0], 'mouseup', onActionConfirmEnd);
    }

    itm.__mbscOff = function () {
      unlisten(document, 'touchstart', onActionCancel, {
        passive: false
      });
      unlisten(document, 'mousedown', onActionCancel);
      unlisten(iconc[0], 'touchstart', onActionConfirmStart, {
        passive: true
      });
      unlisten(iconc[0], 'mousedown', onActionConfirmStart);
      unlisten(iconc[0], 'touchend', onActionConfirmEnd);
      unlisten(iconc[0], 'mouseup', onActionConfirmEnd);
      delete itm.__mbscOff;
    };
  }

  function slideMove() {
    slide(item, startPos + diffX * 100 / itemw);
    rafRunning = false;
  }

  function slideEnd(item, revert, callback) {
    if (item[0].__mbscOff) {
      item[0].__mbscOff();
    }

    if (revert !== false) {
      slide(item, 0, item.attr('data-pos') !== '0' ? 200 : 0, false, function () {
        cleanStage(item, callback);
        resetItem(item);
      });
    } else {
      cleanStage(item, callback);
    }

    confirms = false;
  }

  function slide(item, pos, time, px, callback) {
    pos = Math.max(swipe == 'right' ? 0 : -100, Math.min(pos, swipe == 'left' ? 0 : 100));
    style = item[0].style;
    item.attr('data-pos', pos);
    style[jsPrefix + 'Transform'] = 'translate3d(' + (px ? itemw * pos / 100 + 'px' : pos + '%') + ',0,0)';
    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms';

    if (callback) {
      transition++;
      setTimeout(function () {
        callback();
        transition--;
      }, time);
    }

    animPos = pos;
  }

  function drag(item, top, time, callback) {
    top = Math.max(minDrag, Math.min(top, maxDrag));
    style = item[0].style;
    style[jsPrefix + 'Transform'] = 'translate3d(0,' + top + 'px,0)';
    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms ease-out';

    if (callback) {
      transition++;
      setTimeout(function () {
        callback();
        transition--;
      }, time);
    }
  }

  function stopTimer() {
    clearTimeout(timer);

    if (!cancel && that.sortable) {
      cancel = true;
      fill.remove();
    }
  }

  function setStageProps(stage, iconSlide) {
    var txt = valueOrFunc(stage.text, {
      target: item[0],
      index: itemIndex
    }) || '';

    if (valueOrFunc(stage.disabled, {
      target: item[0],
      index: itemIndex
    })) {
      stagec.addClass('mbsc-lv-ic-disabled');
    } else {
      stagec.removeClass('mbsc-lv-ic-disabled');
    }

    stagec.css('background-color', stage.color || (stage.percent === 0 ? getFirstColor(animPos) : transp));
    iconc.attr('class', 'mbsc-lv-ic-c mbsc-lv-ic-' + (iconSlide ? 'move-' : '') + (animPos < 0 ? 'right' : 'left'));
    icon.attr('class', ' mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-' + (stage.icon || 'none'));
    text.attr('class', 'mbsc-lv-ic-text' + (stage.icon ? '' : ' mbsc-lv-ic-text-only') + (txt ? '' : ' mbsc-lv-ic-only')).html(txt || '&nbsp;');

    if (s.animateIcons) {
      if (quickSwipe) {
        icon.addClass('mbsc-lv-ic-v');
      } else {
        setTimeout(function () {
          icon.addClass('mbsc-lv-ic-a');
        }, 10);
      }
    }
  }

  function cleanStage(item, callback) {
    if (!action) {
      // Don't clean stages if another action started
      icon.attr('class', 'mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none');
      stagec.attr('style', '').removeClass('mbsc-lv-stage-c-v');
      text.html('');
    }

    stagec.removeClass('mbsc-lv-left mbsc-lv-right');

    if (item) {
      event('onSlideEnd', {
        target: item[0],
        index: itemIndex
      });

      if (callback) {
        callback();
      }
    }
  }

  function cleanUndo(item) {
    item.css('top', '').removeClass('mbsc-lv-item-undo'); // Remove placeholder

    if (undoAnim) {
      that.animate(placeholder, 'collapse', function () {
        placeholder.remove();
      });
    } else {
      placeholder.remove();
    }

    cleanStage();
    undoRef = null;
    undoAnim = null;
  }

  function resetItem(item) {
    style = item[0].style;
    style[jsPrefix + 'Transform'] = '';
    style[jsPrefix + 'Transition'] = '';
    style.top = '';
    item.removeClass('mbsc-lv-item-swiping');
  }

  function valueOrFunc(val, args) {
    return $$1.isFunction(val) ? val.call(this, args, that) : val;
  }

  function isSelectable(item) {
    return selectable && !item.hasClass('mbsc-lv-parent') && !item.hasClass('mbsc-lv-back');
  }

  function initItem(item) {
    var id = item.attr('data-ref'),
        role = item.attr('data-role'),
        type = types[item.attr('data-type') || 'defaults'],
        selected = isSelectable(item) && item.attr('data-selected') == 'true';

    if (!id) {
      id = guid++;
      item.attr('data-ref', id);
    }

    treeMap[id] = {
      item: item,
      child: item.children(listSelector),
      parent: item.parent(),
      ref: item.parent()[0] === e ? null : item.parent().parent().attr('data-ref')
    };
    item.addClass(role == 'list-divider' ? 'mbsc-lv-gr-title' : 'mbsc-lv-item' + (type.actionable ? ' mbsc-lv-item-actionable' : '') + (selected ? ' ' + SELECTED_CLASS : ''));
    item.attr('aria-selected', selected ? 'true' : 'false'); // Add sort handle

    if (that.sortable.handle && role != 'list-divider' && !item.children('.mbsc-lv-handle-c').length) {
      item.append(handleDiv);
    }

    if (s.enhance && !item.hasClass('mbsc-lv-item-enhanced')) {
      var itemIcon = item.attr('data-icon'),
          itemImg = item.find('img').eq(0).addClass('mbsc-lv-img');

      if (itemImg.is(':first-child')) {
        item.addClass('mbsc-lv-img-' + (s.rtl ? 'right' : 'left'));
      } else if (itemImg.length) {
        item.addClass('mbsc-lv-img-' + (s.rtl ? 'left' : 'right'));
      }

      item.addClass('mbsc-lv-item-enhanced').children().each(function (i, v) {
        v = $$1(v);

        if (v.is('p, h1, h2, h3, h4, h5, h6')) {
          v.addClass('mbsc-lv-txt');
        }
      });

      if (itemIcon) {
        item.addClass('mbsc-lv-item-ic-' + (item.attr('data-icon-align') || (s.rtl ? 'right' : 'left'))).append('<div class="mbsc-lv-item-ic mbsc-ic mbsc-ic-' + itemIcon + '"></div>');
      }
    }

    item.append(that._getText(mobiscroll, 0.2));
  }

  function initBranch(elm) {
    // Create map object
    $$1(itemSelector, elm).not('.mbsc-lv-back').each(function () {
      initItem($$1(this));
    }); // Add extra classes and markup (arrows and back items)

    $$1(listSelector, elm).not('.mbsc-lv').addClass('mbsc-lv').prepend(htmlLeft).parent().addClass('mbsc-lv-parent mbsc-lv-item-actionable').prepend(htmlRight); // Add parent reference for back buttons

    $$1('.mbsc-lv-back', elm).each(function () {
      $$1(this).attr('data-back', $$1(this).parent().parent().attr('data-ref'));
    });
  }

  function getChildren(list) {
    return list.children(itemSelector).not('.mbsc-lv-back').not('.mbsc-lv-removed').not('.mbsc-lv-ph');
  }

  function getItemByID(item) {
    if (typeof item !== 'object') {
      item = $$1(itemSelector, cont).filter('[data-id="' + item + '"]');
    }

    return $$1(item);
  }

  function getItemLevel(item) {
    var level = 0,
        map = treeMap[item.attr('data-ref')];

    while (map && map.ref) {
      level++;
      map = treeMap[map.ref];
    }

    return level;
  }

  function getNextPrev(item, dir) {
    item = item[dir](); // Returns next or previous item filtering out placeholder or currently dragged element

    while (item.length && (!item.hasClass('mbsc-lv-item') || item.hasClass('mbsc-lv-ph') || item.hasClass('mbsc-lv-item-dragging'))) {
      if (!that.sortable.group && item.hasClass('mbsc-lv-gr-title')) {
        return false;
      }

      item = item[dir]();
    }

    return item;
  }

  function getFirstColor(pos) {
    return (pos > 0 ? type.right : type.left).color || transp;
  }

  function getNumStr(s) {
    return isNumeric(s) ? s + '' : 0;
  }

  function getActionWidth(type, diffX) {
    return +(diffX < 0 ? getNumStr((type.actionsWidth || 0).right) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.right) || getNumStr(s.actionsWidth) : getNumStr((type.actionsWidth || 0).left) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.left) || getNumStr(s.actionsWidth));
  }

  function scrollToItem(item, scrollToTop) {
    if (item) {
      var scrollTop = wnd.scrollTop(),
          itemHeight = item.is('.mbsc-lv-item') ? item[0].offsetHeight : 0,
          itemTop = item.offset().top + (hasContext ? scrollTop - wndTop : 0);

      if (scrollToTop) {
        if (itemTop < scrollTop || itemTop + itemHeight > scrollTop + wndHeight) {
          wnd.scrollTop(itemTop);
        }
      } else {
        if (itemTop < scrollTop) {
          wnd.scrollTop(itemTop);
        } else if (itemTop + itemHeight > scrollTop + wndHeight) {
          wnd.scrollTop(Math.min(itemTop, itemTop + itemHeight - wndHeight / 2));
        }
      }
    }
  }

  function drill(dir, list, item, callback, scrollToTop) {
    var parent = list.parent(),
        ph = list.prev();
    callback = callback || noop;

    if (ph[0] === iconc[0]) {
      ph = iconc.prev();
    }

    if (s.rtl) {
      dir = dir === 'l' ? 'r' : 'l';
    }

    if (currList[0] !== list[0]) {
      event('onNavStart', {
        level: slideLevel,
        direction: dir,
        list: list[0]
      });
      slideCont.prepend(list.addClass('mbsc-lv-v mbsc-lv-sl-new')); // If top of the list is not visible, scroll to top

      scrollToItem(cont);
      animate(slideCont, 'mbsc-lv-sl-' + dir, function () {
        currList.removeClass('mbsc-lv-sl-curr');
        list.removeClass('mbsc-lv-sl-new').addClass('mbsc-lv-sl-curr');

        if (currPh && currPh.length) {
          currList.removeClass('mbsc-lv-v').insertAfter(currPh);
        } else {
          currParent.append(currList.removeClass('mbsc-lv-v'));
        } // Remember the previous element where we need to put back the list later
        // We need this because some frameworks like ember js put additional elements (script tags)
        // and appending to parent element is not ok


        currPh = ph;
        currParent = parent;
        currList = list;
        scrollToItem(item, scrollToTop);
        callback.call(e, item);
        event('onNavEnd', {
          level: slideLevel,
          direction: dir,
          list: list[0]
        });
      });
    } else {
      scrollToItem(item, scrollToTop);
      callback.call(e, item);
    }
  }

  function navigate(item, callback) {
    if (!transition) {
      if (item.hasClass('mbsc-lv-parent')) {
        slideLevel++;
        drill('r', treeMap[item.attr('data-ref')].child, null, callback);
      } else if (item.hasClass('mbsc-lv-back')) {
        slideLevel--;
        drill('l', treeMap[item.attr('data-back')].parent, treeMap[item.attr('data-back')].item, callback);
      }
    }
  }

  function animate(el, anim, callback) {
    var timer;

    function onAnimEnd() {
      clearTimeout(timer);
      transition--;
      el.off(animEnd, onAnimEnd).removeClass(anim);
      callback.call(e, el);
    }

    callback = callback || noop;

    if (s.animation && anim !== 'mbsc-lv-item-none') {
      transition++;
      el.on(animEnd, onAnimEnd).addClass(anim); // animEnd event will not execute with some integration plugins, this is a workaround to make sure it's executed

      timer = setTimeout(onAnimEnd, 250);
    } else {
      callback.call(e, el);
    }
  }

  function doAction(el, action) {
    var queue,
        id = el.attr('data-ref');
    queue = actionQueue[id] = actionQueue[id] || [];

    if (action) {
      queue.push(action);
    }

    if (el.attr('data-action')) {
      return;
    }

    action = queue.shift(); // Check this for safety
    // There was a case in angular were the data-ref attribute was lost,
    // so the queue was empty

    if (action) {
      el.attr('data-action', 1);
      action(function () {
        el.removeAttr('data-action');

        if (queue.length) {
          doAction(el);
        } else {
          delete actionQueue[id];
        }
      });
    }
  }

  function processStages(stages, dir, duplicate) {
    var count, temp;

    if (stages && stages.length) {
      count = 100 / (stages.length + 2);
      $$1.each(stages, function (i, stage) {
        if (stage.key === undefined) {
          stage.key = stageNr++;
        }

        if (stage.percent === undefined) {
          // if no percent passed then generate to both sides
          stage.percent = dir * count * (i + 1);

          if (duplicate) {
            temp = extend$1({}, stage);
            temp.key = stageNr++;
            temp.percent = -count * (i + 1);
            stages.push(temp);
            stageObj[temp.key] = temp;
          }
        }

        stageObj[stage.key] = stage;
      });
    }
  }

  function selectItem($item) {
    if (isSelectable($item)) {
      $item.addClass(SELECTED_CLASS).attr('data-selected', 'true').attr('aria-selected', 'true');
    }
  }

  function deselectItem($item) {
    $item.removeClass(SELECTED_CLASS).removeAttr('data-selected').removeAttr('aria-selected');
  } // Call the parent constructor


  Base.call(this, elem, settings, true);
  /**
   * Animate a list item
   */

  that.animate = function (li, anim, callback) {
    animate(li, 'mbsc-lv-item-' + anim, callback);
  };
  /**
   * Add a new list item
   */


  that.add = function (id, markup, index, callback, p, isUndo) {
    var backBtn,
        length,
        siblings,
        sublevel,
        map,
        pref,
        cssClass = '',
        $parent = p === undefined ? elm : getItemByID(p),
        $list = $parent,
        $item = typeof markup !== 'object' ? $$1('<' + itemNode + ' data-ref="' + guid++ + '" data-id="' + id + '">' + markup + '</' + itemNode + '>') : $$1(markup),
        item = $item[0],
        style = item.style,
        dir = $item.attr('data-pos') < 0 ? 'left' : 'right',
        ref = $item.attr('data-ref');
    callback = callback || noop;

    if (!ref) {
      ref = guid++;
      $item.attr('data-ref', ref);
    }

    initItem($item); // Put action in undo stack

    if (!isUndo) {
      that.addUndoAction(function (next) {
        if (sublevel) {
          that.navigate($parent, function () {
            $list.remove();
            $parent.removeClass('mbsc-lv-parent').children('.mbsc-lv-arr').remove();
            map.child = $parent.children(listSelector);
            that.remove($item, null, next, true);
          });
        } else {
          that.remove($item, null, next, true);
        }
      }, true);
    }

    doAction($item, function (next) {
      resetItem($item.css('top', '').removeClass('mbsc-lv-item-undo')); // If parent is a list item, insert new element in the sublist

      if ($parent.is(itemSelector)) {
        pref = $parent.attr('data-ref'); // If there is no sublist yet, create it

        if (!$parent.children(listSelector).length) {
          sublevel = true;
          $parent.append('<' + listNode + '></' + listNode + '>');
        }
      } else {
        pref = $parent.children('.mbsc-lv-back').attr('data-back');
      }

      map = treeMap[pref];

      if (map) {
        if (!map.child.length) {
          $parent.addClass('mbsc-lv-parent').prepend(htmlRight); // Set parent to be the sublist

          $list = $parent.children(listSelector).prepend(htmlLeft).addClass('mbsc-lv');
          map.child = $list;
          $$1('.mbsc-lv-back', $parent).attr('data-back', pref);
        } else {
          $list = map.child;
        }
      }

      treeMap[ref] = {
        item: $item,
        child: $item.children(listSelector),
        parent: $list,
        ref: pref
      };
      siblings = getChildren($list);
      length = siblings.length;

      if (index === undefined || index === null) {
        index = length;
      }

      if (isUndo) {
        cssClass = 'mbsc-lv-item-new-' + (isUndo ? dir : '');
      }

      initBranch($item.addClass(cssClass));

      if (index !== false) {
        if (!length) {
          backBtn = $$1('.mbsc-lv-back', $list);

          if (backBtn.length) {
            $item.insertAfter(backBtn);
          } else {
            $list.append($item);
          }
        } else if (index < length) {
          $item.insertBefore(siblings.eq(index));
        } else {
          $item.insertAfter(siblings.eq(length - 1));
        }
      }

      cont.trigger('mbsc-refresh'); // If current level is visible

      if (s.animateAddRemove && $list.hasClass('mbsc-lv-v')) {
        // Don't run expand animation if add is running on the "undo" element
        style.height = item.offsetHeight + 'px';
        that.animate($item, isUndo && undoRef === ref ? 'none' : 'expand', function ($item) {
          that.animate($item, isUndo ? 'add-' + dir : 'pop-in', function ($item) {
            style.height = '';
            callback.call(e, $item.removeClass(cssClass));
            next();
          });
        });
      } else {
        callback.call(e, $item.removeClass(cssClass));
        next();
      }

      event('onItemAdd', {
        target: item
      });
    });
  };
  /**
   * Swipe a list item programatically
   */


  that.swipe = function (li, percent, time, demo, callback) {
    var prevPos;
    li = getItemByID(li);
    item = li;
    demoMode = demo;
    simulating = true;
    action = true;
    time = time === undefined ? 300 : time;
    diffX = percent > 0 ? 1 : -1;
    onActionStart();
    onSwipeStart();
    slide(li, percent, time);
    clearTimeout(swipeTimeout);
    clearInterval(swipeInterval);
    swipeInterval = setInterval(function () {
      prevPos = animPos;
      animPos = getPosition(li) / itemw * 100;
      onSwipeMove(prevPos);
    }, 10);
    swipeTimeout = setTimeout(function () {
      clearInterval(swipeInterval);
      prevPos = animPos;
      animPos = percent; // We need one additional move with the final percent to get the correct stage

      onSwipeMove(prevPos);
      onSwipeEnd(callback);
      demoMode = false;
      simulating = false;
      action = false;
    }, time);
  };

  that.openStage = function (li, stage, time, demo) {
    if (stageObj[stage]) {
      that.swipe(li, stageObj[stage].percent, time, demo);
    }
  };

  that.openActions = function (li, dir, time, demo) {
    li = getItemByID(li);
    var percent = getActionWidth(types[li.attr('data-type') || 'defaults'], dir == 'left' ? -1 : 1);
    that.swipe(li, dir == 'left' ? -percent : percent, time, demo);
  };

  that.close = function (li, time) {
    that.swipe(li, 0, time);
  };
  /**
   * Remove a list item
   */


  that.remove = function (id, dir, callback, isUndo) {
    var $item, $parent, anim, index, ref, shouldNavigate, style;

    function deleteSubTree($child) {
      if ($child) {
        shouldNavigate = shouldNavigate || $child.hasClass('mbsc-lv-v');
        $child.children('[data-ref]').each(function () {
          var ref = $$1(this).attr('data-ref');

          if (treeMap[ref]) {
            deleteSubTree(treeMap[ref].child);
            delete treeMap[ref];
          }
        });
      }
    }

    callback = callback || noop;
    $item = getItemByID(id);
    ref = $item.attr('data-ref');

    if ($item.length && treeMap[ref]) {
      $parent = $item.parent();
      index = getChildren($parent).index($item);
      style = $item[0].style;
      deleteSubTree(treeMap[ref].child);

      if (shouldNavigate) {
        anim = s.animation;
        s.animation = false;
        that.navigate($item);
        s.animation = anim;
      }

      delete treeMap[ref]; // Put action in undo stack

      if (!isUndo) {
        // If undo element is removed, undo placeholder should be removed with animation
        if ($item.attr('data-ref') === undoRef) {
          undoAnim = true;
        }

        that.addUndoAction(function (next) {
          that.add(null, $item, index, next, $parent, true);
        }, true);
      }

      doAction($item, function (next) {
        dir = dir || ($item.attr('data-pos') < 0 ? 'left' : 'right');

        if (s.animateAddRemove && $parent.hasClass('mbsc-lv-v')) {
          that.animate($item.addClass('mbsc-lv-removed'), isUndo ? 'pop-out' : 'remove-' + dir, function ($item) {
            style.height = $item[0].offsetHeight + 'px';
            that.animate($item, 'collapse', function ($item) {
              style.height = '';
              resetItem($item.removeClass('mbsc-lv-removed'));

              if (callback.call(e, $item) !== false) {
                $item.remove();
              }

              next();
            });
          });
        } else {
          if (callback.call(e, $item) !== false) {
            $item.remove();
          }

          next();
        }

        event('onItemRemove', {
          target: $item[0]
        });
      });
    }
  };
  /**
   * Moves an item in the list
   */


  that.move = function (li, index, dir, callback, p, isUndo) {
    li = getItemByID(li); //if (getChildren(li.parent()).index(li) !== index) {

    if (!isUndo) {
      that.startActionTrack();
    }

    stagec.append(iconc);
    that.remove(li, dir, null, isUndo);
    that.add(null, li, index, callback, p, isUndo);

    if (!isUndo) {
      that.endActionTrack();
    } //}

  };
  /**
   * Navigate and scroll to the given element
   */


  that.navigate = function (item, callback) {
    var map, level;
    item = getItemByID(item);
    map = treeMap[item.attr('data-ref')];
    level = getItemLevel(item);

    if (map) {
      drill(level >= slideLevel ? 'r' : 'l', map.parent, item, callback, true);
      slideLevel = level;
    }
  };

  that.showLoading = function () {
    isLoading = true;
    loading.addClass('mbsc-show-lv-loading');
    wnd.scrollTop(hasContext ? wnd0.scrollHeight : $$1(s.context)[0].scrollHeight);
  };

  that.hideLoading = function () {
    loading.removeClass('mbsc-show-lv-loading'); // Needs timeout to prevent triggering 
    // the onListEnd event from the scroll listener

    setTimeout(function () {
      isLoading = false;
    }, 100);
  };

  that.select = function (item) {
    if (!multiple) {
      deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
    }

    selectItem(getItemByID(item));
  };

  that.deselect = function (item) {
    deselectItem(getItemByID(item));
  };

  that._processSettings = function () {
    if (elm.is('[mbsc-enhance]')) {
      hadEnhance = true;
      elm.removeAttr('mbsc-enhance');
    }
  };
  /**
   * Listview initialization.
   */


  that._init = function () {
    var contClass,
        headerClass,
        sortable,
        //defSortHandle = elm.find(listSelector).length ? 'left' : 'right',
    i = 0,
        icons = '',
        iconsLeft = '',
        iconsRight = '';
    listNode = s.listNode;
    listSelector = s.listSelector;
    itemNode = s.itemNode;
    itemSelector = s.itemSelector;
    multiple = s.select == 'multiple';
    selectable = s.select != 'off';
    /*
    sortable = s.sort || s.sortable || false;
     // Backward compatiblity for 'group' and sortHandle settings
    // ---
    if (sortable === 'group') {
        sortable = {
            group: false,
            multiLevel: true
        };
    }
     if (sortable === true) {
        sortable = {
            group: true,
            multiLevel: true,
            handle: s.sortHandle
        };
    }
     if (sortable && sortable.handle === undefined) {
        sortable.handle = s.sortHandle;
    }
    // ---
     if (sortable.handle) {
        handlePos = sortable.handle === true ? defSortHandle : sortable.handle;
        handleDiv = '<div class="mbsc-lv-handle-c mbsc-lv-item-h-' + handlePos + ' mbsc-lv-handle"><div class="' + s.handleClass + ' mbsc-lv-handle-bar-c mbsc-lv-handle">' + s.handleMarkup + '</div></div>';
    }
     htmlLeft = '<' + itemNode + ' class="mbsc-lv-item mbsc-lv-back mbsc-lv-item-actionable">' + s.backText + '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.leftArrowClass + '"></div></' + itemNode + '>';
    htmlRight = '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.rightArrowClass + '"></div>';
     contClass = 'mbsc-no-touch mbsc-lv-cont mbsc-lv-' + s.theme + ' mbsc-' + s.theme +
        (halfBorder ? ' mbsc-lv-hb' : '') +
        (s.rtl ? ' mbsc-lv-rtl mbsc-rtl' : ' mbsc-ltr') +
        (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') +
        (s.animateIcons ? ' mbsc-lv-ic-anim' : '') +
        (s.striped ? ' mbsc-lv-alt-row' : '') +
        (s.fixedHeader ? ' mbsc-lv-has-fixed-header' : '') +
        (sortable.handle ? ' mbsc-lv-handle-' + handlePos : '');
    */
    // --- TRIAL SERVER CODE START ---

    sortable = that.remote.listview.sortable;
    handlePos = that.remote.listview.handlePos;
    handleDiv = that.remote.listview.handleDiv;
    htmlLeft = that.remote.listview.htmlLeft;
    htmlRight = that.remote.listview.htmlRight;
    contClass = that.remote.listview.contClass; // --- TRIAL SERVER CODE END ---

    that.sortable = sortable || false;

    if (!cont) {
      // Icon menu container
      icons += '<div class="mbsc-lv-multi-c"></div>'; // Stage icons container

      icons += '<div class="mbsc-lv-ic-c"><div class="mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none"></div><div class="mbsc-lv-ic-text"></div></div>'; // Add classes

      elm.addClass('mbsc-lv mbsc-lv-v mbsc-lv-root').removeClass('mbsc-cloak').show();
      stagec = $$1('<div class="mbsc-lv-stage-c">' + icons + '</div>');
      iconc = $$1('.mbsc-lv-ic-c', stagec);
      multic = $$1('.mbsc-lv-multi-c', stagec);
      icon = $$1('.mbsc-lv-ic-s', stagec);
      text = $$1('.mbsc-lv-ic-text', stagec);
      placeholder = $$1('<' + itemNode + ' class="mbsc-lv-item mbsc-lv-ph"></' + itemNode + '>');
      fill = $$1('<div class="mbsc-lv-fill-item"></div>');
      cont = $$1('<div class="' + contClass + '"><' + listNode + ' class="mbsc-lv mbsc-lv-dummy"></' + listNode + '><div class="mbsc-lv-sl-c"></div>' + '<div class="mbsc-lv-loading"><span class="mbsc-ic mbsc-ic-' + (s.loadingIcon || 'loop2') + '"></span></div></div>');
      cont0 = cont[0];
      dummyCont = $$1('.mbsc-lv-dummy', cont);
      loading = $$1('.mbsc-lv-loading', cont);
      cont.insertAfter(elm);
      onResize(); // Slide events

      listen(cont0, 'mousedown', onStart);
      listen(cont0, 'touchstart', onStart, {
        passive: true
      });
      listen(document, 'touchmove', onMove, {
        passive: false
      });
      cont.on('touchend touchcancel', '.mbsc-lv-item', onEnd).on('click', '.mbsc-lv-item', onClick); // Prevent click on swipe

      listen(e, 'click', onListClick, true); // Init action icons
      // ---

      listen(cont0, 'mousedown', onIconStart);
      listen(document, 'touchstart', onIconStart, {
        passive: false
      });
      cont.on('touchend mouseup', '.mbsc-lv-ic-m', function (ev) {
        if (!demoMode) {
          if (ev.type === 'touchend') {
            preventClick();
          } // If movement is less than 10px, fire the click event handler


          if (confirms && !$$1(this).hasClass('mbsc-lv-ic-disabled') && Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
            runAction((animPos < 0 ? type.rightMenu : type.leftMenu)[$$1(this).index()], confirmItem, confirmIndex);
          }
        }
      }); // ---
      // Init hierarchical navigation
      // ---

      slideCont = $$1('.mbsc-lv-sl-c', cont).append(elm.addClass('mbsc-lv-sl-curr')).attr('data-ref', guid++);
      currList = elm;
      currParent = cont; // ---
    } else {
      cont.attr('class', contClass); // reinit sort handles

      $$1('.mbsc-lv-handle-c', cont).remove(); // remove to reinit list items

      $$1(itemSelector, cont).not('.mbsc-lv-back').removeClass('mbsc-lv-item');
      unlisten(wnd0, 'orientationchange', onResize);
      unlisten(wnd0, 'resize', onResize);
      unlisten(wnd0, 'scroll', onScrollBottom);
      unlisten(wnd0, 'touchmove', onScrollBottom, {
        passive: true
      });

      if (onScrollThrottle) {
        unlisten(wnd0, 'scroll', onScrollThrottle);
        unlisten(wnd0, 'touchmove', onScrollThrottle, {
          passive: true
        });
      }
    }

    hasContext = s.context !== 'body';
    wnd = $$1(hasContext ? s.context : window);
    wnd0 = wnd[0]; // Recalculate sizes on resize / orientationchange

    listen(wnd0, 'orientationchange', onResize);
    listen(wnd0, 'resize', onResize);
    listen(wnd0, 'scroll', onScrollBottom);
    listen(wnd0, 'touchmove', onScrollBottom, {
      passive: true
    }); // Init stages and actions
    // ---

    stageNr = 0;
    types = s.itemGroups || {};
    types.defaults = {
      swipeleft: s.swipeleft,
      swiperight: s.swiperight,
      stages: s.stages,
      actions: s.actions,
      actionsWidth: s.actionsWidth,
      actionable: s.actionable
    };
    initBranch(elm);
    $$1.each(types, function (n, v) {
      v.swipe = v.swipe !== undefined ? v.swipe : s.swipe;
      v.actionable = v.actionable !== undefined ? v.actionable : s.actionable;
      v.stages = v.stages || []; // Init stages

      processStages(v.stages, 1, true);
      processStages(v.stages.left, 1);
      processStages(v.stages.right, -1);

      if (v.stages.left || v.stages.right) {
        v.stages = [].concat(v.stages.left || [], v.stages.right || []);
      }

      found = false;

      if (!v.stages.length) {
        if (v.swipeleft) {
          v.stages.push({
            percent: -30,
            action: v.swipeleft
          });
        }

        if (v.swiperight) {
          v.stages.push({
            percent: 30,
            action: v.swiperight
          });
        }
      }

      $$1.each(v.stages, function (i, v) {
        // find the 0
        if (v.percent === 0) {
          found = true;
          return false;
        }
      });

      if (!found) {
        v.stages.push({
          percent: 0
        });
      }

      v.stages.sort(function (a, b) {
        return a.percent - b.percent;
      });
      $$1.each(v.stages, function (i, s) {
        // find the 0
        if (s.percent === 0) {
          v.start = i;
          return false;
        }
      });

      if (found) {
        v.left = v.right = v.stages[v.start];
      } else {
        v.left = v.stages[v.start - 1] || {};
        v.right = v.stages[v.start + 1] || {};
      } // Init actions


      if (v.actions) {
        v.leftMenu = v.actions.left || v.actions;
        v.rightMenu = v.actions.right || v.leftMenu;
        iconsLeft = '';
        iconsRight = '';

        for (i = 0; i < v.leftMenu.length; i++) {
          iconsLeft += '<div ' + (v.leftMenu[i].color ? 'style="background-color: ' + v.leftMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.leftMenu[i].icon + '">' + (v.leftMenu[i].text || '') + '</div>';
        }

        for (i = 0; i < v.rightMenu.length; ++i) {
          iconsRight += '<div ' + (v.rightMenu[i].color ? 'style="background-color: ' + v.rightMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.rightMenu[i].icon + '">' + (v.rightMenu[i].text || '') + '</div>';
        }

        if (v.actions.left) {
          v.swipe = v.actions.right ? v.swipe : 'right';
        }

        if (v.actions.right) {
          v.swipe = v.actions.left ? v.swipe : 'left';
        }

        v.icons = '<div class="mbsc-lv-multi mbsc-lv-multi-ic-left">' + iconsLeft + '</div><div class="mbsc-lv-multi mbsc-lv-multi-ic-right">' + iconsRight + '</div>';
      }
    }); // ---
    // Init fixed header
    // ---

    if (s.fixedHeader) {
      headerClass = 'mbsc-lv-fixed-header' + (hasContext ? ' mbsc-lv-fixed-header-ctx mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') : '');

      if (!groupHeader) {
        groupHeader = $$1('<div class="' + headerClass + '"></div>');
      } else {
        groupHeader.attr('class', headerClass);
        onScroll();
      }

      if (hasContext) {
        wnd.before(groupHeader);
      } else {
        cont.prepend(groupHeader);
      }

      onScrollThrottle = throttle(onScroll, 200);
      listen(wnd0, 'scroll', onScrollThrottle);
      listen(wnd0, 'touchmove', onScrollThrottle, {
        passive: true
      });
    } // ---


    if (s.hover) {
      if (!hoverTime) {
        cont.on('mouseover.mbsc-lv', '.mbsc-lv-item', function () {
          if (!hoverItem || hoverItem[0] != this) {
            onMouseLeave();
            hoverItem = $$1(this);

            if (types[hoverItem.attr('data-type') || 'defaults'].actions) {
              hoverTimer = setTimeout(function () {
                if (!preventHover) {
                  hoverItemOpened = true;
                  that.openActions(hoverItem, hoverDir, hoverTime, false);
                } else {
                  hoverItem = null;
                }
              }, hoverTimeout);
            }
          }
        }).on('mouseleave.mbsc-lv', onMouseLeave);
      }

      hoverTime = s.hover.time || 200;
      hoverTimeout = s.hover.timeout || 200;
      hoverDir = s.hover.direction || s.hover || 'right';
    }

    if (hadEnhance) {
      cont.attr('mbsc-enhance', '');
    }

    cont.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };
  /**
   * Listview destroy: removes event handlers, classes and additional markup.
   */


  that._destroy = function () {
    var form;
    currParent.append(currList);

    if (hasContext && groupHeader) {
      groupHeader.remove();
    }

    if (hadEnhance) {
      elm.attr('mbsc-enhance', ''); // Destroy form instance if any

      form = instances[cont0.id];

      if (form) {
        form.destroy();
      }
    }

    unlisten(document, 'touchstart', onIconStart, {
      passive: false
    });
    unlisten(document, 'touchmove', onMove, {
      passive: false
    });
    unlisten(e, 'click', onListClick, true);
    cont.find('.mbsc-lv-txt,.mbsc-lv-img').removeClass('mbsc-lv-txt mbsc-lv-img');
    cont.find(listSelector).removeClass('mbsc-lv mbsc-lv-v mbsc-lv-root mbsc-lv-sl-curr').find(itemSelector).removeClass('mbsc-lv-gr-title mbsc-lv-item mbsc-lv-item-enhanced mbsc-lv-parent mbsc-lv-img-left mbsc-lv-img-right mbsc-lv-item-ic-left mbsc-lv-item-ic-right').removeAttr('data-ref');
    $$1('.mbsc-lv-back,.mbsc-lv-handle-c,.mbsc-lv-arr,.mbsc-lv-item-ic', cont).remove();
    elm.insertAfter(cont);
    cont.remove();
    stagec.remove();
    unlisten(wnd0, 'orientationchange', onResize);
    unlisten(wnd0, 'resize', onResize);
    unlisten(wnd0, 'scroll', onScrollBottom);
    unlisten(wnd0, 'touchmove', onScrollBottom, {
      passive: true
    });

    if (onScrollThrottle) {
      unlisten(wnd0, 'scroll', onScrollThrottle);
      unlisten(wnd0, 'touchmove', onScrollThrottle, {
        passive: true
      });
    }
  }; // Undo manager, may be removed later in separate class
  // ---


  var undoing,
      undoQueue = [],
      undoStack = [],
      undoGroup = [],
      undoListener = 0;

  that.startActionTrack = function () {
    // Start a new undo group if not running
    if (!undoListener) {
      undoGroup = [];
    }

    undoListener++;
  };

  that.endActionTrack = function () {
    // End undo group, if this the outermost listener (undoListener counter is 0);
    undoListener--;

    if (!undoListener) {
      undoStack.push(undoGroup);
    }
  };

  that.addUndoAction = function (action, async) {
    var obj = {
      action: action,
      async: async
    }; //if (!undoing) {

    if (undoListener) {
      // Add undo action in current group, if a listener is running
      undoGroup.push(obj);
    } else {
      // Add undo action within a new group
      undoStack.push([obj]);

      if (undoStack.length > s.undoLimit) {
        undoStack.shift();
      }
    } //}

  };

  that.undo = function () {
    var action, i, group;

    function run() {
      if (i < 0) {
        undoing = false; // If there is data in the queue, keep calling the undo

        undo();
      } else {
        action = group[i];
        i--;

        if (action.async) {
          // Run action, next action must be called inside the action
          action.action(run);
        } else {
          // Run action
          action.action(); // Run next action

          run();
        }
      }
    }

    function undo() {
      group = undoQueue.shift();

      if (group) {
        undoing = true;
        i = group.length - 1; // Call actions from the group recoursively

        run();
      }
    }

    if (undoStack.length) {
      undoQueue.push(undoStack.pop());
    } // If undo is currently running, don't do anything (it will be called later from queue)


    if (!undoing) {
      undo();
    }
  }; // ---
  // Constructor


  s = that.settings;
  event = that.trigger;
  that.init();
}; // Defaults

ListView.prototype = {
  _class: 'listview',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _defaults: {
    context: 'body',
    actionsWidth: 90,
    sortDelay: 250,
    undoLimit: 10,
    tap: hasGhostClick,
    swipe: true,
    quickSwipe: true,
    animateAddRemove: true,
    animateIcons: true,
    animation: true,
    revert: true,
    vibrate: true,
    actionable: true,
    handleClass: '',
    handleMarkup: '<div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div>',
    listNode: 'ul',
    listSelector: 'ul,ol',
    itemNode: 'li',
    itemSelector: 'li',
    leftArrowClass: 'mbsc-ic-arrow-left4',
    rightArrowClass: 'mbsc-ic-arrow-right4',
    backText: 'Back',
    undoText: 'Undo',
    stages: [],
    select: 'off'
  }
};
classes.ListView = ListView;
mobiscroll.themes.listview.mobiscroll = {
  leftArrowClass: 'mbsc-ic-arrow-left5',
  rightArrowClass: 'mbsc-ic-arrow-right5'
};

var MbscListviewService = (function () {
    function MbscListviewService() {
        this.addObservable = new Observable();
        this.removeObservable = new Observable();
        this.cardObservable = new Observable();
        this.instanceObservable = new Observable();
        this.inst = null;
    }
    MbscListviewService.prototype.notifyInstanceReady = function (instance) {
        this.inst = instance;
        this.instanceObservable.next(instance);
    };
    MbscListviewService.prototype.onInstanceReady = function () {
        return this.instanceObservable;
    };
    MbscListviewService.prototype.notifyAdded = function (item, parent) {
        this.addObservable.next({ item: item, parent: parent });
    };
    MbscListviewService.prototype.notifyRemoved = function (item) {
        this.removeObservable.next(item);
    };
    MbscListviewService.prototype.notifyCardPresence = function (isCard) {
        this.cardObservable.next(isCard);
    };
    MbscListviewService.prototype.onCardContent = function () {
        return this.cardObservable;
    };
    MbscListviewService.prototype.onItemAdded = function () {
        return this.addObservable;
    };
    MbscListviewService.prototype.onItemRemoved = function () {
        return this.removeObservable;
    };
    MbscListviewService.ctorParameters = function () { return []; };
MbscListviewService.ɵfac = function MbscListviewService_Factory(t) { return new (t || MbscListviewService)(); };
MbscListviewService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscListviewService, factory: function (t) { return MbscListviewService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListviewService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscListviewService;
}());
var MbscSublistService = (function () {
    function MbscSublistService() {
        this.addObservable = new Observable();
        this.removeObserable = new Observable();
    }
    MbscSublistService.prototype.notifyAdded = function (item) {
        this.addObservable.next(item);
    };
    MbscSublistService.prototype.notifyRemoved = function (item) {
        this.removeObserable.next(item);
    };
    MbscSublistService.prototype.onItemAdded = function () {
        return this.addObservable;
    };
    MbscSublistService.prototype.onItemRemoved = function () {
        return this.removeObserable;
    };
    MbscSublistService.ctorParameters = function () { return []; };
MbscSublistService.ɵfac = function MbscSublistService_Factory(t) { return new (t || MbscSublistService)(); };
MbscSublistService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscSublistService, factory: function (t) { return MbscSublistService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSublistService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscSublistService;
}());
var MbscListitemService = (function () {
    function MbscListitemService() {
        this.sublistSubject = new Observable();
        this.inst = null;
    }
    MbscListitemService.prototype.notifySublistCreated = function (item) {
        this.sublistSubject.next(item);
    };
    MbscListitemService.prototype.onSublistCreated = function () {
        return this.sublistSubject;
    };
    MbscListitemService.ctorParameters = function () { return []; };
MbscListitemService.ɵfac = function MbscListitemService_Factory(t) { return new (t || MbscListitemService)(); };
MbscListitemService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscListitemService, factory: function (t) { return MbscListitemService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListitemService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscListitemService;
}());
var MbscListviewSublist = (function () {
    function MbscListviewSublist(parentServ, subServ, itemService) {
        this.parentServ = parentServ;
        this.subServ = subServ;
        this.itemService = itemService;
    }
    MbscListviewSublist.prototype.ngOnInit = function () {
        this.itemService.notifySublistCreated(this);
    };
    MbscListviewSublist.ctorParameters = function () { return [
        { type: MbscListviewService, },
        { type: MbscSublistService, },
        { type: MbscListitemService, },
    ]; };
MbscListviewSublist.ɵfac = function MbscListviewSublist_Factory(t) { return new (t || MbscListviewSublist)(ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService)); };
MbscListviewSublist.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscListviewSublist, selectors: [["mbsc-listview-sublist"]], features: [ɵngcc0.ɵɵProvidersFeature([MbscSublistService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscListviewSublist_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListviewSublist, [{
        type: Component,
        args: [{
                selector: 'mbsc-listview-sublist',
                template: '<ng-content></ng-content>',
                providers: [MbscSublistService]
            }]
    }], function () { return [{ type: MbscListviewService }, { type: MbscSublistService }, { type: MbscListitemService }]; }, null); })();
    return MbscListviewSublist;
}());
var MbscListviewItem = (function () {
    function MbscListviewItem(elem, lvService, lvItemService, subService) {
        var _this = this;
        this.elem = elem;
        this.lvService = lvService;
        this.lvItemService = lvItemService;
        this.subService = subService;
        this.clone = null;
        this.mounted = false;
        this.isParent = false;
        this._instance = undefined;
        this.subitemObserver = null;
        this.selectedChange = new EventEmitter();
        this.sublistObserver = lvItemService.onSublistCreated().subscribe(function (sublist) {
            _this.isParent = true;
            _this.sublist = sublist;
            _this.subitemObserver = sublist.subServ.onItemAdded().subscribe(function (subItem) {
                if (_this.mounted) {
                    _this.lvService.notifyAdded(subItem, _this);
                }
            });
        });
        this.instanceObserver = this.lvService.onInstanceReady().subscribe(function (instance) {
            _this._instance = instance;
        });
        if (lvService.inst) {
            this._instance = lvService.inst;
        }
    }
    Object.defineProperty(MbscListviewItem.prototype, "Index", {
        get: function () {
            var thisElem = $$1(this.elem.nativeElement);
            var index = thisElem.parent().children('mbsc-listview-item, mbsc-listview-header').not('.mbsc-lv-back').index(thisElem);
            return index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscListviewItem.prototype, "Element", {
        get: function () {
            return this.clone || $$1(this.elem.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    MbscListviewItem.prototype.ngAfterViewInit = function () {
        if (this.subService) {
            this.subService.notifyAdded(this);
        }
        else {
            this.lvService.notifyAdded(this);
        }
        this.mounted = true;
    };
    MbscListviewItem.prototype.ngOnDestroy = function () {
        this.lvItemService.onSublistCreated().unsubscribe(this.sublistObserver);
        this.lvService.onInstanceReady().unsubscribe(this.instanceObserver);
        if (this.subitemObserver !== null) {
            this.sublist.subServ.onItemAdded().unsubscribe(this.subitemObserver);
            this.sublist = null;
        }
        var $elm = this.Element, $clone = $elm.clone();
        if ($elm.parent().length) {
            $clone.insertBefore($elm);
            this.clone = $clone;
        }
        if (this.subService) {
            this.subService.notifyRemoved(this);
        }
        else {
            this.lvService.notifyRemoved(this);
        }
    };
    Object.defineProperty(MbscListviewItem.prototype, "selected", {
        get: function () {
            return this._selected;
        },
        set: function (v) {
            this._selected = v;
            if (this._instance) {
                if (this._selected) {
                    this._instance.select(this.elem.nativeElement);
                }
                else {
                    this._instance.deselect(this.elem.nativeElement);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscListviewItem.prototype.toggle = function () {
        this._selected = !this._selected;
        this.selectedChange.emit(this._selected);
    };
    MbscListviewItem.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscListviewService, },
        { type: MbscListitemService, },
        { type: MbscSublistService, decorators: [{ type: Optional },] },
    ]; };
    MbscListviewItem.propDecorators = {
        'id': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'type': [{ type: Input$1 },],
        'selected': [{ type: Input$1 },],
        'selectedChange': [{ type: Output },],
    };
MbscListviewItem.ɵfac = function MbscListviewItem_Factory(t) { return new (t || MbscListviewItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService, 8)); };
MbscListviewItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscListviewItem, selectors: [["mbsc-listview-item"]], hostVars: 5, hostBindings: function MbscListviewItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-id", ctx.id)("data-icon", ctx.icon)("data-icon-align", ctx.iconAlign)("data-selected", ctx.selected)("data-type", ctx.type);
    } }, inputs: { selected: "selected", id: "id", icon: "icon", iconAlign: ["icon-align", "iconAlign"], type: "type" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([MbscListitemService])], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscListviewItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListviewItem, [{
        type: Component,
        args: [{
                selector: 'mbsc-listview-item',
                template: '<ng-content></ng-content>',
                providers: [MbscListitemService],
                host: {
                    '[attr.data-id]': 'id',
                    '[attr.data-icon]': 'icon',
                    '[attr.data-icon-align]': 'iconAlign',
                    '[attr.data-selected]': 'selected',
                    '[attr.data-type]': 'type'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscListviewService }, { type: MbscListitemService }, { type: MbscSublistService, decorators: [{
                type: Optional
            }] }]; }, { selectedChange: [{
            type: Output
        }], selected: [{
            type: Input$1
        }], id: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], type: [{
            type: Input$1
        }] }); })();
    return MbscListviewItem;
}());
var MbscListviewHeader = (function (_super) {
    __extends(MbscListviewHeader, _super);
    function MbscListviewHeader(elem, lvService, itemService, subService) {
        return _super.call(this, elem, lvService, itemService, subService) || this;
    }
    MbscListviewHeader.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscListviewService, },
        { type: MbscListitemService, },
        { type: MbscSublistService, decorators: [{ type: Optional },] },
    ]; };
MbscListviewHeader.ɵfac = function MbscListviewHeader_Factory(t) { return new (t || MbscListviewHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService, 8)); };
MbscListviewHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscListviewHeader, selectors: [["mbsc-listview-header"]], hostAttrs: ["data-role", "list-divider"], hostVars: 1, hostBindings: function MbscListviewHeader_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-id", ctx.id);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([MbscListitemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscListviewHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListviewHeader, [{
        type: Component,
        args: [{
                selector: 'mbsc-listview-header',
                template: '<ng-content></ng-content>',
                providers: [MbscListitemService],
                host: {
                    '[attr.data-id]': 'id',
                    'data-role': 'list-divider'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscListviewService }, { type: MbscListitemService }, { type: MbscSublistService, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return MbscListviewHeader;
}(MbscListviewItem));
var MbscListview = (function (_super) {
    __extends(MbscListview, _super);
    function MbscListview(elem, zone, lvService, optionService) {
        var _this = _super.call(this, elem, zone) || this;
        _this.elem = elem;
        _this.lvService = lvService;
        _this.optionService = optionService;
        _this.onItemTap = new EventEmitter();
        _this.onItemAdd = new EventEmitter();
        _this.onItemRemove = new EventEmitter();
        _this.onListEnd = new EventEmitter();
        _this.onNavEnd = new EventEmitter();
        _this.onNavStart = new EventEmitter();
        _this.onSlideEnd = new EventEmitter();
        _this.onSlideStart = new EventEmitter();
        _this.onSort = new EventEmitter();
        _this.onSortChange = new EventEmitter();
        _this.onSortStart = new EventEmitter();
        _this.onSortEnd = new EventEmitter();
        _this.onSortUpdate = new EventEmitter();
        _this.onStageChange = new EventEmitter();
        _this.cardContent = false;
        _this.addObserver = lvService.onItemAdded().subscribe(function (t) {
            var item = t.item, parent = t.parent;
            if (_this.instance) {
                _this.instance.add(null, item.Element, item.Index, undefined, parent && parent.Element);
            }
        });
        _this.removeObserver = lvService.onItemRemoved().subscribe(function (item) {
            if (_this.instance) {
                _this.instance.remove(item.Element, undefined);
            }
        });
        _this.cardObserver = lvService.onCardContent().subscribe(function (isCard) {
            _this.cardContent = isCard;
        });
        return _this;
    }
    MbscListview.prototype.tapHandler = function (event, inst) {
        var selection = this.select || (inst && inst.settings.select);
        switch (selection) {
            case 'multiple': {
                var item = this._getItem(event.target);
                if (item && !item.isParent) {
                    item.toggle();
                }
                break;
            }
            case 'single': {
                var item = this._getItem(event.target);
                if (item && !item.selected) {
                    this.items.forEach(function (item) {
                        if (item.selected) {
                            item.toggle();
                        }
                    });
                    item.toggle();
                }
            }
        }
        event.inst = inst;
        this.onItemTap.emit(event);
    };
    MbscListview.prototype._getItem = function (nativeEl) {
        return this.items.find(function (item) {
            return item.elem.nativeElement === nativeEl;
        });
    };
    MbscListview.prototype.initControl = function () {
        var _this = this;
        var onItemTap = this.tapHandler.bind(this);
        var onItemTapUser = this.options && this.options.onItemTap;
        if (onItemTapUser) {
            onItemTap = function (event, inst) {
                _this.tapHandler(event, inst);
                return onItemTapUser(event, inst);
            };
        }
        var options = extend$1({
            listNode: 'mbsc-listview',
            listSelector: 'mbsc-listview, mbsc-listview-sublist',
            itemNode: 'mbsc-listview-item',
            itemSelector: 'mbsc-listview-item, mbsc-listview-header'
        }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
        this.instance = new ListView(this.elem.nativeElement, options);
        this.lvService.notifyInstanceReady(this.instance);
    };
    MbscListview.prototype.ngOnDestroy = function () {
        this.lvService.onCardContent().unsubscribe(this.cardObserver);
        this.lvService.onItemAdded().unsubscribe(this.addObserver);
        this.lvService.onItemRemoved().unsubscribe(this.removeObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscListview.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscListviewService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscListview.propDecorators = {
        'actions': [{ type: Input$1 },],
        'actionsWidth': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'striped': [{ type: Input$1 },],
        'animateAddRemove': [{ type: Input$1 },],
        'actionable': [{ type: Input$1 },],
        'animateIcons': [{ type: Input$1 },],
        'enhance': [{ type: Input$1 },],
        'fillAnimation': [{ type: Input$1 },],
        'fixedHeader': [{ type: Input$1 },],
        'hover': [{ type: Input$1 },],
        'iconSlide': [{ type: Input$1 },],
        'itemGroups': [{ type: Input$1 },],
        'loadingIcon': [{ type: Input$1 },],
        'navigateOnDrop': [{ type: Input$1 },],
        'quickSwipe': [{ type: Input$1 },],
        'select': [{ type: Input$1 },],
        'sortable': [{ type: Input$1 },],
        'sortDelay': [{ type: Input$1 },],
        'stages': [{ type: Input$1 },],
        'swipe': [{ type: Input$1 },],
        'swipeleft': [{ type: Input$1 },],
        'swiperight': [{ type: Input$1 },],
        'vibrate': [{ type: Input$1 },],
        'undoText': [{ type: Input$1 },],
        'backText': [{ type: Input$1 },],
        'onItemTap': [{ type: Output },],
        'onItemAdd': [{ type: Output },],
        'onItemRemove': [{ type: Output },],
        'onListEnd': [{ type: Output },],
        'onNavEnd': [{ type: Output },],
        'onNavStart': [{ type: Output },],
        'onSlideEnd': [{ type: Output },],
        'onSlideStart': [{ type: Output },],
        'onSort': [{ type: Output },],
        'onSortChange': [{ type: Output },],
        'onSortStart': [{ type: Output },],
        'onSortEnd': [{ type: Output },],
        'onSortUpdate': [{ type: Output },],
        'onStageChange': [{ type: Output },],
        'options': [{ type: Input$1, args: ['options',] },],
        'items': [{ type: ContentChildren, args: [MbscListviewItem, { descendants: true },] },],
    };
MbscListview.ɵfac = function MbscListview_Factory(t) { return new (t || MbscListview)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscListview.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscListview, selectors: [["mbsc-listview"]], contentQueries: function MbscListview_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscListviewItem, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostAttrs: [1, "mbsc-cloak"], hostVars: 2, hostBindings: function MbscListview_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-card-list", ctx.cardContent);
    } }, inputs: { actions: "actions", actionsWidth: "actionsWidth", context: "context", striped: "striped", animateAddRemove: "animateAddRemove", actionable: "actionable", animateIcons: "animateIcons", enhance: "enhance", fillAnimation: "fillAnimation", fixedHeader: "fixedHeader", hover: "hover", iconSlide: "iconSlide", itemGroups: "itemGroups", loadingIcon: "loadingIcon", navigateOnDrop: "navigateOnDrop", quickSwipe: "quickSwipe", select: "select", sortable: "sortable", sortDelay: "sortDelay", stages: "stages", swipe: "swipe", swipeleft: "swipeleft", swiperight: "swiperight", vibrate: "vibrate", undoText: "undoText", backText: "backText", options: "options" }, outputs: { onItemTap: "onItemTap", onItemAdd: "onItemAdd", onItemRemove: "onItemRemove", onListEnd: "onListEnd", onNavEnd: "onNavEnd", onNavStart: "onNavStart", onSlideEnd: "onSlideEnd", onSlideStart: "onSlideStart", onSort: "onSort", onSortChange: "onSortChange", onSortStart: "onSortStart", onSortEnd: "onSortEnd", onSortUpdate: "onSortUpdate", onStageChange: "onStageChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscListviewService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscListview_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListview, [{
        type: Component,
        args: [{
                selector: 'mbsc-listview',
                template: "<ng-content></ng-content>",
                providers: [MbscListviewService],
                exportAs: 'mobiscroll',
                host: {
                    'class': 'mbsc-cloak',
                    '[class.mbsc-card-list]': 'cardContent'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscListviewService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { actions: [{
            type: Input$1
        }], actionsWidth: [{
            type: Input$1
        }], context: [{
            type: Input$1
        }], striped: [{
            type: Input$1
        }], animateAddRemove: [{
            type: Input$1
        }], actionable: [{
            type: Input$1
        }], animateIcons: [{
            type: Input$1
        }], enhance: [{
            type: Input$1
        }], fillAnimation: [{
            type: Input$1
        }], fixedHeader: [{
            type: Input$1
        }], hover: [{
            type: Input$1
        }], iconSlide: [{
            type: Input$1
        }], itemGroups: [{
            type: Input$1
        }], loadingIcon: [{
            type: Input$1
        }], navigateOnDrop: [{
            type: Input$1
        }], quickSwipe: [{
            type: Input$1
        }], select: [{
            type: Input$1
        }], sortable: [{
            type: Input$1
        }], sortDelay: [{
            type: Input$1
        }], stages: [{
            type: Input$1
        }], swipe: [{
            type: Input$1
        }], swipeleft: [{
            type: Input$1
        }], swiperight: [{
            type: Input$1
        }], vibrate: [{
            type: Input$1
        }], undoText: [{
            type: Input$1
        }], backText: [{
            type: Input$1
        }], onItemTap: [{
            type: Output
        }], onItemAdd: [{
            type: Output
        }], onItemRemove: [{
            type: Output
        }], onListEnd: [{
            type: Output
        }], onNavEnd: [{
            type: Output
        }], onNavStart: [{
            type: Output
        }], onSlideEnd: [{
            type: Output
        }], onSlideStart: [{
            type: Output
        }], onSort: [{
            type: Output
        }], onSortChange: [{
            type: Output
        }], onSortStart: [{
            type: Output
        }], onSortEnd: [{
            type: Output
        }], onSortUpdate: [{
            type: Output
        }], onStageChange: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['options']
        }], items: [{
            type: ContentChildren,
            args: [MbscListviewItem, { descendants: true }]
        }] }); })();
    return MbscListview;
}(MbscBase));
var comp = [
    MbscListview,
    MbscListviewItem,
    MbscListviewHeader,
    MbscListviewSublist
];
var MbscListviewModule = (function () {
    function MbscListviewModule() {
    }
    MbscListviewModule.ctorParameters = function () { return []; };
MbscListviewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscListviewModule });
MbscListviewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscListviewModule_Factory(t) { return new (t || MbscListviewModule)(); }, imports: [[MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscListviewModule, { declarations: [MbscListview, MbscListviewItem, MbscListviewHeader, MbscListviewSublist], imports: [MbscBaseModule], exports: [MbscListview, MbscListviewItem, MbscListviewHeader, MbscListviewSublist] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscListviewModule, [{
        type: NgModule,
        args: [{
                imports: [MbscBaseModule],
                declarations: comp,
                exports: comp
            }]
    }], function () { return []; }, null); })();
    return MbscListviewModule;
}());

var MbscCard = (function (_super) {
    __extends(MbscCard, _super);
    function MbscCard(host, optionsService, lvService, zone) {
        var _this = _super.call(this, host, zone) || this;
        _this.optionsService = optionsService;
        _this.lvService = lvService;
        _this._collapsibleInput = null;
        _this._open = false;
        if (_this.lvService) {
            _this.lvService.notifyCardPresence(true);
        }
        return _this;
    }
    Object.defineProperty(MbscCard.prototype, "collapsibleInput", {
        set: function (v) {
            this._collapsibleInput = v;
            this.inlineOptionsObj.collapsible = this._open;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscCard.prototype, "open", {
        set: function (v) {
            if (this._open != v && this.instance) {
                if (v) {
                    this.instance.show();
                }
                else {
                    this.instance.hide();
                }
            }
            this._open = !!v;
            if (this._collapsibleInput !== null) {
                this.inlineOptionsObj.collapsible = this._open;
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscCard.prototype.initControl = function () {
        var options = extend$1({}, this.optionsService ? this.optionsService.options : {}, this.options, this.inlineOptionsObj);
        this.instance = new Card(this.initialElem.nativeElement, options);
    };
    MbscCard.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscListviewService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscCard.propDecorators = {
        'collapsibleInput': [{ type: Input$1, args: ['collapsible',] },],
        'open': [{ type: Input$1 },],
    };
MbscCard.ɵfac = function MbscCard_Factory(t) { return new (t || MbscCard)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscListviewService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscCard.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscCard, selectors: [["", "mbsc-card", ""]], hostAttrs: [1, "mbsc-cloak"], inputs: { collapsibleInput: ["collapsible", "collapsibleInput"], open: "open" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCard, [{
        type: Directive,
        args: [{
                selector: '[mbsc-card]',
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscListviewService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { collapsibleInput: [{
            type: Input$1,
            args: ['collapsible']
        }], open: [{
            type: Input$1
        }] }); })();
    return MbscCard;
}(MbscBase));
var MbscCardComponent = (function (_super) {
    __extends(MbscCardComponent, _super);
    function MbscCardComponent(host, optionsService, lvService, zone) {
        var _this = _super.call(this, host, optionsService, lvService, zone) || this;
        _this.optionsService = optionsService;
        return _this;
    }
    MbscCardComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscListviewService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscCardComponent.propDecorators = {
        'options': [{ type: Input$1 },],
    };
MbscCardComponent.ɵfac = function MbscCardComponent_Factory(t) { return new (t || MbscCardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscListviewService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardComponent, selectors: [["mbsc-card"]], inputs: { options: "options" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-card',
                template: '<ng-content></ng-content>',
                exportAs: 'mobiscroll',
                styles: [':host { display: block }']
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscListviewService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { options: [{
            type: Input$1
        }] }); })();
    return MbscCardComponent;
}(MbscCard));
var MbscCardHeader = (function () {
    function MbscCardHeader() {
    }
    MbscCardHeader.ctorParameters = function () { return []; };
MbscCardHeader.ɵfac = function MbscCardHeader_Factory(t) { return new (t || MbscCardHeader)(); };
MbscCardHeader.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardHeader, selectors: [["mbsc-card-header"]], hostAttrs: [1, "mbsc-card-header"], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardHeader, [{
        type: Component,
        args: [{
                selector: 'mbsc-card-header',
                template: '<ng-content></ng-content>',
                styles: [':host { display: block; }'],
                host: {
                    'class': 'mbsc-card-header'
                }
            }]
    }], function () { return []; }, null); })();
    return MbscCardHeader;
}());
var MbscCardContent = (function () {
    function MbscCardContent() {
    }
    MbscCardContent.ctorParameters = function () { return []; };
MbscCardContent.ɵfac = function MbscCardContent_Factory(t) { return new (t || MbscCardContent)(); };
MbscCardContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardContent, selectors: [["mbsc-card-content"]], hostAttrs: [1, "mbsc-card-content"], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardContent, [{
        type: Component,
        args: [{
                selector: 'mbsc-card-content',
                template: '<ng-content></ng-content>',
                styles: [':host { display: block; }'],
                host: {
                    'class': 'mbsc-card-content'
                }
            }]
    }], function () { return []; }, null); })();
    return MbscCardContent;
}());
var MbscCardFooter = (function () {
    function MbscCardFooter() {
    }
    MbscCardFooter.ctorParameters = function () { return []; };
MbscCardFooter.ɵfac = function MbscCardFooter_Factory(t) { return new (t || MbscCardFooter)(); };
MbscCardFooter.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardFooter, selectors: [["mbsc-card-footer"]], hostAttrs: [1, "mbsc-card-footer"], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardFooter_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardFooter, [{
        type: Component,
        args: [{
                selector: 'mbsc-card-footer',
                template: '<ng-content></ng-content>',
                styles: [':host { display: block; }'],
                host: {
                    'class': 'mbsc-card-footer'
                }
            }]
    }], function () { return []; }, null); })();
    return MbscCardFooter;
}());
var MbscCardTitle = (function () {
    function MbscCardTitle() {
    }
    MbscCardTitle.ctorParameters = function () { return []; };
MbscCardTitle.ɵfac = function MbscCardTitle_Factory(t) { return new (t || MbscCardTitle)(); };
MbscCardTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardTitle, selectors: [["mbsc-card-title"]], hostAttrs: [1, "mbsc-card-title"], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardTitle, [{
        type: Component,
        args: [{
                selector: 'mbsc-card-title',
                template: '<ng-content></ng-content>',
                styles: [':host { display: block; }'],
                host: {
                    'class': 'mbsc-card-title'
                }
            }]
    }], function () { return []; }, null); })();
    return MbscCardTitle;
}());
var MbscCardSubtitle = (function () {
    function MbscCardSubtitle() {
    }
    MbscCardSubtitle.ctorParameters = function () { return []; };
MbscCardSubtitle.ɵfac = function MbscCardSubtitle_Factory(t) { return new (t || MbscCardSubtitle)(); };
MbscCardSubtitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCardSubtitle, selectors: [["mbsc-card-subtitle"]], hostAttrs: [1, "mbsc-card-subtitle"], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscCardSubtitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardSubtitle, [{
        type: Component,
        args: [{
                selector: 'mbsc-card-subtitle',
                template: '<ng-content></ng-content>',
                styles: [':host { display: block; }'],
                host: {
                    'class': 'mbsc-card-subtitle'
                }
            }]
    }], function () { return []; }, null); })();
    return MbscCardSubtitle;
}());
var comp$1 = [
    MbscCard, MbscCardComponent,
    MbscCardHeader, MbscCardContent, MbscCardFooter,
    MbscCardTitle, MbscCardSubtitle
];
var MbscCardModule = (function () {
    function MbscCardModule() {
    }
    MbscCardModule.ctorParameters = function () { return []; };
MbscCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscCardModule });
MbscCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscCardModule_Factory(t) { return new (t || MbscCardModule)(); }, imports: [[MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCardModule, { declarations: [MbscCard, MbscCardComponent, MbscCardHeader, MbscCardContent, MbscCardFooter, MbscCardTitle, MbscCardSubtitle], imports: [MbscBaseModule], exports: [MbscCard, MbscCardComponent, MbscCardHeader, MbscCardContent, MbscCardFooter, MbscCardTitle, MbscCardSubtitle] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCardModule, [{
        type: NgModule,
        args: [{
                imports: [MbscBaseModule],
                declarations: comp$1,
                exports: comp$1
            }]
    }], function () { return []; }, null); })();
    return MbscCardModule;
}());

/**
 * Convert rgb color to hex
 */

function rgb2hex(rgb) {
  var hex = [Math.round(rgb.r).toString(16), Math.round(rgb.g).toString(16), Math.round(rgb.b).toString(16)];
  $$1.each(hex, function (nr, val) {
    if (val.length == 1) {
      hex[nr] = '0' + val;
    }
  });
  return '#' + hex.join('');
}
/**
 * Convert hex color to rgb
 */


function hex2rgb(hex) {
  hex = parseInt(hex.indexOf('#') > -1 ? hex.substring(1) : hex, 16);
  return {
    r: hex >> 16,
    g: (hex & 0x00FF00) >> 8,
    b: hex & 0x0000FF,
    toString: function toString() {
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    }
  };
}
/**
 * Convert hsv color to rgb
 */


function hsv2rgb(hsv) {
  var r,
      g,
      b,
      h = hsv.h,
      s = hsv.s * 255 / 100,
      v = hsv.v * 255 / 100;

  if (s === 0) {
    r = g = b = v;
  } else {
    var t1 = v,
        t2 = (255 - s) * v / 255,
        t3 = (t1 - t2) * (h % 60) / 60;

    if (h == 360) {
      h = 0;
    }

    if (h < 60) {
      r = t1;
      b = t2;
      g = t2 + t3;
    } else if (h < 120) {
      g = t1;
      b = t2;
      r = t1 - t3;
    } else if (h < 180) {
      g = t1;
      r = t2;
      b = t2 + t3;
    } else if (h < 240) {
      b = t1;
      r = t2;
      g = t1 - t3;
    } else if (h < 300) {
      b = t1;
      g = t2;
      r = t2 + t3;
    } else if (h < 360) {
      r = t1;
      g = t2;
      b = t1 - t3;
    } else {
      r = g = b = 0;
    }
  }

  return {
    r: r,
    g: g,
    b: b,
    toString: function toString() {
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    }
  };
}
/**
 * Convert rgb color to hsv
 */


function rgb2hsv(rgb) {
  var h = 0,
      s,
      v,
      min = Math.min(rgb.r, rgb.g, rgb.b),
      max = Math.max(rgb.r, rgb.g, rgb.b),
      delta = max - min;
  v = max;
  s = max ? 255 * delta / max : 0;

  if (s) {
    if (rgb.r == max) {
      h = (rgb.g - rgb.b) / delta;
    } else if (rgb.g == max) {
      h = 2 + (rgb.b - rgb.r) / delta;
    } else {
      h = 4 + (rgb.r - rgb.g) / delta;
    }
  } else {
    h = -1;
  }

  h *= 60;

  if (h < 0) {
    h += 360;
  }

  s *= 100 / 255;
  v *= 100 / 255;
  return {
    h: h,
    s: s,
    v: v,
    toString: function toString() {
      return 'hsv(' + Math.round(this.h) + ',' + Math.round(this.s) + '%,' + Math.round(this.v) + '%)';
    }
  };
}
/**
 * Convert rgb color to hsl
 */


function rgb2hsl(rgb) {
  var r = rgb.r / 255,
      g = rgb.g / 255,
      b = rgb.b / 255,
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      l = (max + min) / 2,
      h,
      s;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100),
    toString: function toString() {
      return 'hsl(' + this.h + ',' + this.s + '%,' + this.l + '%)';
    }
  };
}
/**
 * Convert hsl color to rgb
 */


function hsl2rgb(hsl) {
  var r,
      g,
      b,
      m,
      c,
      x,
      h = hsl.h,
      s = hsl.s,
      l = hsl.l;

  if (!isFinite(h)) {
    h = 0;
  }

  if (!isFinite(s)) {
    s = 0;
  }

  if (!isFinite(l)) {
    l = 0;
  }

  h /= 60;

  if (h < 0) {
    h = 6 - -h % 6;
  }

  h %= 6;
  s = Math.max(0, Math.min(1, s / 100));
  l = Math.max(0, Math.min(1, l / 100));
  c = (1 - Math.abs(2 * l - 1)) * s;
  x = c * (1 - Math.abs(h % 2 - 1));

  if (h < 1) {
    r = c;
    g = x;
    b = 0;
  } else if (h < 2) {
    r = x;
    g = c;
    b = 0;
  } else if (h < 3) {
    r = 0;
    g = c;
    b = x;
  } else if (h < 4) {
    r = 0;
    g = x;
    b = c;
  } else if (h < 5) {
    r = x;
    g = 0;
    b = c;
  } else {
    r = c;
    g = 0;
    b = x;
  }

  m = l - c / 2;
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255),
    toString: function toString() {
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    }
  };
}
/**
 * Convert hex color to hsl
 */


function hex2hsl(hex) {
  return rgb2hsl(hex2rgb(hex));
}
/**
 * Convert hsl color to hex
 */


function hsl2hex(hsl) {
  return rgb2hex(hsl2rgb(hsl));
}
/**
 * Convert hsv color to hex
 */


function hsv2hex(hsv) {
  return rgb2hex(hsv2rgb(hsv));
}
/**
 * Convert hex color to hsv
 */


function hex2hsv(hex) {
  return rgb2hsv(hex2rgb(hex));
}

var Color = function Color(el, settings, inherit) {
  var s,
      def,
      tempColors,
      trigger,
      scrollView,
      previewScrollView,
      hasClear,
      currValue,
      currHslValue,
      isHorizontalScroll,
      hasPreview,
      sliderTrack,
      refineMode,
      rowItems,
      slider,
      colorIndex,
      enhanceInput,
      singleSelect,
      maxSelect,
      returnObj,
      $input,
      $colorItems,
      $colorPreviewItems,
      $currItem,
      $sliderElm,
      that = this,
      $elm = $$1(el),
      colorPreviewInd = 0,
      previewValues = {},
      tempPreviewValues = {};

  function setValue(fill, change, temp) {
    if (!temp) {
      that._value = that._hasValue ? that._tempValue.slice(0) : null;

      for (var i = 0; i < tempColors.length; ++i) {
        if (tempColors[i].tempChangedColor && that._value && that._value.indexOf(tempColors[i].tempChangedColor) != -1) {
          // set changed color if was set
          tempColors[i].changedColor = tempColors[i].tempChangedColor;
        } // else if (tempColors[i].changedColor && that._value.indexOf(tempColors[i].changedColor) == -1) { // delete changed color if was unset
        //    delete tempColors[i].changedColor;
        //}


        delete tempColors[i].tempChangedColor;
      }
    }

    if (fill) {
      if (that._isInput) {
        $elm.val(that._hasValue ? that._tempValue : '');
      }

      trigger('onFill', {
        valueText: that._hasValue ? that._tempValue : '',
        change: change
      });

      if (change) {
        previewValues = extend$1(true, {}, tempPreviewValues);
        that._preventChange = true;
        $elm.trigger('change');
      }

      refreshSelectedValues(that._value, true);
    }
  }

  function getInputColorItem(value, index) {
    index = index !== undefined ? index : getColorIndex(value);
    return '<div class="mbsc-color-input-item" data-color="' + (index !== undefined ? index : value) + '" style="background: ' + value + ';">' + (singleSelect ? '' : '<div class="mbsc-color-input-item-close mbsc-ic mbsc-ic-material-close"></div>') + '</div>';
  }

  function changeSliderStepsColor(color) {
    sliderTrack[0].style.background = color ? cssPrefix + 'linear-gradient(left, ' + (s.rtl ? '#000000' : '#FFFFFF') + ' 0%, ' + color + ' 50%, ' + (s.rtl ? '#FFFFFF' : '#000000') + ' 100%)' : '';
  }

  function getColorIndex(color) {
    if (Object.keys(tempPreviewValues).length && !isNaN(color)) {
      return color;
    }

    for (var c in tempColors) {
      if (color == tempColors[c].color || color == tempColors[c].changedColor) {
        return c;
      }
    }
  }

  function generateInputItems() {
    if (enhanceInput) {
      var i,
          inputColorItems = '';
      $input.empty();

      if (that._hasValue) {
        if (singleSelect) {
          inputColorItems += getInputColorItem(that._value, colorIndex);
        } else {
          for (i = 0; i < that._value.length; ++i) {
            inputColorItems += getInputColorItem(that._value[i], Object.keys(tempPreviewValues).length && tempPreviewValues[i].colorIndex ? tempPreviewValues[i].colorIndex : getColorIndex(that._value[i]));
          }
        }

        $input.append(inputColorItems);
        that.tap($$1('.mbsc-color-input-item', $input), function (ev) {
          if ($$1(ev.target).hasClass('mbsc-color-input-item-close')) {
            var indx = $$1(this).index();
            ev.stopPropagation();
            ev.preventDefault();

            if (colorIndex === undefined) {
              colorIndex = $$1(ev.target).parent().attr('data-color');
            }

            if (hasPreview && tempColors[colorIndex]) {
              colorPreviewInd = tempColors[colorIndex].previewInd;
              $colorPreviewItems.eq(colorPreviewInd).parent().removeClass('mbsc-color-active');
              previewValues[indx] = {};
              tempPreviewValues[indx] = {};
            }

            that._value.splice(indx, 1);

            that.setVal(that._value, true, true);
          } else if (refineMode && s.display !== 'inline') {
            colorIndex = $$1(ev.target).attr('data-color');

            if (isNaN(colorIndex)) {
              colorIndex = getColorIndex(colorIndex);
            }

            if (colorIndex && tempColors[colorIndex]) {
              tempColors[colorIndex].selected = true;
              colorPreviewInd = tempColors[colorIndex].previewInd; // scroll to view, if the selected color is not resent in the view

              setTimeout(function () {
                scrollView.scroll($colorItems.eq(colorIndex), 400);

                if (hasPreview) {
                  previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd), 400);
                }
              }, 200);
            }
          }
        });
      }
    }
  }

  function convertToFormat(color, type) {
    var colorHex,
        colorValues = color.match(/\d+/gmi);

    switch (true) {
      case color.indexOf('rgb') > -1:
        colorHex = rgb2hex({
          r: colorValues[0],
          g: colorValues[1],
          b: colorValues[2]
        });
        break;

      case color.indexOf('hsl') > -1:
        colorHex = hsl2hex({
          h: colorValues[0],
          s: colorValues[1],
          l: colorValues[2]
        });
        break;

      case color.indexOf('hsv') > -1:
        colorHex = hsv2hex({
          h: colorValues[0],
          s: colorValues[1],
          v: colorValues[2]
        });
        break;

      case color.indexOf('#') > -1:
        colorHex = color;
        break;
    }

    return convertFromHex(colorHex, type || s.format);
  }

  function convertFromHex(color, type) {
    switch (type) {
      case 'rgb':
        return hex2rgb(color);

      case 'hsl':
        return hex2hsl(color);

      case 'hsv':
        return hex2hsv(color);

      default:
        return color;
    }
  }

  function getFirstEmptyPreviewIndex() {
    var i;

    for (i = 0; i < s.select; ++i) {
      if (tempPreviewValues[i].colorIndex === undefined) {
        return i;
      }
    }
  }

  function highlightActiveColor($color, ctx) {
    $$1('.mbsc-color-active', ctx).removeClass('mbsc-color-active');

    if (refineMode) {
      $color.parent().addClass('mbsc-color-active');

      if (hasPreview && $color) {
        if (colorPreviewInd !== undefined) {
          $colorPreviewItems.eq(colorPreviewInd).parent().addClass('mbsc-color-active');
        }
      }
    }
  }

  function refreshSelectedValues(newtempColors, updateInput) {
    var i,
        temp,
        indexes = [],
        prevInd = 0,
        colorValues = $$1.map(tempColors, function (v) {
      return v.changedColor || v.color;
    }); // check the indexes in the tempColors

    if (singleSelect) {
      newtempColors = $$1.isArray(newtempColors) ? newtempColors[0] : newtempColors;
      temp = colorValues.indexOf(newtempColors);

      if (temp > -1) {
        indexes.push(temp);
      }

      if (newtempColors && !indexes.length && refineMode) {
        var inputIndex = +$$1('.mbsc-color-input-item', $input).attr('data-color');

        if (isNaN(inputIndex)) {
          inputIndex = undefined;
        } else {
          indexes.push(inputIndex);
        }

        colorIndex = inputIndex;
      }
    } else if (newtempColors) {
      if (hasPreview && refineMode) {
        for (var c in previewValues) {
          if (previewValues[c].colorIndex !== undefined) {
            indexes.push(+previewValues[c].colorIndex);
          }
        }
      } else {
        for (i = 0; i < newtempColors.length; ++i) {
          temp = colorValues.indexOf(newtempColors[i]);

          if (temp > -1) {
            indexes.push(temp);
            colorValues[temp] = 'temp' + i;
          }
        }
      }
    } // loop trough new color indexes and check the colors


    for (i = 0; i < indexes.length; ++i) {
      if (tempColors[indexes[i]]) {
        toggleColor(true, indexes[i], prevInd++, tempColors[indexes[i]].changedColor || tempColors[indexes[i]].color, true);
      }
    } // loop trough other color indexes and uncheck the colors


    for (i = 0; i < tempColors.length; ++i) {
      if (indexes.indexOf(i) == -1) {
        toggleColor(false, i, undefined, tempColors[i].changedColor || tempColors[i].color, false);
      }
    } // generate new preview object


    if (hasPreview) {
      for (i = prevInd; i < s.select; ++i) {
        tempPreviewValues[i] = {};

        if ($colorPreviewItems) {
          $colorPreviewItems.eq(i).addClass('mbsc-color-preview-item-empty').css({
            background: 'transparent'
          });
        }
      }
    }

    previewValues = extend$1(true, {}, tempPreviewValues);

    if (updateInput !== false) {
      generateInputItems();
    }
  }

  function toggleColor(add, colorIndex, colorPreviewInd, currValue, updatePreview, updateValue) {
    if (hasPreview && updatePreview) {
      tempPreviewValues[colorPreviewInd].colorIndex = add ? colorIndex : undefined;
      tempPreviewValues[colorPreviewInd].color = add ? currValue : undefined;

      if ($colorPreviewItems) {
        var colorPrevItem = $colorPreviewItems.eq(colorPreviewInd);
        colorPrevItem.removeClass('mbsc-color-preview-item-empty').css({
          background: add ? currValue : 'transparent'
        });

        if (!add) {
          colorPrevItem.addClass('mbsc-color-preview-item-empty').parent().removeClass('mbsc-color-active');
        }
      }
    }

    if (updateValue) {
      if (add) {
        that._tempValue.splice(colorPreviewInd, 0, currValue);
      } else {
        that._tempValue.splice(that._tempValue.indexOf(currValue), 1);
      }
    }

    if ($colorItems) {
      if (add) {
        $colorItems.eq(colorIndex).addClass('mbsc-color-selected');
      } else {
        $colorItems.eq(colorIndex).removeClass('mbsc-color-selected').parent().removeClass('mbsc-color-active');
      }
    }

    tempColors[colorIndex].previewInd = add ? colorPreviewInd : undefined;
    tempColors[colorIndex].selected = add;
  }

  function setDefaultValues(colorInd, ctx) {
    if (colorInd !== undefined && (singleSelect || tempColors[colorInd] && tempColors[colorInd].selected)) {
      colorIndex = colorInd;

      if (tempColors[colorInd]) {
        currValue = tempColors[colorInd].changedColor || tempColors[colorInd].color;
        $currItem = $colorItems.eq(colorInd); // refresh slider tempColors

        if (refineMode) {
          highlightActiveColor($colorItems.eq(colorInd), ctx || '');
          currHslValue = convertToFormat(tempColors[colorInd].color, 'hsl');
          currHslValue.l = convertToFormat(currValue, 'hsl').l;
          changeSliderStepsColor(tempColors[colorInd].color);
          slider.setVal(100 - currHslValue.l, false, false);
        }
      }
    } else if (refineMode) {
      changeSliderStepsColor();
    }
  }

  function getColorObjects() {
    var i,
        arr = [];

    for (i = 0; i < tempColors.length; ++i) {
      if (tempColors[i].selected) {
        arr.push(tempColors[i]);
      }
    }

    return arr;
  }

  function colorPreviewTap(ev, $m) {
    var index = $$1(ev.target).index();
    colorIndex = tempPreviewValues[index].colorIndex;
    $currItem = $colorItems.eq(colorIndex); // refresh values

    colorPreviewInd = index;
    setDefaultValues(colorIndex, $m);
    scrollView.scroll($currItem, 250);
    trigger('onPreviewItemTap', {
      target: ev.target,
      value: tempPreviewValues[index].color,
      index: index
    });
  }

  function colorTap(ev, $m) {
    var hasSelect = false,
        $selectedtempColors = $$1('.mbsc-color-selected', $m);
    $currItem = $$1(ev.target);

    if ($currItem.hasClass('mbsc-color-clear-item')) {
      currValue = '';
      that.clear();
      return;
    }

    if ((singleSelect || maxSelect > +$selectedtempColors.length || $currItem.hasClass('mbsc-color-selected')) && mobiscroll.EmtjC) {
      colorIndex = $currItem.attr('data-index');

      if (hasPreview) {
        colorPreviewInd = tempColors[colorIndex].previewInd !== undefined ? tempColors[colorIndex].previewInd : getFirstEmptyPreviewIndex();
        hasSelect = refineMode && $currItem.hasClass('mbsc-color-selected') && !$currItem.parent().hasClass('mbsc-color-active'); // scroll to the preview color

        if ($colorPreviewItems.length > 6) {
          previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd));
        }
      }

      currValue = tempColors[colorIndex].changedColor || tempColors[colorIndex].color;

      if (singleSelect) {
        $selectedtempColors.removeClass('mbsc-color-selected');
        that._tempValue = currValue;

        if (currValue) {
          $currItem.toggleClass('mbsc-color-selected');
        }

        highlightActiveColor($currItem, $m);
      } else {
        highlightActiveColor($currItem, $m);

        if (!hasSelect) {
          toggleColor(!tempColors[colorIndex].selected, colorIndex, colorPreviewInd, currValue, true, true);
        }
      }

      setDefaultValues(colorIndex, $m);

      if (that.live) {
        that._fillValue();

        trigger('onSet', {
          value: that._value
        });
      }

      trigger('onItemTap', {
        target: ev.target,
        value: currValue,
        selected: tempColors[colorIndex].selected,
        index: colorIndex
      });

      that._updateHeader();
    }
  } // Call the parent constructor


  Frame.call(this, el, settings, true); // Public functions

  /**
   * Sets the value
   */

  that.setVal = that._setVal = function (val, fill, change, temp) {
    that._hasValue = val !== null && val !== undefined;
    that._tempValue = singleSelect ? $$1.isArray(val) ? val[0] : val : $$1.isArray(val) ? val : val ? [val] : [];
    setValue(fill, change === undefined ? fill : change, temp);
  };
  /**
   * Returns the selected value
   */


  that.getVal = that._getVal = function (temp) {
    return that._hasValue || temp ? returnObj ? getColorObjects() : that[temp ? '_tempValue' : '_value'] : null;
  };

  that._readValue = function () {
    var v = $elm.val() || '';
    that._hasValue = false;

    if (v.length !== 0 && v !== '') {
      that._hasValue = true;
    }

    if (that._hasValue) {
      that._tempValue = singleSelect ? v : s.format == 'hex' ? v.split(',') : v.match(/[a-z]{3}\((\d+\.?\d{0,}?),\s*([\d.]+)%{0,},\s*([\d.]+)%{0,}\)/gmi);
      setValue(true);
    } else {
      that._tempValue = [];
    }

    refreshSelectedValues(that._tempValue, that._hasValue);
  };

  that._fillValue = function () {
    that._hasValue = true;
    setValue(true, true);
  };

  that._generateContent = function () {
    var i,
        html,
        currColor,
        colorOffset = hasClear ? 1 : 0;
    rowItems = isHorizontalScroll ? Math.ceil((tempColors.length + colorOffset) / s.rows) : s.rows; // generate color content

    html = '<div class="mbsc-color-scroll-cont mbsc-w-p ' + (isHorizontalScroll ? '' : 'mbsc-color-vertical') + '"><div class="mbsc-color-cont">' + (isHorizontalScroll ? '<div class="mbsc-color-row">' : '');

    for (i = 0; i < tempColors.length; ++i) {
      currColor = tempColors[i].changedColor || tempColors[i].color;

      if (hasClear && i === 0) {
        html += '<div class="mbsc-color-item-c"><div tabindex="0" class="mbsc-color-clear-item mbsc-btn-e mbsc-color-selected"><div class="mbsc-color-clear-cross"></div></div></div>';
      }

      if (i !== 0 && (i + colorOffset) % rowItems === 0) {
        html += isHorizontalScroll ? '</div><div class="mbsc-color-row">' : '';
      }

      html += '<div class="mbsc-color-item-c"><div tabindex="0" data-index="' + i + '" class="mbsc-color-item mbsc-btn-e mbsc-ic mbsc-ic-material-check mbsc-color-btn-e ' + (tempColors[i].selected ? 'mbsc-color-selected' : '') + '"  style="background:' + currColor + '"></div>' + that._getText(mobiscroll, 0.2) + '</div>';
    }

    html += '</div></div>' + (isHorizontalScroll ? '</div>' : '');

    if (refineMode) {
      // add refine slider 
      html += '<div class="mbsc-color-slider-cont"><input class="mbsc-color-slider" type="range" data-highlight="false" value="50" min="0" max="100"/></div>';
    } // add preview container 


    if (hasPreview) {
      html += '<div class="mbsc-color-preview-cont"><div class="mbsc-color-refine-preview">';

      for (var c in previewValues) {
        html += '<div class="mbsc-color-preview-item-c mbsc-btn-e mbsc-color-btn-e" tabindex="0"><div class="mbsc-color-preview-item ' + (previewValues[c].color ? '' : 'mbsc-color-preview-item-empty') + '" style="background: ' + (previewValues[c].color || 'initial') + ';"></div></div>';
      }

      html += '</div></div>';
    }

    return html;
  };

  that._position = function ($m) {
    var colorCont, colorItemWidth;

    if (!isHorizontalScroll) {
      colorCont = $m.find('.mbsc-color-cont');
      colorItemWidth = Math.ceil(colorCont.find('.mbsc-color-item-c')[0].offsetWidth);
      colorCont.width(Math.min(Math.floor($m.find('.mbsc-fr-c').width() / colorItemWidth), Math.round(tempColors.length / s.rows)) * colorItemWidth + 1);
    }

    if (scrollView) {
      scrollView.refresh();
    }

    if (previewScrollView) {
      previewScrollView.refresh();
    }
  };

  that._markupInserted = function ($markup) {
    if (!isHorizontalScroll) {
      $markup.find('.mbsc-color-scroll-cont').css('max-height', $markup.find('.mbsc-color-item-c')[0].offsetHeight * s.rows);
    } // init color scrollView


    scrollView = new ScrollViewBase($markup.find('.mbsc-color-scroll-cont')[0], {
      axis: isHorizontalScroll ? 'X' : 'Y',
      rtl: s.rtl,
      elastic: 60,
      stopProp: false,
      mousewheel: s.mousewheel,
      onBtnTap: function onBtnTap(ev) {
        colorTap(ev, $markup);
      }
    });
  };

  that._attachEvents = function ($markup) {
    var modifiedColor;
    $colorItems = $$1('.mbsc-color-item', $markup); // handle color selection with space

    $markup.on('keydown', '.mbsc-color-btn-e', function (ev) {
      ev.stopPropagation();

      if (ev.keyCode == 32) {
        // Space 
        if (ev.target.classList.contains('mbsc-color-item')) {
          colorTap(ev, $markup);
        } else {
          colorPreviewTap(ev, $markup);
        }
      }
    });

    if (hasPreview) {
      $colorPreviewItems = $$1('.mbsc-color-preview-item', $markup);
    } // refine mode 


    if (refineMode) {
      $markup.addClass('mbsc-color-refine');
      $sliderElm = $$1('.mbsc-color-slider', $markup);
      slider = new Slider($sliderElm[0], {
        theme: s.theme,
        rtl: s.rtl
      });
      sliderTrack = $markup.find('.mbsc-progress-track'); // change slider track step color

      if (colorIndex && that._value) {
        setDefaultValues(colorIndex, $markup);
      }

      $sliderElm.on('change', function () {
        if (colorIndex !== undefined && (singleSelect || tempColors[colorIndex] && tempColors[colorIndex].selected)) {
          currHslValue.l = 100 - this.value;
          modifiedColor = convertToFormat(currHslValue.toString()).toString();

          if (singleSelect) {
            that._tempValue = modifiedColor;
          } else {
            that._tempValue[colorPreviewInd !== undefined ? colorPreviewInd : that._tempValue.length] = modifiedColor;
          }

          tempColors[colorIndex].tempChangedColor = modifiedColor;
          $colorItems.eq(colorIndex).css('background', modifiedColor);

          if (hasPreview) {
            tempPreviewValues[colorPreviewInd].color = modifiedColor;
            $colorPreviewItems.eq(colorPreviewInd).removeClass('mbsc-color-preview-item-empty').css({
              'background': modifiedColor
            });
          }

          if (that.live) {
            throttle(that._fillValue());
          }
        }
      });
    }

    if (hasPreview) {
      // init colorprevirew scrollview
      previewScrollView = new ScrollViewBase($markup.find('.mbsc-color-preview-cont')[0], {
        axis: 'X',
        rtl: s.rtl,
        stopProp: false,
        mousewheel: s.mousewheel,
        onBtnTap: function onBtnTap(ev) {
          colorPreviewTap(ev, $markup);
        }
      });
    }

    that._updateHeader();
  };

  that._markupRemove = function () {
    if (scrollView) {
      scrollView.destroy();
    }

    if (slider) {
      slider.destroy();
    }

    if (previewScrollView) {
      previewScrollView.destroy();
    }
  };

  that.__processSettings = function () {
    var i, data;
    s = that.settings;
    trigger = that.trigger;
    isHorizontalScroll = s.navigation == 'horizontal';
    that._value = [];
    that._tempValue = [];
    singleSelect = s.select == 'single';
    hasClear = s.clear !== undefined ? s.clear : singleSelect;
    data = s.data || [];

    if (!data.length) {
      switch (s.format) {
        case 'rgb':
          data = ["rgb(255,235,60)", "rgb(255,153,0)", "rgb(244,68,55)", "rgb(234,30,99)", "rgb(156,38,176)", "rgb(104,58,183)", "rgb(63,81,181)", "rgb(33,150,243)", "rgb(0,151,136)", "rgb(75,175,79)", "rgb(126,93,78)", "rgb(158,158,158)"];

          if (hasClear) {
            data.splice(10, 0, 'rgb(83, 71, 65)');
          }

          break;

        case 'hsl':
          data = ["hsl(54,100%,62%)", "hsl(36,100%,50%)", "hsl(4,90%,59%)", "hsl(340,83%,52%)", "hsl(291,64%,42%)", "hsl(262,52%,47%)", "hsl(231,48%,48%)", "hsl(207,90%,54%)", "hsl(174,100%,30%)", "hsl(122,40%,49%)", "hsl(19,24%,40%)", "hsl(0,0%,62%)"];

          if (hasClear) {
            data.splice(10, 0, 'hsl(20, 12%, 29%)');
          }

          break;

        default:
          data = ['#ffeb3c', '#ff9900', '#f44437', '#ea1e63', '#9c26b0', '#683ab7', '#3f51b5', '#2196f3', '#009788', '#4baf4f', '#7e5d4e', '#9e9e9e'];

          if (hasClear) {
            data.splice(10, 0, '#534741');
          }

      }
    }

    refineMode = s.mode == 'refine';
    hasPreview = !isNaN(s.select);
    maxSelect = isNaN(s.select) ? singleSelect ? 2 : data.length : s.select;
    returnObj = $$1.isPlainObject(data[0]); // generate preview object

    if (hasPreview && !Object.keys(previewValues).length) {
      for (i = 0; i < s.select; ++i) {
        previewValues[i] = {};
        tempPreviewValues[i] = {};
      }
    }

    tempColors = data.slice(0); // convert tempColors into objects

    for (i = 0; i < tempColors.length; ++i) {
      if (!$$1.isPlainObject(data[i])) {
        data[i] = data[i].toLowerCase();
        tempColors[i] = {
          key: i,
          name: data[i],
          color: data[i]
        };
      } else {
        tempColors[i].color = data[i].color;
      }
    }

    def = s.defaultValue || tempColors[0].color;
    currValue = def;
    currHslValue = convertToFormat(currValue, 'hsl');
    enhanceInput = s.enhance && $elm.is('input'); // Create dummy input

    if (enhanceInput) {
      if ($elm.hasClass('mbsc-color-input-hdn')) {
        $input = $elm.prev();
      } else {
        $input = $$1('<div ' + (el.placeholder ? 'data-placeholder="' + el.placeholder + '"' : '') + ' class="mbsc-control mbsc-color-input ' + (s.inputClass || '') + '" readonly ></div>');
        $input.insertBefore($elm);
        $elm.addClass('mbsc-color-input-hdn').attr('tabindex', -1);
      }

      s.anchor = $input;
      that.attachShow($input);
    }
  };

  that.__destroy = function () {
    if (enhanceInput) {
      $elm.removeClass('mbsc-color-input-hdn');
      $input.remove();
    }
  };

  that._checkSize = true; // Constructor

  if (!inherit) {
    that.init();
  }
}; // Extend defaults

Color.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'color',
  _defaults: extend$1({}, Frame.prototype._defaults, {
    headerText: false,
    validate: noop,
    parseValue: noop,
    enhance: true,
    rows: 2,
    select: 'single',
    format: 'hex',
    navigation: 'horizontal',
    compClass: 'mbsc-color'
  })
};
classes.Color = Color;
mobiscroll.themes.color = mobiscroll.themes.frame; // Expose utility functions

util.color = {
  hsv2hex: hsv2hex,
  hsv2rgb: hsv2rgb,
  rgb2hsv: rgb2hsv,
  rgb2hex: rgb2hex,
  rgb2hsl: rgb2hsl,
  hex2rgb: hex2rgb,
  hex2hsv: hex2hsv,
  hex2hsl: hex2hsl
};

var MbscColor = (function (_super) {
    __extends(MbscColor, _super);
    function MbscColor(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.enhance = false;
        _this.onSet = new EventEmitter();
        _this.onClear = new EventEmitter();
        _this.onItemTap = new EventEmitter();
        _this.onPreviewItemTap = new EventEmitter();
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscColor.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscColor.prototype.refreshData = function (newData) {
        this.instance.option('data', newData);
    };
    MbscColor.prototype.initControl = function () {
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Color(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscColor.prototype.setNewValue = function (v) {
        if (this.instance) {
            var changed = void 0;
            if (this.isMulti) {
                changed = !deepEqualsArray(v, this.instance.getVal());
            }
            else {
                var innerValue = this.instance.getVal();
                changed = innerValue !== v;
            }
            if (changed) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscColor.prototype.ngOnInit = function () {
        this.isMulti = this.options && this.options.select && this.options.select !== 'single';
        this.cloneDictionary.data = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscColor.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscColor.propDecorators = {
        'clear': [{ type: Input$1 },],
        'data': [{ type: Input$1, args: ['mbsc-data',] },],
        'defaultValue': [{ type: Input$1 },],
        'enhance': [{ type: Input$1 },],
        'format': [{ type: Input$1 },],
        'inputClass': [{ type: Input$1 },],
        'mode': [{ type: Input$1 },],
        'navigation': [{ type: Input$1 },],
        'preview': [{ type: Input$1 },],
        'previewText': [{ type: Input$1 },],
        'rows': [{ type: Input$1 },],
        'valueText': [{ type: Input$1 },],
        'select': [{ type: Input$1 },],
        'onSet': [{ type: Output },],
        'onClear': [{ type: Output },],
        'onItemTap': [{ type: Output },],
        'onPreviewItemTap': [{ type: Output },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-color',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-colorChange',] },],
    };
MbscColor.ɵfac = function MbscColor_Factory(t) { return new (t || MbscColor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscColor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscColor, selectors: [["", "mbsc-color", ""]], inputs: { value: ["mbsc-color", "value"], clear: "clear", data: ["mbsc-data", "data"], defaultValue: "defaultValue", enhance: "enhance", format: "format", inputClass: "inputClass", mode: "mode", navigation: "navigation", preview: "preview", previewText: "previewText", rows: "rows", valueText: "valueText", select: "select", options: ["mbsc-options", "options"] }, outputs: { onSet: "onSet", onClear: "onClear", onItemTap: "onItemTap", onPreviewItemTap: "onPreviewItemTap", onChangeEmitter: "mbsc-colorChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscColor, [{
        type: Directive,
        args: [{
                selector: '[mbsc-color]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-color']
        }], clear: [{
            type: Input$1
        }], data: [{
            type: Input$1,
            args: ['mbsc-data']
        }], defaultValue: [{
            type: Input$1
        }], enhance: [{
            type: Input$1
        }], format: [{
            type: Input$1
        }], inputClass: [{
            type: Input$1
        }], mode: [{
            type: Input$1
        }], navigation: [{
            type: Input$1
        }], preview: [{
            type: Input$1
        }], previewText: [{
            type: Input$1
        }], rows: [{
            type: Input$1
        }], valueText: [{
            type: Input$1
        }], select: [{
            type: Input$1
        }], onSet: [{
            type: Output
        }], onClear: [{
            type: Output
        }], onItemTap: [{
            type: Output
        }], onPreviewItemTap: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-colorChange']
        }] }); })();
    return MbscColor;
}(MbscFrameBase));
var MbscColorComponent = (function (_super) {
    __extends(MbscColorComponent, _super);
    function MbscColorComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        _this.enhance = true;
        return _this;
    }
    MbscColorComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscColorComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscColorComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'data': [{ type: Input$1 },],
        'enhance': [{ type: Input$1 },],
    };
MbscColorComponent.ɵfac = function MbscColorComponent_Factory(t) { return new (t || MbscColorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscColorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscColorComponent, selectors: [["mbsc-color"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder", data: "data", enhance: "enhance" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscColorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscColorComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscColorComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-color',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], data: [{
            type: Input$1
        }], enhance: [{
            type: Input$1
        }] }); })();
    return MbscColorComponent;
}(MbscColor));
var MbscColorModule = (function () {
    function MbscColorModule() {
    }
    MbscColorModule.ctorParameters = function () { return []; };
MbscColorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscColorModule });
MbscColorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscColorModule_Factory(t) { return new (t || MbscColorModule)(); }, imports: [[CommonModule, MbscFrameBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscColorModule, { declarations: function () { return [MbscColor, MbscColorComponent]; }, imports: function () { return [CommonModule, MbscFrameBaseModule, MbscInputModule]; }, exports: function () { return [MbscColor, MbscColorComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscColorModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscFrameBaseModule, MbscInputModule],
                declarations: [MbscColor, MbscColorComponent],
                exports: [MbscColor, MbscColorComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscColorModule;
}());

var DateTime$1 = Scroller;
presets.date = DateTime;
presets.time = DateTime;
presets.datetime = DateTime;

var MbscDateBase = (function (_super) {
    __extends(MbscDateBase, _super);
    function MbscDateBase(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.options = {};
        _this.preset = 'date';
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscDateBase.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscDateBase.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if ((!innerValue && v) ||
                (innerValue && !v) ||
                (innerValue && v && innerValue.toString() !== v.toString())) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscDateBase.prototype.initControl = function () {
        var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new DateTime$1(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscDateBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: MbscOptionsService, },
        { type: ViewContainerRef, },
    ]; };
    MbscDateBase.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-date',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-dateChange',] },],
    };
MbscDateBase.ɵfac = function MbscDateBase_Factory(t) { return new (t || MbscDateBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscDateBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscDateBase, selectors: [["", "mbsc-dt-b", ""]], inputs: { value: ["mbsc-date", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-dateChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDateBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-dt-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: MbscOptionsService }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-date']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-dateChange']
        }] }); })();
    return MbscDateBase;
}(MbscDatetimeBase));
var MbscDate = (function (_super) {
    __extends(MbscDate, _super);
    function MbscDate(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.preset = 'date';
        return _this;
    }
    MbscDate.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
MbscDate.ɵfac = function MbscDate_Factory(t) { return new (t || MbscDate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscDate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscDate, selectors: [["", "mbsc-date", ""]], exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDate, [{
        type: Directive,
        args: [{
                selector: '[mbsc-date]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, null); })();
    return MbscDate;
}(MbscDateBase));
var MbscDateComponent = (function (_super) {
    __extends(MbscDateComponent, _super);
    function MbscDateComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscDateComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscDateComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscDateComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscDateComponent.ɵfac = function MbscDateComponent_Factory(t) { return new (t || MbscDateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscDateComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscDateComponent, selectors: [["mbsc-date"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscDateComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscDateComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDateComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-date',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscDateComponent;
}(MbscDate));
var MbscTime = (function (_super) {
    __extends(MbscTime, _super);
    function MbscTime(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'time';
        return _this;
    }
    Object.defineProperty(MbscTime.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscTime.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscTime.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-time',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-timeChange',] },],
    };
MbscTime.ɵfac = function MbscTime_Factory(t) { return new (t || MbscTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscTime.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscTime, selectors: [["", "mbsc-time", ""]], inputs: { value: ["mbsc-time", "value"] }, outputs: { onChangeEmitter: "mbsc-timeChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTime, [{
        type: Directive,
        args: [{
                selector: '[mbsc-time]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-time']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-timeChange']
        }] }); })();
    return MbscTime;
}(MbscDateBase));
var MbscTimeComponent = (function (_super) {
    __extends(MbscTimeComponent, _super);
    function MbscTimeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscTimeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscTimeComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscTimeComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscTimeComponent.ɵfac = function MbscTimeComponent_Factory(t) { return new (t || MbscTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTimeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTimeComponent, selectors: [["mbsc-time"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscTimeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscTimeComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimeComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-time',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscTimeComponent;
}(MbscTime));
var MbscDatetime = (function (_super) {
    __extends(MbscDatetime, _super);
    function MbscDatetime(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'datetime';
        return _this;
    }
    Object.defineProperty(MbscDatetime.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscDatetime.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscDatetime.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-datetime',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-datetimeChange',] },],
    };
MbscDatetime.ɵfac = function MbscDatetime_Factory(t) { return new (t || MbscDatetime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscDatetime.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscDatetime, selectors: [["", "mbsc-datetime", ""]], inputs: { value: ["mbsc-datetime", "value"] }, outputs: { onChangeEmitter: "mbsc-datetimeChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDatetime, [{
        type: Directive,
        args: [{
                selector: '[mbsc-datetime]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-datetime']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-datetimeChange']
        }] }); })();
    return MbscDatetime;
}(MbscDateBase));
var MbscDatetimeComponent = (function (_super) {
    __extends(MbscDatetimeComponent, _super);
    function MbscDatetimeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscDatetimeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscDatetimeComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscDatetimeComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscDatetimeComponent.ɵfac = function MbscDatetimeComponent_Factory(t) { return new (t || MbscDatetimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscDatetimeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscDatetimeComponent, selectors: [["mbsc-datetime"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscDatetimeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscDatetimeComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDatetimeComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-datetime',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscDatetimeComponent;
}(MbscDatetime));
var comp$2 = [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];
var MbscDatetimeModule = (function () {
    function MbscDatetimeModule() {
    }
    MbscDatetimeModule.ctorParameters = function () { return []; };
MbscDatetimeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscDatetimeModule });
MbscDatetimeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscDatetimeModule_Factory(t) { return new (t || MbscDatetimeModule)(); }, imports: [[CommonModule, MbscDatetimeBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscDatetimeModule, { declarations: function () { return [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent]; }, imports: function () { return [CommonModule, MbscDatetimeBaseModule, MbscInputModule]; }, exports: function () { return [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDatetimeModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscDatetimeBaseModule, MbscInputModule],
                declarations: comp$2,
                exports: comp$2
            }]
    }], function () { return []; }, null); })();
    return MbscDatetimeModule;
}());

var Popup = function Popup(el, settings, inherit) {
  function addContent($m) {
    $$1('.mbsc-fr-c', $m).append(that._getText(mobiscroll, 0.7));

    if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c') && mobiscroll.EmtjC) {
      $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

      if (!$$1('.mbsc-w-p', $m).length) {
        $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
      }
    }
  }

  var s,
      $prev,
      $elm = $$1(el),
      that = this; // Call the parent constructor

  Frame.call(this, el, settings, true);

  that._generateContent = function () {
    return '';
  };

  that._markupReady = function ($m) {
    if (s.display != 'inline') {
      addContent($m);
    }
  };

  that._markupInserted = function ($m) {
    if (s.display == 'inline') {
      addContent($m);
    }

    $m.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };

  that._markupRemove = function () {
    $elm.hide();

    if ($prev && $prev.parent().length) {
      $prev.after($elm);
    }
  };

  that.__processSettings = function () {
    s = that.settings;
    that.buttons.ok = {
      text: s.okText,
      icon: s.okIcon,
      handler: 'set'
    };
    s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

    if (!$prev && $elm.parent().length) {
      $prev = $$1(document.createComment('popup'));
      $elm.before($prev);
    }

    $elm.hide();
  }; // Constructor


  if (!inherit) {
    that.init();
  }
};
Popup.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasContent: true,
  _hasLang: true,
  _responsive: true,
  _class: 'popup',
  _defaults: extend$1({}, Frame.prototype._defaults, {
    compClass: 'mbsc-wdg',
    okText: 'OK',
    headerText: false
  })
};
classes.Popup = Popup;
classes.Widget = Popup;
mobiscroll.themes.popup = mobiscroll.themes.frame;

// eslint-disable-next-line no-unused-vars
var Eventcalendar = Scroller;

function getHeight(el) {
  var style = getComputedStyle(el);
  return el.innerHeight || el.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
}

var defaults$4 = {
  view: {
    calendar: {
      type: 'month',
      popover: true
    }
  },
  // Localization
  allDayText: 'All-day',
  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'],
  eventText: 'event',
  eventsText: 'events',
  noEventsText: 'No events'
},
    overrides = {
  yearChange: false,
  weekDays: 'short'
};

presets.eventcalendar = function (inst, settings, resp) {
  // Private functions
  // ---
  function processSettings() {
    var view = s.view,
        calendar = view.calendar,
        list = view.eventList,
        months = s.months,
        weeks = s.weeks;

    if (calendar) {
      if (calendar.type == 'week') {
        weeks = calendar.size || 1;
      } else if (calendar.size) {
        months = calendar.size;
      }

      isListOnly = false;
    } else {
      weeks = 0;
      isListOnly = true;
    }

    if (list) {
      listType = list.type;
      listSize = list.size || 1;
    }

    multiLabel = calendar && calendar.labels;
    scrollEventList = list && list.scrollable;
    showEventList = view.eventList;
    showEventBubble = s.eventBubble === undefined ? calendar && calendar.popover : s.eventBubble;
    s.weeks = weeks;
    s.months = months;
  }

  function updateTitle(firstDay, lastDay) {
    var title,
        monthIndex = (s.dateWheels || s.dateFormat).search(/m/i),
        yearIndex = (s.dateWheels || s.dateFormat).search(/y/i),
        firstYear = s.getYear(firstDay),
        firstMonth = s.getMonth(firstDay),
        lastYear = s.getYear(lastDay),
        lastMonth = s.getMonth(lastDay);

    inst._checkBtn($$1('.mbsc-cal-prev-m', $ctx), getDateOnly(firstDay) <= inst._minDate);

    inst._checkBtn($$1('.mbsc-cal-next-m', $ctx), getDateOnly(lastDay) >= inst._maxDate);

    if (listType == 'day') {
      title = formatDate(s.dateFormat, firstDay, s) + (listSize > 1 ? ' - ' + formatDate(s.dateFormat, lastDay, s) : '');
    } else if (listType == 'week') {
      title = formatDate(s.dateFormat, firstDay, s) + ' - ' + formatDate(s.dateFormat, lastDay, s);
    } else if (listType == 'month') {
      if (listSize == 1) {
        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNames[firstMonth] : s.monthNames[firstMonth] + ' ' + firstYear;
      } else {
        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNamesShort[firstMonth] + ' - ' + lastYear + ' ' + s.monthNamesShort[lastMonth] : s.monthNamesShort[firstMonth] + ' ' + firstYear + ' - ' + s.monthNamesShort[lastMonth] + ' ' + lastYear;
      }
    } else if (listType == 'year') {
      title = firstYear + (listSize > 1 ? " - " + lastYear : '');
    }

    $viewTitle.html(title);
  }

  function createEventList(firstDay, lastDay, eventObj) {
    var d,
        i,
        j,
        ev,
        $items,
        count = 0,
        allEvents = [],
        eventHtml = '',
        events = [];

    if (!eventObj) {
      eventObj = inst._prepareObj(eventList, firstDay, lastDay);
    }

    for (d = getDateOnly(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      ev = eventObj[getDateOnly(d)];

      if (ev && ev.length) {
        events.push({
          d: new Date(d),
          list: sortEvents(ev)
        });
      }
    }

    if (events.length > 0) {
      for (i = 0; i < events.length; i++) {
        ev = events[i];
        eventHtml += '<div><div class="mbsc-lv-gr-title mbsc-event-day" data-full="' + getDateStr(ev.d) + '">' + formatDate(s.dateFormat, ev.d, s) + '</div>';

        for (j = 0; j < ev.list.length; j++) {
          var event = ev.list[j],
              start = event.start ? makeDate(event.start) : null,
              end = event.end ? makeDate(event.end) : null,
              color = event.color,
              isRepeating = DAY_OF_WEEK.test(event.d) || DAY_OF_MONTH.test(event.d),
              isMultiDay = start && end && !isSameDay(start, end),
              isFirstDay = isMultiDay ? isSameDay(start, ev.d) : true,
              isLastDay = isMultiDay ? isSameDay(end, ev.d) : true,
              dt = event.d ? isRepeating ? event.d : makeDate(event.d) : start,
              allDay = event.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay;
          allEvents.push({
            d: ev.d,
            e: event
          });
          eventHtml += '<div tabindex="0" role="button" class="mbsc-lv-item mbsc-lv-item-actionable" data-index="' + count + '"><div class="mbsc-event-time">' + (allDay ? s.allDayText : isFirstDay && dt && dt.getTime ? formatDate(s.timeFormat, dt) : isMultiDay && isLastDay ? s.toText : '') + (!allDay && isLastDay && end && end.getTime ? '<br/>' + formatDate(s.timeFormat, end) : '') + '</div>' + '<div class="mbsc-event-color"' + (color ? ' style="background:' + color + ';"' : '') + '></div>' + '<div class="mbsc-event-txt">' + event.text + '</div>' + inst._getText(mobiscroll, 0.3) + '</div>';
          count++;
        }

        eventHtml += '</div>';
      }
    } else {
      eventHtml += '<div class="mbsc-lv-gr-title mbsc-event-empty"><div class="mbsc-empty"><h3>' + s.noEventsText + '</h3></div></div>';
    }

    preventScrollWatch++;
    $eventListCont.html('<div class="mbsc-lv mbsc-lv-v">' + eventHtml + '</div>').scrollTop(0);
    setTimeout(function () {
      // Need setTimeout since scroll listener is throtteled
      preventScrollWatch--;
    }, 150);
    $items = $$1('.mbsc-lv-item', $eventListCont); // Assign event click

    inst.tap($items, function (e) {
      var data = allEvents[$$1(this).attr('data-index')];
      trigger('onEventSelect', {
        domEvent: e,
        event: data.e,
        date: data.d
      });
    });
    handleFocus($items);
  }

  function handleFocus($items) {
    $items.on('keydown', function (ev) {
      if (ev.keyCode === 13 || ev.keyCode === 32) {
        this.click();
      }
    }).on('focus', function () {
      if (window.__mbscFocusVisible) {
        $$1(this).addClass('mbsc-focus');
      }
    }).on('blur', function () {
      $$1(this).removeClass('mbsc-focus');
    });
  }

  function createEventPopover() {
    if (popoverData) {
      var d = getDateOnly(popoverData.d),
          events = popoverData.events || eventObj[d],
          cell = popoverData.cell || $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', inst._markup)[0];
      showEvents(events, d, cell);
      popoverData = null;
    }
  }

  function formatDuration(start, end) {
    var lbl = s.labelsShort,
        time = end - start,
        seconds = Math.abs(time) / 1000,
        minutes = seconds / 60,
        hours = minutes / 60,
        days = hours / 24,
        years = days / 365;
    return seconds < 45 && Math.round(seconds) + ' ' + lbl[5].toLowerCase() || //seconds < 90 && '1 minute' ||
    minutes < 45 && Math.round(minutes) + ' ' + lbl[4].toLowerCase() || //minutes < 90 && '1 hour' ||
    hours < 24 && Math.round(hours) + ' ' + lbl[3].toLowerCase() || //hours < 42 && '1 day' ||
    days < 30 && Math.round(days) + ' ' + lbl[2].toLowerCase() || //days < 45 && '1 month' ||
    days < 365 && Math.round(days / 30) + ' ' + lbl[1].toLowerCase() || //years < 1.5 && '1 year' ||
    Math.round(years) + ' ' + lbl[0].toLowerCase();
  }

  function sortEvents(events) {
    return events.slice(0).sort(s.eventOrder);
  }

  function showEvents(events, d, cell) {
    if (events) {
      var $eventCont,
          $eventContInner,
          $eventScroller,
          eventScroller,
          $items,
          html = '<div class="mbsc-cal-event-list">';
      $eventCont = $$1('<div class="mbsc-cal-events ' + (s.eventBubbleClass || '') + '">' + '<div class="mbsc-cal-events-i"><div class="mbsc-cal-events-sc">' + '</div><div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div></div></div>');
      $eventContInner = $$1('.mbsc-cal-events-i', $eventCont);
      $eventScroller = $$1('.mbsc-cal-events-sc', $eventCont);
      inst.tap($eventContInner, function () {
        if (!eventScroller.scrolled) {
          hideEvents();
        }
      });
      popup = new Popup($eventCont[0], {
        display: 'bubble',
        theme: s.theme,
        lang: s.lang,
        context: s.context,
        buttons: [],
        anchor: cell,
        showOverlay: false,
        cssClass: 'mbsc-no-padding mbsc-cal-events-popup',
        onShow: function onShow() {
          eventScroller = new ScrollViewBase($eventContInner[0], {
            scrollbar: $$1('.mbsc-sc-bar-c', $eventCont),
            stopProp: false
          });
          $$1(document).on('click', hideEventsOnClick);
        },
        onClose: function onClose(event, inst) {
          inst.destroy();

          if (eventScroller) {
            eventScroller.destroy();
          }

          $$1(document).off('click', hideEventsOnClick);
        }
      }); // Store the popup on the instance, we need to destroy it in case of an option call or re-init

      inst._popup = popup;
      eventDay = cell;
      events = sortEvents(events);
      $$1.each(events, function (i, e) {
        var start = e.start ? makeDate(e.start) : null,
            end = e.end ? makeDate(e.end) : null,
            isRepeating = DAY_OF_WEEK.test(e.d) || DAY_OF_MONTH.test(e.d),
            dt = e.d ? isRepeating ? e.d : makeDate(e.d) : start,
            isMultiDay = start && end && !isSameDay(start, end),
            isFirstDay = isMultiDay ? isSameDay(start, d) : true,
            isLastDay = isMultiDay ? isSameDay(end, d) : true,
            allDay = e.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay,
            bg = e.color,
            ariaFrom = '',
            ariaTo = '',
            ariaLabel = $$1('<div>' + e.text + '</div>').text();

        if (dt.getTime) {
          ariaFrom = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, dt);
        }

        if (end) {
          ariaTo = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, end);
        }

        html += '<div tabindex="0" role="button" title="' + ariaLabel + '" aria-label="' + ariaLabel + (ariaFrom ? ', ' + s.fromText + ': ' + ariaFrom : '') + (ariaTo ? ', ' + s.toText + ': ' + ariaTo : '') + '" class="mbsc-cal-event mbsc-lv-item mbsc-lv-item-actionable">' + '<div class="mbsc-cal-event-color" style="' + (bg ? 'background:' + bg + ';' : '') + '"></div>' + '<div class="mbsc-cal-event-text">' + '<div class="mbsc-cal-event-time">' + (allDay ? s.allDayText : isFirstDay && dt.getTime ? formatDate(s.timeFormat, dt) : '') + '</div>' + e.text + '</div>' + (start && end && !e.allDay ? '<div class="mbsc-cal-event-dur">' + s.formatDuration(start, end, e) + '</div>' : '') + '</div>';
      });
      html += '</div>';
      $eventScroller.html(html);
      popup.show();
      trigger('onEventBubbleShow', {
        target: eventDay,
        eventList: $eventCont[0]
      });
      $items = $$1('.mbsc-cal-event', $eventScroller); // Assign event click

      inst.tap($items, function (e) {
        if (!eventScroller.scrolled) {
          trigger('onEventSelect', {
            domEvent: e,
            event: events[$$1(this).index()],
            date: d
          });
        }
      });
      handleFocus($items);
      hasEventBubble = true;
    }
  }

  function onScroll() {
    var d, top, parts;

    if (!preventScrollWatch) {
      $$1('.mbsc-event-day', this).each(function () {
        top = this.offsetTop - eventListCont.scrollTop;

        if (top >= 0 && top < 35) {
          parts = $$1(this).attr('data-full').split('-');
          d = adjustedDate(parts[0], parts[1] - 1, parts[2]);

          if (!isSameDay(d, currDay)) {
            preventEventScroll = true;
            inst.setVal(d);
          }

          return false;
        }
      });
    }
  }

  function hideEvents() {
    if (popup && hasEventBubble) {
      popup.hide();
    }

    eventDay = null;
    hasEventBubble = false;
  }

  function hideEventsOnClick(e) {
    if ($$1(e.target).closest('.mbsc-cal-day').length == 0) {
      hideEvents();
    }
  }

  function refresh() {
    hideEvents();
    inst.redraw();
  }

  function getFirstLast(day) {
    var y = s.getYear(day),
        m = s.getMonth(day),
        d = s.getDay(day);
    currFirstDay = day;

    if (listType == 'day') {
      currLastDay = s.getDate(y, m, d + listSize - 1);
    } else if (listType == 'week') {
      // get first day of week
      var diff,
          weekDay = currFirstDay.getDay();
      diff = d + s.firstDay - (s.firstDay - weekDay > 0 ? 7 : 0) - weekDay;
      currFirstDay = s.getDate(y, m, diff);
      currLastDay = s.getDate(y, m, diff + listSize * 7 - 1);
    } else if (listType == 'month') {
      currFirstDay = s.getDate(y, m, 1);
      currLastDay = s.getDate(y, m + listSize, 0);
    } else if (listType == 'year') {
      currFirstDay = s.getDate(y, 0, 1);
      currLastDay = s.getDate(y + listSize, 0, 0);
    }
  }

  function scrollToDay(d, prevAnim) {
    // Scroll to the day in the list, if any
    if (showEventList && !preventEventScroll) {
      var $day = $$1('.mbsc-event-day[data-full="' + getDateStr(d) + '"]', $eventListCont);

      if ($day.length) {
        preventScrollWatch++;
        smoothScroll(eventListCont, $day.parent()[0].offsetTop, prevAnim, function () {
          // Need setTimeout since scroll listener is throtteled
          setTimeout(function () {
            preventScrollWatch--;
          }, 150);
        });
      }
    }
  }

  function triggerLoading(change, render) {
    if (change) {
      trigger('onPageChange', {
        firstDay: currFirstDay,
        lastDay: currLastDay
      });
    }

    if (!render) {
      trigger('onPageLoading', {
        firstDay: currFirstDay,
        lastDay: currLastDay
      });
    }

    trigger('onPageLoaded', {
      firstDay: currFirstDay,
      lastDay: currLastDay
    });
  } // ---


  var base,
      $ctx,
      $eventListCont,
      $viewTitle,
      currDay,
      currFirstDay,
      currLastDay,
      eventDay,
      eventListCont,
      eventObj,
      hasEventBubble,
      isChanging,
      isLabelTap,
      isListOnly,
      listType,
      listSize,
      multiLabel,
      popoverData,
      popup,
      preventEventScroll,
      preventScrollAnim,
      prevFirstDay,
      prevLastDay,
      scrollEventList,
      showEventList,
      showEventBubble,
      showMore,
      elm = this,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$4, orig, overrides, settings, resp),
      preventScrollWatch = 0,
      eventID = 0,
      eventList = extend$1(true, [], s.data),
      firstLoad = true,
      trigger = inst.trigger; // Keep tracking events in settings,
  // otherwise changes will be lost on an eventual option call

  s.data = eventList;
  $$1.each(eventList, function (i, e) {
    if (e._id === undefined) {
      e._id = eventID++;
    }
  });
  processSettings();
  base = CalendarBase.call(this, inst); // Extended methods
  // ---

  inst._onGenMonth = function (start, end) {
    eventObj = inst._prepareObj(eventList, start, end);
    inst._labels = multiLabel ? eventObj : null;
  };

  inst._onRefresh = function (render) {
    preventScrollAnim = true; // Will re-create the list

    prevFirstDay = null;
    prevLastDay = null;

    if (isListOnly) {
      triggerLoading(false, render);
    }
  };

  inst._onSetDate = function (d, diff) {
    currDay = d;

    if (isListOnly) {
      if (!preventEventScroll && !isChanging) {
        getFirstLast(d);

        if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, currFirstDay) || !isSameDay(prevLastDay, currLastDay)) {
          triggerLoading(true);
        }
      }
    } else if (!diff && !isChanging) {
      hideEvents();

      if (showEventList && listType == 'day') {
        // List events for the day
        createEventList(d, d, eventObj);
      }

      if ((showEventBubble || showMore) && !isLabelTap) {
        // Show event popover
        createEventPopover();
      }

      scrollToDay(d);
    }

    preventEventScroll = false;
    showMore = false;
    isLabelTap = false;
  };

  inst._getDayProps = function (d) {
    var events = eventObj[d],
        ret = {
      events: events
    };

    if (!s.marked && !s.labels && !multiLabel) {
      if (events) {
        ret.background = events[0] && events[0].background;
        ret.marked = events; // For backward compatibility

        ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt">' + events.length + ' ' + (events.length > 1 ? s.eventsText : s.eventText) + '</div>' : '<div class="mbsc-cal-marks"><div class="mbsc-cal-mark"></div></div>';
      } else {
        ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt-ph"></div>' : '';
      }
    }

    return ret;
  };

  inst.addEvent = function (events) {
    var ret = [];
    events = extend$1(true, [], $$1.isArray(events) ? events : [events]);
    $$1.each(events, function (i, e) {
      if (e._id === undefined) {
        e._id = eventID++;
      }

      eventList.push(e);
      ret.push(e._id);
    });
    refresh();
    return ret;
  };

  inst.updateEvent = function (event) {
    $$1.each(eventList, function (j, e) {
      if (e._id === event._id) {
        eventList.splice(j, 1, event);
        return false;
      }
    });
    refresh();
  };

  inst.removeEvent = function (eids) {
    eids = $$1.isArray(eids) ? eids : [eids];
    $$1.each(eids, function (i, eid) {
      $$1.each(eventList, function (j, e) {
        if (e._id === eid) {
          eventList.splice(j, 1);
          return false;
        }
      });
    });
    refresh();
  };

  inst.getEvents = function (d) {
    var obj;

    if (d) {
      d.setHours(0, 0, 0, 0);
      obj = inst._prepareObj(eventList, d, d);
      return obj[d] ? sortEvents(obj[d]) : [];
    }

    return extend$1(true, [], eventList);
  };

  inst.setEvents = function (events) {
    var ret = [];
    s.data = eventList = extend$1(true, [], events);
    $$1.each(eventList, function (i, e) {
      if (e._id === undefined) {
        e._id = eventID++;
      }

      ret.push(e._id);
    });
    refresh();
    return ret;
  };

  inst.navigate = function (d, anim, pop) {
    d = makeDate(d, inst._format, s);
    popoverData = pop ? {
      d: d
    } : null;
    inst.setVal(d, true, true, false, anim ? 200 : 0);
  }; // ---


  return extend$1({}, base, {
    multiLabel: multiLabel,
    headerText: false,
    buttons: s.display !== 'inline' ? ['close'] : s.buttons,
    compClass: 'mbsc-ev-cal mbsc-calendar mbsc-dt mbsc-sc',
    formatDuration: formatDuration,
    onMarkupReady: function onMarkupReady(ev, inst) {
      $ctx = $$1(ev.target);
      currDay = inst.getDate(true);

      if (showEventList) {
        $eventListCont = $$1('<div class="mbsc-lv-cont mbsc-lv-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme : '') + (scrollEventList ? ' mbsc-event-list-h' : '') + ' mbsc-event-list"></div>').appendTo($$1('.mbsc-fr-w', $ctx));
        $eventListCont.on('scroll', throttle(onScroll));
        eventListCont = $eventListCont[0];
      }

      base.onMarkupReady.call(this, ev);
      $viewTitle = $$1('.mbsc-cal-month', $ctx);
      hasEventBubble = false;
      getFirstLast(currDay);

      if (showEventList && isListOnly) {
        triggerLoading(); // Init navigation arrows

        createStepper($$1('.mbsc-cal-btn', $ctx), function (i, diff) {
          var y = s.getYear(currFirstDay),
              m = s.getMonth(currFirstDay),
              d = s.getDay(currFirstDay);

          if (listType == 'day') {
            currFirstDay = s.getDate(y, m, d + diff * listSize);
            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize - 1);
          } else if (listType == 'week') {
            currFirstDay = s.getDate(y, m, d + diff * listSize * 7);
            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize * 7 - 1);
          } else if (listType == 'month') {
            currFirstDay = s.getDate(y, m + diff * listSize, 1);
            currLastDay = s.getDate(y, m + (diff + 1) * listSize, 0);
          } else if (listType == 'year') {
            currFirstDay = s.getDate(y + diff * listSize, 0, 1);
            currLastDay = s.getDate(y + (diff + 1) * listSize, 0, 0);
          }

          triggerLoading(true);
        }, 200);
      }

      addWindowFocus();
    },
    onDayChange: function onDayChange(day) {
      var cell = day.target,
          show = cell !== eventDay;

      if (show) {
        showMore = showEventBubble !== false && $$1('.mbsc-cal-txt-more', cell).length;
        popoverData = {
          d: day.date,
          cell: s.outerMonthChange && $$1(cell).hasClass('mbsc-cal-day-diff') ? null : cell,
          events: day.events
        };
      }
    },
    onLabelTap: function onLabelTap(ev) {
      if (ev.label) {
        trigger('onEventSelect', {
          domEvent: ev.domEvent,
          event: ev.label,
          date: ev.date
        });
        isLabelTap = true;
      }
    },
    onPageChange: function onPageChange(ev) {
      hideEvents();
      isChanging = true;

      if (!inst._isSetDate) {
        inst.setVal(ev.firstDay);
      }
    },
    onPageLoaded: function onPageLoaded(ev) {
      var firstDay = ev.firstDay,
          lastDay = ev.lastDay;

      if (showEventList) {
        if (isListOnly) {
          if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, firstDay) || !isSameDay(prevLastDay, lastDay)) {
            prevFirstDay = firstDay;
            prevLastDay = lastDay;
            createEventList(firstDay, lastDay);
            updateTitle(firstDay, lastDay);
          }
        } else {
          if (listType == 'month') {
            // month view
            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay) + listSize, 0);
          } else if (listType == 'week') {
            // week view
            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay), s.getDay(firstDay) + listSize * 7 - 1);
          } else {
            firstDay = inst.getVal(true);
            lastDay = firstDay;
          }

          createEventList(firstDay, lastDay, eventObj);
        }

        if (!firstLoad && !isSameDay(currDay, firstDay)) {
          scrollToDay(currDay, preventScrollAnim);
          preventScrollAnim = false;
        }
      }

      if (showEventBubble) {
        createEventPopover();
      }

      isChanging = false;
    },
    onPosition: function onPosition(ev) {
      base.onPosition.call(this, ev);

      if (popup) {
        popup.position();
      }

      if (showEventList && scrollEventList) {
        $eventListCont.addClass('mbsc-event-list-h');
        var context = s.display == 'inline' ? elm.parentNode : window,
            availableHeight = getHeight(context),
            listHeight = availableHeight - ev.popup.offsetHeight;
        eventListCont.style.height = listHeight > 200 ? listHeight + 'px' : '';
        $eventListCont.removeClass('mbsc-event-list-h');

        if (firstLoad && listHeight) {
          scrollToDay(currDay, true);
          firstLoad = false;
        }
      }
    },
    onHide: function onHide() {
      base.onHide.call(this); // Destroy the popup stored on the instance,
      // the local variable is lost in case of option call or re-init

      if (inst._popup) {
        inst._popup.destroy();
      }

      removeWindowFocus();
    }
  });
};

var MbscEventcalendar = (function (_super) {
    __extends(MbscEventcalendar, _super);
    function MbscEventcalendar(initialElem, zone, optionService) {
        var _this = _super.call(this, initialElem, zone, null, null, null) || this;
        _this.optionService = optionService;
        _this.onEventSelect = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.onSetDate = new EventEmitter();
        _this.options = {};
        return _this;
    }
    MbscEventcalendar.prototype.refreshData = function (newData) {
        this.instance.setEvents(newData);
    };
    MbscEventcalendar.prototype.initControl = function () {
        var options = extend$1({ preset: 'eventcalendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Eventcalendar(this.element, options);
    };
    MbscEventcalendar.prototype.ngOnInit = function () {
        this.cloneDictionary.data = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscEventcalendar.prototype.setNewValue = function () { };
    MbscEventcalendar.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscEventcalendar.propDecorators = {
        'data': [{ type: Input$1, args: ['mbsc-data',] },],
        'layout': [{ type: Input$1 },],
        'showEventCount': [{ type: Input$1 },],
        'eventBubble': [{ type: Input$1 },],
        'formatDuration': [{ type: Input$1 },],
        'view': [{ type: Input$1 },],
        'allDayText': [{ type: Input$1 },],
        'eventText': [{ type: Input$1 },],
        'eventsText': [{ type: Input$1 },],
        'labelsShort': [{ type: Input$1 },],
        'noEventsText': [{ type: Input$1 },],
        'onEventSelect': [{ type: Output },],
        'onCellHoverIn': [{ type: Output },],
        'onCellHoverOut': [{ type: Output },],
        'onDayChange': [{ type: Output },],
        'onSetDate': [{ type: Output },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
    };
MbscEventcalendar.ɵfac = function MbscEventcalendar_Factory(t) { return new (t || MbscEventcalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscEventcalendar.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscEventcalendar, selectors: [["", "mbsc-eventcalendar", ""]], inputs: { data: ["mbsc-data", "data"], layout: "layout", showEventCount: "showEventCount", eventBubble: "eventBubble", formatDuration: "formatDuration", view: "view", allDayText: "allDayText", eventText: "eventText", eventsText: "eventsText", labelsShort: "labelsShort", noEventsText: "noEventsText", options: ["mbsc-options", "options"] }, outputs: { onEventSelect: "onEventSelect", onCellHoverIn: "onCellHoverIn", onCellHoverOut: "onCellHoverOut", onDayChange: "onDayChange", onSetDate: "onSetDate" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscEventcalendar, [{
        type: Directive,
        args: [{
                selector: '[mbsc-eventcalendar]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { data: [{
            type: Input$1,
            args: ['mbsc-data']
        }], layout: [{
            type: Input$1
        }], showEventCount: [{
            type: Input$1
        }], eventBubble: [{
            type: Input$1
        }], formatDuration: [{
            type: Input$1
        }], view: [{
            type: Input$1
        }], allDayText: [{
            type: Input$1
        }], eventText: [{
            type: Input$1
        }], eventsText: [{
            type: Input$1
        }], labelsShort: [{
            type: Input$1
        }], noEventsText: [{
            type: Input$1
        }], onEventSelect: [{
            type: Output
        }], onCellHoverIn: [{
            type: Output
        }], onCellHoverOut: [{
            type: Output
        }], onDayChange: [{
            type: Output
        }], onSetDate: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }] }); })();
    return MbscEventcalendar;
}(MbscCalBase));
var MbscEventcalendarComponent = (function (_super) {
    __extends(MbscEventcalendarComponent, _super);
    function MbscEventcalendarComponent(initialElem, zone, optionService) {
        var _this = _super.call(this, initialElem, zone, optionService) || this;
        _this.options = {};
        return _this;
    }
    MbscEventcalendarComponent.prototype.ngOnInit = function () {
        var display = this.options && this.options.display || this.display;
        if (!display) {
            this.display = 'inline';
            this.inlineOptionsObj.display = 'inline';
        }
        _super.prototype.ngOnInit.call(this);
    };
    MbscEventcalendarComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscEventcalendarComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscEventcalendarComponent.propDecorators = {
        'data': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
    };
MbscEventcalendarComponent.ɵfac = function MbscEventcalendarComponent_Factory(t) { return new (t || MbscEventcalendarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscEventcalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscEventcalendarComponent, selectors: [["mbsc-eventcalendar"]], inputs: { data: "data", options: "options" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, template: function MbscEventcalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscEventcalendarComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-eventcalendar',
                exportAs: 'mobiscroll',
                template: '<div></div>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { data: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }] }); })();
    return MbscEventcalendarComponent;
}(MbscEventcalendar));
var MbscEventcalendarModule = (function () {
    function MbscEventcalendarModule() {
    }
    MbscEventcalendarModule.ctorParameters = function () { return []; };
MbscEventcalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscEventcalendarModule });
MbscEventcalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscEventcalendarModule_Factory(t) { return new (t || MbscEventcalendarModule)(); }, imports: [[MbscCalBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscEventcalendarModule, { declarations: [MbscEventcalendar, MbscEventcalendarComponent], imports: [MbscCalBaseModule], exports: [MbscEventcalendar, MbscEventcalendarComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscEventcalendarModule, [{
        type: NgModule,
        args: [{
                imports: [MbscCalBaseModule],
                declarations: [MbscEventcalendar, MbscEventcalendarComponent],
                exports: [MbscEventcalendar, MbscEventcalendarComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscEventcalendarModule;
}());

var hasPromise = isBrowser && !!window.Promise;
var popupQueue = [];
var notificationQueue = [];
var activeNotification;

function showPopup(popup) {
  if (!popupQueue.length) {
    popup.show();
  }

  popupQueue.push(popup);
}

function showNotification(notification) {
  var isAny = notificationQueue.length;
  notificationQueue.push(notification); // Only show notification if no popup is visible
  // otherwise postpone it until popup is closed

  if (!popupQueue.length) {
    // If there's a visible notification, hide it.
    // The notification will be shown after hide animation is complete
    if (isAny) {
      notificationQueue[0].hide();
    } else {
      // Prevent focus on show for notifications
      notification.show(false, true);
    }
  }
}

function getSettings(queue, settings, resolve, more) {
  //const active = mobiscroll.activeInstance;
  return extend$1({
    display: settings.display || 'center',
    cssClass: 'mbsc-alert',
    okText: settings.okText,
    cancelText: settings.cancelText,
    context: settings.context,
    theme: settings.theme,
    closeOnOverlayTap: false,
    onBeforeClose: function onBeforeClose() {
      queue.shift();
    },
    onHide: function onHide(ev, inst) {
      //mobiscroll.activeInstance = active;
      if (resolve) {
        resolve(inst._resolve);
      }

      if (settings.callback) {
        settings.callback(inst._resolve);
      }

      if (inst) {
        inst.destroy();
      } // Show next


      if (popupQueue.length) {
        popupQueue[0].show();
      } else if (notificationQueue.length) {
        // Prevent focus on show for notifications
        notificationQueue[0].show(false, true);
      }
    }
  }, more);
}

function getMessage(settings) {
  return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
}

function showAlert(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
  showPopup(inst);
}

function showConfirm(popup, settings, resolve) {
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onSet: function onSet() {
      inst._resolve = true;
    }
  }));
  inst._resolve = false;
  showPopup(inst);
}

function showPrompt(popup, settings, resolve) {
  var input, label;
  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
    buttons: ['cancel', 'ok'],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;
      label = inst._markup.find('label');
      label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
      input = inst._markup.find('input')[0];
      setTimeout(function () {
        input.focus();
        input.setSelectionRange(0, input.value.length);
      }, 300);
    },
    onSet: function onSet() {
      inst._resolve = input.value;
    }
  }));
  inst._resolve = null;
  showPopup(inst);
}

function showSnackbar(popup, settings, resolve, cssClass, animation) {
  var notificationTimer;
  var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
    display: settings.display || 'bottom',
    animate: animation,
    cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
    scrollLock: false,
    focusTrap: false,
    buttons: [],
    onMarkupReady: function onMarkupReady(event, inst) {
      var s = inst.settings;

      var button = inst._markup.find('button');

      button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
    },
    onShow: function onShow(ev, inst) {
      activeNotification = inst;

      if (settings.duration !== false) {
        notificationTimer = setTimeout(function () {
          if (inst) {
            inst.hide();
          }
        }, settings.duration || 3000);
      }

      if (settings.button) {
        inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {
          inst.hide();

          if (settings.button.action) {
            settings.button.action.call(this);
          }
        });
      }
    },
    onClose: function onClose() {
      activeNotification = null;
      clearTimeout(notificationTimer);
    }
  }));
  showNotification(inst);
}

function showToast(popup, settings, resolve) {
  showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
}

function show(func, popup, settings) {
  var p;

  if (hasPromise) {
    p = new Promise(function (resolve) {
      func(popup, settings, resolve);
    });
  } else {
    func(popup, settings);
  }

  return p;
}

mobiscroll.alert = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showAlert, popup, settings);
};

mobiscroll.confirm = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings);
  return show(showConfirm, popup, settings);
};

mobiscroll.prompt = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input class="mbsc-control" tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
  return show(showPrompt, popup, settings);
};

mobiscroll.snackbar = function (settings) {
  var popup = document.createElement('div'),
      btn = settings.button;
  popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
  return show(showSnackbar, popup, settings);
};

mobiscroll.toast = function (settings) {
  var popup = document.createElement('div');
  popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
  return show(showToast, popup, settings);
};

mobiscroll.notification = {
  dismiss: function dismiss() {
    if (activeNotification) {
      activeNotification.hide();
    }
  }
};

var halfBorder$1 = os == 'ios' && majorVersion > 7;
var Form = function Form(el, settings) {
  var s,
      cssClass = '',
      $ctx = $$1(el),
      controls = {},
      that = this;

  function touched() {
    $ctx.removeClass('mbsc-no-touch');
  } // Call the parent constructor


  Base.call(this, el, settings, true);

  that.refresh = function (shallow) {
    if (s.enhance) {
      initControls($ctx, controls, s, shallow);
    }
  };
  /**
   * Form initialization.
   */


  that._init = function () {
    if (!mobiscroll.themes.form[s.theme]) {
      s.theme = 'mobiscroll';
    }

    if (!$ctx.hasClass('mbsc-form')) {
      $ctx.show();
      listen($ctx[0], 'touchstart', touched, {
        passive: true
      });
    }

    if (cssClass) {
      $ctx.removeClass(cssClass);
    } // --- TRIAL SERVER CODE START ---


    cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---

    $ctx.addClass(cssClass).removeClass('mbsc-cloak');
    that.refresh();
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $ctx.removeClass(cssClass);
    unlisten($ctx[0], 'touchstart', touched, {
      passive: true
    });

    for (var id in controls) {
      controls[id].destroy();
    }
  };
  /**
   * Object with the underlying form control instances
   * keys are the element id's
   */


  that.controls = controls; // Constructor

  s = that.settings;
  that.init();
}; // Extend defaults

Form.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'form',
  _defaults: {
    tap: hasGhostClick,
    stopProp: true,
    rtl: false,
    enhance: true
  }
};
classes.Form = Form; // Init mbsc-form elements on page load

autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

var MbscForm = (function (_super) {
    __extends(MbscForm, _super);
    function MbscForm(initialElem, _formService, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this._formService = _formService;
        _this.enhance = false;
        return _this;
    }
    MbscForm.prototype.ngOnInit = function () {
        this.optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this._formService.options = this.optionsObj;
    };
    MbscForm.prototype.initControl = function () {
        var opt = this.options;
        if (opt && opt.enhance === undefined) {
            opt.enhance = false;
        }
        var options = extend$1({}, opt, this.inlineOptionsObj);
        this.instance = new Form(this.rootElem.nativeElement, options);
    };
    MbscForm.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscForm.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'enhance': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
        'rootElem': [{ type: ViewChild, args: ['rootElement', { static: false },] },],
    };
MbscForm.ɵfac = function MbscForm_Factory(t) { return new (t || MbscForm)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscForm.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscForm, selectors: [["mbsc-form"]], viewQuery: function MbscForm_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rootElem = _t.first);
    } }, inputs: { options: "options", enhance: "enhance", context: "context", inputStyle: ["input-style", "inputStyle"], labelStyle: ["label-style", "labelStyle"] }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscOptionsService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["rootElement", ""]], template: function MbscForm_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscForm, [{
        type: Component,
        args: [{
                selector: 'mbsc-form',
                template: "<div #rootElement><ng-content></ng-content></div>",
                providers: [MbscOptionsService],
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService }, { type: ɵngcc0.NgZone }]; }, { options: [{
            type: Input$1,
            args: ['options']
        }], enhance: [{
            type: Input$1
        }], context: [{
            type: Input$1
        }], inputStyle: [{
            type: Input$1,
            args: ['input-style']
        }], labelStyle: [{
            type: Input$1,
            args: ['label-style']
        }], rootElem: [{
            type: ViewChild,
            args: ['rootElement', { static: false }]
        }] }); })();
    return MbscForm;
}(MbscBase));
var MbscTextarea = (function (_super) {
    __extends(MbscTextarea, _super);
    function MbscTextarea(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    MbscTextarea.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new TextArea(this._initElem.nativeElement, options);
    };
    MbscTextarea.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscTextarea.propDecorators = {
        'rows': [{ type: Input$1 },],
        'wrap': [{ type: Input$1 },],
    };
MbscTextarea.ɵfac = function MbscTextarea_Factory(t) { return new (t || MbscTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscTextarea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTextarea, selectors: [["mbsc-textarea"]], hostAttrs: [1, "mbsc-control-ng"], inputs: { rows: "rows", wrap: "wrap" }, features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 6, vars: 30, consts: [[1, "mbsc-input-wrap"], [3, "placeholder", "ngModel", "disabled", "readonly", "ngModelChange", "blur"], ["initElement", ""], ["class", "mbsc-err-msg", 4, "ngIf"], [1, "mbsc-err-msg"]], template: function MbscTextarea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵelementStart(3, "textarea", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MbscTextarea_Template_textarea_ngModelChange_3_listener($event) { return ctx.innerValue = $event; })("blur", function MbscTextarea_Template_textarea_blur_3_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, MbscTextarea_span_5_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-err", ctx.error)("mbsc-input-box", ctx.inputStyle == "box")("mbsc-input-outline", ctx.inputStyle == "outline")("mbsc-label-stacked", ctx.labelStyle == "stacked")("mbsc-label-inline", ctx.labelStyle == "inline")("mbsc-label-floating", ctx.labelStyle == "floating");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("placeholder", ctx.placeholder)("ngModel", ctx.innerValue)("disabled", ctx.disabled)("readonly", ctx._readonly);
        ɵngcc0.ɵɵattribute("name", ctx.name)("rows", ctx.rows)("wrap", ctx.wrap)("minlength", ctx.minlength)("maxlength", ctx.maxlength)("autocomplete", ctx.autocomplete)("autocapitalize", ctx.autocapitalize)("autocorrect", ctx.autocorrect)("spellcheck", ctx.spellcheck)("autofocus", ctx.autofocus)("required", ctx.required)("data-icon", ctx.icon ? ctx.icon : null)("data-icon-align", ctx.iconAlign ? ctx.iconAlign : null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
    } }, directives: [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc1.MinLengthValidator, ɵngcc1.MaxLengthValidator, ɵngcc1.RequiredValidator, ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTextarea, [{
        type: Component,
        args: [{
                selector: 'mbsc-textarea',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <textarea #initElement [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.rows]=\"rows\"\n                    [attr.wrap]=\"wrap\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\" \n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.required]=\"required\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\"></textarea>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                providers: [MbscInputService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { rows: [{
            type: Input$1
        }], wrap: [{
            type: Input$1
        }] }); })();
    return MbscTextarea;
}(MbscInputBase));
var MbscDropdown = (function (_super) {
    __extends(MbscDropdown, _super);
    function MbscDropdown(hostElem, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this._inputService = _inputService;
        _inputService.input = _this;
        return _this;
    }
    Object.defineProperty(MbscDropdown.prototype, "value", {
        set: function (v) {
            var _this = this;
            this._value = v;
            setTimeout(function () {
                _this.instance._setText();
            });
        },
        enumerable: true,
        configurable: true
    });
    MbscDropdown.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Select(this._initElem.nativeElement, options);
        var that = this;
        setTimeout(function () {
            that.instance._setText();
        });
    };
    MbscDropdown.prototype.writeValue = function (v) {
        this._value = v;
        if (this.instance) {
            var that_1 = this;
            setTimeout(function () {
                that_1.instance._setText();
            });
        }
    };
    MbscDropdown.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscDropdown.propDecorators = {
        'label': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'value': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
MbscDropdown.ɵfac = function MbscDropdown_Factory(t) { return new (t || MbscDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscDropdown.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscDropdown, selectors: [["mbsc-dropdown"]], hostAttrs: [1, "mbsc-control-ng"], inputs: { value: "value", label: "label", icon: "icon", iconAlign: ["icon-align", "iconAlign"], inputStyle: ["input-style", "inputStyle"], labelStyle: ["label-style", "labelStyle"] }, features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 7, vars: 19, consts: [[1, "mbsc-input-wrap"], [3, "ngModel", "disabled", "ngModelChange", "blur"], ["initElement", ""], ["class", "mbsc-err-msg", 4, "ngIf"], [1, "mbsc-err-msg"]], template: function MbscDropdown_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵelementStart(3, "select", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MbscDropdown_Template_select_ngModelChange_3_listener($event) { return ctx.innerValue = $event; })("blur", function MbscDropdown_Template_select_blur_3_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, MbscDropdown_span_6_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-err", ctx.error)("mbsc-input-box", ctx.inputStyle == "box")("mbsc-input-outline", ctx.inputStyle == "outline")("mbsc-label-stacked", ctx.labelStyle == "stacked")("mbsc-label-inline", ctx.labelStyle == "inline")("mbsc-label-floating", ctx.labelStyle == "floating");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngModel", ctx.innerValue)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("name", ctx.name)("data-icon", ctx.icon ? ctx.icon : null)("data-icon-align", ctx.iconAlign ? ctx.iconAlign : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
    } }, directives: [ɵngcc1.SelectControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDropdown, [{
        type: Component,
        args: [{
                selector: 'mbsc-dropdown',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n            <label \n                [class.mbsc-err]=\"error\"\n                [class.mbsc-input-box]=\"inputStyle == 'box'\"\n                [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n                [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n                [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n                [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n            >\n            {{label}}\n            <span class=\"mbsc-input-wrap\">\n                <select #initElement\n                    [(ngModel)]=\"innerValue\" \n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [disabled]=\"disabled\"\n                    (blur)=\"onTouch($event)\">\n                    <ng-content></ng-content>\n                </select>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
                providers: [MbscInputService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { value: [{
            type: Input$1
        }], label: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], inputStyle: [{
            type: Input$1,
            args: ['input-style']
        }], labelStyle: [{
            type: Input$1,
            args: ['label-style']
        }] }); })();
    return MbscDropdown;
}(MbscFormValueBase));
var MbscButton = (function (_super) {
    __extends(MbscButton, _super);
    function MbscButton(hostElem, formService, zone) {
        var _this = _super.call(this, hostElem, formService, zone) || this;
        _this._flat = false;
        _this._block = false;
        _this._outline = false;
        _this._classesObj = {};
        _this.type = 'button';
        return _this;
    }
    Object.defineProperty(MbscButton.prototype, "cssClasses", {
        get: function () {
            for (var k in this._classesObj) {
                delete this._classesObj[k];
            }
            this._classesObj['mbsc-btn-flat'] = this._flat;
            this._classesObj['mbsc-btn-block'] = this._block;
            this._classesObj['mbsc-btn-outline'] = this._outline;
            if (this.classes) {
                var cssClasses = this.classes.split(' ');
                if (cssClasses.length) {
                    for (var i = 0; i < cssClasses.length; i++) {
                        if (cssClasses[i]) {
                            this._classesObj[cssClasses[i]] = true;
                        }
                    }
                }
            }
            if (this.color) {
                this._classesObj['mbsc-btn-' + this.color] = true;
            }
            return this._classesObj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "flat", {
        set: function (val) {
            this._flat = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "block", {
        set: function (val) {
            this._block = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscButton.prototype, "outline", {
        set: function (val) {
            this._outline = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    MbscButton.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Button(this._initElem.nativeElement, options);
    };
    MbscButton.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscButton.propDecorators = {
        'classes': [{ type: Input$1, args: ['class',] },],
        'type': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'flat': [{ type: Input$1 },],
        'block': [{ type: Input$1 },],
        'outline': [{ type: Input$1 },],
    };
MbscButton.ɵfac = function MbscButton_Factory(t) { return new (t || MbscButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscButton.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscButton, selectors: [["mbsc-button"]], inputs: { flat: "flat", block: "block", outline: "outline", classes: ["class", "classes"], type: "type", icon: "icon" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 3, vars: 5, consts: [[3, "type", "ngClass", "disabled"], ["initElement", ""]], template: function MbscButton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("type", ctx.type)("ngClass", ctx.cssClasses)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("name", ctx.name)("data-icon", ctx.icon ? ctx.icon : null);
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscButton, [{
        type: Component,
        args: [{
                selector: 'mbsc-button',
                template: "\n        <button #initElement \n            [type]=\"type\"\n            [ngClass]=\"cssClasses\"\n            [attr.name]=\"name\"\n            [attr.data-icon]=\"icon ? icon : null\"\n            [disabled]=\"disabled\">\n            <ng-content></ng-content>\n        </button>\n    ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { flat: [{
            type: Input$1
        }], block: [{
            type: Input$1
        }], outline: [{
            type: Input$1
        }], classes: [{
            type: Input$1,
            args: ['class']
        }], type: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }] }); })();
    return MbscButton;
}(MbscFormBase));
var MbscCheckbox = (function (_super) {
    __extends(MbscCheckbox, _super);
    function MbscCheckbox(hostElem, cdr, formService, _inputService, control, zone) {
        var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;
        _this.cdr = cdr;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscCheckbox.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-checkbox-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscCheckbox.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new CheckBox(this._initElem.nativeElement, options);
    };
    MbscCheckbox.prototype.writeValue = function (v) {
        this._value = v;
        this.cdr.detectChanges();
    };
    MbscCheckbox.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscCheckbox.propDecorators = {
        'color': [{ type: Input$1 },],
        'inputStyle': [{ type: Input$1, args: ['input-style',] },],
        'labelStyle': [{ type: Input$1, args: ['label-style',] },],
    };
MbscCheckbox.ɵfac = function MbscCheckbox_Factory(t) { return new (t || MbscCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscCheckbox.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscCheckbox, selectors: [["mbsc-checkbox"]], hostAttrs: [1, "mbsc-control-ng"], inputs: { color: "color", inputStyle: ["input-style", "inputStyle"], labelStyle: ["label-style", "labelStyle"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 5, vars: 7, consts: [[3, "ngClass"], ["type", "checkbox", 3, "disabled", "ngModel", "ngModelChange", "blur"], ["initElement", ""], ["class", "mbsc-err-msg", 4, "ngIf"], [1, "mbsc-err-msg"]], template: function MbscCheckbox_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MbscCheckbox_Template_input_ngModelChange_1_listener($event) { return ctx.innerValue = $event; })("blur", function MbscCheckbox_Template_input_blur_1_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵtemplate(4, MbscCheckbox_span_4_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("ngModel", ctx.innerValue);
        ɵngcc0.ɵɵattribute("name", ctx.name)("data-label-style", ctx.labelStyle)("data-input-style", ctx.inputStyle);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
    } }, directives: [ɵngcc2.NgClass, ɵngcc1.CheckboxControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc2.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscCheckbox, [{
        type: Component,
        args: [{
                selector: 'mbsc-checkbox',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"checkbox\"\n                [attr.name]=\"name\"\n                [disabled]=\"disabled\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [(ngModel)]=\"innerValue\"\n                (blur)=\"onTouch($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { color: [{
            type: Input$1
        }], inputStyle: [{
            type: Input$1,
            args: ['input-style']
        }], labelStyle: [{
            type: Input$1,
            args: ['label-style']
        }] }); })();
    return MbscCheckbox;
}(MbscFormValueBase));
var MbscSwitch = (function (_super) {
    __extends(MbscSwitch, _super);
    function MbscSwitch(hostElem, zone, _formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.disabled = false;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscSwitch.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSwitch.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-switch-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSwitch.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscSwitch.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSwitch.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Switch(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSwitch.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSwitch.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'disabled': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
MbscSwitch.ɵfac = function MbscSwitch_Factory(t) { return new (t || MbscSwitch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscSwitch.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSwitch, selectors: [["mbsc-switch"]], viewQuery: function MbscSwitch_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);
    } }, hostAttrs: [1, "mbsc-control-ng"], inputs: { value: "value", options: "options", disabled: "disabled", name: "name", color: "color", error: "error", errorMessage: "errorMessage" }, outputs: { onChangeEmitter: "valueChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 5, vars: 6, consts: [[3, "ngClass"], ["class", "mbsc-err-msg", 4, "ngIf"], ["type", "checkbox", "data-role", "switch", 3, "disabled", "blur"], ["initElement", ""], [1, "mbsc-err-msg"]], template: function MbscSwitch_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, MbscSwitch_span_2_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵelementStart(3, "input", 2, 3);
        ɵngcc0.ɵɵlistener("blur", function MbscSwitch_Template_input_blur_3_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("name", ctx.name)("data-label-style", ctx.labelStyle)("data-input-style", ctx.inputStyle);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSwitch, [{
        type: Component,
        args: [{
                selector: 'mbsc-switch',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            <input #initElement \n                type=\"checkbox\"\n                data-role=\"switch\"\n                [attr.name]=\"name\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                exportAs: 'mobiscroll',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { value: [{
            type: Input$1,
            args: ['value']
        }], options: [{
            type: Input$1,
            args: ['options']
        }], disabled: [{
            type: Input$1
        }], name: [{
            type: Input$1
        }], color: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], onChangeEmitter: [{
            type: Output,
            args: ['valueChange']
        }], _initElem: [{
            type: ViewChild,
            args: ['initElement', { static: false }]
        }] }); })();
    return MbscSwitch;
}(MbscControlBase));
var MbscStepper = (function (_super) {
    __extends(MbscStepper, _super);
    function MbscStepper(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscStepper.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscStepper.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-stepper-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscStepper.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscStepper.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscStepper.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Stepper(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscStepper.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscStepper.propDecorators = {
        'readonly': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
MbscStepper.ɵfac = function MbscStepper_Factory(t) { return new (t || MbscStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscStepper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscStepper, selectors: [["mbsc-stepper"]], viewQuery: function MbscStepper_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);
    } }, hostAttrs: [1, "mbsc-control-ng"], inputs: { readonly: "readonly", value: "value", options: "options", name: "name", min: "min", max: "max", step: "step", val: "val", disabled: "disabled", color: "color" }, outputs: { onChangeEmitter: "valueChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 10, consts: [[3, "ngClass"], ["data-role", "stepper", 3, "disabled", "readonly"], ["initElement", ""]], template: function MbscStepper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelement(2, "input", 1, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx._readonly);
        ɵngcc0.ɵɵattribute("name", ctx.name)("min", ctx.min !== undefined ? ctx.min : null)("max", ctx.max !== undefined ? ctx.max : null)("step", ctx.step !== undefined ? ctx.step : null)("data-val", ctx.val ? ctx.val : null)("data-label-style", ctx.labelStyle)("data-input-style", ctx.inputStyle);
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscStepper, [{
        type: Component,
        args: [{
                selector: 'mbsc-stepper',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <div [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #initElement\n                data-role=\"stepper\"\n                [attr.name]=\"name\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [disabled]=\"disabled\" \n                [readonly]=\"_readonly\"/>\n        </div>\n    ",
                exportAs: 'mobiscroll',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { readonly: [{
            type: Input$1
        }], value: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['options']
        }], name: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], val: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], color: [{
            type: Input$1
        }], onChangeEmitter: [{
            type: Output,
            args: ['valueChange']
        }], _initElem: [{
            type: ViewChild,
            args: ['initElement', { static: false }]
        }] }); })();
    return MbscStepper;
}(MbscControlBase));
var MbscProgress = (function (_super) {
    __extends(MbscProgress, _super);
    function MbscProgress(hostElement, zone, _formService, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this.max = undefined;
        _this.icon = undefined;
        _this.iconAlign = undefined;
        _this.val = undefined;
        _this.disabled = false;
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscProgress.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscProgress.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-progress-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscProgress.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
        }
    };
    MbscProgress.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscProgress.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Progress(this._initElem.nativeElement, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscProgress.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscProgress.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'value': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'val': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'color': [{ type: Input$1 },],
        '_initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
MbscProgress.ɵfac = function MbscProgress_Factory(t) { return new (t || MbscProgress)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscProgress.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscProgress, selectors: [["mbsc-progress"]], viewQuery: function MbscProgress_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);
    } }, hostAttrs: [1, "mbsc-control-ng"], inputs: { value: "value", options: "options", max: "max", icon: "icon", iconAlign: ["icon-align", "iconAlign"], val: "val", disabled: "disabled", stepLabels: ["step-labels", "stepLabels"], color: "color" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 8, consts: [[3, "ngClass"], ["initElement", ""]], template: function MbscProgress_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelement(2, "progress", null, 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("data-step-labels", ctx.dataStepLabels)("data-icon", ctx.icon ? ctx.icon : null)("data-icon-align", ctx.iconAlign ? ctx.iconAlign : null)("data-label-style", ctx.labelStyle)("data-input-style", ctx.inputStyle)("max", ctx.max !== undefined ? ctx.max : null)("data-val", ctx.val !== undefined ? ctx.val : null);
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscProgress, [{
        type: Component,
        args: [{
                selector: 'mbsc-progress',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <progress #initElement\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.data-val]=\"val !== undefined ? val : null\"\n            >\n            </progress>\n        </label>\n    ",
                exportAs: 'mobiscroll',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { value: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['options']
        }], max: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], val: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], stepLabels: [{
            type: Input$1,
            args: ['step-labels']
        }], color: [{
            type: Input$1
        }], _initElem: [{
            type: ViewChild,
            args: ['initElement', { static: false }]
        }] }); })();
    return MbscProgress;
}(MbscControlBase));
var groupName = 1;
var MbscRadioService = (function () {
    function MbscRadioService() {
        this._lastValue = null;
        this._valueObservable = new Observable();
    }
    Object.defineProperty(MbscRadioService.prototype, "name", {
        get: function () {
            if (!this._name) {
                this._name = 'mbsc-radio-group-' + (groupName++);
            }
            return this._name;
        },
        set: function (n) {
            this._name = n;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "multiSelect", {
        get: function () {
            return this._multiSelect;
        },
        set: function (v) {
            this._multiSelect = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.prototype.onValueChanged = function () {
        return this._valueObservable;
    };
    MbscRadioService.prototype.changeValue = function (v) {
        this._valueObservable.next(v);
        this._lastValue = v;
    };
    Object.defineProperty(MbscRadioService.prototype, "getLastValue", {
        get: function () {
            return this._lastValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadioService.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (v) {
            this._color = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioService.ctorParameters = function () { return []; };
MbscRadioService.ɵfac = function MbscRadioService_Factory(t) { return new (t || MbscRadioService)(); };
MbscRadioService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscRadioService, factory: function (t) { return MbscRadioService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRadioService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscRadioService;
}());
var MbscRadioGroupBase = (function (_super) {
    __extends(MbscRadioGroupBase, _super);
    function MbscRadioGroupBase(hostElement, formService, _inputService, _radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, control, zone) || this;
        _this._radioService = _radioService;
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.innerValue = v;
            _this.onTouch();
        });
        return _this;
    }
    Object.defineProperty(MbscRadioGroupBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this._radioService.changeValue(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscRadioGroupBase.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        if (this.name) {
            this._radioService.name = this.name;
        }
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscRadioGroupBase.prototype.writeValue = function (v) {
        this._value = v;
        this._radioService.changeValue(v);
    };
    MbscRadioGroupBase.prototype.updateOptions = function () { };
    MbscRadioGroupBase.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadioGroupBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, },
        { type: NgZone, },
    ]; };
    MbscRadioGroupBase.propDecorators = {
        'name': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
    };
MbscRadioGroupBase.ɵfac = function MbscRadioGroupBase_Factory(t) { return new (t || MbscRadioGroupBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscRadioGroupBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscRadioGroupBase, selectors: [["", "mbsc-rg-b", ""]], inputs: { value: "value", name: "name" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRadioGroupBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-rg-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscRadioService }, { type: ɵngcc1.NgControl }, { type: ɵngcc0.NgZone }]; }, { value: [{
            type: Input$1
        }], name: [{
            type: Input$1
        }] }); })();
    return MbscRadioGroupBase;
}(MbscFormValueBase));
var MbscRadioGroup = (function (_super) {
    __extends(MbscRadioGroup, _super);
    function MbscRadioGroup(hostElement, formService, _inputService, radioService, control, zone) {
        return _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
    }
    MbscRadioGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
MbscRadioGroup.ɵfac = function MbscRadioGroup_Factory(t) { return new (t || MbscRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscRadioGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRadioGroup, selectors: [["mbsc-radio-group"]], features: [ɵngcc0.ɵɵProvidersFeature([MbscRadioService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRadioGroup, [{
        type: Component,
        args: [{
                selector: 'mbsc-radio-group',
                template: "<ng-content></ng-content>",
                providers: [MbscRadioService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscRadioService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
    return MbscRadioGroup;
}(MbscRadioGroupBase));
var MbscRadio = (function (_super) {
    __extends(MbscRadio, _super);
    function MbscRadio(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this._colorClass = {};
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscRadio.prototype, "checked", {
        get: function () {
            return this.value == this.modelValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRadio.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-radio-' + this.color] = true;
            }
            if (this.error) {
                this._colorClass['mbsc-err'] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRadio.prototype.clicked = function (e) {
        this._radioService.changeValue(this.value);
    };
    MbscRadio.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Radio(this._initElem.nativeElement, options);
    };
    MbscRadio.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.color = this._radioService.color;
    };
    MbscRadio.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscRadio.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscRadio.propDecorators = {
        'value': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
    };
MbscRadio.ɵfac = function MbscRadio_Factory(t) { return new (t || MbscRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscRadio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRadio, selectors: [["mbsc-radio"]], hostAttrs: [1, "mbsc-control-ng"], inputs: { value: "value", error: "error", errorMessage: "errorMessage" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 5, vars: 7, consts: [[3, "ngClass"], ["type", "radio", 3, "value", "checked", "disabled", "click"], ["initElement", ""], ["class", "mbsc-err-msg", 4, "ngIf"], [1, "mbsc-err-msg"]], template: function MbscRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("click", function MbscRadio_Template_input_click_1_listener($event) { return ctx.clicked($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵtemplate(4, MbscRadio_span_4_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("name", ctx.name)("value", ctx.value);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.error && ctx.errorMessage);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRadio, [{
        type: Component,
        args: [{
                selector: 'mbsc-radio',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <label [ngClass]=\"colorClass\">\n            <input #initElement \n                type=\"radio\" \n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [value]=\"value\" \n                [checked]=\"checked\"\n                [disabled]=\"disabled\"\n                (click)=\"clicked($event)\" />\n            <ng-content></ng-content>\n            <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n        </label>\n    "
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscRadioService }, { type: ɵngcc0.NgZone }]; }, { value: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }] }); })();
    return MbscRadio;
}(MbscFormBase));
var MbscSegmentedGroup = (function (_super) {
    __extends(MbscSegmentedGroup, _super);
    function MbscSegmentedGroup(hostElement, formService, _inputService, radioService, control, zone) {
        var _this = _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;
        _this.select = 'single';
        return _this;
    }
    Object.defineProperty(MbscSegmentedGroup.prototype, "multiSelect", {
        get: function () {
            return this.select == 'multiple';
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmentedGroup.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this._radioService.multiSelect = this.multiSelect;
        if (this.color) {
            this._radioService.color = this.color;
        }
    };
    MbscSegmentedGroup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscSegmentedGroup.propDecorators = {
        'select': [{ type: Input$1 },],
    };
MbscSegmentedGroup.ɵfac = function MbscSegmentedGroup_Factory(t) { return new (t || MbscSegmentedGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscSegmentedGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSegmentedGroup, selectors: [["mbsc-segmented-group"]], inputs: { select: "select" }, features: [ɵngcc0.ɵɵProvidersFeature([MbscRadioService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 2, vars: 0, consts: [[1, "mbsc-segmented", "mbsc-segmented-group", "mbsc-no-touch"]], template: function MbscSegmentedGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSegmentedGroup, [{
        type: Component,
        args: [{
                selector: 'mbsc-segmented-group',
                template: "<div class=\"mbsc-segmented mbsc-segmented-group mbsc-no-touch\"><ng-content></ng-content></div>",
                providers: [MbscRadioService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscRadioService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { select: [{
            type: Input$1
        }] }); })();
    return MbscSegmentedGroup;
}(MbscRadioGroupBase));
var MbscSegmented = (function (_super) {
    __extends(MbscSegmented, _super);
    function MbscSegmented(hostElement, formService, _radioService, zone) {
        var _this = _super.call(this, hostElement, formService, zone) || this;
        _this._radioService = _radioService;
        _this.checkedChange = new EventEmitter();
        var v = _this._radioService.getLastValue;
        if (v !== null) {
            _this.modelValue = v;
        }
        _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {
            _this.modelValue = v;
        });
        return _this;
    }
    Object.defineProperty(MbscSegmented.prototype, "isChecked", {
        get: function () {
            if (this.multiSelect) {
                if (this.checked !== undefined) {
                    return this.checked;
                }
                else {
                    return this.modelValue && this.modelValue.includes(this.value);
                }
            }
            else {
                return this.value == this.modelValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.clicked = function (e) {
        if (this.multiSelect && this.checked !== undefined) {
            this.checkedChange.emit(!(!!this.checked));
        }
        else {
            if (this.multiSelect) {
                if (this.modelValue.includes(this.value)) {
                    var i = this.modelValue.indexOf(this.value);
                    this.modelValue.splice(i, 1);
                }
                else {
                    this.modelValue.push(this.value);
                }
                this._radioService.changeValue(this.modelValue);
            }
            else {
                this._radioService.changeValue(this.value);
            }
        }
    };
    Object.defineProperty(MbscSegmented.prototype, "cssClass", {
        get: function () {
            var cl = 'mbsc-segmented-item';
            if (this.color) {
                cl += ' mbsc-segmented-' + this.color;
            }
            return cl;
        },
        enumerable: true,
        configurable: true
    });
    MbscSegmented.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new SegmentedItem(this._initElem.nativeElement, options);
    };
    MbscSegmented.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.name = this._radioService.name;
        this.multiSelect = this._radioService.multiSelect;
        this.color = this._radioService.color;
    };
    MbscSegmented.prototype.ngOnDestroy = function () {
        this._radioService.onValueChanged().unsubscribe(this.valueObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscSegmented.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: MbscRadioService, },
        { type: NgZone, },
    ]; };
    MbscSegmented.propDecorators = {
        'icon': [{ type: Input$1 },],
        'value': [{ type: Input$1 },],
        'checked': [{ type: Input$1 },],
        'checkedChange': [{ type: Output },],
    };
MbscSegmented.ɵfac = function MbscSegmented_Factory(t) { return new (t || MbscSegmented)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscSegmented.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSegmented, selectors: [["mbsc-segmented"]], hostVars: 2, hostBindings: function MbscSegmented_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClass);
    } }, inputs: { icon: "icon", value: "value", checked: "checked" }, outputs: { checkedChange: "checkedChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 6, vars: 8, consts: [[1, "mbsc-segmented-item-ready"], ["data-role", "segmented", 3, "type", "value", "checked", "disabled", "click"], ["initElement", ""], [1, "mbsc-segmented-content"], [3, "class", 4, "ngIf"]], template: function MbscSegmented_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1, 2);
        ɵngcc0.ɵɵlistener("click", function MbscSegmented_Template_input_click_1_listener($event) { return ctx.clicked($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtemplate(4, MbscSegmented_span_4_Template, 1, 3, "span", 4);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("type", ctx.multiSelect ? "checkbox" : "radio")("value", ctx.value)("checked", ctx.isChecked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("name", ctx.name)("value", ctx.value)("data-icon", ctx.icon ? ctx.icon : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSegmented, [{
        type: Component,
        args: [{
                selector: 'mbsc-segmented',
                host: { '[class]': 'cssClass' },
                template: "\n        <label class=\"mbsc-segmented-item-ready\">\n            <input #initElement \n                data-role=\"segmented\"\n                [type]=\"multiSelect ? 'checkbox' : 'radio'\" \n                [value]=\"value\" \n                [checked]=\"isChecked\"\n                [disabled]=\"disabled\"\n                [attr.name]=\"name\" \n                [attr.value]=\"value\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                (click)=\"clicked($event)\" />\n            <span class=\"mbsc-segmented-content\">\n                <span *ngIf=\"icon\" class=\"{{'mbsc-ic mbsc-ic-' + icon }}\"></span>\n                <ng-content></ng-content>\n            </span>\n        </label>\n    "
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: MbscRadioService }, { type: ɵngcc0.NgZone }]; }, { icon: [{
            type: Input$1
        }], value: [{
            type: Input$1
        }], checked: [{
            type: Input$1
        }], checkedChange: [{
            type: Output
        }] }); })();
    return MbscSegmented;
}(MbscFormBase));
var MbscSlider = (function (_super) {
    __extends(MbscSlider, _super);
    function MbscSlider(hostElement, _formService, zone, control) {
        var _this = _super.call(this, hostElement, zone, control, null, null) || this;
        _this._formService = _formService;
        _this._dummy = undefined;
        _this._needsTimeout = false;
        _this.disabled = false;
        _this._colorClass = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscSlider.prototype, "isMulti", {
        get: function () {
            return this._lastValue instanceof Array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dummyArray", {
        get: function () {
            if (!this._dummy || (this.isMulti && this._lastValue && this._lastValue.length && this._dummy.length !== this._lastValue.length)) {
                this._dummy = Array(this.isMulti ? this._lastValue.length : 1).fill(0).map(function (x, i) { return i; });
            }
            return this._dummy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "dataStepLabels", {
        get: function () {
            if (typeof (this.stepLabels) === 'string') {
                return this.stepLabels;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscSlider.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-slider-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscSlider.prototype.reInitialize = function () {
        var _this = this;
        this.instance.destroy();
        this.setElement();
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
    };
    MbscSlider.prototype.setNewValue = function (v) {
        var _this = this;
        this._lastValue = v;
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (this.isMulti && (!innerValue || innerValue.length != v.length)) {
                setTimeout(function () {
                    _this.reInitialize();
                    _this.instance.setVal(_this._lastValue, true, false);
                });
            }
            else {
                var changed = (this.isMulti && !deepEqualsArray(innerValue, v)) || (!this.isMulti && innerValue !== v);
                if (changed) {
                    this.instance.setVal(v, true, false);
                }
            }
        }
    };
    MbscSlider.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscSlider.prototype.initControl = function () {
        var _this = this;
        this.inputElements.forEach(function (input, index) {
            if (index) {
                _this.handleChange(input.nativeElement);
            }
        });
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Slider(this.inputElements.first.nativeElement, options);
        if (this.initialValue !== undefined && this.initialValue !== null) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSlider.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscSlider.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'name': [{ type: Input$1 },],
        'tooltip': [{ type: Input$1 },],
        'highlight': [{ type: Input$1 },],
        'live': [{ type: Input$1 },],
        'valueTemplate': [{ type: Input$1, args: ['value-template',] },],
        'icon': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'stepLabels': [{ type: Input$1, args: ['step-labels',] },],
        'value': [{ type: Input$1, args: ['value',] },],
        'color': [{ type: Input$1 },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'inputElements': [{ type: ViewChildren, args: ['inputElements',] },],
    };
MbscSlider.ɵfac = function MbscSlider_Factory(t) { return new (t || MbscSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscSlider.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSlider, selectors: [["mbsc-slider"]], viewQuery: function MbscSlider_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputElements = _t);
    } }, hostAttrs: [1, "mbsc-control-ng"], inputs: { value: "value", options: "options", name: "name", tooltip: "tooltip", highlight: "highlight", live: "live", valueTemplate: ["value-template", "valueTemplate"], icon: "icon", val: "val", max: "max", min: "min", step: "step", disabled: "disabled", stepLabels: ["step-labels", "stepLabels"], color: "color" }, outputs: { onChangeEmitter: "valueChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 3, vars: 2, consts: [[3, "ngClass"], ["type", "range", 3, "disabled", "blur", 4, "ngFor", "ngForOf"], ["type", "range", 3, "disabled", "blur"], ["inputElements", ""]], template: function MbscSlider_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, MbscSlider_input_2_Template, 2, 15, "input", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.dummyArray);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgForOf], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSlider, [{
        type: Component,
        args: [{
                selector: 'mbsc-slider',
                host: { 'class': 'mbsc-control-ng' },
                template: "\n        <label [ngClass]=\"colorClass\">\n            <ng-content></ng-content>\n            <input #inputElements *ngFor=\"let v of dummyArray\" \n                type=\"range\"\n                [disabled]=\"disabled\"\n                [attr.value]=\"dummyArray.length > 1 && initialValue ? initialValue[v]: initialValue\"\n                [attr.data-step-labels]=\"dataStepLabels\"\n                [attr.data-template]=\"valueTemplate\"\n                [attr.data-tooltip]=\"tooltip ? 'true' : null\"\n                [attr.data-highlight]=\"highlight\"\n                [attr.data-live]=\"live\"\n                [attr.data-icon]=\"icon ? icon : null\"\n                [attr.data-val]=\"val ? val : null\"\n                [attr.data-label-style]=\"labelStyle\"\n                [attr.data-input-style]=\"inputStyle\"\n                [attr.name]=\"name\"\n                [attr.max]=\"max !== undefined ? max : null\"\n                [attr.min]=\"min !== undefined ? min : null\"\n                [attr.step]=\"step !== undefined ? step : null\"\n                (blur)=\"onTouch($event)\" />\n        </label>\n    ",
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { value: [{
            type: Input$1,
            args: ['value']
        }], options: [{
            type: Input$1,
            args: ['options']
        }], name: [{
            type: Input$1
        }], tooltip: [{
            type: Input$1
        }], highlight: [{
            type: Input$1
        }], live: [{
            type: Input$1
        }], valueTemplate: [{
            type: Input$1,
            args: ['value-template']
        }], icon: [{
            type: Input$1
        }], val: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], stepLabels: [{
            type: Input$1,
            args: ['step-labels']
        }], color: [{
            type: Input$1
        }], onChangeEmitter: [{
            type: Output,
            args: ['valueChange']
        }], inputElements: [{
            type: ViewChildren,
            args: ['inputElements']
        }] }); })();
    return MbscSlider;
}(MbscControlBase));
var MbscRating = (function (_super) {
    __extends(MbscRating, _super);
    function MbscRating(hostElem, zone, formService, control) {
        var _this = _super.call(this, hostElem, zone, control, null, null) || this;
        _this.formService = formService;
        _this.min = undefined;
        _this.max = undefined;
        _this.step = undefined;
        _this.disabled = false;
        _this.val = undefined;
        _this.onChangeEmitter = new EventEmitter();
        _this._colorClass = {};
        return _this;
    }
    Object.defineProperty(MbscRating.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRating.prototype, "colorClass", {
        get: function () {
            for (var k in this._colorClass) {
                delete this._colorClass[k];
            }
            if (this.color) {
                this._colorClass['mbsc-rating-' + this.color] = true;
            }
            return this._colorClass;
        },
        enumerable: true,
        configurable: true
    });
    MbscRating.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (this.instance.getVal() !== v) {
                this.instance.setVal(v, true, false);
            }
        }
    };
    MbscRating.prototype.ngOnInit = function () {
        this._inheritedOptions = this.formService ? this.formService.options : {};
        _super.prototype.ngOnInit.call(this);
    };
    MbscRating.prototype.initControl = function () {
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Rating(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscRating.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscRating.propDecorators = {
        'options': [{ type: Input$1 },],
        'name': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'empty': [{ type: Input$1 },],
        'filled': [{ type: Input$1 },],
        'readonly': [{ type: Input$1 },],
        'val': [{ type: Input$1 },],
        'template': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['value',] },],
        'onChangeEmitter': [{ type: Output, args: ['valueChange',] },],
        'color': [{ type: Input$1 },],
    };
MbscRating.ɵfac = function MbscRating_Factory(t) { return new (t || MbscRating)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscRating.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRating, selectors: [["mbsc-rating"]], hostAttrs: [1, "mbsc-control-ng"], inputs: { readonly: "readonly", value: "value", options: "options", name: "name", min: "min", max: "max", step: "step", disabled: "disabled", empty: "empty", filled: "filled", val: "val", template: "template", color: "color" }, outputs: { onChangeEmitter: "valueChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 3, vars: 13, consts: [[3, "ngClass"], ["type", "rating", "data-role", "rating", 3, "disabled", "readonly", "blur"]], template: function MbscRating_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "input", 1);
        ɵngcc0.ɵɵlistener("blur", function MbscRating_Template_input_blur_2_listener($event) { return ctx.onTouch($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.colorClass);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("readonly", ctx._readonly);
        ɵngcc0.ɵɵattribute("name", ctx.name)("min", ctx.min !== undefined ? ctx.min : null)("max", ctx.max !== undefined ? ctx.max : null)("step", ctx.step !== undefined ? ctx.step : null)("data-val", ctx.val ? ctx.val : null)("data-template", ctx.template ? ctx.template : null)("data-empty", ctx.empty)("data-filled", ctx.filled)("data-label-style", ctx.labelStyle)("data-input-style", ctx.inputStyle);
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRating, [{
        type: Component,
        args: [{
                selector: 'mbsc-rating',
                host: { 'class': 'mbsc-control-ng' },
                template: "<label [ngClass]=\"colorClass\">\n        <ng-content></ng-content>\n        <input type=\"rating\" data-role=\"rating\" \n            [attr.name]=\"name\"\n            [attr.min]=\"min !== undefined ? min : null\"\n            [attr.max]=\"max !== undefined ? max : null\"\n            [attr.step]=\"step !== undefined ? step : null\"\n            [attr.data-val]=\"val ? val : null\"\n            [attr.data-template]=\"template ? template : null\"\n            [attr.data-empty]=\"empty\"\n            [attr.data-filled]=\"filled\"\n            [attr.data-label-style]=\"labelStyle\"\n            [attr.data-input-style]=\"inputStyle\"\n            [disabled]=\"disabled\"\n            [readonly]=\"_readonly\"\n            (blur)=\"onTouch($event)\" />\n    </label>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { readonly: [{
            type: Input$1
        }], value: [{
            type: Input$1,
            args: ['value']
        }], options: [{
            type: Input$1
        }], name: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], empty: [{
            type: Input$1
        }], filled: [{
            type: Input$1
        }], val: [{
            type: Input$1
        }], template: [{
            type: Input$1
        }], onChangeEmitter: [{
            type: Output,
            args: ['valueChange']
        }], color: [{
            type: Input$1
        }] }); })();
    return MbscRating;
}(MbscControlBase));
var MbscFormGroup = (function () {
    function MbscFormGroup(initialElem) {
        this.initialElem = initialElem;
        this.collapsible = null;
        this._open = false;
        this.instance = null;
        this.element = null;
        this.element = initialElem;
    }
    Object.defineProperty(MbscFormGroup.prototype, "open", {
        set: function (v) {
            if (this._open != v && this.instance) {
                if (v) {
                    this.instance.show();
                }
                else {
                    this.instance.hide();
                }
            }
            this._open = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscFormGroup.prototype.emptyOrTrue = function (v) {
        return emptyOrTrue(v);
    };
    MbscFormGroup.prototype.ngAfterViewInit = function () {
        if (this.collapsible !== null) {
            this.instance = new CollapsibleBase(this.element.nativeElement, { isOpen: this._open !== false });
        }
    };
    MbscFormGroup.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscFormGroup.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscFormGroup.propDecorators = {
        'collapsible': [{ type: Input$1 },],
        'open': [{ type: Input$1 },],
        'inset': [{ type: Input$1 },],
    };
MbscFormGroup.ɵfac = function MbscFormGroup_Factory(t) { return new (t || MbscFormGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MbscFormGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscFormGroup, selectors: [["mbsc-form-group"]], hostVars: 4, hostBindings: function MbscFormGroup_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-form-group-inset", ctx.emptyOrTrue(ctx.inset))("mbsc-form-group", !ctx.emptyOrTrue(ctx.inset));
    } }, inputs: { collapsible: "collapsible", open: "open", inset: "inset" }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscFormGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormGroup, [{
        type: Component,
        args: [{
                selector: 'mbsc-form-group',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.mbsc-form-group-inset]': 'emptyOrTrue(inset)',
                    '[class.mbsc-form-group]': '!emptyOrTrue(inset)'
                },
                styles: [':host { display: block; }']
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { collapsible: [{
            type: Input$1
        }], open: [{
            type: Input$1
        }], inset: [{
            type: Input$1
        }] }); })();
    return MbscFormGroup;
}());
var MbscFormGroupTitle = (function () {
    function MbscFormGroupTitle() {
    }
    MbscFormGroupTitle.ctorParameters = function () { return []; };
MbscFormGroupTitle.ɵfac = function MbscFormGroupTitle_Factory(t) { return new (t || MbscFormGroupTitle)(); };
MbscFormGroupTitle.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscFormGroupTitle, selectors: [["mbsc-form-group-title"]], hostVars: 2, hostBindings: function MbscFormGroupTitle_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-form-group-title", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscFormGroupTitle_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormGroupTitle, [{
        type: Component,
        args: [{
                selector: 'mbsc-form-group-title',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.mbsc-form-group-title]': 'true'
                },
                styles: [':host { display: block; }']
            }]
    }], function () { return []; }, null); })();
    return MbscFormGroupTitle;
}());
var MbscFormGroupContent = (function () {
    function MbscFormGroupContent() {
    }
    MbscFormGroupContent.ctorParameters = function () { return []; };
MbscFormGroupContent.ɵfac = function MbscFormGroupContent_Factory(t) { return new (t || MbscFormGroupContent)(); };
MbscFormGroupContent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscFormGroupContent, selectors: [["mbsc-form-group-content"]], hostVars: 2, hostBindings: function MbscFormGroupContent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-form-group-content", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscFormGroupContent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormGroupContent, [{
        type: Component,
        args: [{
                selector: 'mbsc-form-group-content',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.mbsc-form-group-content]': 'true'
                },
                styles: [':host { display: block; }']
            }]
    }], function () { return []; }, null); })();
    return MbscFormGroupContent;
}());
var MbscAccordion = (function () {
    function MbscAccordion() {
    }
    MbscAccordion.ctorParameters = function () { return []; };
MbscAccordion.ɵfac = function MbscAccordion_Factory(t) { return new (t || MbscAccordion)(); };
MbscAccordion.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscAccordion, selectors: [["mbsc-accordion"]], hostVars: 2, hostBindings: function MbscAccordion_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mbsc-accordion", true);
    } }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscAccordion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscAccordion, [{
        type: Component,
        args: [{
                selector: 'mbsc-accordion',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.mbsc-accordion]': 'true'
                },
                styles: [':host { display: block; }']
            }]
    }], function () { return []; }, null); })();
    return MbscAccordion;
}());
var comp$3 = [
    MbscForm,
    MbscTextarea,
    MbscDropdown,
    MbscButton,
    MbscCheckbox,
    MbscSwitch,
    MbscStepper,
    MbscProgress,
    MbscRadioGroup,
    MbscRadioGroupBase,
    MbscRadio,
    MbscSegmentedGroup,
    MbscSegmented,
    MbscSlider,
    MbscRating,
    MbscFormGroup,
    MbscFormGroupTitle,
    MbscFormGroupContent,
    MbscAccordion
];
var MbscFormsModule = (function () {
    function MbscFormsModule() {
    }
    MbscFormsModule.ctorParameters = function () { return []; };
MbscFormsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscFormsModule });
MbscFormsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscFormsModule_Factory(t) { return new (t || MbscFormsModule)(); }, imports: [[FormsModule, CommonModule, MbscBaseModule, MbscInputModule], MbscInputModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscFormsModule, { declarations: function () { return [MbscForm, MbscTextarea, MbscDropdown, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscRadioGroup, MbscRadioGroupBase, MbscRadio, MbscSegmentedGroup, MbscSegmented, MbscSlider, MbscRating, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion]; }, imports: function () { return [FormsModule, CommonModule, MbscBaseModule, MbscInputModule]; }, exports: function () { return [MbscForm, MbscTextarea, MbscDropdown, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscRadioGroup, MbscRadioGroupBase, MbscRadio, MbscSegmentedGroup, MbscSegmented, MbscSlider, MbscRating, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion, MbscInputModule, MbscInput]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscFormsModule, [{
        type: NgModule,
        args: [{
                imports: [FormsModule, CommonModule, MbscBaseModule, MbscInputModule],
                declarations: comp$3,
                exports: [comp$3, MbscInputModule, MbscInput]
            }]
    }], function () { return []; }, null); })();
    return MbscFormsModule;
}());

var defaults$5 = {
  invalid: [],
  showInput: true,
  inputClass: '',
  itemSelector: 'li'
};
var List = function List(inst) {
  var currLevel,
      input,
      prevent,
      w,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$5, orig),
      layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),
      isLiquid = layout == 'liquid',
      origReadOnly = s.readonly,
      elm = $$1(this),
      id = this.id + '_dummy',
      lvl = 0,
      currWheelVector = [],
      wa = s.wheelArray || createWheelArray(elm),
      fwv = firstWheelVector(wa);

  function getDepth(tree, l) {
    var i;
    lvl = l > lvl ? l : lvl;

    for (i = 0; i < tree.length; i++) {
      if (tree[i].children) {
        getDepth(tree[i].children, l + 1);
      }
    }
  }
  /**
   * Disables the invalid items on the wheels
   * @param {Object} dw - the jQuery mobiscroll object
   * @param {Number} nrWheels - the number of the current wheels
   * @param {Array} whArray - The wheel array objects containing the wheel tree
   * @param {Array} whVector - the wheel vector containing the current keys
   */


  function getDisabled(nrWheels, whArray, whVector) {
    var i = 0,
        disabled = [];

    while (i < nrWheels) {
      disabled[i] = getInvalidKeys(whVector, i, whArray);
      i++;
    }

    return disabled;
  }
  /**
   * Returns the invalid keys of one wheel as an array
   * @param {Array} whVector - the wheel vector used to search for the wheel in the wheel array
   * @param {Number} index - index of the wheel in the wheel vector, that we are interested in
   * @param {Array} whArray - the wheel array we are searching in
   * @return {Array} - list of invalid keys
   */


  function getInvalidKeys(whVector, index, whArray) {
    var i = 0,
        n,
        whObjA = whArray,
        invalids = [];

    while (i < index) {
      var ii = whVector[i];

      for (n in whObjA) {
        if (whObjA[n].key == ii) {
          whObjA = whObjA[n].children;
          break;
        }
      }

      i++;
    }

    i = 0;

    while (i < whObjA.length) {
      if (whObjA[i].invalid) {
        invalids.push(whObjA[i].key);
      }

      i++;
    }

    return invalids;
  }
  /**
   * Creates a Boolean vector with true values (except one) that can be used as the readonly vector
   * n - the length of the vector
   * i - the index of the value that's going to be false
   */


  function createROVector(n, i) {
    var a = [];

    while (n) {
      a[--n] = true;
    }

    a[i] = false;
    return a;
  }
  /**
   * Creates the wheel array from the vector provided
   * wv - wheel vector containing the values that should be selected on the wheels
   * l - the length of the wheel array
   */


  function generateWheelsFromVector(wv, l, index) {
    var nextLevel,
        j,
        i = 0,
        hasChildren = true,
        w = [[]],
        wtObjA = wa;

    if (l) {
      // if length is defined we need to generate that many wheels (even if they are empty)
      for (j = 0; j < l; j++) {
        if (isLiquid) {
          w[0][j] = {};
        } else {
          w[j] = [{}];
        }
      }
    }

    while (hasChildren) {
      if (isLiquid) {
        w[0][i] = getWheelFromObjA(wtObjA, i);
      } else {
        w[i] = [getWheelFromObjA(wtObjA, i)];
      }

      j = 0;
      nextLevel = null;

      while (j < wtObjA.length && !nextLevel) {
        if (wtObjA[j].key == wv[i] && (index !== undefined && i <= index || index === undefined)) {
          nextLevel = wtObjA[j];
        }

        j++;
      }

      if (!nextLevel) {
        nextLevel = getFirstValidItemObjOrInd(wtObjA);
      }

      if (nextLevel && nextLevel.children) {
        wtObjA = nextLevel.children;
        i++;
      } else {
        hasChildren = false;
      }
    }

    return w;
  }
  /**
   * Returns the first valid Wheel Node Object or its index from a Wheel Node Object Array
   * getInd - if it is true then the return value is going to be the index, otherwise the object itself
   */


  function getFirstValidItemObjOrInd(wtObjA, getInd) {
    if (!wtObjA) {
      return false;
    }

    var i = 0,
        obj;

    while (i < wtObjA.length) {
      if (!(obj = wtObjA[i++]).invalid) {
        return getInd ? i - 1 : obj;
      }
    }

    return false;
  }

  function getWheelFromObjA(objA, i) {
    var wheel = {
      data: [],
      label: s.labels && s.labels[i] ? s.labels[i] : i
    },
        j = 0;

    while (j < objA.length) {
      wheel.data.push({
        value: objA[j].key,
        display: objA[j].value
      });
      j++;
    }

    return wheel;
  }
  /**
   * Hides the last i number of wheels
   * i - the last number of wheels that has to be hidden
   */


  function hideWheels(i) {
    if (inst._isVisible) {
      $$1('.mbsc-sc-whl-w', inst._markup).css('display', '').slice(i).hide();
    }
  }
  /**
   * Generates the first wheel vector from the wheeltree
   * wt - the wheel tree object
   * uses the lvl global variable to determine the length of the vector
   */


  function firstWheelVector(wa) {
    var t = [],
        ndObjA = wa,
        obj,
        ok = true,
        i = 0;

    while (ok) {
      obj = getFirstValidItemObjOrInd(ndObjA);
      t[i++] = obj.key;
      ok = obj.children;

      if (ok) {
        ndObjA = ok;
      }
    }

    return t;
  }
  /**
   * Calculates the level of a wheel vector and the new wheel vector, depending on current wheel vector and the index of the changed wheel
   * wv - current wheel vector
   * index - index of the changed wheel
   */


  function calcLevelOfVector2(wv, index) {
    var childIdx,
        childName,
        i,
        level = 0,
        ndObjA = wa,
        next = true,
        t = [];

    while (next) {
      if (wv[level] !== undefined && level <= index) {
        i = 0;
        childName = wv[level];
        childIdx = undefined;

        while (i < ndObjA.length && childIdx === undefined) {
          if (ndObjA[i].key == wv[level] && !ndObjA[i].invalid) {
            childIdx = i;
          }

          i++;
        }
      } else {
        childIdx = getFirstValidItemObjOrInd(ndObjA, true);
        childName = ndObjA[childIdx] && ndObjA[childIdx].key;
      }

      t[level] = childName;
      level++;
      next = ndObjA[childIdx] ? ndObjA[childIdx].children : false;
      ndObjA = ndObjA[childIdx] && ndObjA[childIdx].children;
    } // return the calculated level and the wheel vector as an object


    return {
      lvl: level,
      nVector: t
    };
  }

  function createWheelArray(ul) {
    var wheelArray = [];
    var children = ul.length > 1 ? ul : ul.children(s.itemSelector);
    children.each(function (index) {
      var that = $$1(this),
          c = that.clone();
      c.children('ul,ol').remove();
      c.children(s.itemSelector).remove();
      var v = inst._processMarkup ? inst._processMarkup(c) : c.html().replace(/^\s\s*/, '').replace(/\s\s*$/, ''),
          inv = that.attr('data-invalid') ? true : false,
          wheelObj = {
        key: that.attr('data-val') === undefined || that.attr('data-val') === null ? index : that.attr('data-val'),
        value: v,
        invalid: inv,
        children: null
      },
          nest = s.itemSelector === 'li' ? that.children('ul,ol') : that.children(s.itemSelector);

      if (nest.length) {
        wheelObj.children = createWheelArray(nest);
      }

      wheelArray.push(wheelObj);
    });
    return wheelArray;
  }

  function changeWheels(values, index, o) {
    var j,
        i = (index || 0) + 1,
        args = [],
        w = {},
        wheels = {};
    w = generateWheelsFromVector(values, null, index);

    for (j = 0; j < values.length; j++) {
      inst._tempWheelArray[j] = values[j] = o.nVector[j] || 0;
    }

    while (i < o.lvl) {
      wheels[i] = isLiquid ? w[0][i] : w[i][0];
      args.push(i++);
    }

    hideWheels(o.lvl);
    currWheelVector = values.slice(0);

    if (args.length) {
      prevent = true;
      inst.changeWheel(wheels);
    }
  } // Calculate the maximum depth of the tree


  getDepth(wa, 1);
  w = generateWheelsFromVector(fwv, lvl); // Remove input if exists

  $$1('#' + id).remove();

  if (s.input) {
    input = $$1(s.input);
  } else if (s.showInput) {
    input = $$1('<input type="text" id="' + id + '" value="" class="' + s.inputClass + '" placeholder="' + (s.placeholder || '') + '" readonly />').insertBefore(elm);
  }

  if (input) {
    inst.attachShow(input);
  }

  if (!s.wheelArray) {
    elm.hide();
  }

  return {
    wheels: w,
    anchor: input,
    layout: layout,
    headerText: false,
    setOnTap: lvl == 1,
    formatValue: function formatValue(d) {
      if (currLevel === undefined) {
        currLevel = calcLevelOfVector2(d, d.length).lvl;
      }

      return d.slice(0, currLevel).join(' ');
    },
    parseValue: function parseValue(value) {
      return value ? (value + '').split(' ') : (s.defaultValue || fwv).slice(0);
    },
    onBeforeShow: function onBeforeShow() {
      var t = inst.getArrayVal(true);
      currWheelVector = t.slice(0);
      s.wheels = generateWheelsFromVector(t, lvl, lvl);
      prevent = true;
    },
    onWheelGestureStart: function onWheelGestureStart(ev) {
      s.readonly = createROVector(lvl, ev.index);
    },
    onWheelAnimationEnd: function onWheelAnimationEnd(ev) {
      var index = ev.index,
          values = inst.getArrayVal(true),
          o = calcLevelOfVector2(values, index);
      currLevel = o.lvl;
      s.readonly = origReadOnly;

      if (values[index] != currWheelVector[index]) {
        changeWheels(values, index, o);
      }
    },
    onFill: function onFill(ev) {
      currLevel = undefined;

      if (input) {
        input.val(ev.valueText);
      }
    },
    validate: function validate(data) {
      var values = data.values,
          index = data.index,
          o = calcLevelOfVector2(values, values.length);
      currLevel = o.lvl;

      if (index === undefined) {
        hideWheels(o.lvl);

        if (!prevent) {
          changeWheels(values, index, o);
        }
      }

      prevent = false;
      return {
        disabled: getDisabled(currLevel, wa, values)
      };
    },
    onDestroy: function onDestroy() {
      if (input) {
        $$1('#' + id).remove();
      }

      elm.show();
    }
  };
};

var ImageScroller = Scroller;

presets.image = function (inst) {
  if (inst.settings.enhance) {
    inst._processMarkup = function (li) {
      var hasIcon = li.attr('data-icon');
      li.children().each(function (i, v) {
        v = $$1(v);

        if (v.is('img')) {
          $$1('<div class="mbsc-img-c"></div>').insertAfter(v).append(v.addClass('mbsc-img'));
        } else if (v.is('p')) {
          v.addClass('mbsc-img-txt');
        }
      });

      if (hasIcon) {
        li.prepend('<div class="mbsc-ic mbsc-ic-' + hasIcon + '"></div');
      }

      li.html('<div class="mbsc-img-w">' + li.html() + '</div>');
      return li.html();
    };
  }

  return List.call(this, inst);
};

var MbscImage = (function (_super) {
    __extends(MbscImage, _super);
    function MbscImage(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.enhance = true;
        _this.placeholder = '';
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscImage.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscImage.prototype.initControl = function () {
        var _this = this;
        var target = this.target;
        if (target) {
            if (typeof target !== 'string') {
                if (target._elementRef && target._elementRef.nativeElement) {
                    target = target._elementRef.nativeElement;
                }
                else if (target.getInputElement) {
                    target.getInputElement().then(function (inp) {
                        _this.updateOptions({ input: inp }, true, false, false);
                    });
                }
                else if (target.element) {
                    target = target.element;
                }
            }
        }
        var options = extend$1({ preset: 'image', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new ImageScroller(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscImage.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
            if (this._inputService && this._inputService.input) {
                this._inputService.input.innerValue = this.instance._value;
            }
        }
    };
    MbscImage.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscImage.propDecorators = {
        'defaultValue': [{ type: Input$1 },],
        'enhance': [{ type: Input$1 },],
        'inputClass': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'labels': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'wheelArray': [{ type: Input$1, args: ['mbsc-data',] },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'target': [{ type: Input$1, args: ['mbsc-target',] },],
        'value': [{ type: Input$1, args: ['mbsc-image',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-imageChange',] },],
    };
MbscImage.ɵfac = function MbscImage_Factory(t) { return new (t || MbscImage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscImage.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscImage, selectors: [["", "mbsc-image", ""]], inputs: { value: ["mbsc-image", "value"], defaultValue: "defaultValue", enhance: "enhance", inputClass: "inputClass", invalid: "invalid", labels: "labels", placeholder: "placeholder", showInput: "showInput", wheelArray: ["mbsc-data", "wheelArray"], options: ["mbsc-options", "options"], target: ["mbsc-target", "target"] }, outputs: { onChangeEmitter: "mbsc-imageChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscImage, [{
        type: Directive,
        args: [{
                selector: '[mbsc-image]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-image']
        }], defaultValue: [{
            type: Input$1
        }], enhance: [{
            type: Input$1
        }], inputClass: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], labels: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], showInput: [{
            type: Input$1
        }], wheelArray: [{
            type: Input$1,
            args: ['mbsc-data']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], target: [{
            type: Input$1,
            args: ['mbsc-target']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-imageChange']
        }] }); })();
    return MbscImage;
}(MbscScrollerBase));
var MbscImageComponent = (function (_super) {
    __extends(MbscImageComponent, _super);
    function MbscImageComponent(initialElem, zone, listService, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.listService = listService;
        _this.errorMessage = '';
        _this.label = '';
        _this.placeholder = '';
        _this.showInput = false;
        _this.inlineOptionsObj = {
            itemSelector: 'mbsc-image-item',
            showInput: false
        };
        return _this;
    }
    MbscImageComponent.prototype.setElement = function () {
        if (this.itemWrapper) {
            this.element = this.itemWrapper.nativeElement;
        }
        else {
            this.element = this.initialElem.nativeElement;
        }
    };
    MbscImageComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.addRemoveHandler = this.listService.onAddRemove().subscribe(function (item) {
            if (_this.instance) {
                _this.instance.option({});
            }
        });
    };
    MbscImageComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscImageComponent.prototype.initControl = function () {
        if (!this.target) {
            this.target = $$1('mbsc-input', this.initialElem.nativeElement)[0];
        }
        _super.prototype.initControl.call(this);
    };
    MbscImageComponent.prototype.ngOnDestroy = function () {
        this.listService.onAddRemove().unsubscribe(this.addRemoveHandler);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscImageComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscListService, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscImageComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'wheelArray': [{ type: Input$1, args: ['data',] },],
        'label': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'itemWrapper': [{ type: ViewChild, args: ['itemWrapper', { static: false },] },],
        'showInput': [{ type: Input$1 },],
    };
MbscImageComponent.ɵfac = function MbscImageComponent_Factory(t) { return new (t || MbscImageComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscListService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscImageComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscImageComponent, selectors: [["mbsc-image"]], viewQuery: function MbscImageComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemWrapper = _t.first);
    } }, inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", wheelArray: ["data", "wheelArray"], label: "label", placeholder: "placeholder", showInput: "showInput" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscListService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 4, vars: 1, consts: [[3, "name", "theme", "disabled", "error", "errorMessage", "icon", "icon-align", "placeholder", "controlNg", 4, "ngIf"], ["itemWrapper", ""], [3, "name", "theme", "disabled", "error", "errorMessage", "icon", "icon-align", "placeholder", "controlNg"]], template: function MbscImageComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscImageComponent_mbsc_input_0_Template, 2, 10, "mbsc-input", 0);
        ɵngcc0.ɵɵelementStart(1, "span", null, 1);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscImageComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-image',
                exportAs: 'mobiscroll',
                template: "<mbsc-input *ngIf=\"!inline || showInput\" \n        [name]=\"name\" \n        [theme]=\"theme\" \n        [disabled]=\"disabled\" \n        [error]=\"error\" \n        [errorMessage]=\"errorMessage\" \n        [icon]=\"inputIcon\" \n        [icon-align]=\"iconAlign\"\n        [placeholder]=\"placeholder\"\n        [controlNg]=\"false\">{{label}}\n        </mbsc-input>\n        <span #itemWrapper><ng-content></ng-content></span>",
                providers: [MbscListService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscListService }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], wheelArray: [{
            type: Input$1,
            args: ['data']
        }], label: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], itemWrapper: [{
            type: ViewChild,
            args: ['itemWrapper', { static: false }]
        }], showInput: [{
            type: Input$1
        }] }); })();
    return MbscImageComponent;
}(MbscImage));
var MbscImageItem = (function () {
    function MbscImageItem(listService) {
        this.listService = listService;
    }
    MbscImageItem.prototype.ngAfterViewInit = function () {
        this.listService.notifyAddRemove(this);
    };
    MbscImageItem.prototype.ngOnDestroy = function () {
        this.listService.notifyAddRemove(this);
    };
    MbscImageItem.ctorParameters = function () { return [
        { type: MbscListService, },
    ]; };
    MbscImageItem.propDecorators = {
        'value': [{ type: Input$1 },],
        'icon': [{ type: Input$1 },],
    };
MbscImageItem.ɵfac = function MbscImageItem_Factory(t) { return new (t || MbscImageItem)(ɵngcc0.ɵɵdirectiveInject(MbscListService)); };
MbscImageItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscImageItem, selectors: [["mbsc-image-item"]], hostVars: 2, hostBindings: function MbscImageItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-val", ctx.value)("data-icon", ctx.icon);
    } }, inputs: { value: "value", icon: "icon" }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscImageItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscImageItem, [{
        type: Component,
        args: [{
                selector: 'mbsc-image-item',
                template: '<ng-content></ng-content>',
                host: {
                    '[attr.data-val]': 'value',
                    '[attr.data-icon]': 'icon'
                }
            }]
    }], function () { return [{ type: MbscListService }]; }, { value: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }] }); })();
    return MbscImageItem;
}());
var MbscImageModule = (function () {
    function MbscImageModule() {
    }
    MbscImageModule.ctorParameters = function () { return []; };
MbscImageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscImageModule });
MbscImageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscImageModule_Factory(t) { return new (t || MbscImageModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscImageModule, { declarations: function () { return [MbscImage, MbscImageComponent, MbscImageItem]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscImage, MbscImageComponent, MbscImageItem]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscImageModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscImage, MbscImageComponent, MbscImageItem],
                exports: [MbscImage, MbscImageComponent, MbscImageItem]
            }]
    }], function () { return []; }, null); })();
    return MbscImageModule;
}());

var Measurement = Scroller;
var defaults$6 = {
  batch: 50,
  min: 0,
  max: 100,
  defaultUnit: '',
  units: null,
  unitNames: null,
  invalid: [],
  sign: false,
  step: 0.05,
  scale: 2,
  convert: function convert(val) {
    return val;
  },
  // Localization
  decimalSeparator: '.',
  signText: '&nbsp;',
  wholeText: 'Whole',
  fractionText: 'Fraction',
  unitText: 'Unit'
};

presets.measurement = function (inst) {
  var orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$6, orig),
      wheel = {},
      w = [[]],
      wholeInvalids = {},
      wholeWheel = {},
      fractionWheel = {},
      fractions = [],
      useSign = s.sign,
      useUnits = s.units && s.units.length,
      baseUnit = useUnits ? s.defaultUnit || s.units[0] : '',
      units = [],
      useFract = s.step < 1,
      wholeStep = s.step > 1 ? s.step : 1,
      fractLength = useFract ? Math.max(s.scale, (s.step + '').split('.')[1].length) : 1,
      one = Math.pow(10, fractLength),
      steps = Math.round(useFract ? s.step * one : s.step),
      fractNr,
      realValue,
      oldUnit,
      idxFract,
      idxWhole,
      idxUnit,
      minVal,
      maxVal,
      minWhole,
      maxWhole,
      minFract,
      maxFract,
      wholeOffset = 0,
      fractOffset = 0,
      v,
      j,
      i = 0;

  function getWhole(k) {
    return Math.max(minWhole, Math.min(maxWhole, useFract ? k < 0 ? Math.ceil(k) : Math.floor(k) : step(Math.round(k - wholeOffset), steps) + wholeOffset));
  }

  function getFract(k) {
    return useFract ? step((Math.abs(k) - Math.abs(getWhole(k))) * one - fractOffset, steps) + fractOffset : 0;
  }

  function getParts(v) {
    var whole = getWhole(v),
        fract = getFract(v),
        sign = v < 0 ? '-' : '+';

    if (fract >= one) {
      if (v < 0) {
        whole--;
      } else {
        whole++;
      }

      fract = 0;
    }

    return [sign, whole, fract];
  }

  function getNr(d) {
    var whole = +d[idxWhole],
        fract = useFract ? d[idxFract] / one * (whole < 0 ? -1 : 1) : 0;
    return (useSign && d[0] == '-' ? -1 : 1) * (whole + fract);
  }

  function step(v, st) {
    return Math.round(v / st) * st;
  }

  function convert(v, u1, u2) {
    if (u1 === u2 || !s.convert) {
      return v;
    }

    return s.convert.call(this, v, u1, u2);
  }

  function setMinMax(unit) {
    var minv, maxv;
    minVal = convert(s.min, baseUnit, unit);
    maxVal = convert(s.max, baseUnit, unit);

    if (useFract) {
      minWhole = minVal < 0 ? Math.ceil(minVal) : Math.floor(minVal);
      maxWhole = maxVal < 0 ? Math.ceil(maxVal) : Math.floor(maxVal);
      minFract = getFract(minVal);
      maxFract = getFract(maxVal);
    } else {
      minWhole = Math.round(minVal);
      maxWhole = Math.round(maxVal);
      maxWhole = minWhole + Math.floor((maxWhole - minWhole) / steps) * steps;
      wholeOffset = minWhole % steps;
    }

    minv = minWhole;
    maxv = maxWhole;

    if (useSign) {
      maxv = Math.abs(minv) > Math.abs(maxv) ? Math.abs(minv) : Math.abs(maxv);
      minv = minv < 0 ? 0 : minv;
    }

    wholeWheel.min = minv < 0 ? Math.ceil(minv / wholeStep) : Math.floor(minv / wholeStep);
    wholeWheel.max = maxv < 0 ? Math.ceil(maxv / wholeStep) : Math.floor(maxv / wholeStep);
  }

  function format(d) {
    return getNr(d).toFixed(useFract ? fractLength : 0) + (useUnits ? ' ' + units[d[idxUnit]] : '');
  } // Extended methods
  // ---


  inst.setVal = function (val, fill, change, temp, time) {
    // Force parse if value is passed as an array
    inst._setVal($$1.isArray(val) ? format(val) : val, fill, change, temp, time);
  }; // ---
  // Inits
  // generate array from unitNames


  if (s.units) {
    for (j = 0; j < s.units.length; ++j) {
      v = s.units[j];
      units.push(s.unitNames ? s.unitNames[v] || v : v);
    }
  } // Check if sign is needed


  if (useSign) {
    useSign = false;

    if (useUnits) {
      for (j = 0; j < s.units.length; j++) {
        if (convert(s.min, baseUnit, s.units[j]) < 0) {
          useSign = true;
        }
      }
    } else {
      useSign = s.min < 0;
    }
  } // Sign wheel (if enabled)


  if (useSign) {
    w[0].push({
      data: ['-', '+'],
      label: s.signText
    });
    i++;
  } // Whole wheel (later generated)


  wholeWheel = {
    label: s.wholeText,
    data: function data(i) {
      return minWhole % wholeStep + i * wholeStep;
    },
    getIndex: function getIndex(i) {
      return Math.round((i - minWhole % wholeStep) / wholeStep);
    }
  };
  w[0].push(wholeWheel);
  idxWhole = i++;
  setMinMax(baseUnit); // Fraction wheel

  if (useFract) {
    w[0].push(fractionWheel);
    fractionWheel.data = [];
    fractionWheel.label = s.fractionText;

    for (j = fractOffset; j < one; j += steps) {
      fractions.push(j);
      fractionWheel.data.push({
        value: j,
        display: s.decimalSeparator + pad(j, fractLength)
      });
    }

    idxFract = i++;
    fractNr = Math.ceil(100 / steps);

    if (s.invalid && s.invalid.length) {
      // Calculate whole invalids
      $$1.each(s.invalid, function (i, v) {
        var w = v > 0 ? Math.floor(v) : Math.ceil(v);

        if (w === 0) {
          // We need to track +0 and -0 sepparately
          w = v <= 0 ? -0.001 : 0.001;
        }

        wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;

        if (v === 0) {
          w = 0.001;
          wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;
        }
      });
      $$1.each(wholeInvalids, function (i, v) {
        if (v < fractNr) {
          delete wholeInvalids[i];
        } else {
          wholeInvalids[i] = i;
        }
      });
    }
  } // Unit wheel


  if (useUnits) {
    wheel = {
      data: [],
      label: s.unitText,
      cssClass: 'mbsc-msr-whl-unit',
      circular: false
    };

    for (j = 0; j < s.units.length; j++) {
      wheel.data.push({
        value: j,
        display: units[j]
      });
    }

    w[0].push(wheel);
  }

  idxUnit = i;
  return {
    wheels: w,
    minWidth: useSign && useFract ? 70 : 80,
    showLabel: false,
    formatValue: format,
    compClass: 'mbsc-msr mbsc-sc',
    parseValue: function parseValue(v) {
      var vv = (typeof v === 'number' ? v + '' : v) || s.defaultValue,
          d = (vv + '').split(' '),
          val = +d[0],
          ret = [],
          parts,
          unit = '';

      if (useUnits) {
        unit = $$1.inArray(d[1], units);
        unit = unit == -1 ? $$1.inArray(baseUnit, s.units) : unit;
        unit = unit == -1 ? 0 : unit;
      }

      oldUnit = useUnits ? s.units[unit] : '';
      setMinMax(oldUnit);
      val = isNaN(val) ? 0 : val;
      val = constrain(val, minVal, maxVal);
      parts = getParts(val);
      parts[1] = constrain(parts[1], minWhole, maxWhole);
      realValue = val;

      if (useSign) {
        ret[0] = parts[0];
        parts[1] = Math.abs(parts[1]);
      }

      ret[idxWhole] = parts[1];

      if (useFract) {
        ret[idxFract] = parts[2];
      }

      if (useUnits) {
        ret[idxUnit] = unit;
      }

      return ret;
    },
    onCancel: function onCancel() {
      realValue = undefined;
    },
    validate: function validate(data) {
      var minus,
          parts,
          whole,
          iparts,
          from,
          values = data.values,
          index = data.index,
          dir = data.direction,
          dis = {},
          disabled = [],
          wheels = {},
          newUnit = useUnits ? s.units[values[idxUnit]] : ''; // Sign changed

      if (useSign && index === 0) {
        realValue = Math.abs(realValue) * (values[0] == '-' ? -1 : 1);
      } // Set real value if numbers changed


      if (index === idxWhole || index === idxFract && useFract || realValue === undefined || index === undefined) {
        realValue = getNr(values);
        oldUnit = newUnit;
      } // Convert value if unit changed


      if (useUnits && index === idxUnit && oldUnit !== newUnit || index === undefined) {
        setMinMax(newUnit);
        realValue = convert(realValue, oldUnit, newUnit);
        oldUnit = newUnit;
        parts = getParts(realValue);

        if (index !== undefined) {
          //wholeWheel._refresh();
          wheels[idxWhole] = wholeWheel;
          inst.changeWheel(wheels);
        }

        if (useSign) {
          values[0] = parts[0];
        }
      } // Disable invalid values


      disabled[idxWhole] = [];

      if (useSign) {
        // Disable +/- signs
        disabled[0] = [];

        if (minVal > 0) {
          disabled[0].push('-');
          values[0] = '+';
        }

        if (maxVal < 0) {
          disabled[0].push('+');
          values[0] = '-';
        }

        from = Math.abs(values[0] == '-' ? minWhole : maxWhole);

        for (i = from + wholeStep; i < from + 20 * wholeStep; i += wholeStep) {
          disabled[idxWhole].push(i);
          dis[i] = true;
        }
      }

      realValue = constrain(realValue, minVal, maxVal);
      parts = getParts(realValue);
      whole = useSign ? Math.abs(parts[1]) : parts[1];
      minus = useSign ? values[0] == '-' : realValue < 0;
      values[idxWhole] = whole;

      if (minus) {
        // Need this for 0
        parts[0] = '-';
      }

      if (useFract) {
        values[idxFract] = parts[2];
      } // Disable invalid values on whole wheel


      $$1.each(useFract ? wholeInvalids : s.invalid, function (i, v) {
        // disable whole user values
        if (useSign && minus) {
          if (v <= 0) {
            v = Math.abs(v);
          } else {
            return;
          }
        }

        v = step(convert(v, baseUnit, newUnit), useFract ? 1 : steps);
        dis[v] = true;
        disabled[idxWhole].push(v);
      }); // Find nearest valid whole value

      values[idxWhole] = inst.getValidValue(idxWhole, whole, dir, dis);
      parts[1] = values[idxWhole] * (useSign && minus ? -1 : 1); // Validate fraction wheel values

      if (useFract) {
        disabled[idxFract] = []; // We need to make difference between +0 and -0, so we compare the strings instead of numbers

        var p1 = useSign ? values[0] + values[1] : (realValue < 0 ? '-' : '+') + Math.abs(parts[1]),
            p2 = (minVal < 0 ? '-' : '+') + Math.abs(minWhole),
            p3 = (maxVal < 0 ? '-' : '+') + Math.abs(maxWhole); // Disable out of range fraction values

        if (p1 === p2) {
          $$1(fractions).each(function (i, v) {
            if (minus ? v > minFract : v < minFract) {
              disabled[idxFract].push(v);
            }
          });
        }

        if (p1 === p3) {
          $$1(fractions).each(function (i, v) {
            if (minus ? v < maxFract : v > maxFract) {
              disabled[idxFract].push(v);
            }
          });
        } // Disable invalid fraction values


        $$1.each(s.invalid, function (i, v) {
          iparts = getParts(convert(v, baseUnit, newUnit)); // Sign and whole part matches

          if ((parts[0] === iparts[0] || parts[1] === 0 && iparts[1] === 0 && iparts[2] === 0) && parts[1] === iparts[1]) {
            disabled[idxFract].push(iparts[2]);
          }
        });
      }

      return {
        disabled: disabled,
        valid: values
      };
    }
  };
};

var defaults$7 = {
  min: -20,
  max: 40,
  defaultUnit: 'c',
  units: ['c', 'k', 'f', 'r'],
  unitNames: {
    c: '°C',
    k: 'K',
    f: '°F',
    r: '°R'
  }
},
    cobj = {
  c2k: function c2k(c) {
    return c + 273.15;
  },
  c2f: function c2f(c) {
    return c * 9 / 5 + 32;
  },
  c2r: function c2r(c) {
    return (c + 273.15) * 9 / 5;
  },
  k2c: function k2c(k) {
    return k - 273.15;
  },
  k2f: function k2f(k) {
    return k * 9 / 5 - 459.67;
  },
  k2r: function k2r(k) {
    return k * 9 / 5;
  },
  f2c: function f2c(f) {
    return (f - 32) * 5 / 9;
  },
  f2k: function f2k(f) {
    return (f + 459.67) * 5 / 9;
  },
  f2r: function f2r(f) {
    return f + 459.67;
  },
  r2c: function r2c(r) {
    return (r - 491.67) * 5 / 9;
  },
  r2k: function r2k(r) {
    return r * 5 / 9;
  },
  r2f: function r2f(r) {
    return r - 459.67;
  }
};

presets.temperature = function (inst) {
  var s = extend$1({}, defaults$7, inst.settings);
  extend$1(inst.settings, s, {
    sign: true,
    convert: function convert(val, unit1, unit2) {
      return cobj[unit1 + '2' + unit2](val);
    }
  });
  return presets.measurement.call(this, inst);
};

var defaults$8 = {
  min: 0,
  max: 100,
  defaultUnit: 'km',
  units: ['m', 'km', 'in', 'ft', 'yd', 'mi']
},
    cobj$1 = {
  mm: 0.001,
  cm: 0.01,
  dm: 0.1,
  m: 1,
  dam: 10,
  hm: 100,
  km: 1000,
  'in': 0.0254,
  ft: 0.3048,
  yd: 0.9144,
  ch: 20.1168,
  fur: 201.168,
  mi: 1609.344,
  lea: 4828.032
};

presets.distance = function (inst) {
  var s = extend$1({}, defaults$8, inst.settings);
  extend$1(inst.settings, s, {
    sign: false,
    convert: function convert(val, unit1, unit2) {
      return val * cobj$1[unit1] / cobj$1[unit2];
    }
  });
  return presets.measurement.call(this, inst);
};

var defaults$9 = {
  min: 0,
  max: 100,
  defaultUnit: 'kph',
  units: ['kph', 'mph', 'mps', 'fps', 'knot'],
  unitNames: {
    kph: 'km/h',
    mph: 'mi/h',
    mps: 'm/s',
    fps: 'ft/s',
    knot: 'knot'
  }
},
    cobj$2 = {
  kph: 1,
  mph: 1.60934,
  mps: 3.6,
  fps: 1.09728,
  knot: 1.852
};

presets.speed = function (inst) {
  var s = extend$1({}, defaults$9, inst.settings);
  extend$1(inst.settings, s, {
    sign: false,
    convert: function convert(val, unit1, unit2) {
      return val * cobj$2[unit1] / cobj$2[unit2];
    }
  });
  return presets.measurement.call(this, inst);
};

var defaults$a = {
  min: 0,
  max: 100,
  defaultUnit: 'N',
  units: ['N', 'kp', 'lbf', 'pdl']
},
    cobj$3 = {
  N: 1,
  kp: 9.80665,
  lbf: 4.448222,
  pdl: 0.138255
};

presets.force = function (inst) {
  var s = extend$1({}, defaults$a, inst.settings);
  extend$1(inst.settings, s, {
    sign: false,
    convert: function convert(val, unit1, unit2) {
      return val * cobj$3[unit1] / cobj$3[unit2];
    }
  });
  return presets.measurement.call(this, inst);
};

var defaults$b = {
  min: 0,
  max: 1000,
  defaultUnit: 'kg',
  units: ['g', 'kg', 'oz', 'lb'],
  unitNames: {
    tlong: 't (long)',
    tshort: 't (short)'
  }
},
    cobj$4 = {
  mg: 0.001,
  cg: 0.01,
  dg: 0.1,
  g: 1,
  dag: 10,
  hg: 100,
  kg: 1000,
  t: 1000000,
  drc: 1.7718452,
  oz: 28.3495,
  lb: 453.59237,
  st: 6350.29318,
  qtr: 12700.58636,
  cwt: 50802.34544,
  tlong: 1016046.9088,
  tshort: 907184.74
};

presets.mass = function (inst) {
  var s = extend$1({}, defaults$b, inst.settings);
  extend$1(inst.settings, s, {
    sign: false,
    convert: function convert(val, unit1, unit2) {
      return val * cobj$4[unit1] / cobj$4[unit2];
    }
  });
  return presets.measurement.call(this, inst);
};

var MbscMeasurementBase = (function (_super) {
    __extends(MbscMeasurementBase, _super);
    function MbscMeasurementBase(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.preset = 'measurement';
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscMeasurementBase.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscMeasurementBase.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscMeasurementBase.prototype.initControl = function () {
        var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Scroller(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscMeasurementBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscMeasurementBase.propDecorators = {
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'decimalSeparator': [{ type: Input$1 },],
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'scale': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'defaultUnit': [{ type: Input$1 },],
        'unitNames': [{ type: Input$1 },],
        'units': [{ type: Input$1 },],
        'wholeText': [{ type: Input$1 },],
        'fractionText': [{ type: Input$1 },],
        'signText': [{ type: Input$1 },],
        'value': [{ type: Input$1, args: ['mbsc-measurement',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-measurementChange',] },],
    };
MbscMeasurementBase.ɵfac = function MbscMeasurementBase_Factory(t) { return new (t || MbscMeasurementBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscMeasurementBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscMeasurementBase, selectors: [["", "mbsc-m-b", ""]], inputs: { value: ["mbsc-measurement", "value"], max: "max", min: "min", decimalSeparator: "decimalSeparator", defaultValue: "defaultValue", invalid: "invalid", scale: "scale", step: "step", defaultUnit: "defaultUnit", unitNames: "unitNames", units: "units", wholeText: "wholeText", fractionText: "fractionText", signText: "signText" }, outputs: { onChangeEmitter: "mbsc-measurementChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMeasurementBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-m-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-measurement']
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], decimalSeparator: [{
            type: Input$1
        }], defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], scale: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], defaultUnit: [{
            type: Input$1
        }], unitNames: [{
            type: Input$1
        }], units: [{
            type: Input$1
        }], wholeText: [{
            type: Input$1
        }], fractionText: [{
            type: Input$1
        }], signText: [{
            type: Input$1
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-measurementChange']
        }] }); })();
    return MbscMeasurementBase;
}(MbscScrollerBase));
var MbscMeasurementChild = (function (_super) {
    __extends(MbscMeasurementChild, _super);
    function MbscMeasurementChild(initialElement, zone, control, inputService, optionService, view) {
        return _super.call(this, initialElement, zone, control, inputService, optionService, view) || this;
    }
    MbscMeasurementChild.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, },
        { type: MbscInputService, },
        { type: MbscOptionsService, },
        { type: ViewContainerRef, },
    ]; };
    MbscMeasurementChild.propDecorators = {
        'convert': [{ type: Input$1 },],
    };
MbscMeasurementChild.ɵfac = function MbscMeasurementChild_Factory(t) { return new (t || MbscMeasurementChild)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscMeasurementChild.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscMeasurementChild, selectors: [["", "mbsc-m-c", ""]], inputs: { convert: "convert" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMeasurementChild, [{
        type: Directive,
        args: [{ selector: '[mbsc-m-c]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl }, { type: MbscInputService }, { type: MbscOptionsService }, { type: ɵngcc0.ViewContainerRef }]; }, { convert: [{
            type: Input$1
        }] }); })();
    return MbscMeasurementChild;
}(MbscMeasurementBase));
var MbscMeasurement = (function (_super) {
    __extends(MbscMeasurement, _super);
    function MbscMeasurement(initialElem, zone, control, inputService, optionService, view) {
        return _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
    }
    MbscMeasurement.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscMeasurement.propDecorators = {
        'convert': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
    };
MbscMeasurement.ɵfac = function MbscMeasurement_Factory(t) { return new (t || MbscMeasurement)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscMeasurement.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscMeasurement, selectors: [["", "mbsc-measurement", ""]], inputs: { convert: "convert", options: ["mbsc-options", "options"] }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMeasurement, [{
        type: Directive,
        args: [{
                selector: '[mbsc-measurement]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { convert: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }] }); })();
    return MbscMeasurement;
}(MbscMeasurementBase));
var MbscMeasurementComponent = (function (_super) {
    __extends(MbscMeasurementComponent, _super);
    function MbscMeasurementComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscMeasurementComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscMeasurementComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscMeasurementComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscMeasurementComponent.ɵfac = function MbscMeasurementComponent_Factory(t) { return new (t || MbscMeasurementComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscMeasurementComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscMeasurementComponent, selectors: [["mbsc-measurement"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscMeasurementComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscMeasurementComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMeasurementComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-measurement',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscMeasurementComponent;
}(MbscMeasurement));
var MbscTemperature = (function (_super) {
    __extends(MbscTemperature, _super);
    function MbscTemperature(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'temperature';
        return _this;
    }
    Object.defineProperty(MbscTemperature.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscTemperature.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscTemperature.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-temperature',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-temperatureChange',] },],
    };
MbscTemperature.ɵfac = function MbscTemperature_Factory(t) { return new (t || MbscTemperature)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscTemperature.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscTemperature, selectors: [["", "mbsc-temperature", ""]], inputs: { value: ["mbsc-temperature", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-temperatureChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTemperature, [{
        type: Directive,
        args: [{
                selector: '[mbsc-temperature]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-temperature']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-temperatureChange']
        }] }); })();
    return MbscTemperature;
}(MbscMeasurementChild));
var MbscTemperatureComponent = (function (_super) {
    __extends(MbscTemperatureComponent, _super);
    function MbscTemperatureComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscTemperatureComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscTemperatureComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscTemperatureComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscTemperatureComponent.ɵfac = function MbscTemperatureComponent_Factory(t) { return new (t || MbscTemperatureComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTemperatureComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTemperatureComponent, selectors: [["mbsc-temperature"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscTemperatureComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscTemperatureComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTemperatureComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-temperature',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscTemperatureComponent;
}(MbscTemperature));
var MbscDistance = (function (_super) {
    __extends(MbscDistance, _super);
    function MbscDistance(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'distance';
        return _this;
    }
    Object.defineProperty(MbscDistance.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscDistance.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscDistance.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-distance',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-distanceChange',] },],
    };
MbscDistance.ɵfac = function MbscDistance_Factory(t) { return new (t || MbscDistance)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscDistance.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscDistance, selectors: [["", "mbsc-distance", ""]], inputs: { value: ["mbsc-distance", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-distanceChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDistance, [{
        type: Directive,
        args: [{
                selector: '[mbsc-distance]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-distance']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-distanceChange']
        }] }); })();
    return MbscDistance;
}(MbscMeasurementBase));
var MbscDistanceComponent = (function (_super) {
    __extends(MbscDistanceComponent, _super);
    function MbscDistanceComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscDistanceComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscDistanceComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscDistanceComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscDistanceComponent.ɵfac = function MbscDistanceComponent_Factory(t) { return new (t || MbscDistanceComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscDistanceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscDistanceComponent, selectors: [["mbsc-distance"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscDistanceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscDistanceComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscDistanceComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-distance',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscDistanceComponent;
}(MbscDistance));
var MbscSpeed = (function (_super) {
    __extends(MbscSpeed, _super);
    function MbscSpeed(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'speed';
        return _this;
    }
    Object.defineProperty(MbscSpeed.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscSpeed.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscSpeed.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-speed',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-speedChange',] },],
    };
MbscSpeed.ɵfac = function MbscSpeed_Factory(t) { return new (t || MbscSpeed)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscSpeed.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscSpeed, selectors: [["", "mbsc-speed", ""]], inputs: { value: ["mbsc-speed", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-speedChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSpeed, [{
        type: Directive,
        args: [{
                selector: '[mbsc-speed]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-speed']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-speedChange']
        }] }); })();
    return MbscSpeed;
}(MbscMeasurementBase));
var MbscSpeedComponent = (function (_super) {
    __extends(MbscSpeedComponent, _super);
    function MbscSpeedComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscSpeedComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscSpeedComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscSpeedComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscSpeedComponent.ɵfac = function MbscSpeedComponent_Factory(t) { return new (t || MbscSpeedComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscSpeedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSpeedComponent, selectors: [["mbsc-speed"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscSpeedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscSpeedComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSpeedComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-speed',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscSpeedComponent;
}(MbscSpeed));
var MbscForce = (function (_super) {
    __extends(MbscForce, _super);
    function MbscForce(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'force';
        return _this;
    }
    Object.defineProperty(MbscForce.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscForce.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscForce.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-force',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-forceChange',] },],
    };
MbscForce.ɵfac = function MbscForce_Factory(t) { return new (t || MbscForce)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscForce.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscForce, selectors: [["", "mbsc-force", ""]], inputs: { value: ["mbsc-force", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-forceChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscForce, [{
        type: Directive,
        args: [{
                selector: '[mbsc-force]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-force']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-forceChange']
        }] }); })();
    return MbscForce;
}(MbscMeasurementBase));
var MbscForceComponent = (function (_super) {
    __extends(MbscForceComponent, _super);
    function MbscForceComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscForceComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscForceComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscForceComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscForceComponent.ɵfac = function MbscForceComponent_Factory(t) { return new (t || MbscForceComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscForceComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscForceComponent, selectors: [["mbsc-force"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscForceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscForceComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscForceComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-force',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscForceComponent;
}(MbscForce));
var MbscMass = (function (_super) {
    __extends(MbscMass, _super);
    function MbscMass(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'mass';
        return _this;
    }
    Object.defineProperty(MbscMass.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscMass.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscMass.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-mass',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-massChange',] },],
    };
MbscMass.ɵfac = function MbscMass_Factory(t) { return new (t || MbscMass)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscMass.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscMass, selectors: [["", "mbsc-mass", ""]], inputs: { value: ["mbsc-mass", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-massChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMass, [{
        type: Directive,
        args: [{
                selector: '[mbsc-mass]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-mass']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-massChange']
        }] }); })();
    return MbscMass;
}(MbscMeasurementBase));
var MbscMassComponent = (function (_super) {
    __extends(MbscMassComponent, _super);
    function MbscMassComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscMassComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscMassComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscMassComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscMassComponent.ɵfac = function MbscMassComponent_Factory(t) { return new (t || MbscMassComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscMassComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscMassComponent, selectors: [["mbsc-mass"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscMassComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscMassComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMassComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-mass',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscMassComponent;
}(MbscMass));
var comp$4 = [
    MbscMeasurement,
    MbscMeasurementBase,
    MbscMeasurementChild,
    MbscMeasurementComponent,
    MbscTemperature,
    MbscTemperatureComponent,
    MbscDistance,
    MbscDistanceComponent,
    MbscSpeed,
    MbscSpeedComponent,
    MbscForce,
    MbscForceComponent,
    MbscMass,
    MbscMassComponent
];
var MbscMeasurementModule = (function () {
    function MbscMeasurementModule() {
    }
    MbscMeasurementModule.ctorParameters = function () { return []; };
MbscMeasurementModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscMeasurementModule });
MbscMeasurementModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscMeasurementModule_Factory(t) { return new (t || MbscMeasurementModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscMeasurementModule, { declarations: function () { return [MbscMeasurement, MbscMeasurementBase, MbscMeasurementChild, MbscMeasurementComponent, MbscTemperature, MbscTemperatureComponent, MbscDistance, MbscDistanceComponent, MbscSpeed, MbscSpeedComponent, MbscForce, MbscForceComponent, MbscMass, MbscMassComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscMeasurement, MbscMeasurementBase, MbscMeasurementChild, MbscMeasurementComponent, MbscTemperature, MbscTemperatureComponent, MbscDistance, MbscDistanceComponent, MbscSpeed, MbscSpeedComponent, MbscForce, MbscForceComponent, MbscMass, MbscMassComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscMeasurementModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: comp$4,
                exports: comp$4
            }]
    }], function () { return []; }, null); })();
    return MbscMeasurementModule;
}());

// eslint-disable-next-line no-unused-vars
var guid$1 = 1;
var ScrollView = function ScrollView(elm, settings, inherit) {
  var $activeItem,
      $cont,
      $ctx,
      $wnd,
      contWidth,
      itemWidth,
      isClick,
      observer,
      oldWidth,
      posDebounce,
      rtl,
      scrollView,
      snap,
      s,
      totalWidth,
      touched,
      trigger,
      cssClasses = {},
      that = this,
      $elm = $$1(elm);

  function onResize(ev) {
    clearTimeout(posDebounce);
    posDebounce = setTimeout(function () {
      size(!ev || ev.type !== 'load');
    }, 200);
  }

  function onClick() {
    if (isClick && this.parentNode === elm) {
      onItemTap($$1(this), true);
    }
  }

  function onItemTap($item, toggle, animTime) {
    if (!$item.length) {
      return;
    }

    if (animTime === undefined) {
      animTime = 1000;
    }

    toggle = that._onItemTap($item, toggle);
    $activeItem = $item;

    if ($item.parent()[0] == elm) {
      var bl = $item.offset().left,
          bp = $item[0].offsetLeft,
          bw = $item[0].offsetWidth,
          cl = $cont.offset().left;

      if (rtl) {
        bp = totalWidth - bp - bw;
      } // Scroll item to view


      if (s.variant == 'a') {
        if (bl < cl) {
          scrollView.scroll(rtl ? bp + bw - contWidth : -bp, animTime, true);
        } else if (bl + bw > cl + contWidth) {
          scrollView.scroll(rtl ? bp : contWidth - bp - bw, animTime, true);
        }
      } else {
        // Scroll item to center
        scrollView.scroll((contWidth / 2 - bp - bw / 2) * (rtl ? -1 : 1), animTime, true);
      }
    }

    if (toggle && !$item.hasClass('mbsc-disabled')) {
      // Trigger tap event
      trigger('onItemTap', {
        target: $item[0]
      });
    }
  }

  function initMarkup() {
    var $firstItem, props;

    that._initMarkup($cont);

    $elm.find('.mbsc-ripple').remove();
    that._$items = $elm.children();

    that._$items.each(function (i) {
      var cssClass,
          $item = $$1(this),
          ref = $item.attr('data-ref');

      if (!ref) {
        ref = guid$1++;
      }

      if (i === 0) {
        $firstItem = $item;
      }

      if (!$activeItem) {
        $activeItem = that._getActiveItem($item);
      }

      props = that._getItemProps($item) || {};
      cssClass = 'mbsc-scv-item mbsc-btn-e ' + (props.cssClass || '');
      $item.attr('data-ref', ref).removeClass(cssClasses[ref]).addClass(cssClass);
      cssClasses[ref] = cssClass;
      $item.append(that._getText(mobiscroll, 0.2));
    });

    if (!$activeItem) {
      $activeItem = $firstItem;
    }

    that._markupReady($cont);
  }

  function size(check, noScroll) {
    var w = s.itemWidth,
        layout = s.layout;
    that.contWidth = contWidth = $cont.width();

    if (that._checkResp()) {
      return false;
    }

    if (check && oldWidth === contWidth || !contWidth) {
      // Don't do anything if container width has not changed
      return;
    }

    oldWidth = contWidth;

    if (isNumeric(layout)) {
      itemWidth = contWidth ? contWidth / layout : w;

      if (itemWidth < w) {
        layout = 'liquid';
      }
    }

    if (w) {
      if (layout == 'liquid') {
        // The specified itemWidth will be handled as min width
        itemWidth = contWidth ? contWidth / Math.min(Math.floor(contWidth / w), that._$items.length) : w;
      } else if (layout == 'fixed') {
        // Fixed width
        itemWidth = w;
      }
    }

    that._size(contWidth, itemWidth);

    if (itemWidth) {
      $elm.children().css('width', itemWidth + 'px');
    }

    that.totalWidth = totalWidth = elm.offsetWidth;
    extend$1(scrollView.settings, {
      contSize: contWidth,
      maxSnapScroll: s.paging ? 1 : false,
      maxScroll: 0,
      minScroll: totalWidth > contWidth ? contWidth - totalWidth : 0,
      snap: s.paging ? contWidth : snap ? itemWidth || '.mbsc-scv-item' : false,
      elastic: totalWidth > contWidth ? itemWidth || contWidth : false
    }); // Pass new values to scrollview

    scrollView.refresh(noScroll); // Make sure the active item remains visible

    if ($activeItem) {
      onItemTap($activeItem, false);
    }
  } // Call the parent constructor


  Base.call(this, elm, settings, true);

  that.navigate = function ($item, toggle, animTime) {
    onItemTap(that._getItem($item), toggle, animTime);
  };

  that.next = function (toggle) {
    if ($activeItem) {
      var $next = $activeItem.next();

      if ($next.length) {
        $activeItem = $next;
        onItemTap($activeItem, toggle);
      }
    }
  };

  that.prev = function (toggle) {
    if ($activeItem) {
      var $prev = $activeItem.prev();

      if ($prev.length) {
        $activeItem = $prev;
        onItemTap($activeItem, toggle);
      }
    }
  };
  /**
   * Recalculates sizes.
   */


  that.refresh = that.position = function (noScroll) {
    initMarkup();
    size(false, noScroll);
  };
  /**
   * Initialization.
   */


  that._init = function () {
    var contClass;
    $ctx = $$1(s.context);
    $wnd = $$1(s.context == 'body' ? window : s.context);

    that.__init();
    /*
    rtl = s.rtl;
    snap = (s.itemWidth && s.layout != 'fixed' && s.snap === undefined) ? true : s.snap;
    contClass = 'mbsc-scv-c mbsc-no-touch' + ' mbsc-' + s.theme + ' ' +
        (s.cssClass || '') + ' ' +
        (s.wrapperClass || '') +
        (s.baseTheme ? ' mbsc-' + s.baseTheme : '') +
        (rtl ? ' mbsc-rtl' : ' mbsc-ltr') +
        (s.itemWidth ? ' mbsc-scv-hasw' : '') +
        (s.context == 'body' ? '' : ' mbsc-scv-ctx') + ' ' +
        (that._getContClass() || '');
        */
    // --- REMOTE TRIAL CODE START ---


    rtl = that.remote.menustrip.rtlSetting;
    snap = that.remote.menustrip.snapSetting;
    contClass = that.remote.menustrip.contClass + (that._getContClass() || ''); // --- REMOTE TRIAL CODE END ---

    if (!$cont) {
      $cont = $$1('<div class="' + contClass + '"><div class="mbsc-scv-sc"></div></div>').on('click', '.mbsc-scv-item', onClick).insertAfter($elm);
      $cont.find('.mbsc-scv-sc').append($elm); // When images are loaded, size migth change

      $cont.find('img').on('load', onResize);
      $wnd.on('orientationchange resize', onResize);
      observer = resizeObserver($cont[0], onResize, s.zone);
      scrollView = new ScrollViewBase($cont[0], {
        axis: 'X',
        contSize: 0,
        maxScroll: 0,
        maxSnapScroll: 1,
        minScroll: 0,
        snap: 1,
        elastic: 1,
        rtl: rtl,
        mousewheel: s.mousewheel,
        thresholdX: s.threshold,
        stopProp: s.stopProp,
        onStart: function onStart(ev) {
          if (ev.domEvent.type == 'touchstart') {
            isClick = false;

            if (!touched) {
              touched = true;
              $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
            }
          }
        },
        onBtnTap: function onBtnTap(ev) {
          isClick = true; // Trigger click and activate target, if it's a form control

          var domEvent = ev.domEvent,
              target = domEvent.target;

          if (domEvent.type === 'touchend' && s.tap) {
            activateControl(target, getControlType($$1(target)), domEvent);
          }
        },
        onGestureStart: function onGestureStart(ev) {
          trigger('onGestureStart', ev);
        },
        onGestureEnd: function onGestureEnd(ev) {
          trigger('onGestureEnd', ev);
        },
        onMove: function onMove(ev) {
          trigger('onMove', ev);
        },
        onAnimationStart: function onAnimationStart(ev) {
          trigger('onAnimationStart', ev);
        },
        onAnimationEnd: function onAnimationEnd(ev) {
          trigger('onAnimationEnd', ev);
        }
      });
    } else {
      $cont.attr('class', contClass); // Remove ripple events (if theme changed)

      if (elm.__mbscRippleOff) {
        elm.__mbscRippleOff();
      }
    } // Prepare markup


    $elm.css('display', '').addClass('mbsc-scv').removeClass('mbsc-cloak');
    initMarkup();
    trigger('onMarkupReady', {
      target: $cont[0]
    });
    size();
  };

  that._size = noop;
  that._initMarkup = noop;
  that._markupReady = noop;
  that._getContClass = noop;
  that._getItemProps = noop;
  that._getActiveItem = noop;
  that.__init = noop;
  that.__destroy = noop;
  /**
   * Destroy
   */

  that._destroy = function () {
    that.__destroy();

    $wnd.off('orientationchange resize', onResize);
    $elm.removeClass('mbsc-scv').insertAfter($cont).find('.mbsc-scv-item').each(function () {
      var $item = $$1(this);
      $item.width('').removeClass(cssClasses[$item.attr('data-ref')]);
    });
    $cont.remove();
    scrollView.destroy();
    observer.detach();
  };

  that._getItem = function (item) {
    if (typeof item !== 'object') {
      item = that._$items.filter('[data-id="' + item + '"]');
    }

    return $$1(item);
  };

  that._onItemTap = function ($item, toggle) {
    if (toggle === undefined) {
      return true;
    }

    return toggle;
  }; // ---
  // Constructor


  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
}; // Defaults

ScrollView.prototype = {
  _class: 'scrollview',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _defaults: {
    tap: hasGhostClick,
    stopProp: false,
    context: 'body',
    layout: 'liquid'
  }
};
classes.ScrollView = ScrollView;

var NavigationBase = function NavigationBase(elm, settings, inherit) {
  var $ctx,
      display,
      multiple,
      select,
      selectedClass,
      s,
      $elm = $$1(elm),
      that = this;

  function removePagePadding() {
    if (display && display != 'inline') {
      $ctx.find('.mbsc-page').css('padding-' + display, '');
    }
  }

  function selectItem($item) {
    $item.addClass(selectedClass).attr('data-selected', 'true').attr('aria-selected', 'true');
  }

  function deselectItem($item) {
    $item.removeClass(selectedClass).removeAttr('data-selected').removeAttr('aria-selected');
  } // Call the parent constructor


  ScrollView.call(this, elm, settings, true);

  that.select = function ($item) {
    if (!multiple) {
      deselectItem(that._$items.filter('.mbsc-ms-item-sel'));
    }

    selectItem(that._getItem($item));
  };

  that.deselect = function ($item) {
    deselectItem(that._getItem($item));
  };

  that.enable = function ($item) {
    that._getItem($item).removeClass('mbsc-disabled').removeAttr('data-disabled').removeAttr('aria-disabled');
  };

  that.disable = function ($item) {
    that._getItem($item).addClass('mbsc-disabled').attr('data-disabled', 'true').attr('aria-disabled', 'true');
  };

  that.setBadge = function ($item, content) {
    var $badge;
    $item = that._getItem($item).attr('data-badge', content);
    $badge = $$1('.mbsc-ms-badge', $item);

    if ($badge.length) {
      if (content) {
        $badge.html(content);
      } else {
        $badge.remove();
      }
    } else if (content) {
      $item.append('<span class="mbsc-ms-badge">' + content + '</span>');
    }
  };

  that._markupReady = function ($cont) {
    if (that._hasIcons) {
      $cont.addClass('mbsc-ms-icons');
    } else {
      $cont.removeClass('mbsc-ms-icons');
    }

    if (that._hasText) {
      $cont.addClass('mbsc-ms-txt');
    } else {
      $cont.removeClass('mbsc-ms-txt');
    }

    that.__markupReady($cont);
  };

  that._size = function (contWidth, itemWidth) {
    that.__size(contWidth, itemWidth); // Add space to pages within context


    if (display != 'inline') {
      $ctx.find('.mbsc-page').css('padding-' + display, elm.offsetHeight + 'px');
    }
  };

  that._onItemTap = function ($item, toggle) {
    if (that.__onItemTap($item, toggle) === false) {
      return false;
    }

    if (toggle === undefined) {
      toggle = !multiple;
    }

    if (select && toggle && !$item.hasClass('mbsc-disabled')) {
      if (multiple) {
        if ($item.attr('data-selected') == 'true') {
          deselectItem($item);
        } else {
          selectItem($item);
        }
      } else {
        deselectItem(that._$items.filter('.mbsc-ms-item-sel'));
        selectItem($item);
      }
    }

    return toggle;
  };

  that._getActiveItem = function ($item) {
    var selected = $item.attr('data-selected') == 'true';

    if (select && !multiple && selected) {
      return $item;
    }
  };

  that._getItemProps = function ($item) {
    var selected = $item.attr('data-selected') == 'true',
        disabled = $item.attr('data-disabled') == 'true',
        icon = $item.attr('data-icon'),
        badge = $item.attr('data-badge');
    $item.attr('data-role', 'button').attr('aria-selected', selected ? 'true' : 'false').attr('aria-disabled', disabled ? 'true' : 'false').find('.mbsc-ms-badge').remove();

    if (badge) {
      $item.append('<span class="mbsc-ms-badge">' + badge + '</span>');
    }

    if (icon) {
      that._hasIcons = true;
    }

    if ($item.text()) {
      that._hasText = true;
    }

    return {
      cssClass: 'mbsc-ms-item ' + (s.itemClass || '') + ' ' + (selected ? selectedClass : '') + (disabled ? ' mbsc-disabled ' + (s.disabledClass || '') : '') + (icon ? ' mbsc-ms-ic mbsc-ic mbsc-ic-' + icon : '')
    };
  };

  that._getContClass = function () {
    return ' mbsc-ms-c mbsc-ms-' + s.variant + ' mbsc-ms-' + display + (select ? '' : ' mbsc-ms-nosel') + (that.__getContClass() || '');
  };

  that.__init = function () {
    that.___init();

    $ctx = $$1(s.context); // Remove old padding from mbsc-page
    // if display changed dynamically

    removePagePadding();
    display = s.display;
    multiple = s.select == 'multiple';
    select = s.select != 'off';
    selectedClass = ' mbsc-ms-item-sel ' + (s.activeClass || '');
    $elm.addClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));
  };

  that.__destroy = function () {
    $elm.removeClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));
    removePagePadding();

    that.___destroy();
  };

  that.__onItemTap = noop;
  that.__getContClass = noop;
  that.__markupReady = noop;
  that.__size = noop;
  that.___init = noop;
  that.___destroy = noop; // ---
  // Constructor

  s = that.settings;

  if (!inherit) {
    that.init();
  }
}; // Defaults

NavigationBase.prototype = {
  _defaults: extend$1({}, ScrollView.prototype._defaults)
};

var Navigation = function Navigation(elm, settings) {
  var $elm = $$1(elm),
      $menu,
      $popup,
      menuClass,
      s,
      popup,
      isList = $elm.is('ul,ol'),
      that = this; // Call the parent constructor

  NavigationBase.call(this, elm, settings, true);

  that._initMarkup = function () {
    if ($menu) {
      $menu.remove();
    }

    if ($popup) {
      $elm.append($popup.children());
    }
  };

  that.__size = function (contWidth, itemWidth) {
    var showMore,
        showMoreWidth = itemWidth || 72,
        itemsNr = that._$items.length,
        itemsWidth = 0;
    popup.hide(); // show more menu

    if (s.type == 'bottom') {
      $elm.removeClass('mbsc-scv-liq'); //.empty(); // empty list

      $menu.remove();

      that._$items.remove().each(function (i) {
        var $item = $$1(this);
        $elm.append($item);
        itemsWidth += itemWidth || this.offsetWidth || 0; // if next item doesn't fit, add to show more menu

        if (Math.round(itemsWidth + (i < itemsNr - 1 ? showMoreWidth : 0)) > contWidth) {
          showMore = true;
          $popup.append($item.css('width', '').addClass('mbsc-fr-btn-e'));
        }
      });

      $menu.attr('class', menuClass + (s.moreIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.moreIcon : '')).html(that._hasIcons && that._hasText ? s.moreText : ''); // add show more item if needed

      if (showMore) {
        $elm.append($menu);
      }
    }

    if (s.layout == 'liquid') {
      $elm.addClass('mbsc-scv-liq');
    }
  };

  that.__onItemTap = function ($item) {
    if ($item.hasClass('mbsc-menu-item') && that.trigger('onMenuShow', {
      target: $item[0],
      menu: popup
    }) !== false) {
      popup.show(false, true);
      return false;
    }
  };

  that.__getContClass = function () {
    return s.type == 'hamburger' ? ' mbsc-ms-hamburger' : '';
  };

  that.__markupReady = function ($cont) {
    if (s.type == 'hamburger') {
      $popup.append(that._$items.addClass('mbsc-fr-btn-e'));
      $menu.attr('class', menuClass + (s.menuIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.menuIcon : '')).html(s.menuText || '');
      $elm.append($menu);

      if (!s.menuText || !s.menuIcon) {
        $cont.removeClass('mbsc-ms-icons');
      }

      if (!s.menuText) {
        $cont.removeClass('mbsc-ms-txt');
      } else {
        $cont.addClass('mbsc-ms-txt');
      }
    }
  };

  that.___init = function () {
    var $target;

    if (s.type == 'tab') {
      s.display = s.display || 'top';
      s.variant = s.variant || 'b';
    } else if (s.type == 'bottom') {
      s.display = s.display || 'bottom';
      s.variant = s.variant || 'a';
    } else if (s.type == 'hamburger') {
      s.display = s.display || 'inline';
      s.variant = s.variant || 'a';
    }

    menuClass = 'mbsc-scv-item mbsc-ms-item mbsc-btn-e mbsc-menu-item ' + (s.itemClass || '');

    if (!$menu) {
      $menu = $$1(isList ? '<li></li>' : '<div></div>');
      $popup = $$1(isList ? '<ul></ul>' : '<div></div>').addClass('mbsc-scv mbsc-ms');
    }

    popup = new Popup($popup[0], {
      display: 'bubble',
      theme: s.theme,
      lang: s.lang,
      context: s.context,
      buttons: [],
      anchor: $menu,
      onBeforeShow: function onBeforeShow(event, inst) {
        $target = null;
        inst.settings.cssClass = 'mbsc-wdg mbsc-ms-a mbsc-ms-more' + (that._hasText ? '' : ' mbsc-ms-more-icons');
      },
      onBeforeClose: function onBeforeClose() {
        return that.trigger('onMenuHide', {
          target: $target && $target[0],
          menu: popup
        });
      },
      onMarkupReady: function onMarkupReady(event, inst) {
        that.tap(inst._markup.find('.mbsc-fr-c'), function (ev) {
          $target = $$1(ev.target).closest('.mbsc-ms-item');

          if ($target.length && !$target.hasClass('mbsc-disabled')) {
            that.navigate($target, true);
            popup.hide();
          }
        });
      }
    });
  };

  that.___destroy = function () {
    popup.destroy();
    $elm.append(that._$items);
    $menu.remove();
  }; // ---
  // Constructor


  s = that.settings;
  that.init();
}; // Defaults

Navigation.prototype = {
  _class: 'navigation',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _defaults: extend$1({}, NavigationBase.prototype._defaults, {
    type: 'bottom',
    moreText: 'More',
    moreIcon: 'material-more-horiz',
    menuIcon: 'material-menu'
  })
};
classes.Navigation = Navigation;

var MbscNotifyItemService = (function () {
    function MbscNotifyItemService() {
        this._instanceObservable = new Observable();
        this._addRemoveObservable = new Observable();
        this.inst = null;
    }
    MbscNotifyItemService.prototype.notifyInstanceReady = function (instance) {
        this.inst = instance;
        this._instanceObservable.next(instance);
    };
    MbscNotifyItemService.prototype.notifyAddRemove = function (item) {
        this._addRemoveObservable.next(item);
    };
    MbscNotifyItemService.prototype.onInstanceReady = function () {
        return this._instanceObservable;
    };
    MbscNotifyItemService.prototype.onAddRemove = function () {
        return this._addRemoveObservable;
    };
    MbscNotifyItemService.ctorParameters = function () { return []; };
MbscNotifyItemService.ɵfac = function MbscNotifyItemService_Factory(t) { return new (t || MbscNotifyItemService)(); };
MbscNotifyItemService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MbscNotifyItemService, factory: function (t) { return MbscNotifyItemService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNotifyItemService, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return MbscNotifyItemService;
}());
var MbscScrollItemBase = (function () {
    function MbscScrollItemBase(notifyItemService, _elem) {
        var _this = this;
        this.notifyItemService = notifyItemService;
        this._elem = _elem;
        this._instance = undefined;
        this.instanceObserver = this.notifyItemService.onInstanceReady().subscribe(function (instance) {
            _this._instance = instance;
        });
        if (notifyItemService.inst) {
            this._instance = notifyItemService.inst;
        }
    }
    Object.defineProperty(MbscScrollItemBase.prototype, "nativeElement", {
        get: function () {
            return this._elem.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    MbscScrollItemBase.prototype.ngAfterViewInit = function () {
        this.notifyItemService.notifyAddRemove(this);
    };
    MbscScrollItemBase.prototype.ngOnDestroy = function () {
        this.notifyItemService.onInstanceReady().unsubscribe(this.instanceObserver);
        this.notifyItemService.notifyAddRemove(this);
    };
    MbscScrollItemBase.ctorParameters = function () { return [
        { type: MbscNotifyItemService, },
        { type: ElementRef, },
    ]; };
    MbscScrollItemBase.propDecorators = {
        'id': [{ type: Input$1 },],
    };
MbscScrollItemBase.ɵfac = function MbscScrollItemBase_Factory(t) { return new (t || MbscScrollItemBase)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MbscScrollItemBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScrollItemBase, selectors: [["mbsc-si-b"]], inputs: { id: "id" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollItemBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-si-b' }]
    }], function () { return [{ type: MbscNotifyItemService }, { type: ɵngcc0.ElementRef }]; }, { id: [{
            type: Input$1
        }] }); })();
    return MbscScrollItemBase;
}());
var MbscScrollViewBase = (function (_super) {
    __extends(MbscScrollViewBase, _super);
    function MbscScrollViewBase(initialElem, zone, notifyItemService) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.notifyItemService = notifyItemService;
        _this.onItemTap = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onAnimationStart = new EventEmitter();
        _this.onAnimationEnd = new EventEmitter();
        _this.onMove = new EventEmitter();
        _this.onGestureStart = new EventEmitter();
        _this.onGestureEnd = new EventEmitter();
        return _this;
    }
    MbscScrollViewBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
    ]; };
    MbscScrollViewBase.propDecorators = {
        'context': [{ type: Input$1 },],
        'itemWidth': [{ type: Input$1 },],
        'layout': [{ type: Input$1 },],
        'mousewheel': [{ type: Input$1 },],
        'snap': [{ type: Input$1 },],
        'threshold': [{ type: Input$1 },],
        'paging': [{ type: Input$1 },],
        'onItemTap': [{ type: Output },],
        'onMarkupReady': [{ type: Output },],
        'onAnimationStart': [{ type: Output },],
        'onAnimationEnd': [{ type: Output },],
        'onMove': [{ type: Output },],
        'onGestureStart': [{ type: Output },],
        'onGestureEnd': [{ type: Output },],
    };
MbscScrollViewBase.ɵfac = function MbscScrollViewBase_Factory(t) { return new (t || MbscScrollViewBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService)); };
MbscScrollViewBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScrollViewBase, selectors: [["mbsc-s-b"]], inputs: { context: "context", itemWidth: "itemWidth", layout: "layout", mousewheel: "mousewheel", snap: "snap", threshold: "threshold", paging: "paging" }, outputs: { onItemTap: "onItemTap", onMarkupReady: "onMarkupReady", onAnimationStart: "onAnimationStart", onAnimationEnd: "onAnimationEnd", onMove: "onMove", onGestureStart: "onGestureStart", onGestureEnd: "onGestureEnd" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-s-b' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }]; }, { context: [{
            type: Input$1
        }], itemWidth: [{
            type: Input$1
        }], layout: [{
            type: Input$1
        }], mousewheel: [{
            type: Input$1
        }], snap: [{
            type: Input$1
        }], threshold: [{
            type: Input$1
        }], paging: [{
            type: Input$1
        }], onItemTap: [{
            type: Output
        }], onMarkupReady: [{
            type: Output
        }], onAnimationStart: [{
            type: Output
        }], onAnimationEnd: [{
            type: Output
        }], onMove: [{
            type: Output
        }], onGestureStart: [{
            type: Output
        }], onGestureEnd: [{
            type: Output
        }] }); })();
    return MbscScrollViewBase;
}(MbscBase));
var MbscScrollViewBaseModule = (function () {
    function MbscScrollViewBaseModule() {
    }
    MbscScrollViewBaseModule.ctorParameters = function () { return []; };
MbscScrollViewBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscScrollViewBaseModule });
MbscScrollViewBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscScrollViewBaseModule_Factory(t) { return new (t || MbscScrollViewBaseModule)(); }, imports: [[CommonModule, MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollViewBaseModule, { declarations: function () { return [MbscScrollItemBase, MbscScrollViewBase]; }, imports: function () { return [CommonModule, MbscBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscBaseModule],
                declarations: [MbscScrollItemBase, MbscScrollViewBase]
            }]
    }], function () { return []; }, null); })();
    return MbscScrollViewBaseModule;
}());

var MbscNavItemBase = (function (_super) {
    __extends(MbscNavItemBase, _super);
    function MbscNavItemBase(notifyItemService, elem) {
        var _this = _super.call(this, notifyItemService, elem) || this;
        _this.selectedChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscNavItemBase.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        set: function (v) {
            this._disabled = v;
            if (this._instance) {
                if (this._disabled) {
                    this._instance.disable(this._elem.nativeElement);
                }
                else {
                    this._instance.enable(this._elem.nativeElement);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscNavItemBase.prototype, "selected", {
        get: function () {
            return this._selected;
        },
        set: function (v) {
            this._selected = v;
            if (this._instance) {
                if (this._selected) {
                    this._instance.select(this._elem.nativeElement);
                }
                else {
                    this._instance.deselect(this._elem.nativeElement);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNavItemBase.prototype.toggle = function () {
        this._selected = !this._selected;
        this.selectedChange.emit(this._selected);
    };
    MbscNavItemBase.ctorParameters = function () { return [
        { type: MbscNotifyItemService, },
        { type: ElementRef, },
    ]; };
    MbscNavItemBase.propDecorators = {
        'icon': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'selected': [{ type: Input$1 },],
        'selectedChange': [{ type: Output },],
    };
MbscNavItemBase.ɵfac = function MbscNavItemBase_Factory(t) { return new (t || MbscNavItemBase)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MbscNavItemBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNavItemBase, selectors: [["mbsc-ni-b"]], inputs: { disabled: "disabled", selected: "selected", icon: "icon" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNavItemBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-ni-b' }]
    }], function () { return [{ type: MbscNotifyItemService }, { type: ɵngcc0.ElementRef }]; }, { disabled: [{
            type: Input$1
        }], selected: [{
            type: Input$1
        }], icon: [{
            type: Input$1
        }], selectedChange: [{
            type: Output
        }] }); })();
    return MbscNavItemBase;
}(MbscScrollItemBase));
var MbscNavigationBase = (function (_super) {
    __extends(MbscNavigationBase, _super);
    function MbscNavigationBase(initialElem, zone, notifyItemService) {
        return _super.call(this, initialElem, zone, notifyItemService) || this;
    }
    MbscNavigationBase.prototype.tapHandler = function (event, inst) {
        var selection = this.select || (inst && inst.settings.select);
        switch (selection) {
            case 'multiple': {
                var item = this._getItem(event.target);
                item.toggle();
                break;
            }
            case 'single': {
                var item = this._getItem(event.target);
                if (item && !item.selected) {
                    this.items.forEach(function (item) {
                        if (item.selected) {
                            item.toggle();
                        }
                    });
                    item.toggle();
                }
            }
        }
        event.inst = inst;
        this.onItemTap.emit(event);
    };
    MbscNavigationBase.prototype._getItem = function (nativeEl) {
        return this.items.find(function (item) {
            return item.nativeElement === nativeEl;
        });
    };
    MbscNavigationBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
    ]; };
    MbscNavigationBase.propDecorators = {
        'display': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['options',] },],
        'items': [{ type: ContentChildren, args: [MbscNavItemBase,] },],
    };
MbscNavigationBase.ɵfac = function MbscNavigationBase_Factory(t) { return new (t || MbscNavigationBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService)); };
MbscNavigationBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNavigationBase, selectors: [["mbsc-n-b"]], contentQueries: function MbscNavigationBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscNavItemBase, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, inputs: { display: "display", options: "options" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNavigationBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-n-b' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }]; }, { display: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['options']
        }], items: [{
            type: ContentChildren,
            args: [MbscNavItemBase]
        }] }); })();
    return MbscNavigationBase;
}(MbscScrollViewBase));
var MbscNavigationBaseModule = (function () {
    function MbscNavigationBaseModule() {
    }
    MbscNavigationBaseModule.ctorParameters = function () { return []; };
MbscNavigationBaseModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscNavigationBaseModule });
MbscNavigationBaseModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscNavigationBaseModule_Factory(t) { return new (t || MbscNavigationBaseModule)(); }, imports: [[CommonModule, MbscScrollViewBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNavigationBaseModule, { declarations: function () { return [MbscNavigationBase, MbscNavItemBase]; }, imports: function () { return [CommonModule, MbscScrollViewBaseModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNavigationBaseModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollViewBaseModule],
                declarations: [MbscNavigationBase, MbscNavItemBase]
            }]
    }], function () { return []; }, null); })();
    return MbscNavigationBaseModule;
}());

var MbscNavItem = (function (_super) {
    __extends(MbscNavItem, _super);
    function MbscNavItem(notifyItemService, elem, inj, routerToken) {
        var _this = _super.call(this, notifyItemService, elem) || this;
        _this.inj = inj;
        _this.routerLinkActiveOptions = { exact: false };
        _this.instObserver = notifyItemService.onInstanceReady().subscribe(function (instance) {
            if (_this.initialBadge) {
                instance.setBadge(_this.nativeElement, _this.initialBadge);
            }
        });
        if (routerToken) {
            _this.injectedRouter = routerToken;
            _this.activatedRoute = _this.inj.get(_this.injectedRouter.routerState.root.__proto__.constructor, null);
        }
        if (_this.injectedRouter) {
            _this.injectedRouter.events.subscribe(function (ev) {
                clearTimeout(_this.debounceHandler);
                _this.debounceHandler = setTimeout(function () {
                    _this.checkSelected();
                });
            });
        }
        return _this;
    }
    Object.defineProperty(MbscNavItem.prototype, "badge", {
        set: function (badge) {
            if (this._instance) {
                this._instance.setBadge(this.nativeElement, badge);
            }
            else {
                this.initialBadge = badge;
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNavItem.prototype.checkSelected = function () {
        if (this.injectedRouter && this.routerLink !== null && this.routerLink !== undefined) {
            var commands = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];
            var urlTree = this.injectedRouter.createUrlTree(commands, { relativeTo: this.activatedRoute });
            var selected = this.injectedRouter.isActive(urlTree, this.routerLinkActiveOptions.exact);
            if (selected) {
                this._selected = selected;
            }
            if (this._instance) {
                if (selected) {
                    this._instance.select(this._elem.nativeElement);
                }
                else {
                    this._instance.deselect(this._elem.nativeElement);
                }
            }
        }
    };
    MbscNavItem.prototype.ngOnDestroy = function () {
        this.notifyItemService.onInstanceReady().unsubscribe(this.instObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscNavItem.ctorParameters = function () { return [
        { type: MbscNotifyItemService, },
        { type: ElementRef, },
        { type: Injector, },
        { type: MbscRouterToken, decorators: [{ type: Optional },] },
    ]; };
    MbscNavItem.propDecorators = {
        'badge': [{ type: Input$1 },],
        'routerLink': [{ type: Input$1 },],
        'routerLinkActiveOptions': [{ type: Input$1 },],
    };
MbscNavItem.ɵfac = function MbscNavItem_Factory(t) { return new (t || MbscNavItem)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(MbscRouterToken, 8)); };
MbscNavItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNavItem, selectors: [["mbsc-nav-item"]], hostVars: 4, hostBindings: function MbscNavItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-icon", ctx.icon)("data-disabled", ctx.disabled)("data-selected", ctx.selected)("data-id", ctx.id);
    } }, inputs: { badge: "badge", routerLink: "routerLink", routerLinkActiveOptions: "routerLinkActiveOptions" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscNavItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNavItem, [{
        type: Component,
        args: [{
                selector: 'mbsc-nav-item',
                template: '<ng-content></ng-content>',
                host: {
                    '[attr.data-icon]': 'icon',
                    '[attr.data-disabled]': 'disabled',
                    '[attr.data-selected]': 'selected',
                    '[attr.data-id]': 'id'
                }
            }]
    }], function () { return [{ type: MbscNotifyItemService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Injector }, { type: MbscRouterToken, decorators: [{
                type: Optional
            }] }]; }, { badge: [{
            type: Input$1
        }], routerLink: [{
            type: Input$1
        }], routerLinkActiveOptions: [{
            type: Input$1
        }] }); })();
    return MbscNavItem;
}(MbscNavItemBase));
var MbscNav = (function (_super) {
    __extends(MbscNav, _super);
    function MbscNav(initialElem, zone, notifyItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
        _this.optionService = optionService;
        _this.select = 'single';
        _this.onMenuHide = new EventEmitter();
        _this.onMenuShow = new EventEmitter();
        return _this;
    }
    MbscNav.prototype.initControl = function () {
        var _this = this;
        var onItemTap = this.tapHandler.bind(this);
        var onItemTapUser = this.options && this.options.onItemTap;
        if (onItemTapUser) {
            onItemTap = function (event, inst) {
                _this.tapHandler(event, inst);
                return onItemTapUser(event, inst);
            };
        }
        var options = extend$1({ type: this.type }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
        this.instance = new Navigation(this.initialElem.nativeElement, options);
        this.notifyItemService.notifyInstanceReady(this.instance);
        this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
            _this.instance.refresh();
        });
    };
    MbscNav.prototype.ngOnDestroy = function () {
        this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscNav.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNav.propDecorators = {
        'moreText': [{ type: Input$1 },],
        'moreIcon': [{ type: Input$1 },],
        'menuText': [{ type: Input$1 },],
        'menuIcon': [{ type: Input$1 },],
        'onMenuHide': [{ type: Output },],
        'onMenuShow': [{ type: Output },],
        'items': [{ type: ContentChildren, args: [MbscNavItem,] },],
    };
MbscNav.ɵfac = function MbscNav_Factory(t) { return new (t || MbscNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNav, selectors: [["mbsc-nav"]], contentQueries: function MbscNav_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscNavItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostAttrs: [1, "mbsc-cloak"], inputs: { moreText: "moreText", moreIcon: "moreIcon", menuText: "menuText", menuIcon: "menuIcon" }, outputs: { onMenuHide: "onMenuHide", onMenuShow: "onMenuShow" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNav, [{
        type: Component,
        args: [{
                selector: 'mbsc-nav',
                template: '<ng-content></ng-content>',
                providers: [MbscNotifyItemService],
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { moreText: [{
            type: Input$1
        }], moreIcon: [{
            type: Input$1
        }], menuText: [{
            type: Input$1
        }], menuIcon: [{
            type: Input$1
        }], onMenuHide: [{
            type: Output
        }], onMenuShow: [{
            type: Output
        }], items: [{
            type: ContentChildren,
            args: [MbscNavItem]
        }] }); })();
    return MbscNav;
}(MbscNavigationBase));
var MbscBottomNav = (function (_super) {
    __extends(MbscBottomNav, _super);
    function MbscBottomNav(initialElem, zone, navItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
        _this.type = 'bottom';
        return _this;
    }
    MbscBottomNav.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
MbscBottomNav.ɵfac = function MbscBottomNav_Factory(t) { return new (t || MbscBottomNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscBottomNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscBottomNav, selectors: [["mbsc-bottom-nav"]], hostAttrs: [1, "mbsc-cloak"], exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscBottomNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscBottomNav, [{
        type: Component,
        args: [{
                selector: 'mbsc-bottom-nav',
                template: '<ng-content></ng-content>',
                providers: [MbscNotifyItemService],
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return MbscBottomNav;
}(MbscNav));
var MbscHamburgerNav = (function (_super) {
    __extends(MbscHamburgerNav, _super);
    function MbscHamburgerNav(initialElem, zone, navItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
        _this.type = 'hamburger';
        return _this;
    }
    MbscHamburgerNav.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
MbscHamburgerNav.ɵfac = function MbscHamburgerNav_Factory(t) { return new (t || MbscHamburgerNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscHamburgerNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscHamburgerNav, selectors: [["mbsc-hamburger-nav"]], hostAttrs: [1, "mbsc-cloak"], exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscHamburgerNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscHamburgerNav, [{
        type: Component,
        args: [{
                selector: 'mbsc-hamburger-nav',
                template: '<ng-content></ng-content>',
                providers: [MbscNotifyItemService],
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return MbscHamburgerNav;
}(MbscNav));
var MbscTabNav = (function (_super) {
    __extends(MbscTabNav, _super);
    function MbscTabNav(initialElem, zone, navItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;
        _this.type = 'tab';
        return _this;
    }
    MbscTabNav.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
MbscTabNav.ɵfac = function MbscTabNav_Factory(t) { return new (t || MbscTabNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTabNav.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTabNav, selectors: [["mbsc-tab-nav"]], hostAttrs: [1, "mbsc-cloak"], exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscTabNav_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTabNav, [{
        type: Component,
        args: [{
                selector: 'mbsc-tab-nav',
                template: '<ng-content></ng-content>',
                providers: [MbscNotifyItemService],
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return MbscTabNav;
}(MbscNav));
var comps = [
    MbscNavItem,
    MbscNav,
    MbscBottomNav,
    MbscHamburgerNav,
    MbscTabNav
];
var MbscNavigationModule = (function () {
    function MbscNavigationModule() {
    }
    MbscNavigationModule.forRoot = function (config) {
        return {
            ngModule: MbscNavigationModule,
            providers: [{
                    provide: MbscRouterToken,
                    useExisting: config.angularRouter
                }]
        };
    };
    MbscNavigationModule.ctorParameters = function () { return []; };
MbscNavigationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscNavigationModule });
MbscNavigationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscNavigationModule_Factory(t) { return new (t || MbscNavigationModule)(); }, imports: [[CommonModule, MbscNavigationBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNavigationModule, { declarations: function () { return [MbscNavItem, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav]; }, imports: function () { return [CommonModule, MbscNavigationBaseModule]; }, exports: function () { return [MbscNavItem, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNavigationModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscNavigationBaseModule],
                declarations: comps,
                exports: comps
            }]
    }], function () { return []; }, null); })();
    return MbscNavigationModule;
}());

var NumberScroller = Measurement;
presets.number = presets.measurement;

var MbscNumber = (function (_super) {
    __extends(MbscNumber, _super);
    function MbscNumber(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscNumber.prototype, "value", {
        set: function (v) {
            if (!this.control) {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumber.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscNumber.prototype.initControl = function () {
        var options = extend$1({ preset: 'number' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new NumberScroller(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscNumber.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumber.propDecorators = {
        'decimalSeparator': [{ type: Input$1 },],
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'scale': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'wholeText': [{ type: Input$1 },],
        'fractionText': [{ type: Input$1 },],
        'signText': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-number',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numberChange',] },],
    };
MbscNumber.ɵfac = function MbscNumber_Factory(t) { return new (t || MbscNumber)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumber.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumber, selectors: [["", "mbsc-number", ""]], inputs: { value: ["mbsc-number", "value"], decimalSeparator: "decimalSeparator", defaultValue: "defaultValue", invalid: "invalid", max: "max", min: "min", scale: "scale", step: "step", wholeText: "wholeText", fractionText: "fractionText", signText: "signText", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numberChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumber, [{
        type: Directive,
        args: [{
                selector: '[mbsc-number]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-number']
        }], decimalSeparator: [{
            type: Input$1
        }], defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], scale: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], wholeText: [{
            type: Input$1
        }], fractionText: [{
            type: Input$1
        }], signText: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numberChange']
        }] }); })();
    return MbscNumber;
}(MbscScrollerBase));
var MbscNumberComponent = (function (_super) {
    __extends(MbscNumberComponent, _super);
    function MbscNumberComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumberComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumberComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumberComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumberComponent.ɵfac = function MbscNumberComponent_Factory(t) { return new (t || MbscNumberComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumberComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumberComponent, selectors: [["mbsc-number"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumberComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumberComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumberComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-number',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumberComponent;
}(MbscNumber));
var MbscNumberModule = (function () {
    function MbscNumberModule() {
    }
    MbscNumberModule.ctorParameters = function () { return []; };
MbscNumberModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscNumberModule });
MbscNumberModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscNumberModule_Factory(t) { return new (t || MbscNumberModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNumberModule, { declarations: function () { return [MbscNumber, MbscNumberComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscNumber, MbscNumberComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumberModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscNumber, MbscNumberComponent],
                exports: [MbscNumber, MbscNumberComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscNumberModule;
}());

var presets$1 = {};
var Numpad = function Numpad(el, settings, inherit) {
  var $markup,
      deleteBtn,
      disabledClass,
      ph,
      pos,
      s,
      mask,
      sX,
      sY,
      eX,
      eY,
      diffX,
      diffY,
      action,
      interval,
      tempValueArray,
      tempTotal,
      trigger,
      total,
      valueArray,
      $elm = $$1(el),
      that = this,
      actions = [],
      tempActions = [],
      tempVariables = {},
      variables = {},
      customKeys = {},
      numericKeys = {
    48: 0,
    49: 1,
    50: 2,
    51: 3,
    52: 4,
    53: 5,
    54: 6,
    55: 7,
    56: 8,
    57: 9,
    96: 0,
    97: 1,
    98: 2,
    99: 3,
    100: 4,
    101: 5,
    102: 6,
    103: 7,
    104: 8,
    105: 9
  };

  function display(manual) {
    // Validate
    var i,
        ret = s.validate.call(el, {
      values: tempValueArray.slice(0),
      variables: tempVariables
    }, that) || [],
        disabled = ret && ret.disabled || [];
    that._isValid = ret.invalid ? false : true; // Generate formatted value

    that._tempValue = s.formatValue.call(el, tempValueArray.slice(0), tempVariables, that);
    pos = tempValueArray.length;
    tempTotal = ret.length || total;

    if (that._isVisible && mobiscroll.EmtjC) {
      // Fill template with numbers
      $$1('.mbsc-np-ph', $markup).each(function (i) {
        $$1(this).html(s.fill == 'ltr' ? i >= pos ? ph : mask || tempValueArray[i] : i >= total - tempTotal ? i + pos < total ? ph : mask || tempValueArray[i + pos - total] : '');
      }); // Fill variable placeholders

      $$1('.mbsc-np-cph', $markup).each(function () {
        $$1(this).html(tempVariables[$$1(this).attr('data-var')] || $$1(this).attr('data-ph'));
      }); // Disable all numeric buttons if template is full

      if (pos === total) {
        for (i = 0; i <= 9; i++) {
          disabled.push(i);
        }
      } // Disable invalid buttons


      $$1('.mbsc-np-btn', $markup).removeClass(disabledClass);

      for (i = 0; i < disabled.length; i++) {
        $$1('.mbsc-np-btn[data-val="' + disabled[i] + '"]', $markup).addClass(disabledClass);
      } // Disable set button


      if (that._isValid) {
        $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).removeClass(disabledClass);
      } else {
        $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).addClass(disabledClass);
      } // Fill input if in live mode


      if (that.live) {
        that._hasValue = manual || that._hasValue;
        fillValue(manual, false, manual);

        if (manual) {
          trigger('onSet', {
            valueText: that._value
          });
        }
      }
    }
  }

  function fillValue(fill, disp, change, temp) {
    if (disp) {
      display();
    }

    if (!temp) {
      valueArray = tempValueArray.slice(0);
      variables = extend$1({}, tempVariables);
      actions = tempActions.slice(0);
      that._value = that._hasValue ? that._tempValue : null;
    }

    if (fill) {
      if (that._isInput) {
        $elm.val(that._hasValue && that._isValid ? that._value : '');
      }

      trigger('onFill', {
        valueText: that._hasValue ? that._tempValue : '',
        change: change
      });

      if (change) {
        that._preventChange = true;
        $elm.trigger('change');
      }
    }
  }

  function loadValues(values) {
    var i,
        vars,
        val = values || [],
        ret = [];
    tempActions = [];
    tempVariables = {};

    for (i = 0; i < val.length; i++) {
      //if (isNaN(parseInt(val[i]))) {
      if (/:/.test(val[i])) {
        vars = val[i].split(':');
        tempVariables[vars[0]] = vars[1];
        tempActions.push(vars[0]);
      } else {
        ret.push(val[i]);
        tempActions.push('digit');
      }
    }

    return ret;
  }

  function triggerInput(btn, ev) {
    trigger('onInput', {
      domEvent: ev,
      target: btn,
      values: tempValueArray.slice(0),
      valueText: that._tempValue,
      variables: tempVariables
    });
  }

  function addKeys(keys, pos) {
    if (keys) {
      keys = $$1.isArray(keys) ? keys : [keys];
      keys.forEach(function (key) {
        customKeys[key] = pos;
      });
    }
  }

  function onNumberTap(btn, val, ev) {
    if (!pos && !val && !s.allowLeadingZero || btn.hasClass('mbsc-disabled') || btn.hasClass('mbsc-np-btn-empty')) {
      return;
    }

    if (pos < total && mobiscroll.EmtjC) {
      tempActions.push('digit');
      tempValueArray.push(val);
      display(true);
      triggerInput(btn[0], ev);
    }
  }

  function onCustomTap(btn, ev) {
    var i,
        v,
        val = btn.attr('data-val'),
        track = btn.attr('data-track') !== 'false',
        variable = btn.attr('data-var');

    if (!btn.hasClass('mbsc-disabled')) {
      if (variable) {
        v = variable.split(':');

        if (track) {
          tempActions.push(v[0]);
        }

        tempVariables[v[0]] = v[2] === undefined ? v[1] : tempVariables[v[0]] == v[1] ? v[2] : v[1];
      }

      if (val.length + pos <= tempTotal) {
        for (i = 0; i < val.length; ++i) {
          v = isNumeric(val[i]) ? +val[i] : val[i];

          if (s.allowLeadingZero || pos || v) {
            tempActions.push('digit');
            tempValueArray.push(v);
            pos = tempValueArray.length;
          }
        }
      }

      display(true);
      triggerInput(btn[0], ev);
    }
  }

  function onDeleteTap(ev) {
    var i,
        old,
        act = tempActions.pop();

    if (pos || act !== 'digit') {
      if (act !== 'digit' && tempVariables[act]) {
        delete tempVariables[act];
        old = tempActions.slice(0);
        tempActions = [];

        for (i = 0; i < old.length; i++) {
          if (old[i] !== act) {
            tempActions.push(old[i]);
          }
        }
      } else {
        tempValueArray.pop();
      }

      display(true);
      triggerInput(deleteBtn, ev);
    }
  }

  function startDelete(ev) {
    action = true;
    sX = getCoord(ev, 'X');
    sY = getCoord(ev, 'Y');
    clearInterval(interval);
    clearTimeout(interval);
    onDeleteTap(ev);
    interval = setInterval(function () {
      onDeleteTap(ev);
    }, 150);
  }

  function stopDelete() {
    clearInterval(interval);
    action = false;
  }

  function onStart(ev) {
    if (testTouch(ev, this)) {
      if (ev.type == 'keydown' && ev.keyCode != 32) {
        return;
      }

      startDelete(ev);

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
      }
    }
  }

  function onMove(ev) {
    if (action) {
      eX = getCoord(ev, 'X');
      eY = getCoord(ev, 'Y');
      diffX = eX - sX;
      diffY = eY - sY;

      if (Math.abs(diffX) > 7 || Math.abs(diffY) > 7) {
        stopDelete();
      }
    }
  }

  function onEnd(ev) {
    if (action) {
      ev.preventDefault();
      stopDelete();

      if (ev.type == 'mouseup') {
        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
      }
    }
  } // Call the parent constructor


  Frame.call(this, el, settings, true); // Public functions

  /**
   * Sets the value
   */

  that.setVal = that._setVal = function (val, fill, change, temp) {
    that._hasValue = val !== null && val !== undefined && val !== '';
    tempValueArray = loadValues($$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that));
    fillValue(fill, true, change === undefined ? fill : change, temp);
  };
  /**
   * Returns the selected value
   */


  that.getVal = that._getVal = function (temp) {
    return that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
  };
  /*
   * Sets the value (passed as an array)
   */


  that.setArrayVal = that.setVal;
  /*
   * Returns the selected wheel values as an array
   */

  that.getArrayVal = function (temp) {
    return temp ? tempValueArray.slice(0) : that._hasValue ? valueArray.slice(0) : null;
  }; // Protected overrides


  that._readValue = function () {
    var v = $elm.val() || '';

    if (v !== '') {
      that._hasValue = true;
    }

    if (mask) {
      tempVariables = {};
      tempActions = [];
      tempValueArray = [];
    } else {
      tempVariables = that._hasValue ? variables : {};
      tempActions = that._hasValue ? actions : [];
      tempValueArray = that._hasValue && valueArray ? valueArray.slice(0) : loadValues(s.parseValue.call(el, v, that));
      fillValue(false, true);
    }
  };

  that._fillValue = function () {
    that._hasValue = true;
    fillValue(true, false, true);
  };

  that._generateContent = function () {
    var i,
        j,
        v,
        k = 1,
        leftKey = s.leftKey,
        rightKey = s.rightKey,
        template = '',
        html = ''; // Display

    html += '<div class="mbsc-np-hdr"><div role="button" tabindex="0" aria-label="' + s.deleteText + '" class="mbsc-np-del mbsc-fr-btn-e mbsc-ic mbsc-ic-' + s.deleteIcon + '"></div><div class="mbsc-np-dsp">'; // Process template

    template = s.template.replace(/d/g, '<span class="mbsc-np-ph">' + ph + '</span>').replace(/&#100;/g, 'd'); // Generate the template for custom buttons

    template = template.replace(/{([a-zA-Z0-9]*):?([a-zA-Z0-9\-_]*)}/g, '<span class="mbsc-np-cph" data-var="$1" data-ph="$2">$2</span>');
    html += template;
    html += '</div></div>'; // Digit buttons

    html += '<div class="mbsc-np-tbl-c mbsc-w-p"><div class="mbsc-np-tbl">';

    for (i = 0; i < 4; i++) {
      html += '<div class="mbsc-np-row">';

      for (j = 0; j < 3; j++) {
        v = k;

        if (k == 10 || k == 12) {
          v = '';
        } else if (k == 11) {
          v = 0;
        }

        if (v === '') {
          if (k == 10 && leftKey) {
            addKeys(leftKey.keys, 'left');
            html += '<div role="button" tabindex="0" class="mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-left mbsc-fr-btn-e" ' + (leftKey.variable ? 'data-var="' + leftKey.variable + '"' : '') + ' data-val="' + (leftKey.value || '') + '" ' + (leftKey.track !== undefined ? ' data-track="' + leftKey.track + '"' : '') + '>' + leftKey.text + '</div>';
          } else if (k == 12 && s.rightKey) {
            addKeys(rightKey.keys, 'right');
            html += '<div role="button" tabindex="0" class="mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-right mbsc-fr-btn-e" ' + (rightKey.variable ? 'data-var="' + rightKey.variable + '"' : '') + ' data-val="' + (rightKey.value || '') + '" ' + (rightKey.track !== undefined ? ' data-track="' + rightKey.track + '"' : '') + ' >' + rightKey.text + '</div>';
          } else {
            html += '<div class="mbsc-np-btn mbsc-np-btn-empty"></div>';
          }
        } else {
          html += '<div tabindex="0" role="button" class="mbsc-np-btn mbsc-fr-btn-e" data-val="' + v + '">' + v + that._getText(mobiscroll, 0.2) + '</div>';
        }

        k++;
      }

      html += '</div>';
    }

    html += '</div></div>';
    return html;
  };

  that._markupReady = function () {
    $markup = that._markup;
    display();
  };

  that._attachEvents = function ($m) {
    $m.on('keydown', function (ev) {
      var btn,
          key = ev.keyCode;

      if (customKeys[key] !== undefined) {
        btn = $$1('.mbsc-np-btn-custom-' + customKeys[key], $m);

        if (btn.length) {
          if (btn.attr('data-var') === 'sign:-:') {
            tempVariables.sign = key === 107 || key === 187 ? '-' : '';
          }

          onCustomTap(btn, ev);
        }
      } else if (numericKeys[key] !== undefined) {
        onNumberTap($$1('.mbsc-np-btn[data-val="' + numericKeys[key] + '"]', $m), numericKeys[key], ev);
      } else if (key == 8) {
        ev.preventDefault();
        onDeleteTap(ev);
      }
    });
    that.tap($$1('.mbsc-np-btn', $m), function (ev) {
      var btn = $$1(this);

      if (btn.hasClass('mbsc-np-btn-custom')) {
        onCustomTap(btn, ev);
      } else {
        onNumberTap(btn, +btn.attr('data-val'), ev);
      }
    }, false, 30, true);
    deleteBtn = $$1('.mbsc-np-del', $m)[0];
    listen(deleteBtn, 'touchstart', onStart, {
      passive: true
    });
    listen(deleteBtn, 'mousedown', onStart);
    listen(deleteBtn, 'keydown', onStart);
    listen(deleteBtn, 'touchmove', onMove, {
      passive: true
    });
    listen(deleteBtn, 'mousemove', onMove);
    listen(deleteBtn, 'touchend', onEnd);
    listen(deleteBtn, 'mouseup', onEnd);
    listen(deleteBtn, 'keyup', onEnd);
  };

  that.__init = function () {
    s = that.settings;
    s.template = s.template.replace(/\\d/, '&#100;');
    ph = s.placeholder;
    total = (s.template.match(/d/g) || []).length;
    disabledClass = 'mbsc-disabled ' + (s.disabledClass || '');
    mask = s.mask;
    trigger = that.trigger;

    if (mask && $elm.is('input')) {
      $elm.attr('type', 'password');
    }
  };

  that._indexOf = function (cont, v) {
    var i;

    for (i = 0; i < cont.length; ++i) {
      if (cont[i].toString() === v.toString()) {
        return i;
      }
    }

    return -1;
  }; // Constructor


  if (!inherit) {
    that.init();
  }
}; // Extend defaults

Numpad.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _class: 'numpad',
  _presets: presets$1,
  _defaults: extend$1({}, Frame.prototype._defaults, {
    template: 'dd.dd',
    placeholder: '0',
    deleteIcon: 'backspace',
    allowLeadingZero: false,
    headerText: false,
    fill: 'rtl',
    compClass: 'mbsc-np',
    // Localization
    deleteText: 'Delete',
    decimalSeparator: '.',
    thousandsSeparator: ',',
    // @todo
    // ---
    //fillFullTemplate: true,
    // ---
    validate: noop,
    parseValue: noop,
    formatValue: function formatValue(value, variables, inst) {
      var i,
          j = 1,
          s = inst.settings,
          ph = s.placeholder,
          template = s.template,
          valueLen = value.length,
          tempLen = template.length,
          res = '';

      for (i = 0; i < tempLen; i++) {
        if (template[tempLen - i - 1] == 'd') {
          if (j <= valueLen) {
            res = value[valueLen - j] + res;
          } else {
            res = ph + res;
          }

          j++;
        } else {
          res = template[tempLen - i - 1] + res;
        }
      }

      $$1.each(variables, function (i, v) {
        res = res.replace('{' + i + '}', v);
      });
      return $$1('<div>' + res + '</div>').text();
    }
  })
};
classes.Numpad = Numpad;
mobiscroll.themes.numpad = mobiscroll.themes.frame; // Decimal preset
// ---

var decimalDefaults = {
  entryMode: 'template',
  min: 0,
  max: 99.99,
  maxScale: 4,
  prefix: '',
  suffix: '',
  returnAffix: false
};

presets$1.decimal = function (inst) {
  var orig = extend$1({}, inst.settings),
      conditionalDefaults = {
    scale: orig.entryMode == 'freeform' ? undefined : 2
  },
      s = extend$1(inst.settings, decimalDefaults, conditionalDefaults, orig),
      scale = s.scale,
      min = +s.min.toFixed(scale),
      max = +s.max.toFixed(scale),
      negativeNum = min < 0,
      thousandRegex = new RegExp(s.thousandsSeparator, 'g'),
      maxIntLength = (Math.floor(Math.max(max, Math.abs(min))) + '').length + 1,
      freeEntry = s.entryMode == 'freeform';
  /**
   * Returns the number from the digits
   * @param {Array} digitArray
   * @param {boolean} isNegative
   */

  function getNumber(digitArray, isNegative) {
    if (!digitArray.length) {
      return null;
    }

    var ret = +digitArray.map(function (v, i) {
      return (i === 0 && v === '.' ? '0' : '') + v;
    }).join(''); // in the case of NOT the freeEntry mode, the decimal point wont be part of the digits array
    // in that case the value will need to be adjusted to the right scale

    if (!freeEntry) {
      for (var i = 0; i < scale; i++) {
        ret /= 10;
      }
    }

    return isNegative ? ret * -1 : ret;
  }
  /**
   * Returns the formatted value from the array of digits
   * @param {Array} digitArray
   */


  function getFormatted(digitArray, forInput) {
    var numberStr = '';

    if (freeEntry && (scale === undefined || !forInput)) {
      if (digitArray[0] === '.') {
        // add missing leading zero when only the decimal point is pressed
        numberStr += '0';
      }

      numberStr += digitArray.join('');
    } else {
      var nr = getNumber(digitArray);

      if (forInput && freeEntry) {
        numberStr = nr === null ? '' : nr.toFixed(scale);
      } else {
        numberStr = (nr === null ? 0 : nr).toFixed(scale);
      }
    } // split the value by the decimal separator to add thousand separators to the integer part


    var parts = numberStr.split('.'),
        integer = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, s.thousandsSeparator),
        dec = parts[1] ? s.decimalSeparator + parts[1] : ''; // when decimal separator also needed when there is no decimal part in free entry mode
    // because this function also used for the displayed number on the numpad, not only for the input

    if (parts[1] !== undefined && !parts[1].length && freeEntry) {
      dec = s.decimalSeparator;
    }

    return integer + dec;
  } // Extended methods
  // ---


  inst.setVal = function (val, fill, change, temp) {
    if (val || val === 0) {
      if (typeof val === 'string') {
        val = +val.replace(s.thousandsSeparator, '').replace(s.decimalSeparator, '.');
      }

      val = constrain(val, min, max);
    }

    return inst._setVal(val, fill, change, temp);
  };

  inst.getVal = function (temp) {
    var val = inst._getVal(temp),
        valNr = (val + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');

    return isNumeric(valNr) ? +valNr : val;
  }; // ---


  var numberTemplate = Array(maxIntLength).join('d'); // in the case of freeEntry, the decimal point should not be part of the template

  if (freeEntry) {
    if (scale !== undefined) {
      // +2 index required:
      // - 1 for the decimal point
      // - 1 for the join method, since the "d"s will be the separators (and there's one separator less than value)
      numberTemplate += scale ? Array(scale + 2).join('d') : '';
    } else {
      numberTemplate += Array(s.maxScale + 2).join('d');
    }
  } else {
    // +1 required for the join method, since the "d"s will be the separators (and there's one separator less than value)
    numberTemplate += scale ? '.' + Array(scale + 1).join('d') : '';
  }

  var template = (negativeNum ? '{sign}' : '') + s.prefix.replace(/d/g, '\\d') + numberTemplate + s.suffix.replace(/d/g, '\\d');
  return {
    template: template,
    leftKey: negativeNum ? {
      text: '-/+',
      variable: 'sign:-:',
      track: false,
      keys: [107, 109, 187, 189]
    } : undefined,
    rightKey: freeEntry ? {
      text: s.decimalSeparator,
      value: '.',
      keys: [110, 190]
    } : undefined,
    allowLeadingZero: freeEntry,
    parseValue: function parseValue(value) {
      var i,
          m,
          v = value || s.defaultValue,
          ret = [],
          fixScale = scale !== undefined ? scale : s.maxScale;

      if (value === '' || value === null || value === undefined) {
        return ret;
      }

      if (+value === 0) {
        if (freeEntry) {
          return [0];
        } else {
          return [];
        }
      }

      if (v) {
        v = (v + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');
        m = v.match(/\d+\.?\d*/g);

        if (m) {
          m = (+m[0]).toFixed(fixScale);

          for (i = 0; i < m.length; i++) {
            if (m[i] != '.') {
              if (+m[i]) {
                ret.push(+m[i]);
              } else if (ret.length) {
                // No leading 0s
                // in freeEntry mode, zeros after the decimal point are only necessary if there are other nonzero digits after them
                // for example 10.0001 - decimal zeros are required => 10.0001 => [1, 0, ., 0, 0, 0, 1]
                // for example 10.1000 - decimal zeros are not required => 10.1 => [1, 0, ., 1]
                var decIndex = m.indexOf('.');
                var nonZero = m.length > i + 1 && m.substring(i + 1).match(/[1-9]+/);

                if (!freeEntry || i < decIndex || nonZero) {
                  ret.push(0);
                }
              }
            } else if (freeEntry) {
              // in the case of freeEntry, the decimal point should be part of the input digits
              ret.push('.');
            }
          }

          var decimalIndex = m.indexOf('.'); // if there are no digits after the point remove the point

          if (ret.indexOf('.') >= 0 && (m.length <= decimalIndex + 1 || !m.substring(decimalIndex + 1).match(/[1-9]+/))) {
            ret.splice(ret.indexOf('.'), 1);
          }
        }
      }

      if (value < 0) {
        // make the sign the last thing to manipulate
        ret.unshift('sign:' + '-');
      }

      return ret;
    },
    formatValue: function formatValue(value, variables) {
      var v = getFormatted(value, true),
          nr = getNumber(value, variables && variables.sign == '-');
      return (nr < 0 ? '-' : '') + (s.returnAffix ? s.prefix + v + s.suffix : v);
    },
    validate: function validate(data) {
      var i,
          digits = data.values,
          v = getFormatted(digits),
          nr = getNumber(digits, data.variables && data.variables.sign == '-'),
          disabled = [],
          invalid = nr > max || nr < min || (s.invalid ? inst._indexOf(s.invalid, nr) != -1 : false);

      if (!digits.length && !s.allowLeadingZero && !freeEntry) {
        disabled.push(0);
      }

      if (digits.length >= maxIntLength || digits.indexOf('.') !== -1) {
        disabled.push('.');
      }

      if (freeEntry) {
        if (digits.length == 1 && digits[0] === 0) {
          for (i = 0; i <= 9; i++) {
            disabled.push(i);
          }
        }

        if (!digits.length || digits[digits.length - 1] == '.') {
          invalid = true;
        } // Only allow max maxScale decimal values


        var sca = scale !== undefined ? scale : s.maxScale; // >= meaning: starting zero digit may be missing, that's why

        if (digits.length >= sca + 1 && digits[digits.length - sca - 1] == '.') {
          for (i = 0; i <= 9; i++) {
            disabled.push(i);
          }
        }
      } // Display the formatted value


      if (inst.isVisible()) {
        $$1('.mbsc-np-dsp', inst._markup).html((data.variables.sign || '') + s.prefix + v + s.suffix || '&nbsp;');
      }

      return {
        disabled: disabled,
        invalid: invalid
      };
    }
  };
}; // ---
// Timespan preset
// ---


function getSeconds(value) {
  var i = 0,
      m = 1,
      ret = 0;

  while (value.length) {
    if (i > 3) {
      m = 60 * 60;
    } else if (i > 1) {
      m = 60;
    }

    ret = ret + value.pop() * m * (i % 2 ? 10 : 1);
    i++;
  }

  return ret;
}

var parts = ['h', 'm', 's'],
    timespanDefaults = {
  min: 0,
  max: 362439,
  //99 * 60 * 60 + 99 * 60 + 99
  defaultValue: 0,
  hourTextShort: 'h',
  minuteTextShort: 'm',
  secTextShort: 's'
};

presets$1.timespan = function (inst) {
  var orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, timespanDefaults, orig),
      labels = {
    h: s.hourTextShort.replace(/d/g, '\\d'),
    m: s.minuteTextShort.replace(/d/g, '\\d'),
    s: s.secTextShort.replace(/d/g, '\\d')
  },
      template = 'd<span class="mbsc-np-sup mbsc-np-time">' + labels.s + '</span>';

  function formatTime(seconds) {
    var p,
        ret = '',
        m = 60 * 60;
    $$1(parts).each(function (i, v) {
      p = Math.floor(seconds / m);
      seconds -= p * m;
      m /= 60;

      if (p > 0 || v == 's' && !ret) {
        ret = ret + (ret ? ' ' : '') + p + labels[v];
      }
    });
    return ret;
  }

  if (s.max > 9) {
    template = 'd' + template;
  }

  if (s.max > 99) {
    template = '<span class="mbsc-np-ts-m">' + (s.max > 639 ? 'd' : '') + 'd</span><span class="mbsc-np-sup mbsc-np-time">' + labels.m + '</span>' + template;
  }

  if (s.max > 6039) {
    template = '<span class="mbsc-np-ts-h">' + (s.max > 38439 ? 'd' : '') + 'd</span><span class="mbsc-np-sup mbsc-np-time">' + labels.h + '</span>' + template;
  } // Extended methods
  // ---


  inst.setVal = function (val, fill, change, temp) {
    if (isNumeric(val)) {
      val = formatTime(val);
    }

    return inst._setVal(val, fill, change, temp);
  };

  inst.getVal = function (temp) {
    return inst._hasValue || temp ? getSeconds(inst.getArrayVal(temp)) : null;
  }; // ---


  return {
    template: template,
    parseValue: function parseValue(value) {
      var p,
          vv = value || formatTime(s.defaultValue),
          ret = [];

      if (vv) {
        $$1(parts).each(function (i, v) {
          p = new RegExp('(\\d+)' + labels[v], 'gi').exec(vv);

          if (p) {
            p = +p[1];

            if (p > 9) {
              ret.push(Math.floor(p / 10));
              ret.push(p % 10);
            } else {
              if (ret.length) {
                // No leading 0s
                ret.push(0);
              }

              if (p || ret.length) {
                // No leading 0s
                ret.push(p);
              }
            }
          } else if (ret.length) {
            ret.push(0);
            ret.push(0);
          }
        });
      }

      return ret;
    },
    formatValue: function formatValue(value) {
      return formatTime(getSeconds(value));
    },
    validate: function validate(data) {
      var value = data.values,
          v = getSeconds(value.slice(0)),
          disabled = [];

      if (!value.length) {
        disabled.push(0);
      }

      return {
        disabled: disabled,
        invalid: v > s.max || v < s.min || (s.invalid ? inst._indexOf(s.invalid, +v) != -1 : false)
      };
    }
  };
}; // ---
// Time preset
// ---


var timeDefaults = {
  timeFormat: 'hh:ii A',
  amText: 'am',
  pmText: 'pm'
};

presets$1.time = function (inst) {
  var orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, timeDefaults, orig),
      timeFormat = s.timeFormat.split(':'),
      isAmPM = s.timeFormat.match(/a/i),
      am = isAmPM ? isAmPM[0] == 'a' ? s.amText : s.amText.toUpperCase() : '',
      pm = isAmPM ? isAmPM[0] == 'a' ? s.pmText : s.pmText.toUpperCase() : '',
      l = 0,
      minH = s.min ? '' + s.min.getHours() : '',
      maxH = s.max ? '' + s.max.getHours() : '',
      minM = s.min ? '' + (s.min.getMinutes() < 10 ? '0' + s.min.getMinutes() : s.min.getMinutes()) : '',
      maxM = s.max ? '' + (s.max.getMinutes() < 10 ? '0' + s.max.getMinutes() : s.max.getMinutes()) : '',
      minS = s.min ? '' + (s.min.getSeconds() < 10 ? '0' + s.min.getSeconds() : s.min.getSeconds()) : '',
      maxS = s.max ? '' + (s.max.getSeconds() < 10 ? '0' + s.max.getSeconds() : s.max.getSeconds()) : '';

  if (s.min) {
    s.min.setFullYear(2014, 7, 20);
  }

  if (s.max) {
    s.max.setFullYear(2014, 7, 20);
  }

  function getFormattedTime(value, variables) {
    var i,
        ret = '';

    for (i = 0; i < value.length; ++i) {
      ret += value[i] + (i % 2 == (value.length % 2 == 1 ? 0 : 1) && i != value.length - 1 ? ':' : '');
    }

    $$1.each(variables, function (i, v) {
      ret += ' ' + v;
    });
    return ret;
  }

  function disableButtons(value) {
    var i,
        isMinH,
        isMaxH,
        isMinM,
        isMaxM,
        invH,
        invM,
        invS,
        hour,
        minutes,
        length = value.length,
        disabled = [],
        digitNr = 2 * timeFormat.length;
    l = digitNr;

    if (!length) {
      if (isAmPM) {
        disabled.push(0);
        disabled.push(s.leftKey.value);
      }

      disabled.push(s.rightKey.value);
    }

    if (!isAmPM && (digitNr - length < 2 || value[0] != 1 && (value[0] > 2 || value[1] > 3) && digitNr - length <= 2)) {
      disabled.push('30');
      disabled.push('00');
    }

    if ((isAmPM ? value[0] > 1 || value[1] > 2 : value[0] != 1 && (value[0] > 2 || value[1] > 3)) && value[0]) {
      // if the hour number is not a two digit number
      value.unshift(0);
      l = digitNr - 1;
    }

    if (length == l || length === digitNr - 1 && value[2] > 5) {
      for (i = 0; i <= 9; ++i) {
        disabled.push(i);
      }
    } else if (length == 1 && isAmPM && value[0] == 1 || !isAmPM && value[0] == 2 && value[1] > 3 && length % 2 == 1) {
      for (i = 6; i <= 9; ++i) {
        disabled.push(i);
      }
    }

    hour = value[1] !== undefined ? '' + value[0] + value[1] : '';
    minutes = +maxM == +(value[3] !== undefined ? '' + value[2] + value[3] : '');

    if (s.invalid) {
      for (i = 0; i < s.invalid.length; ++i) {
        invH = s.invalid[i].getHours();
        invM = s.invalid[i].getMinutes();
        invS = s.invalid[i].getSeconds();

        if (invH == +hour) {
          if (timeFormat.length == 2 && (invM < 10 ? 0 : +('' + invM)[0]) == +value[2]) {
            // disable invalid minutes
            disabled.push(invM < 10 ? invM : +('' + invM)[1]);
            break;
          } else if ((invS < 10 ? 0 : +('' + invS)[0]) == +value[4]) {
            // disable invalid sec
            disabled.push(invS < 10 ? invS : +('' + invS)[1]);
            break;
          }
        }
      }
    }

    if (s.min || s.max) {
      isMinH = +minH == +hour;
      isMaxH = +maxH == +hour;
      isMaxM = isMaxH && minutes;
      isMinM = isMinH && minutes;

      if (length === 0) {
        for (i = isAmPM ? 2 : minH > 19 ? minH[0] : 3; i <= (minH[0] == 1 ? 9 : minH[0] - 1); ++i) {
          // disables values lower than min and leves the 1,2 buttons
          disabled.push(i);
        }

        if (minH >= 10) {
          disabled.push(0);

          if (minH[0] == 2) {
            //if 2x hour is min
            for (i = 3; i <= 9; ++i) {
              disabled.push(i);
            }
          }
        }

        if (maxH && maxH < 10 || minH && minH >= 10) {
          //disables values between min and max values
          for (i = maxH && maxH < 10 ? +maxH[0] + 1 : 0; i < (minH && minH >= 10 ? minH[0] : 10); ++i) {
            disabled.push(i);
          }
        }
      }

      if (length == 1) {
        if (value[0] === 0) {
          // disable min values if 24h format, and starts with 0
          for (i = 0; i < minH[0]; ++i) {
            //kiveve minH[0] == 1 ? 9 :
            disabled.push(i);
          }
        }

        if (minH && value[0] !== 0 && (isAmPM ? value[0] == 1 : value[0] == 2)) {
          // don't allow lower values entered, ex. 2:56
          for (i = isAmPM ? 3 : 4; i <= 9; ++i) {
            disabled.push(i);
          }
        }

        if (value[0] == minH[0]) {
          // is min value
          for (i = 0; i < minH[1]; ++i) {
            disabled.push(i);
          }
        }

        if (value[0] == maxH[0] && !isAmPM) {
          // is max value
          for (i = +maxH[1] + 1; i <= 9; ++i) {
            disabled.push(i);
          }
        }
      }

      if (length == 2 && (isMinH || isMaxH)) {
        for (i = isMaxH ? +maxM[0] + 1 : 0; i < (isMinH ? +minM[0] : 10); ++i) {
          disabled.push(i);
        }
      }

      if (length == 3 && (isMaxH && value[2] == maxM[0] || isMinH && value[2] == minM[0])) {
        for (i = isMaxH && value[2] == maxM[0] ? +maxM[1] + 1 : 0; i < (isMinH && value[2] == minM[0] ? +minM[1] : 10); ++i) {
          disabled.push(i);
        }
      }

      if (length == 4 && (isMinM || isMaxM)) {
        for (i = isMaxM ? +maxS[0] + 1 : 0; i < (isMinM ? +minS[0] : 10); ++i) {
          disabled.push(i);
        }
      }

      if (length == 5 && (isMinM && value[4] == minS[0] || isMaxM && value[4] == maxS[0])) {
        for (i = isMaxM && value[4] == maxS[0] ? +maxS[1] + 1 : 0; i < (isMinM && value[4] == minS[0] ? +minS[1] : 10); ++i) {
          disabled.push(i);
        }
      }
    }

    return disabled;
  }

  return {
    placeholder: '-',
    allowLeadingZero: true,
    template: (timeFormat.length == 3 ? 'dd:dd:dd' : timeFormat.length == 2 ? 'dd:dd' : 'dd') + (isAmPM ? '<span class="mbsc-np-sup">{ampm:--}</span>' : ''),
    leftKey: isAmPM ? {
      text: am,
      variable: 'ampm:' + am,
      value: '00'
    } : {
      text: ':00',
      value: '00'
    },
    rightKey: isAmPM ? {
      text: pm,
      variable: 'ampm:' + pm,
      value: '00'
    } : {
      text: ':30',
      value: '30'
    },
    parseValue: function parseValue(value) {
      var i,
          m,
          v = value || s.defaultValue,
          ret = [];

      if (v) {
        v = v + '';
        m = v.match(/\d/g);

        if (m) {
          for (i = 0; i < m.length; i++) {
            ret.push(+m[i]);
          }
        }

        if (isAmPM) {
          ret.push('ampm:' + (v.match(new RegExp(s.pmText, 'gi')) ? pm : am));
        }
      }

      return ret;
    },
    formatValue: function formatValue(value, variables) {
      return getFormattedTime(value, variables);
    },
    validate: function validate(data) {
      var value = data.values,
          variables = data.variables,
          formattedTime = getFormattedTime(value, variables),
          d = value.length >= 3 ? new Date(2014, 7, 20, '' + value[0] + (value.length % 2 === 0 ? value[1] : ''), '' + value[value.length % 2 === 0 ? 2 : 1] + value[value.length % 2 === 0 ? 3 : 2]) : '';
      return {
        disabled: disableButtons(value),
        length: l,
        invalid: (isAmPM ? !new RegExp('^(0?[1-9]|1[012])(:[0-5]\\d)?(:[0-5][0-9])' + ' (?:' + s.amText + '|' + s.pmText + ')$', 'i').test(formattedTime) : !/^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/.test(formattedTime)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false) || !((s.min ? s.min <= d : true) && (s.max ? d <= s.max : true))
      };
    }
  };
}; // Date preset
// ---


var dateDefaults = {
  dateOrder: 'mdy',
  dateFormat: 'mm/dd/yy',
  delimiter: '/'
};

presets$1.date = function (inst) {
  var yi,
      mi,
      di,
      i,
      indexArray = [],
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, dateTimeDefaults, dateDefaults, orig),
      templ = s.dateOrder,
      minM = s.min ? '' + (s.getMonth(s.min) + 1) : 0,
      maxM = s.max ? '' + (s.getMonth(s.max) + 1) : 0,
      minD = s.min ? '' + s.getDay(s.min) : 0,
      maxD = s.max ? '' + s.getDay(s.max) : 0,
      minY = s.min ? '' + s.getYear(s.min) : 0,
      maxY = s.max ? '' + s.getYear(s.max) : 0;
  templ = templ.replace(/y+/gi, 'yyyy');
  templ = templ.replace(/m+/gi, 'mm');
  templ = templ.replace(/d+/gi, 'dd');
  yi = templ.toUpperCase().indexOf('Y');
  mi = templ.toUpperCase().indexOf('M');
  di = templ.toUpperCase().indexOf('D');
  templ = '';
  indexArray.push({
    val: yi,
    n: 'yyyy'
  }, {
    val: mi,
    n: 'mm'
  }, {
    val: di,
    n: 'dd'
  });
  indexArray.sort(function (a, b) {
    return a.val - b.val;
  });
  $$1.each(indexArray, function (i, v) {
    templ += v.n;
  });
  yi = templ.indexOf('y');
  mi = templ.indexOf('m');
  di = templ.indexOf('d');
  templ = '';

  for (i = 0; i < 8; ++i) {
    templ += 'd';

    if (i + 1 == yi || i + 1 == mi || i + 1 == di) {
      templ += s.delimiter;
    }
  }

  function isleapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }

  function disableButtons(value) {
    var i,
        j,
        invY,
        invM,
        invD,
        disabled = [],
        year = value[yi + 3] !== undefined ? '' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3] : '',
        month = value[mi + 1] !== undefined ? '' + value[mi] + value[mi + 1] : '',
        day = value[di + 1] !== undefined ? '' + value[di] + value[di + 1] : '',
        maxDay = '' + s.getMaxDayOfMonth(year || 2012, month - 1 || 0),
        // Use a leap year if no year present to allow day 29 to be enetered
    isMin = minY === year && +minM === +month,
        isMax = maxY === year && +maxM === +month;

    if (s.invalid) {
      for (i = 0; i < s.invalid.length; ++i) {
        invY = s.getYear(s.invalid[i]);
        invM = s.getMonth(s.invalid[i]);
        invD = s.getDay(s.invalid[i]);

        if (invY == +year && invM + 1 == +month) {
          //disable the ivalid day
          if ((invD < 10 ? 0 : +('' + invD)[0]) == +value[di]) {
            disabled.push(invD < 10 ? invD : +('' + invD)[1]);
            break;
          }
        }

        if (invM + 1 == +month && invD == +day) {
          //disable invalid year
          if (('' + invY).substring(0, 3) == '' + value[yi] + value[yi + 1] + value[yi + 2]) {
            disabled.push(('' + invY)[3]);
            break;
          }
        }

        if (invY == +year && invD == +day) {
          //disable the ivalid month
          if ((invM < 10 ? 0 : +('' + (invM + 1))[0]) == +value[mi]) {
            disabled.push(invM < 10 ? invM : +('' + (invM + 1))[1]);
            break;
          }
        }
      }
    } // month check


    if (day == '31' && (value.length == mi || value.length == mi + 1)) {
      // disable 30 day months
      if (value[mi] != 1) {
        disabled.push(2, 4, 6, 9, 11);
      } else {
        disabled.push(1);
      }
    }

    if (day == '30' && value[mi] === 0 && value.length <= mi + 1) {
      // disable february
      disabled.push(2);
    }

    if (value.length == mi) {
      // before month's first digit set, disable values outside min/max
      for (i = maxY === year && +maxM < 10 ? 1 : 2; i <= 9; ++i) {
        disabled.push(i);
      }

      if (minY === year && +minM >= 10) {
        disabled.push(0);
      }
    }

    if (value.length == mi + 1) {
      // before month's second digit set
      if (value[mi] == 1) {
        // if two digit month number
        for (i = maxY === year ? +maxM[1] + 1 : 3; i <= 9; ++i) {
          disabled.push(i);
        }

        if (minY == year) {
          // if min year diable lower values
          for (i = 0; i < +minM[1]; ++i) {
            disabled.push(i);
          }
        }
      }

      if (value[mi] === 0) {
        //if month number starts with 0
        disabled.push(0);

        if (maxY === year || minY === year) {
          // if min/max diable lower/greater values
          for (i = maxY === year ? +day > +maxD ? +maxM : +maxM + 1 : 0; i <= (minY === year ? +day < +minD ? +minM - 1 : +minM - 1 : 9); ++i) {
            disabled.push(i);
          }
        }
      }
    } // day check


    if (value.length == di) {
      // before day first digit set
      for (i = isMax ? (+maxD > 10 ? +maxD[0] : 0) + 1 : +maxDay[0] + 1; i <= 9; ++i) {
        disabled.push(i);
      }

      if (isMin) {
        // if is min year and month disable lower values
        for (i = 0; i < (+minD < 10 ? 0 : minD[0]); ++i) {
          disabled.push(i);
        }
      }
    }

    if (value.length == di + 1) {
      // before day second digit set
      if (value[di] >= 3 || month == '02') {
        //disable greater values than the maxDay's second digit
        for (i = +maxDay[1] + 1; i <= 9; ++i) {
          disabled.push(i);
        }
      }

      if (isMax && +maxD[0] == value[di]) {
        //if max year and month disable greater values
        for (i = +maxD[1] + 1; i <= 9; ++i) {
          disabled.push(i);
        }
      }

      if (isMin && minD[0] == value[di]) {
        //if min year and month disable lower values
        for (i = 0; i < +minD[1]; ++i) {
          disabled.push(i);
        }
      }

      if (value[di] === 0) {
        // if month first digit 0
        disabled.push(0);

        if (isMax || isMin) {
          // disable greater/lower valies if min or max
          for (i = isMax ? +maxD + 1 : 1; i <= (isMin ? +minD - 1 : 9); ++i) {
            disabled.push(i);
          }
        }
      }
    } // year check


    if (value[yi + 2] !== undefined && month == '02' && day == '29') {
      // if 29th and february than just leap years allowed
      for (j = +('' + value[yi] + value[yi + 1] + value[yi + 2] + 0); j <= +('' + value[yi] + value[yi + 1] + value[yi + 2] + 9); ++j) {
        disabled.push(!isleapYear(j) ? j % 10 : '');
      }
    }

    if (value.length == yi) {
      // before year's first digit set
      if (s.min) {
        // disable lower values
        for (i = 0; i < +minY[0]; ++i) {
          disabled.push(i);
        }
      }

      if (s.max) {
        //disable greater values
        for (i = +maxY[0] + 1; i <= 9; ++i) {
          disabled.push(i);
        }
      }

      disabled.push(0);
    }

    if (s.min || s.max) {
      for (j = 1; j < 4; ++j) {
        if (value.length == yi + j) {
          // before year's i-th digit set
          if (value[yi + j - 1] == +minY[j - 1] && (j == 3 ? value[yi + j - 2] == +minY[j - 2] : true)) {
            for (i = 0; i < +minY[j] + (j == 3 && value[mi + 1] && +minM > +month ? 1 : 0); ++i) {
              //if month less than min-month than doesn't allow minYear
              disabled.push(i);
            }
          }

          if (value[yi + j - 1] == +maxY[j - 1] && (j == 3 ? value[yi + j - 2] == +maxY[j - 2] : true)) {
            for (i = +maxY[j] + (j == 3 && +maxM < +month ? 0 : 1); i <= 9; ++i) {
              //if month greater than max-month than doesn't allow maxYear
              disabled.push(i);
            }
          }
        }
      }
    }

    return disabled;
  }

  function calcDate(value) {
    return new Date(+('' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3]), +('' + value[mi] + value[mi + 1]) - 1, +('' + value[di] + value[di + 1]));
  } // Extended methods
  // ---


  inst.getVal = function (temp) {
    return inst._hasValue || temp ? calcDate(inst.getArrayVal(temp)) : null;
  }; // ---


  return {
    placeholder: '-',
    fill: 'ltr',
    allowLeadingZero: true,
    template: templ,
    parseValue: function parseValue(value) {
      var i,
          ret = [],
          v = value || s.defaultValue,
          d = parseDate(s.dateFormat, v, s);

      if (v) {
        for (i = 0; i < indexArray.length; ++i) {
          if (/m/i.test(indexArray[i].n)) {
            ret = ret.concat(((s.getMonth(d) < 9 ? '0' : '') + (s.getMonth(d) + 1)).split(''));
          } else if (/d/i.test(indexArray[i].n)) {
            ret = ret.concat(((s.getDay(d) < 10 ? '0' : '') + s.getDay(d)).split(''));
          } else {
            ret = ret.concat((s.getYear(d) + '').split(''));
          }
        }
      }

      return ret;
    },
    formatValue: function formatValue(value) {
      return formatDate(s.dateFormat, calcDate(value), s);
    },
    validate: function validate(data) {
      var value = data.values,
          d = calcDate(value);
      return {
        disabled: disableButtons(value),
        invalid: !(d != 'Invalid Date' && (s.min ? s.min <= d : true) && (s.max ? d <= s.max : true)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false)
      };
    }
  };
}; // ---

var MbscNumpadBase = (function (_super) {
    __extends(MbscNumpadBase, _super);
    function MbscNumpadBase(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onSet = new EventEmitter();
        _this.onClear = new EventEmitter();
        _this.onInput = new EventEmitter();
        return _this;
    }
    MbscNumpadBase.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpadBase.propDecorators = {
        'allowLeadingZero': [{ type: Input$1 },],
        'deleteIcon': [{ type: Input$1 },],
        'fill': [{ type: Input$1 },],
        'leftKey': [{ type: Input$1 },],
        'mask': [{ type: Input$1 },],
        'placeholderChar': [{ type: Input$1, args: ['char-placeholder',] },],
        'rightKey': [{ type: Input$1 },],
        'template': [{ type: Input$1 },],
        'validate': [{ type: Input$1 },],
        'onSet': [{ type: Output },],
        'onClear': [{ type: Output },],
        'onInput': [{ type: Output },],
        'cancelText': [{ type: Input$1 },],
        'clearText': [{ type: Input$1 },],
        'setText': [{ type: Input$1 },],
    };
MbscNumpadBase.ɵfac = function MbscNumpadBase_Factory(t) { return new (t || MbscNumpadBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpadBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpadBase, selectors: [["", "mbsc-n-b", ""]], inputs: { allowLeadingZero: "allowLeadingZero", deleteIcon: "deleteIcon", fill: "fill", leftKey: "leftKey", mask: "mask", placeholderChar: ["char-placeholder", "placeholderChar"], rightKey: "rightKey", template: "template", validate: "validate", cancelText: "cancelText", clearText: "clearText", setText: "setText" }, outputs: { onSet: "onSet", onClear: "onClear", onInput: "onInput" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadBase, [{
        type: Directive,
        args: [{ selector: '[mbsc-n-b]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { allowLeadingZero: [{
            type: Input$1
        }], deleteIcon: [{
            type: Input$1
        }], fill: [{
            type: Input$1
        }], leftKey: [{
            type: Input$1
        }], mask: [{
            type: Input$1
        }], placeholderChar: [{
            type: Input$1,
            args: ['char-placeholder']
        }], rightKey: [{
            type: Input$1
        }], template: [{
            type: Input$1
        }], validate: [{
            type: Input$1
        }], onSet: [{
            type: Output
        }], onClear: [{
            type: Output
        }], onInput: [{
            type: Output
        }], cancelText: [{
            type: Input$1
        }], clearText: [{
            type: Input$1
        }], setText: [{
            type: Input$1
        }] }); })();
    return MbscNumpadBase;
}(MbscFrameBase));
var MbscNumpad = (function (_super) {
    __extends(MbscNumpad, _super);
    function MbscNumpad(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.preset = undefined;
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscNumpad.prototype, "value", {
        set: function (v) {
            if (!this.control) {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumpad.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscNumpad.prototype.initControl = function () {
        var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Numpad(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscNumpad.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpad.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-numpad',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numpadChange',] },],
    };
MbscNumpad.ɵfac = function MbscNumpad_Factory(t) { return new (t || MbscNumpad)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpad.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpad, selectors: [["", "mbsc-numpad", ""]], inputs: { value: ["mbsc-numpad", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numpadChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpad, [{
        type: Directive,
        args: [{
                selector: '[mbsc-numpad]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-numpad']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numpadChange']
        }] }); })();
    return MbscNumpad;
}(MbscNumpadBase));
var MbscNumpadComponent = (function (_super) {
    __extends(MbscNumpadComponent, _super);
    function MbscNumpadComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumpadComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumpadComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumpadComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumpadComponent.ɵfac = function MbscNumpadComponent_Factory(t) { return new (t || MbscNumpadComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumpadComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumpadComponent, selectors: [["mbsc-numpad"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumpadComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumpadComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-numpad',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumpadComponent;
}(MbscNumpad));
var MbscNumpadDecimal = (function (_super) {
    __extends(MbscNumpadDecimal, _super);
    function MbscNumpadDecimal(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'decimal';
        return _this;
    }
    Object.defineProperty(MbscNumpadDecimal.prototype, "value", {
        set: function (v) {
            if (this.instance || v !== '') {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumpadDecimal.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpadDecimal.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-numpad-decimal',] },],
        'decimalSeparator': [{ type: Input$1 },],
        'defaultValue': [{ type: Input$1 },],
        'entryMode': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'scale': [{ type: Input$1 },],
        'maxScale': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'prefix': [{ type: Input$1 },],
        'returnAffix': [{ type: Input$1 },],
        'suffix': [{ type: Input$1 },],
        'thousandsSeparator': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numpad-decimalChange',] },],
    };
MbscNumpadDecimal.ɵfac = function MbscNumpadDecimal_Factory(t) { return new (t || MbscNumpadDecimal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpadDecimal.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpadDecimal, selectors: [["", "mbsc-numpad-decimal", ""]], inputs: { value: ["mbsc-numpad-decimal", "value"], decimalSeparator: "decimalSeparator", defaultValue: "defaultValue", entryMode: "entryMode", invalid: "invalid", scale: "scale", maxScale: "maxScale", min: "min", max: "max", prefix: "prefix", returnAffix: "returnAffix", suffix: "suffix", thousandsSeparator: "thousandsSeparator", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numpad-decimalChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadDecimal, [{
        type: Directive,
        args: [{
                selector: '[mbsc-numpad-decimal]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-numpad-decimal']
        }], decimalSeparator: [{
            type: Input$1
        }], defaultValue: [{
            type: Input$1
        }], entryMode: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], scale: [{
            type: Input$1
        }], maxScale: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], prefix: [{
            type: Input$1
        }], returnAffix: [{
            type: Input$1
        }], suffix: [{
            type: Input$1
        }], thousandsSeparator: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numpad-decimalChange']
        }] }); })();
    return MbscNumpadDecimal;
}(MbscNumpad));
var MbscNumpadDecimalComponent = (function (_super) {
    __extends(MbscNumpadDecimalComponent, _super);
    function MbscNumpadDecimalComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumpadDecimalComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumpadDecimalComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumpadDecimalComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumpadDecimalComponent.ɵfac = function MbscNumpadDecimalComponent_Factory(t) { return new (t || MbscNumpadDecimalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumpadDecimalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumpadDecimalComponent, selectors: [["mbsc-numpad-decimal"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumpadDecimalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumpadDecimalComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadDecimalComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-numpad-decimal',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumpadDecimalComponent;
}(MbscNumpadDecimal));
var MbscNumpadDate = (function (_super) {
    __extends(MbscNumpadDate, _super);
    function MbscNumpadDate(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscNumpadDate.prototype, "value", {
        set: function (v) {
            if (this.instance || v !== '') {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumpadDate.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if ((innerValue && !v) ||
                (!innerValue && v) ||
                (innerValue && v && innerValue.getTime() !== v.getTime())) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscNumpadDate.prototype.initControl = function () {
        var options = extend$1({ preset: 'date' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Numpad(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscNumpadDate.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpadDate.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-numpad-date',] },],
        'dateFormat': [{ type: Input$1 },],
        'dateOrder': [{ type: Input$1 },],
        'delimiter': [{ type: Input$1 },],
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numpad-dateChange',] },],
    };
MbscNumpadDate.ɵfac = function MbscNumpadDate_Factory(t) { return new (t || MbscNumpadDate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpadDate.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpadDate, selectors: [["", "mbsc-numpad-date", ""]], inputs: { value: ["mbsc-numpad-date", "value"], dateFormat: "dateFormat", dateOrder: "dateOrder", delimiter: "delimiter", defaultValue: "defaultValue", invalid: "invalid", min: "min", max: "max", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numpad-dateChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadDate, [{
        type: Directive,
        args: [{
                selector: '[mbsc-numpad-date]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-numpad-date']
        }], dateFormat: [{
            type: Input$1
        }], dateOrder: [{
            type: Input$1
        }], delimiter: [{
            type: Input$1
        }], defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numpad-dateChange']
        }] }); })();
    return MbscNumpadDate;
}(MbscNumpadBase));
var MbscNumpadDateComponent = (function (_super) {
    __extends(MbscNumpadDateComponent, _super);
    function MbscNumpadDateComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumpadDateComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumpadDateComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumpadDateComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumpadDateComponent.ɵfac = function MbscNumpadDateComponent_Factory(t) { return new (t || MbscNumpadDateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumpadDateComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumpadDateComponent, selectors: [["mbsc-numpad-date"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumpadDateComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumpadDateComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadDateComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-numpad-date',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumpadDateComponent;
}(MbscNumpadDate));
var MbscNumpadTime = (function (_super) {
    __extends(MbscNumpadTime, _super);
    function MbscNumpadTime(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscNumpadTime.prototype, "value", {
        set: function (v) {
            if (this.instance || v !== '') {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumpadTime.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscNumpadTime.prototype.initControl = function () {
        var options = extend$1({ preset: 'time' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Numpad(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscNumpadTime.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpadTime.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-numpad-time',] },],
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'timeFormat': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numpad-timeChange',] },],
    };
MbscNumpadTime.ɵfac = function MbscNumpadTime_Factory(t) { return new (t || MbscNumpadTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpadTime.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpadTime, selectors: [["", "mbsc-numpad-time", ""]], inputs: { value: ["mbsc-numpad-time", "value"], defaultValue: "defaultValue", invalid: "invalid", max: "max", min: "min", timeFormat: "timeFormat", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numpad-timeChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadTime, [{
        type: Directive,
        args: [{
                selector: '[mbsc-numpad-time]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-numpad-time']
        }], defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], timeFormat: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numpad-timeChange']
        }] }); })();
    return MbscNumpadTime;
}(MbscNumpadBase));
var MbscNumpadTimeComponent = (function (_super) {
    __extends(MbscNumpadTimeComponent, _super);
    function MbscNumpadTimeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumpadTimeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumpadTimeComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumpadTimeComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumpadTimeComponent.ɵfac = function MbscNumpadTimeComponent_Factory(t) { return new (t || MbscNumpadTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumpadTimeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumpadTimeComponent, selectors: [["mbsc-numpad-time"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumpadTimeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumpadTimeComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadTimeComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-numpad-time',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumpadTimeComponent;
}(MbscNumpadTime));
var MbscNumpadTimespan = (function (_super) {
    __extends(MbscNumpadTimespan, _super);
    function MbscNumpadTimespan(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'timespan';
        return _this;
    }
    Object.defineProperty(MbscNumpadTimespan.prototype, "value", {
        set: function (v) {
            if (this.instance || v !== '') {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscNumpadTimespan.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscNumpadTimespan.propDecorators = {
        'value': [{ type: Input$1, args: ['mbsc-numpad-timespan',] },],
        'defaultValue': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-numpad-timespanChange',] },],
    };
MbscNumpadTimespan.ɵfac = function MbscNumpadTimespan_Factory(t) { return new (t || MbscNumpadTimespan)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscNumpadTimespan.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscNumpadTimespan, selectors: [["", "mbsc-numpad-timespan", ""]], inputs: { value: ["mbsc-numpad-timespan", "value"], defaultValue: "defaultValue", invalid: "invalid", min: "min", max: "max", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-numpad-timespanChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadTimespan, [{
        type: Directive,
        args: [{
                selector: '[mbsc-numpad-timespan]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-numpad-timespan']
        }], defaultValue: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-numpad-timespanChange']
        }] }); })();
    return MbscNumpadTimespan;
}(MbscNumpad));
var MbscNumpadTimespanComponent = (function (_super) {
    __extends(MbscNumpadTimespanComponent, _super);
    function MbscNumpadTimespanComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscNumpadTimespanComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscNumpadTimespanComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscNumpadTimespanComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscNumpadTimespanComponent.ɵfac = function MbscNumpadTimespanComponent_Factory(t) { return new (t || MbscNumpadTimespanComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscNumpadTimespanComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNumpadTimespanComponent, selectors: [["mbsc-numpad-timespan"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscNumpadTimespanComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscNumpadTimespanComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadTimespanComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-numpad-timespan',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscNumpadTimespanComponent;
}(MbscNumpadTimespan));
var comps$1 = [
    MbscNumpad,
    MbscNumpadBase,
    MbscNumpadComponent,
    MbscNumpadDecimal,
    MbscNumpadDecimalComponent,
    MbscNumpadDate,
    MbscNumpadDateComponent,
    MbscNumpadTime,
    MbscNumpadTimeComponent,
    MbscNumpadTimespan,
    MbscNumpadTimespanComponent
];
var MbscNumpadModule = (function () {
    function MbscNumpadModule() {
    }
    MbscNumpadModule.ctorParameters = function () { return []; };
MbscNumpadModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscNumpadModule });
MbscNumpadModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscNumpadModule_Factory(t) { return new (t || MbscNumpadModule)(); }, imports: [[CommonModule, MbscFrameBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNumpadModule, { declarations: function () { return [MbscNumpad, MbscNumpadBase, MbscNumpadComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent]; }, imports: function () { return [CommonModule, MbscFrameBaseModule, MbscInputModule]; }, exports: function () { return [MbscNumpad, MbscNumpadBase, MbscNumpadComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNumpadModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscFrameBaseModule, MbscInputModule],
                declarations: comps$1,
                exports: comps$1
            }]
    }], function () { return []; }, null); })();
    return MbscNumpadModule;
}());

var Optionlist = function Optionlist(elm, settings) {
  var that = this; // Call the parent constructor

  NavigationBase.call(this, elm, settings, true);
  /**
   * Optionlist initialization.
   */

  that.___init = function () {}; // Constructor


  that.init();
}; // Defaults

Optionlist.prototype = {
  _class: 'optionlist',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _defaults: extend$1({}, NavigationBase.prototype._defaults, {
    select: 'multiple',
    variant: 'a',
    display: 'inline'
  })
};
classes.Optionlist = Optionlist;
mobiscroll.themes.optionlist = mobiscroll.themes.navigation;

var MbscOptionItem = (function (_super) {
    __extends(MbscOptionItem, _super);
    function MbscOptionItem(notifyItemService, _elem) {
        return _super.call(this, notifyItemService, _elem) || this;
    }
    MbscOptionItem.ctorParameters = function () { return [
        { type: MbscNotifyItemService, },
        { type: ElementRef, },
    ]; };
MbscOptionItem.ɵfac = function MbscOptionItem_Factory(t) { return new (t || MbscOptionItem)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MbscOptionItem.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscOptionItem, selectors: [["mbsc-option-item"]], hostVars: 4, hostBindings: function MbscOptionItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-icon", ctx.icon)("data-disabled", ctx.disabled)("data-selected", ctx.selected)("data-id", ctx.id);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscOptionItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscOptionItem, [{
        type: Component,
        args: [{
                selector: 'mbsc-option-item',
                template: '<ng-content></ng-content>',
                host: {
                    '[attr.data-icon]': 'icon',
                    '[attr.data-disabled]': 'disabled',
                    '[attr.data-selected]': 'selected',
                    '[attr.data-id]': 'id'
                }
            }]
    }], function () { return [{ type: MbscNotifyItemService }, { type: ɵngcc0.ElementRef }]; }, null); })();
    return MbscOptionItem;
}(MbscNavItemBase));
var MbscOptionlist = (function (_super) {
    __extends(MbscOptionlist, _super);
    function MbscOptionlist(initialElem, zone, notifyItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
        _this.optionService = optionService;
        return _this;
    }
    MbscOptionlist.prototype.initControl = function () {
        var _this = this;
        var onItemTap = this.tapHandler.bind(this);
        var onItemTapUser = this.options && this.options.onItemTap;
        if (onItemTapUser) {
            onItemTap = function (event, inst) {
                _this.tapHandler(event, inst);
                return onItemTapUser(event, inst);
            };
        }
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
        this.instance = new Optionlist(this.initialElem.nativeElement, options);
        this.notifyItemService.notifyInstanceReady(this.instance);
        this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
            _this.instance.refresh();
        });
    };
    MbscOptionlist.prototype.ngOnDestroy = function () {
        this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscOptionlist.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscOptionlist.propDecorators = {
        'select': [{ type: Input$1 },],
        'items': [{ type: ContentChildren, args: [MbscOptionItem,] },],
    };
MbscOptionlist.ɵfac = function MbscOptionlist_Factory(t) { return new (t || MbscOptionlist)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscOptionlist.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscOptionlist, selectors: [["mbsc-optionlist"]], contentQueries: function MbscOptionlist_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscOptionItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);
    } }, hostAttrs: [1, "mbsc-cloak"], inputs: { select: "select" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscOptionlist_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscOptionlist, [{
        type: Component,
        args: [{
                selector: 'mbsc-optionlist',
                template: '<ng-content></ng-content>',
                providers: [MbscNotifyItemService],
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { select: [{
            type: Input$1
        }], items: [{
            type: ContentChildren,
            args: [MbscOptionItem]
        }] }); })();
    return MbscOptionlist;
}(MbscNavigationBase));
var MbscOptionlistModule = (function () {
    function MbscOptionlistModule() {
    }
    MbscOptionlistModule.ctorParameters = function () { return []; };
MbscOptionlistModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscOptionlistModule });
MbscOptionlistModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscOptionlistModule_Factory(t) { return new (t || MbscOptionlistModule)(); }, imports: [[MbscNavigationBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscOptionlistModule, { declarations: [MbscOptionItem, MbscOptionlist], imports: [MbscNavigationBaseModule], exports: [MbscOptionItem, MbscOptionlist] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscOptionlistModule, [{
        type: NgModule,
        args: [{
                imports: [MbscNavigationBaseModule],
                declarations: [MbscOptionItem, MbscOptionlist],
                exports: [MbscOptionItem, MbscOptionlist]
            }]
    }], function () { return []; }, null); })();
    return MbscOptionlistModule;
}());

// ---

var Page = function Page(el, settings) {
  var cssClass = '',
      $elm = $$1(el),
      that = this,
      s = that.settings; // Call the parent constructor

  Base.call(this, el, settings, true);
  /**
   * Page initialization.
   */

  that._init = function () {
    var ctx = s.context,
        $ctx = $$1(ctx),
        $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
        $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
        css = {};

    if (ctx == 'body') {
      $$1('body,html').addClass('mbsc-page-ctx');
    } else {
      $ctx.addClass('mbsc-page-ctx');
    }

    if (cssClass) {
      $elm.removeClass(cssClass);
    }

    if ($topMenu.length) {
      css.paddingTop = $topMenu[0].offsetHeight;
    }

    if ($bottomMenu.length) {
      css.paddingBottom = $bottomMenu[0].offsetHeight;
    }

    cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
    $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
  };
  /**
   * Destroys the mobiscroll instance.
   */


  that._destroy = function () {
    $elm.removeClass(cssClass);
  }; // Constructor


  s = that.settings;
  that.init();
}; // Extend defaults

Page.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _class: 'page',
  _defaults: {
    context: 'body'
  }
};
classes.Page = Page;
mobiscroll.themes.page.mobiscroll = {}; // ---
// Page end
// Init mbsc-page elements on page load or when mbsc-enhance event is triggeres

autoInit('[mbsc-page]', Page);

var MbscPage = (function (_super) {
    __extends(MbscPage, _super);
    function MbscPage(hostElement, optionsService, zone) {
        var _this = _super.call(this, hostElement, zone) || this;
        _this.optionsService = optionsService;
        return _this;
    }
    MbscPage.prototype.ngOnInit = function () {
        var optionsObj = extend$1({}, this.options, this.inlineOptionsObj);
        this.optionsService.options = optionsObj;
    };
    MbscPage.prototype.initControl = function () {
        var options = extend$1({}, this.options, this.inlineOptionsObj);
        this.instance = new Page(this.initElem.nativeElement, options);
    };
    MbscPage.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, },
        { type: NgZone, },
    ]; };
    MbscPage.propDecorators = {
        'options': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'initElem': [{ type: ViewChild, args: ['initElement', { static: false },] },],
    };
MbscPage.ɵfac = function MbscPage_Factory(t) { return new (t || MbscPage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscPage.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscPage, selectors: [["mbsc-page"]], viewQuery: function MbscPage_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.initElem = _t.first);
    } }, inputs: { options: "options", context: "context" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscOptionsService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 3, vars: 0, consts: [["initElement", ""]], template: function MbscPage_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscPage, [{
        type: Component,
        args: [{
                selector: 'mbsc-page',
                template: '<div #initElement><ng-content></ng-content></div>',
                providers: [MbscOptionsService],
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService }, { type: ɵngcc0.NgZone }]; }, { options: [{
            type: Input$1
        }], context: [{
            type: Input$1
        }], initElem: [{
            type: ViewChild,
            args: ['initElement', { static: false }]
        }] }); })();
    return MbscPage;
}(MbscBase));
var MbscNote = (function () {
    function MbscNote(initialElem) {
        this.initialElem = initialElem;
        this.color = 'primary';
    }
    Object.defineProperty(MbscNote.prototype, "classNames", {
        get: function () {
            return 'mbsc-note mbsc-note-' + this.color;
        },
        enumerable: true,
        configurable: true
    });
    MbscNote.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MbscNote.propDecorators = {
        'color': [{ type: Input$1 },],
    };
MbscNote.ɵfac = function MbscNote_Factory(t) { return new (t || MbscNote)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MbscNote.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscNote, selectors: [["mbsc-note"]], hostVars: 2, hostBindings: function MbscNote_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.classNames);
    } }, inputs: { color: "color" }, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscNote_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] { display: block; }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscNote, [{
        type: Component,
        args: [{
                selector: 'mbsc-note',
                template: '<ng-content></ng-content>',
                host: {
                    '[class]': 'classNames'
                },
                styles: [':host { display: block; }']
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { color: [{
            type: Input$1
        }] }); })();
    return MbscNote;
}());
var MbscAvatar = (function () {
    function MbscAvatar() {
        this.draggable = false;
    }
    MbscAvatar.ctorParameters = function () { return []; };
    MbscAvatar.propDecorators = {
        'draggable': [{ type: Input$1 },],
        'src': [{ type: Input$1 },],
        'alt': [{ type: Input$1 },],
    };
MbscAvatar.ɵfac = function MbscAvatar_Factory(t) { return new (t || MbscAvatar)(); };
MbscAvatar.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscAvatar, selectors: [["mbsc-avatar"]], inputs: { draggable: "draggable", src: "src", alt: "alt" }, decls: 1, vars: 3, consts: [[1, "mbsc-avatar", 3, "src", "alt", "draggable"]], template: function MbscAvatar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "img", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("src", ctx.src, ɵngcc0.ɵɵsanitizeUrl)("alt", ctx.alt)("draggable", ctx.draggable);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscAvatar, [{
        type: Component,
        args: [{
                selector: 'mbsc-avatar',
                template: '<img class="mbsc-avatar" [src]="src" [alt]="alt" [draggable]="draggable" />'
            }]
    }], function () { return []; }, { draggable: [{
            type: Input$1
        }], src: [{
            type: Input$1
        }], alt: [{
            type: Input$1
        }] }); })();
    return MbscAvatar;
}());
var MbscPageModule = (function () {
    function MbscPageModule() {
    }
    MbscPageModule.ctorParameters = function () { return []; };
MbscPageModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscPageModule });
MbscPageModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscPageModule_Factory(t) { return new (t || MbscPageModule)(); }, imports: [[MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscPageModule, { declarations: [MbscPage, MbscNote, MbscAvatar], imports: [MbscBaseModule], exports: [MbscPage, MbscNote, MbscAvatar] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscPageModule, [{
        type: NgModule,
        args: [{
                imports: [MbscBaseModule],
                declarations: [MbscPage, MbscNote, MbscAvatar],
                exports: [MbscPage, MbscNote, MbscAvatar]
            }]
    }], function () { return []; }, null); })();
    return MbscPageModule;
}());

var MbscPopup = (function (_super) {
    __extends(MbscPopup, _super);
    function MbscPopup(initialElem, optionService, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.optionService = optionService;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onDestroy = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        _this.onSet = new EventEmitter();
        return _this;
    }
    MbscPopup.prototype.ngAfterViewInit = function () {
        this.getInlineEvents();
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);
        this.instance = new Popup(this.initialElem.nativeElement, options);
    };
    MbscPopup.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: NgZone, },
    ]; };
    MbscPopup.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
        'anchor': [{ type: Input$1 },],
        'animate': [{ type: Input$1 },],
        'buttons': [{ type: Input$1 },],
        'closeOnOverlayTap': [{ type: Input$1 },],
        'context': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'display': [{ type: Input$1 },],
        'focusOnClose': [{ type: Input$1 },],
        'focusTrap': [{ type: Input$1 },],
        'headerText': [{ type: Input$1 },],
        'showOnFocus': [{ type: Input$1 },],
        'showOnTap': [{ type: Input$1 },],
        'touchUi': [{ type: Input$1 },],
        'okText': [{ type: Input$1 },],
        'cancelText': [{ type: Input$1 },],
        'onBeforeClose': [{ type: Output },],
        'onBeforeShow': [{ type: Output },],
        'onCancel': [{ type: Output },],
        'onClose': [{ type: Output },],
        'onDestroy': [{ type: Output },],
        'onFill': [{ type: Output },],
        'onMarkupReady': [{ type: Output },],
        'onPosition': [{ type: Output },],
        'onShow': [{ type: Output },],
        'onSet': [{ type: Output },],
    };
MbscPopup.ɵfac = function MbscPopup_Factory(t) { return new (t || MbscPopup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MbscPopup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscPopup, selectors: [["mbsc-popup"]], hostAttrs: [1, "mbsc-cloak"], inputs: { options: "options", anchor: "anchor", animate: "animate", buttons: "buttons", closeOnOverlayTap: "closeOnOverlayTap", context: "context", disabled: "disabled", display: "display", focusOnClose: "focusOnClose", focusTrap: "focusTrap", headerText: "headerText", showOnFocus: "showOnFocus", showOnTap: "showOnTap", touchUi: "touchUi", okText: "okText", cancelText: "cancelText" }, outputs: { onBeforeClose: "onBeforeClose", onBeforeShow: "onBeforeShow", onCancel: "onCancel", onClose: "onClose", onDestroy: "onDestroy", onFill: "onFill", onMarkupReady: "onMarkupReady", onPosition: "onPosition", onShow: "onShow", onSet: "onSet" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscPopup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscPopup, [{
        type: Component,
        args: [{
                selector: 'mbsc-popup',
                template: "<ng-content></ng-content>",
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.NgZone }]; }, { options: [{
            type: Input$1,
            args: ['options']
        }], anchor: [{
            type: Input$1
        }], animate: [{
            type: Input$1
        }], buttons: [{
            type: Input$1
        }], closeOnOverlayTap: [{
            type: Input$1
        }], context: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], display: [{
            type: Input$1
        }], focusOnClose: [{
            type: Input$1
        }], focusTrap: [{
            type: Input$1
        }], headerText: [{
            type: Input$1
        }], showOnFocus: [{
            type: Input$1
        }], showOnTap: [{
            type: Input$1
        }], touchUi: [{
            type: Input$1
        }], okText: [{
            type: Input$1
        }], cancelText: [{
            type: Input$1
        }], onBeforeClose: [{
            type: Output
        }], onBeforeShow: [{
            type: Output
        }], onCancel: [{
            type: Output
        }], onClose: [{
            type: Output
        }], onDestroy: [{
            type: Output
        }], onFill: [{
            type: Output
        }], onMarkupReady: [{
            type: Output
        }], onPosition: [{
            type: Output
        }], onShow: [{
            type: Output
        }], onSet: [{
            type: Output
        }] }); })();
    return MbscPopup;
}(MbscBase));
var MbscWidget = (function (_super) {
    __extends(MbscWidget, _super);
    function MbscWidget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MbscWidget.ctorParameters = function () { return []; };
MbscWidget.ɵfac = function MbscWidget_Factory(t) { return ɵMbscWidget_BaseFactory(t || MbscWidget); };
MbscWidget.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscWidget, selectors: [["mbsc-widget"]], hostAttrs: [1, "mbsc-cloak"], exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscWidget_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
var ɵMbscWidget_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(MbscWidget);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscWidget, [{
        type: Component,
        args: [{
                selector: 'mbsc-widget',
                template: "<ng-content></ng-content>",
                exportAs: 'mobiscroll',
                host: { 'class': 'mbsc-cloak' }
            }]
    }], null, null); })();
    return MbscWidget;
}(MbscPopup));
var MbscPopupModule = (function () {
    function MbscPopupModule() {
    }
    MbscPopupModule.ctorParameters = function () { return []; };
MbscPopupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscPopupModule });
MbscPopupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscPopupModule_Factory(t) { return new (t || MbscPopupModule)(); }, imports: [[MbscBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscPopupModule, { declarations: [MbscPopup, MbscWidget], imports: [MbscBaseModule], exports: [MbscPopup, MbscWidget] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscPopupModule, [{
        type: NgModule,
        args: [{
                imports: [MbscBaseModule],
                declarations: [MbscPopup, MbscWidget],
                exports: [MbscPopup, MbscWidget]
            }]
    }], function () { return []; }, null); })();
    return MbscPopupModule;
}());

var RangePicker = Scroller;
var defaults$c = {
  autoCorrect: true,
  showSelector: true,
  minRange: 1,
  rangeTap: true
};

presets.range = function (inst) {
  // Private functions
  // ---
  function normalize(d, ref) {
    if (d) {
      d.setFullYear(ref.getFullYear());
      d.setMonth(ref.getMonth());
      d.setDate(ref.getDate());
    }
  }

  function normalizeTime(date, isEnd) {
    var o = inst._order,
        d = new Date(date);

    if (o.h === undefined) {
      d.setHours(isEnd ? 23 : 0);
    }

    if (o.i === undefined) {
      d.setMinutes(isEnd ? 59 : 0);
    }

    if (o.s === undefined) {
      d.setSeconds(isEnd ? 59 : 0);
    }

    d.setMilliseconds(isEnd ? 999 : 0);
    return d;
  }

  function updateInputs(change) {
    inst._startDate = startDate = tempStartDate;
    inst._endDate = endDate = tempEndDate;

    if (s.startInput) {
      $$1(s.startInput).val(inst.startVal);

      if (change) {
        $$1(s.startInput).trigger('change');
      }
    }

    if (s.endInput) {
      $$1(s.endInput).val(inst.endVal);

      if (change) {
        $$1(s.endInput).trigger('change');
      }
    }
  }

  function addDays(d, days) {
    return new Date(d.getFullYear(), d.getMonth(), d.getDate() + days);
  }

  function checkRangeSize(curr) {
    if (hasTime) {
      // Check exact times in milliseconds for min and max ranges
      if (tempEndDate - tempStartDate > s.maxRange - 1) {
        if (curr) {
          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.maxRange + 1));
        } else {
          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.maxRange - 1));
        }
      }

      if (tempEndDate - tempStartDate < s.minRange - 1) {
        if (curr) {
          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.minRange + 1));
        } else {
          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.minRange - 1));
        }
      }
    } else {
      // Work with days only, not milliseconds. This way daylight saving times are handled
      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) > maxDays) {
        if (curr) {
          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - maxDays)), false);
        } else {
          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, maxDays - 1)), true);
        }
      }

      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) < minDays) {
        if (curr) {
          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - minDays)), false);
        } else {
          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, minDays - 1)), true);
        }
      }
    }
  }

  function validate(dates, ui) {
    var ret = true;

    if (dates && tempStartDate && tempEndDate) {
      // We need to check this 2 times, because the
      // corrected range is constrained by min/max dates
      checkRangeSize(curr);
      checkRangeSize(!curr);
    }

    if (!tempStartDate || !tempEndDate) {
      ret = false;
    }

    if (ui) {
      highlightDays();
    }

    return ret;
  }

  function calcDayNr() {
    return tempStartDate && tempEndDate ? Math.max(1, Math.round((new Date(tempEndDate).setHours(0, 0, 0, 0) - new Date(tempStartDate).setHours(0, 0, 0, 0)) / 86400000) + 1) : 0;
  }

  function selectTab(tab) {
    tab.addClass(selectedClass).attr('aria-checked', 'true');
  }

  function setActiveTab() {
    if (showSelector && ctx) {
      $$1('.mbsc-range-btn', ctx).removeClass(selectedClass).removeAttr('aria-checked');
      selectTab($$1('.mbsc-range-btn', ctx).eq(curr));
    }
  }

  function highlightDays() {
    var start,
        startT,
        end,
        endT,
        hl,
        nr = 0,
        startClass = autoChange || !curr ? ' mbsc-cal-day-hl mbsc-cal-sel-start' : ' mbsc-cal-sel-start',
        endClass = autoChange || curr ? ' mbsc-cal-day-hl mbsc-cal-sel-end' : ' mbsc-cal-sel-end';
    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';

    if (ctx) {
      $$1('.mbsc-range-btn-v-start', ctx).html(inst.startVal || '&nbsp;');
      $$1('.mbsc-range-btn-v-end', ctx).html(inst.endVal || '&nbsp;'); // Highlight dates

      start = tempStartDate ? new Date(tempStartDate) : null;
      end = tempEndDate ? new Date(tempEndDate) : null;

      if (!start && end) {
        start = new Date(end);
      }

      if (!end && start) {
        end = new Date(start);
      }

      hl = curr ? end : start;
      $$1('.mbsc-cal-day-picker .mbsc-cal-day-hl', ctx).removeClass(highlightClass);
      $$1('.mbsc-cal-day-picker .mbsc-selected', ctx).removeClass('mbsc-cal-sel-start mbsc-cal-sel-end ' + selectedClass).removeAttr('aria-selected');

      if (start && end) {
        startT = start.setHours(0, 0, 0, 0);
        endT = end.setHours(0, 0, 0, 0);

        while (end >= start && nr < 126) {
          $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(selectedClass + ' ' + (hl.getTime() === startT ? startClass : '') + (hl.getTime() === endT ? endClass : '')).attr('aria-selected', 'true');
          hl.setDate(hl.getDate() + (curr ? -1 : 1));
          hl.setHours(0, 0, 0, 0);
          nr++;
        }
      }
    }
  }

  function setTimeInfo(d, end) {
    return {
      h: d ? d.getHours() : end ? 23 : 0,
      i: d ? d.getMinutes() : end ? 59 : 0,
      s: d ? d.getSeconds() : end ? 59 : 0
    };
  }

  function validateDates() {
    if (tempStartDate) {
      init = true;
      inst.setDate(tempStartDate, false, 0, true);
      tempStartDate = inst.getDate(true);
    }

    if (tempEndDate) {
      init = true;
      inst.setDate(tempEndDate, false, 0, true);
      tempEndDate = inst.getDate(true);
    }
  }

  function onBtnClick(ev) {
    if (testTouch(ev, this)) {
      inst._showDayPicker();

      inst.setActiveDate($$1(this).attr('data-select'));
    }
  } // ---


  var base,
      ctx,
      dayChange,
      format,
      hasTime,
      init,
      maxDate,
      minDate,
      set,
      tempStartDate,
      tempStartTime,
      tempEndDate,
      tempEndTime,
      timeOnly,
      showSelector,
      startDate = inst._startDate,
      endDate = inst._endDate,
      curr = 0,
      now = new Date(),
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$c, orig),
      startAnchor = s.anchor,
      autoChange = s.rangeTap,
      oneDay = 24 * 60 * 60 * 1000,
      minDays = Math.max(1, Math.ceil(s.minRange / oneDay)),
      maxDays = Math.max(1, Math.ceil(s.maxRange / oneDay)),
      disabledClass = 'mbsc-disabled ' + (s.disabledClass || ''),
      selectedClass = 'mbsc-selected ' + (s.selectedClass || ''),
      highlightClass = 'mbsc-cal-day-hl',
      def = s.defaultValue === null ? [] : s.defaultValue || [new Date(now.setHours(0, 0, 0, 0)), new Date(now.getFullYear(), now.getMonth(), now.getDate() + 6, 23, 59, 59, 999)];

  if (autoChange) {
    s.tabs = true;
  }

  base = CalendarBase.call(this, inst);
  format = inst._format;
  hasTime = /time/i.test(s.controls.join(','));
  timeOnly = s.controls.join('') === 'time';
  showSelector = s.showSelector;
  maxDate = s.max ? normalizeTime(makeDate(s.max, format, s), true) : Infinity;
  minDate = s.min ? normalizeTime(makeDate(s.min, format, s), false) : -Infinity;
  def[0] = makeDate(def[0], format, s, s.isoParts);
  def[1] = makeDate(def[1], format, s, s.isoParts);

  if (s.startInput) {
    inst.attachShow($$1(s.startInput), function () {
      curr = 0;
      s.anchor = startAnchor || $$1(s.startInput);
    });
  }

  if (s.endInput) {
    inst.attachShow($$1(s.endInput), function () {
      curr = 1;
      s.anchor = startAnchor || $$1(s.endInput);
    });
  }

  inst._getDayProps = function (d, props) {
    var start = tempStartDate ? new Date(tempStartDate.getFullYear(), tempStartDate.getMonth(), tempStartDate.getDate()) : null,
        end = tempEndDate ? new Date(tempEndDate.getFullYear(), tempEndDate.getMonth(), tempEndDate.getDate()) : null;
    return {
      selected: start && end && d >= start && d <= tempEndDate,
      cssClass: props.cssClass + ' ' + ((autoChange || !curr) && start && start.getTime() === d.getTime() || (autoChange || curr) && end && end.getTime() === d.getTime() ? highlightClass : '') + (start && start.getTime() === d.getTime() ? ' mbsc-cal-sel-start' : '') + (end && end.getTime() === d.getTime() ? ' mbsc-cal-sel-end' : '')
    };
  }; // Extended methods
  // ---


  inst.setVal = function (values, fill, change, temp, time) {
    var v = values || [],
        d = values;
    tempStartDate = makeDate(v[0], format, s, s.isoParts);
    tempEndDate = makeDate(v[1], format, s, s.isoParts);
    validateDates();
    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';
    d = base.parseValue(curr ? tempEndDate : tempStartDate, inst);

    if (!temp) {
      inst._startDate = startDate = tempStartDate;
      inst._endDate = endDate = tempEndDate;
    }

    set = true;

    inst._setVal(d, fill, change, temp, time);
  };

  inst.getVal = function (temp) {
    return temp ? [returnDate(tempStartDate, s, format), returnDate(tempEndDate, s, format)] : inst._hasValue ? [returnDate(startDate, s, format), returnDate(endDate, s, format)] : null;
  };

  inst.setActiveDate = function (active) {
    var hl; //if (!autoChange) {

    curr = active == 'start' ? 0 : 1; //}

    hl = active == 'start' ? tempStartDate : tempEndDate;

    if (inst.isVisible()) {
      //if (!autoChange) {
      setActiveTab();

      if (!autoChange) {
        $$1('.mbsc-cal-table .mbsc-cal-day-hl', ctx).removeClass(highlightClass);

        if (hl) {
          $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(highlightClass);
        }
      }

      if (hl) {
        init = true;
        inst.setDate(hl, false, 1000, true);
      }
    }
  };

  inst.getValue = inst.getVal; // ---
  // ---

  return extend$1({}, base, {
    highlight: false,
    outerMonthChange: false,
    formatValue: function formatValue() {
      return inst.startVal + (s.endInput ? '' : inst.endVal ? ' - ' + inst.endVal : '');
    },
    parseValue: function parseValue(v) {
      var parts = v ? v.split(' - ') : [],
          startVal = s.startInput ? $$1(s.startInput).val() : parts[0],
          endVal = s.endInput ? $$1(s.endInput).val() : parts[1];
      s.defaultValue = def[1]; // used by parseDate

      endDate = endVal ? parseDate(format, endVal, s) : def[1];
      s.defaultValue = def[0]; // used by parseDate

      startDate = startVal ? parseDate(format, startVal, s) : def[2];
      s.defaultValue = def[curr];
      inst.startVal = startDate ? formatDate(format, startDate, s) : '';
      inst.endVal = endDate ? formatDate(format, endDate, s) : '';
      inst._startDate = startDate;
      inst._endDate = endDate;
      return base.parseValue(curr ? endDate : startDate, inst);
    },
    onFill: function onFill(ev) {
      updateInputs(ev.change);
    },
    onBeforeClose: function onBeforeClose(ev) {
      // Don't allow invalid selection
      if (ev.button === 'set' && !validate(true, true)) {
        inst.setActiveDate(curr ? 'start' : 'end');
        return false;
      }
    },
    onHide: function onHide() {
      base.onHide.call(inst);
      curr = 0;
      ctx = null;
      s.anchor = startAnchor;
    },
    onClear: function onClear() {
      if (autoChange) {
        curr = 0;
      }
    },
    onBeforeShow: function onBeforeShow() {
      tempStartDate = startDate || def[0];
      tempEndDate = endDate || def[1];
      tempStartTime = setTimeInfo(tempStartDate, 0);
      tempEndTime = setTimeInfo(tempEndDate, 1);

      if (s.counter) {
        s.headerText = function () {
          var nr = calcDayNr();
          return (nr > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, nr);
        };
      }

      set = true;
    },
    onMarkupReady: function onMarkupReady(ev) {
      var html; // Validate start end end dates

      validateDates(); // Set the current date (start or end)

      if (curr && tempEndDate || !curr && tempStartDate) {
        init = true;
        inst.setDate(curr ? tempEndDate : tempStartDate, false, 0, true);
      }

      highlightDays(); // Call calbase

      base.onMarkupReady.call(this, ev);
      ctx = $$1(ev.target);
      ctx.addClass('mbsc-range');

      if (showSelector) {
        html = '<div class="mbsc-range-btn-t" role="radiogroup">' + '<div class="mbsc-range-btn-c mbsc-range-btn-start"><div role="radio" data-select="start" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.fromText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-start">' + (inst.startVal || '&nbsp;') + '</div></div></div>' + '<div class="mbsc-range-btn-c mbsc-range-btn-end"><div role="radio" data-select="end" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.toText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-end">' + (inst.endVal || '&nbsp;') + '</div></div></div>' + '</div>';

        if (s.headerText) {
          $$1('.mbsc-fr-hdr', ctx).after(html);
        } else {
          $$1('.mbsc-fr-w', ctx).prepend(html);
        }

        setActiveTab();
      }

      $$1('.mbsc-range-btn', ctx).each(function (i, el) {
        listen(el, 'touchstart', onBtnClick, {
          passive: true
        });
        listen(el, 'click', onBtnClick);
      });
    },
    onDayChange: function onDayChange(day) {
      day.active = curr ? 'end' : 'start';
      dayChange = true;
    },
    onSetDate: function onSetDate(day) {
      var d;

      if (!init) {
        d = normalizeTime(day.date, curr);

        if (!set || dayChange) {
          if (autoChange && dayChange) {
            if (curr == 1 && d < tempStartDate) {
              curr = 0;
            }

            if (curr) {
              d.setHours(tempEndTime.h, tempEndTime.i, tempEndTime.s, 999);
            } else {
              d.setHours(tempStartTime.h, tempStartTime.i, tempStartTime.s, 0);
            }
          }

          if (curr) {
            tempEndDate = new Date(d);
            tempEndTime = setTimeInfo(tempEndDate);
          } else {
            tempStartDate = new Date(d);
            tempStartTime = setTimeInfo(tempStartDate);
          } // Make sure times are on the same day for comparison


          if (timeOnly && s.autoCorrect) {
            normalize(tempStartDate, d);
            normalize(tempEndDate, d);
          } // Set end date on start selection if rangeTap is enabled


          if (autoChange && dayChange && !curr) {
            //tempEndDate = new Date(d.setHours(23, 59, 59, 999));
            tempEndDate = null;
          }
        }
      }

      if (timeOnly && !s.autoCorrect && tempEndDate < tempStartDate) {
        // Set end time to next day
        tempEndDate = new Date(tempEndDate.setDate(tempEndDate.getDate() + 1));
      } // Validate min/max ranges


      inst._isValid = validate(set || dayChange || s.autoCorrect, !init);
      day.active = curr ? 'end' : 'start'; // Toggle start/end if rangeTap is enabled

      if (!init && autoChange) {
        if (dayChange) {
          curr = curr ? 0 : 1;
        }

        setActiveTab();
      }

      if (inst.isVisible()) {
        // Disable set button
        if (inst._isValid) {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).removeClass(disabledClass);
        } else {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).addClass(disabledClass);
        }
      }

      dayChange = false;
      set = false;
      init = false;
    },
    onTabChange: function onTabChange(ev) {
      if (ev.tab != 'calendar') {
        inst.setDate(curr ? tempEndDate : tempStartDate, false, 1000, true);
      }

      validate(true, true);
    }
  });
};

var RANGE_SUB_TEMPLATE = "<mbsc-input\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\" \n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";
var MbscRangeStartComponent = (function () {
    function MbscRangeStartComponent(host, parent, zone, control) {
        this.host = host;
        this.parent = parent;
        this.zone = zone;
        this.control = control;
        this.theme = undefined;
        this.errorMessage = '';
        this.placeholder = '';
        this.rangeIndex = 0;
        this.oldAccessor = null;
        this.onChange = function (value) { };
        this.onTouch = function () { };
        this.initialSet = true;
        this.checkAccessor();
    }
    Object.defineProperty(MbscRangeStartComponent.prototype, "element", {
        get: function () {
            var i = $$1(this.host.nativeElement).find('input');
            return i[0];
        },
        enumerable: true,
        configurable: true
    });
    MbscRangeStartComponent.prototype.checkAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscRangeStartComponent.prototype.handleChange = function () {
        var _this = this;
        $$1(this.element).on('change', function () {
            _this.zone.run(function () {
                var arr = _this.parent.instance.getVal(), value = arr ? arr[_this.rangeIndex] : undefined, current = undefined, valueText = _this.parent.instance[_this.rangeIndex === 0 ? 'startVal' : 'endVal'];
                if (arr && value && _this.element.value !== valueText && _this.parent.enableManualEdit) {
                    var newArr = new Array(2), otherIndex = _this.rangeIndex === 1 ? 0 : 1;
                    newArr[_this.rangeIndex] = _this.element.value;
                    newArr[otherIndex] = arr[otherIndex];
                    _this.parent.instance.setVal(newArr, true, true);
                }
                else {
                    if (_this.control && _this.control.value && _this.control.value instanceof Array) {
                        current = _this.control.value[_this.rangeIndex];
                    }
                    else if (_this.control && _this.control.value) {
                        current = _this.control.value;
                    }
                    if (_this.control) {
                        if (!isDateEqual(current, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                }
            });
        });
    };
    MbscRangeStartComponent.prototype.ngAfterViewInit = function () {
        this.handleChange();
        this.checkAccessor();
    };
    MbscRangeStartComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscRangeStartComponent.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscRangeStartComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
    };
    MbscRangeStartComponent.prototype.writeValue = function (v) {
        var _this = this;
        if (this.parent && this.parent.instance) {
            var arr_1 = this.parent.instance.getVal(), val = (arr_1 && arr_1.length) ? arr_1[this.rangeIndex] : undefined;
            if (!isDateEqual(v, val)) {
                if (v === undefined) {
                    arr_1 = undefined;
                }
                else {
                    arr_1 = arr_1 || [];
                    arr_1[this.rangeIndex] = v;
                }
                this.parent.instance.setVal(arr_1, true, false);
                if (this.initialSet) {
                    setTimeout(function () {
                        _this.parent.instance.setVal(arr_1, true, false);
                        _this.initialSet = false;
                    });
                }
            }
        }
    };
    MbscRangeStartComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscRangeComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return MbscRangeComponent; }),] },] },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
    MbscRangeStartComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'disabled': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscRangeStartComponent.ɵfac = function MbscRangeStartComponent_Factory(t) { return new (t || MbscRangeStartComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(function () { return MbscRangeComponent; })), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscRangeStartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRangeStartComponent, selectors: [["mbsc-range-start"]], inputs: { errorMessage: "errorMessage", placeholder: "placeholder", disabled: "disabled", inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error" }, ngContentSelectors: _c1, decls: 2, vars: 9, consts: [[3, "controlNg", "name", "theme", "disabled", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscRangeStartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "mbsc-input", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx.name)("theme", ctx.theme)("disabled", ctx.disabled)("placeholder", ctx.placeholder)("error", ctx.error)("errorMessage", ctx.errorMessage)("icon", ctx.inputIcon)("icon-align", ctx.iconAlign);
    } }, directives: [MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRangeStartComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-range-start',
                template: RANGE_SUB_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscRangeComponent, decorators: [{
                type: Inject,
                args: [forwardRef(function () { return MbscRangeComponent; })]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, { errorMessage: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], disabled: [{
            type: Input$1
        }], inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }] }); })();
    return MbscRangeStartComponent;
}());
var MbscRangeEndComponent = (function (_super) {
    __extends(MbscRangeEndComponent, _super);
    function MbscRangeEndComponent(el, parent, zone, control) {
        var _this = _super.call(this, el, parent, zone, control) || this;
        _this.rangeIndex = 1;
        return _this;
    }
    MbscRangeEndComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscRangeComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return MbscRangeComponent; }),] },] },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
    ]; };
MbscRangeEndComponent.ɵfac = function MbscRangeEndComponent_Factory(t) { return new (t || MbscRangeEndComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(function () { return MbscRangeComponent; })), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8)); };
MbscRangeEndComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRangeEndComponent, selectors: [["mbsc-range-end"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 2, vars: 9, consts: [[3, "controlNg", "name", "theme", "disabled", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscRangeEndComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "mbsc-input", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("controlNg", false)("name", ctx.name)("theme", ctx.theme)("disabled", ctx.disabled)("placeholder", ctx.placeholder)("error", ctx.error)("errorMessage", ctx.errorMessage)("icon", ctx.inputIcon)("icon-align", ctx.iconAlign);
    } }, directives: [MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRangeEndComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-range-end',
                template: RANGE_SUB_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscRangeComponent, decorators: [{
                type: Inject,
                args: [forwardRef(function () { return MbscRangeComponent; })]
            }] }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }]; }, null); })();
    return MbscRangeEndComponent;
}(MbscRangeStartComponent));
var MbscRange = (function (_super) {
    __extends(MbscRange, _super);
    function MbscRange(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onSetDate = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscRange.prototype, "endInput", {
        set: function (v) {
            var element = v;
            if (typeof v == "string") {
                var hasInput = $$1(v).find('input');
                if (hasInput.length) {
                    element = hasInput[0];
                }
            }
            this._endInput = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRange.prototype, "startInput", {
        set: function (v) {
            var element = v;
            if (typeof v == "string") {
                var hasInput = $$1(v).find('input');
                if (hasInput.length) {
                    element = hasInput[0];
                }
            }
            this._startInput = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRange.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscRange.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (!deepEqualsArray(v, this.instance.getVal())) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    Object.defineProperty(MbscRange.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (!_this._wrapper) {
                        if (_this.oldAccessor) {
                            _this.oldAccessor.writeValue(event.valueText);
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MbscRange.prototype.initControl = function () {
        var options = extend$1({
            preset: 'range',
            skipShow: this._wrapper
        }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {
            endInput: this._wrapper ? this.end.element : this._endInput,
            startInput: this._wrapper ? this.start.element : this._startInput
        }, this.optionExtensions);
        this.instance = new RangePicker(this._wrapper ? this.initialElem.nativeElement : this.element, options);
        if (this.initialValue) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscRange.prototype.ngAfterContentInit = function () {
        if (this.start || this.end) {
            this._wrapper = true;
        }
        else {
            this._wrapper = false;
        }
    };
    MbscRange.prototype.handleChange = function () {
        var _this = this;
        if (this._wrapper) {
            $$1(this.start.element).on('change', function () {
                _this.zone.run(function () {
                    var value = _this.instance.getVal();
                    if (_this.control) {
                        if (!deepEqualsArray(_this.control.value, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                    else {
                        _this.onChangeEmitter.emit(value);
                    }
                });
            });
            $$1(this.end.element).on('change', function () {
                _this.zone.run(function () {
                    var value = _this.instance.getVal();
                    if (_this.control) {
                        if (!deepEqualsArray(_this.control.value, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                    else {
                        _this.onChangeEmitter.emit(value);
                    }
                });
            });
        }
        else {
            var that_1 = this;
            $$1(this.element).on('change', function () {
                that_1.zone.run(function () {
                    if (that_1.element.value !== that_1.instance._value && that_1.enableManualEdit) {
                        var v = that_1.element.value && that_1.element.value.split(' - ');
                        if (v) {
                            that_1.instance.setVal(v, true, true);
                        }
                    }
                    else {
                        var value = that_1.instance.getVal();
                        if (that_1.control) {
                            that_1.onChange(value);
                            that_1.control.control.patchValue(value);
                        }
                        else {
                            that_1.onChangeEmitter.emit(value);
                        }
                    }
                });
            });
        }
    };
    MbscRange.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscRange.propDecorators = {
        'autoCorrect': [{ type: Input$1 },],
        'controls': [{ type: Input$1 },],
        'endInput': [{ type: Input$1 },],
        'maxRange': [{ type: Input$1 },],
        'minRange': [{ type: Input$1 },],
        'showSelector': [{ type: Input$1 },],
        'startInput': [{ type: Input$1 },],
        'fromText': [{ type: Input$1 },],
        'toText': [{ type: Input$1 },],
        'onSetDate': [{ type: Output },],
        'onCellHoverIn': [{ type: Output },],
        'onCellHoverOut': [{ type: Output },],
        'onDayChange': [{ type: Output },],
        'start': [{ type: ContentChild, args: [MbscRangeStartComponent, { static: false },] },],
        'end': [{ type: ContentChild, args: [MbscRangeEndComponent, { static: false },] },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-range',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-rangeChange',] },],
    };
MbscRange.ɵfac = function MbscRange_Factory(t) { return new (t || MbscRange)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscRange.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscRange, selectors: [["", "mbsc-range", ""]], contentQueries: function MbscRange_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscRangeStartComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscRangeEndComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.start = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.end = _t.first);
    } }, inputs: { endInput: "endInput", startInput: "startInput", value: ["mbsc-range", "value"], autoCorrect: "autoCorrect", controls: "controls", maxRange: "maxRange", minRange: "minRange", showSelector: "showSelector", fromText: "fromText", toText: "toText", options: ["mbsc-options", "options"] }, outputs: { onSetDate: "onSetDate", onCellHoverIn: "onCellHoverIn", onCellHoverOut: "onCellHoverOut", onDayChange: "onDayChange", onChangeEmitter: "mbsc-rangeChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRange, [{
        type: Directive,
        args: [{
                selector: '[mbsc-range]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { endInput: [{
            type: Input$1
        }], startInput: [{
            type: Input$1
        }], value: [{
            type: Input$1,
            args: ['mbsc-range']
        }], autoCorrect: [{
            type: Input$1
        }], controls: [{
            type: Input$1
        }], maxRange: [{
            type: Input$1
        }], minRange: [{
            type: Input$1
        }], showSelector: [{
            type: Input$1
        }], fromText: [{
            type: Input$1
        }], toText: [{
            type: Input$1
        }], onSetDate: [{
            type: Output
        }], onCellHoverIn: [{
            type: Output
        }], onCellHoverOut: [{
            type: Output
        }], onDayChange: [{
            type: Output
        }], start: [{
            type: ContentChild,
            args: [MbscRangeStartComponent, { static: false }]
        }], end: [{
            type: ContentChild,
            args: [MbscRangeEndComponent, { static: false }]
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-rangeChange']
        }] }); })();
    return MbscRange;
}(MbscCalBase));
var MbscRangeComponent = (function (_super) {
    __extends(MbscRangeComponent, _super);
    function MbscRangeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscRangeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscRangeComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscRangeComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscRangeComponent.ɵfac = function MbscRangeComponent_Factory(t) { return new (t || MbscRangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscRangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscRangeComponent, selectors: [["mbsc-range"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c6, decls: 3, vars: 1, consts: [[3, "controlNg", "name", "theme", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscRangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵtemplate(2, MbscRangeComponent_mbsc_input_2_Template, 2, 10, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._wrapper && (!ctx.inline || ctx.showInput));
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRangeComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-range',
                exportAs: 'mobiscroll',
                template: "<ng-content select=\"mbsc-range-start\"></ng-content>\n    <ng-content select=\"mbsc-range-end\"></ng-content>\n    <mbsc-input *ngIf=\"!_wrapper && (!inline || showInput)\" \n        [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n        [error]=\"error\" [errorMessage]=\"errorMessage\" \n        [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n        <ng-content></ng-content>\n    </mbsc-input>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscRangeComponent;
}(MbscRange));
var MbscRangeModule = (function () {
    function MbscRangeModule() {
    }
    MbscRangeModule.ctorParameters = function () { return []; };
MbscRangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscRangeModule });
MbscRangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscRangeModule_Factory(t) { return new (t || MbscRangeModule)(); }, imports: [[CommonModule, MbscCalBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscRangeModule, { declarations: function () { return [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent]; }, imports: function () { return [CommonModule, MbscCalBaseModule, MbscInputModule]; }, exports: function () { return [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscRangeModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscCalBaseModule, MbscInputModule],
                declarations: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent],
                exports: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscRangeModule;
}());

var MbscScroller = (function (_super) {
    __extends(MbscScroller, _super);
    function MbscScroller(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscScroller.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscScroller.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscScroller.prototype.initControl = function () {
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Scroller(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscScroller.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscScroller.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-scroller',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-scrollerChange',] },],
    };
MbscScroller.ɵfac = function MbscScroller_Factory(t) { return new (t || MbscScroller)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscScroller.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScroller, selectors: [["", "mbsc-scroller", ""]], inputs: { value: ["mbsc-scroller", "value"], options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-scrollerChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScroller, [{
        type: Directive,
        args: [{
                selector: '[mbsc-scroller]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-scroller']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-scrollerChange']
        }] }); })();
    return MbscScroller;
}(MbscScrollerBase));
var MbscScrollerComponent = (function (_super) {
    __extends(MbscScrollerComponent, _super);
    function MbscScrollerComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscScrollerComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscScrollerComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscScrollerComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscScrollerComponent.ɵfac = function MbscScrollerComponent_Factory(t) { return new (t || MbscScrollerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscScrollerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscScrollerComponent, selectors: [["mbsc-scroller"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscScrollerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscScrollerComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollerComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-scroller',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscScrollerComponent;
}(MbscScroller));
var MbscScrollerModule = (function () {
    function MbscScrollerModule() {
    }
    MbscScrollerModule.ctorParameters = function () { return []; };
MbscScrollerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscScrollerModule });
MbscScrollerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscScrollerModule_Factory(t) { return new (t || MbscScrollerModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollerModule, { declarations: function () { return [MbscScroller, MbscScrollerComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscScroller, MbscScrollerComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollerModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscScroller, MbscScrollerComponent],
                exports: [MbscScroller, MbscScrollerComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscScrollerModule;
}());

var MbscScrollView = (function (_super) {
    __extends(MbscScrollView, _super);
    function MbscScrollView(initialElem, zone, notifyItemService, optionService) {
        var _this = _super.call(this, initialElem, zone, notifyItemService) || this;
        _this.optionService = optionService;
        return _this;
    }
    MbscScrollView.prototype.initControl = function () {
        var _this = this;
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);
        this.instance = new ScrollView(this.initialElem.nativeElement, options);
        this.notifyItemService.notifyInstanceReady(this.instance);
        this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {
            _this.instance.refresh();
        });
    };
    MbscScrollView.prototype.ngOnDestroy = function () {
        this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    MbscScrollView.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscScrollView.propDecorators = {
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
    };
MbscScrollView.ɵfac = function MbscScrollView_Factory(t) { return new (t || MbscScrollView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscScrollView.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScrollView, selectors: [["", "mbsc-scrollview", ""]], hostAttrs: [1, "mbsc-cloak"], inputs: { options: ["mbsc-options", "options"] }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollView, [{
        type: Directive,
        args: [{
                selector: '[mbsc-scrollview]',
                exportAs: 'mobiscroll',
                providers: [MbscNotifyItemService],
                host: { 'class': 'mbsc-cloak' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { options: [{
            type: Input$1,
            args: ['mbsc-options']
        }] }); })();
    return MbscScrollView;
}(MbscScrollViewBase));
var MbscScrollViewItem = (function (_super) {
    __extends(MbscScrollViewItem, _super);
    function MbscScrollViewItem(initialElem, notifyItemService) {
        return _super.call(this, notifyItemService, initialElem) || this;
    }
    MbscScrollViewItem.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscNotifyItemService, },
    ]; };
MbscScrollViewItem.ɵfac = function MbscScrollViewItem_Factory(t) { return new (t || MbscScrollViewItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService)); };
MbscScrollViewItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscScrollViewItem, selectors: [["", "mbsc-scrollview-item", ""]], hostVars: 1, hostBindings: function MbscScrollViewItem_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-id", ctx.id);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewItem, [{
        type: Directive,
        args: [{
                selector: '[mbsc-scrollview-item]',
                host: {
                    '[attr.data-id]': 'id'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscNotifyItemService }]; }, null); })();
    return MbscScrollViewItem;
}(MbscScrollItemBase));
var MbscScrollViewComponent = (function (_super) {
    __extends(MbscScrollViewComponent, _super);
    function MbscScrollViewComponent(initialElem, zone, notifyItemService, optionService) {
        return _super.call(this, initialElem, zone, notifyItemService, optionService) || this;
    }
    MbscScrollViewComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: MbscNotifyItemService, },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscScrollViewComponent.propDecorators = {
        'options': [{ type: Input$1, args: ['options',] },],
    };
MbscScrollViewComponent.ɵfac = function MbscScrollViewComponent_Factory(t) { return new (t || MbscScrollViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscScrollViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscScrollViewComponent, selectors: [["mbsc-scrollview"]], inputs: { options: "options" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscScrollViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-scrollview',
                exportAs: 'mobiscroll',
                template: "<ng-content></ng-content>",
                providers: [MbscNotifyItemService]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: MbscNotifyItemService }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { options: [{
            type: Input$1,
            args: ['options']
        }] }); })();
    return MbscScrollViewComponent;
}(MbscScrollView));
var MbscScrollViewItemComponent = (function (_super) {
    __extends(MbscScrollViewItemComponent, _super);
    function MbscScrollViewItemComponent(initialElem, notifyItemService) {
        return _super.call(this, initialElem, notifyItemService) || this;
    }
    MbscScrollViewItemComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: MbscNotifyItemService, },
    ]; };
MbscScrollViewItemComponent.ɵfac = function MbscScrollViewItemComponent_Factory(t) { return new (t || MbscScrollViewItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService)); };
MbscScrollViewItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscScrollViewItemComponent, selectors: [["mbsc-scrollview-item"]], hostVars: 1, hostBindings: function MbscScrollViewItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-id", ctx.id);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function MbscScrollViewItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewItemComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-scrollview-item',
                template: '<ng-content></ng-content>',
                host: {
                    '[attr.data-id]': 'id'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MbscNotifyItemService }]; }, null); })();
    return MbscScrollViewItemComponent;
}(MbscScrollViewItem));
var MbscScrollViewModule = (function () {
    function MbscScrollViewModule() {
    }
    MbscScrollViewModule.ctorParameters = function () { return []; };
MbscScrollViewModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscScrollViewModule });
MbscScrollViewModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscScrollViewModule_Factory(t) { return new (t || MbscScrollViewModule)(); }, imports: [[MbscScrollViewBaseModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollViewModule, { declarations: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent], imports: [MbscScrollViewBaseModule], exports: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscScrollViewModule, [{
        type: NgModule,
        args: [{
                imports: [MbscScrollViewBaseModule],
                declarations: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent],
                exports: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscScrollViewModule;
}());

var Select$1 = Scroller;
var defaults$d = {
  inputClass: '',
  rtl: false,
  showInput: true,
  groupLabel: 'Groups',
  dataHtml: 'html',
  dataText: 'text',
  dataValue: 'value',
  dataGroup: 'group',
  dataDisabled: 'disabled',
  filterPlaceholderText: 'Type to filter',
  filterEmptyText: 'No results',
  filterClearIcon: 'material-close'
};

presets.select = function (inst, settings) {
  var $input,
      dataArray,
      filterLength,
      filterText,
      group,
      groupArray,
      groupWheel,
      groups,
      groupWheelIdx,
      hasRemoteData,
      option,
      optionArray,
      optionWheel,
      optionWheelIdx,
      prevent,
      defaultValue = '',
      selectedTexts = {},
      animTime = 1000,
      elm = this,
      $elm = $$1(elm),
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$d, orig),
      $filterEmpty = $$1('<div class="mbsc-sel-empty">' + s.filterEmptyText + '</div>'),
      origReadOnly = s.readonly,
      options = {},
      layout = s.layout || (/top|bottom|inline/.test(s.display) || s.filter ? 'liquid' : ''),
      isLiquid = layout == 'liquid' || !s.touchUi,
      multiple = isNumeric(s.select) ? s.select : s.select == 'multiple' || $elm.prop('multiple'),
      tapSelect = multiple || (s.filter || s.tapSelect ? 1 : false),
      id = this.id + '_dummy',
      lbl = $$1('label[for="' + this.id + '"]').attr('for', id),
      label = s.label !== undefined ? s.label : lbl.length ? lbl.text() : $elm.attr('name'),
      groupSetup = s.group,
      hasData = !!s.data,
      hasGroups = hasData ? !!s.group : $$1('optgroup', $elm).length,
      hasGroupWheel = hasGroups && groupSetup && groupSetup.groupWheel !== false,
      groupSep = hasGroups && groupSetup && hasGroupWheel && groupSetup.clustered === true,
      groupHdr = hasGroups && (!groupSetup || groupSetup.header !== false && !groupSep),
      values = $elm.val() || (multiple ? [] : ['']),
      invalid = [];

  function prepareData(filter) {
    var gr,
        html,
        lbl,
        opt,
        txt,
        val,
        l = 0,
        c = 0,
        groupIndexes = {};
    options = {};
    groups = {};
    optionArray = [];
    groupArray = []; // Reset invalids

    invalid.length = 0;

    if (hasData) {
      $$1.each(dataArray, function (i, v) {
        txt = v[s.dataText] + ''; // Convert to string

        html = v[s.dataHtml];
        val = v[s.dataValue];
        lbl = v[s.dataGroup];
        opt = {
          value: val,
          html: html,
          text: txt,
          index: i,
          cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''
        };
        options[val] = opt;

        if (!filter || matchesFilter(txt, filter)) {
          optionArray.push(opt);

          if (hasGroups) {
            if (groupIndexes[lbl] === undefined) {
              gr = {
                text: lbl,
                value: c,
                options: [],
                index: c
              };
              groups[c] = gr;
              groupIndexes[lbl] = c;
              groupArray.push(gr);
              c++;
            } else {
              gr = groups[groupIndexes[lbl]];
            }

            if (groupSep) {
              opt.index = gr.options.length;
            }

            opt.group = groupIndexes[lbl];
            gr.options.push(opt);
          }

          if (v[s.dataDisabled]) {
            invalid.push(val);
          }
        }
      });
    } else {
      if (hasGroups) {
        var addGroup = true;
        $$1('optgroup', $elm).each(function (i) {
          groups[i] = {
            text: this.label,
            value: i,
            options: [],
            index: i
          };
          addGroup = true;
          $$1('option', this).each(function (j) {
            opt = {
              value: this.value,
              text: this.text,
              index: groupSep ? j : l++,
              group: i,
              cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''
            };
            options[this.value] = opt;

            if (!filter || matchesFilter(this.text, filter)) {
              if (addGroup) {
                groupArray.push(groups[i]);
                addGroup = false;
              }

              optionArray.push(opt);
              groups[i].options.push(opt);

              if (this.disabled) {
                invalid.push(this.value);
              }
            }
          });
        });
      } else {
        $$1('option', $elm).each(function (i) {
          opt = {
            value: this.value,
            text: this.text,
            index: i
          };
          options[this.value] = opt;

          if (!filter || matchesFilter(this.text, filter)) {
            optionArray.push(opt);

            if (this.disabled) {
              invalid.push(this.value);
            }
          }
        });
      }
    }

    if (s.defaultValue) {
      defaultValue = s.defaultValue;
    } else if (optionArray.length) {
      defaultValue = optionArray[0].value;
    } else {
      defaultValue = '';
    }

    if (groupHdr) {
      optionArray = [];
      l = 0;
      $$1.each(groups, function (i, gr) {
        if (gr.options.length) {
          val = '__group' + i;
          opt = {
            text: gr.text,
            value: val,
            group: i,
            index: l++,
            cssClass: 'mbsc-sel-gr'
          };
          options[val] = opt;
          optionArray.push(opt);
          invalid.push(opt.value);
          $$1.each(gr.options, function (j, opt) {
            opt.index = l++;
            optionArray.push(opt);
          });
        }
      });
    }

    if ($filterEmpty) {
      if (optionArray.length) {
        $filterEmpty.removeClass('mbsc-sel-empty-v');
      } else {
        $filterEmpty.addClass('mbsc-sel-empty-v');
      }
    }
  }

  function genValues(data, tapSelect, label, multiple, cssClass) {
    var i,
        values = [];

    if (data) {
      for (i = 0; i < data.length; i++) {
        values.push({
          value: data[i].value,
          display: data[i].html || data[i].text,
          cssClass: data[i].cssClass
        });
      }
    }

    return {
      circular: false,
      multiple: tapSelect && !multiple ? 1 : multiple,
      cssClass: (tapSelect && !multiple ? 'mbsc-sel-one' : '') + ' ' + cssClass,
      data: values,
      label: label
    };
  }

  function genGroupWheel() {
    return genValues(groupArray, tapSelect, s.groupLabel, false, 'mbsc-sel-gr-whl');
  }

  function genOptWheel() {
    return genValues(groupSep && groups[group] ? groups[group].options : optionArray, tapSelect, label, multiple, '');
  }

  function genWheels() {
    var w = [[]];

    if (hasGroupWheel) {
      groupWheel = genGroupWheel();

      if (isLiquid) {
        w[0][groupWheelIdx] = groupWheel;
      } else {
        w[groupWheelIdx] = [groupWheel];
      }
    }

    optionWheel = genOptWheel();

    if (isLiquid) {
      w[0][optionWheelIdx] = optionWheel;
    } else {
      w[optionWheelIdx] = [optionWheel];
    }

    return w;
  }

  function getOption(v) {
    if (multiple) {
      if (v && isString(v)) {
        v = v.split(',');
      }

      if ($$1.isArray(v)) {
        v = v[0];
      }
    }

    option = v === undefined || v === null || v === '' ? defaultValue : v;

    if (!options[option] && optionArray && optionArray.length) {
      option = optionArray[0].value;
    }

    if (hasGroupWheel) {
      group = options[option] ? options[option].group : null;
    }
  }

  function getText(opt) {
    return selectedTexts[opt] || (options[opt] ? options[opt].text : '');
  }

  function formatValue(d, inst, fill) {
    var i,
        opt,
        sel = [],
        selected = fill ? inst._selected : inst._tempSelected;

    if (tapSelect) {
      for (i in selected[optionWheelIdx]) {
        sel.push(getText(i));
      }

      return sel.join(', ');
    }

    opt = d[optionWheelIdx];
    return getText(opt);
  }

  function onFill() {
    var i,
        html = '',
        val = inst.getVal(),
        txt = s.formatValue.call(elm, inst.getArrayVal(), inst, true);

    if (!(s.filter && s.display == 'inline')) {
      $input.val(txt);
    } // If we have a native select, but data was passed in setting,
    // create an option tag with the selected value


    if ($elm.is('select') && hasData) {
      if (multiple) {
        for (i = 0; i < val.length; i++) {
          html += '<option value="' + val[i] + '">' + getText(val[i]) + '</option>';
        }
      } else {
        html = '<option value="' + (val === null ? '' : val) + '">' + txt + '</option>';
      }

      $elm.html(html);
    }

    if (elm !== $input[0]) {
      // if the target is the same, we should not overwrite it
      $elm.val(val);
    }
  }

  function changeWheel() {
    var wheels = {};
    wheels[optionWheelIdx] = genOptWheel();
    prevent = true;
    inst.changeWheel(wheels);
  }

  function matchesFilter(str, filter) {
    filter = filter.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'); // escape the special characters

    return str.match(new RegExp(filter, 'ig'));
  }

  function getData(data) {
    return s.data.dataField ? data[s.data.dataField] : s.data.processResponse ? s.data.processResponse(data) : data;
  }

  function prepareWheels(filter) {
    var wheels = {};
    prepareData(filter);
    getOption(option);
    s.wheels = genWheels();
    wheels[optionWheelIdx] = optionWheel;
    inst._tempWheelArray[optionWheelIdx] = option;

    if (hasGroupWheel) {
      wheels[groupWheelIdx] = groupWheel;
      inst._tempWheelArray[groupWheelIdx] = group;
    }

    inst.changeWheel(wheels, 0, true);
    onFill();
  }

  function triggerOnFilter(value) {
    return inst.trigger('onFilter', {
      filterText: value
    });
  }

  function loadGroupOptions(values) {
    if (values[groupWheelIdx] != group) {
      group = values[groupWheelIdx];
      option = groups[group].options[0].value;
      values[optionWheelIdx] = option;

      if (groupSep) {
        changeWheel();
      } else {
        inst.setArrayVal(values, false, false, true, animTime);
      }
    }
  } // Extended methods
  // ---


  inst.setVal = function (val, fill, change, temp, time) {
    if (tapSelect) {
      if (val !== null && val !== undefined && !multiple) {
        val = [val];
      }

      if (val && isString(val)) {
        val = val.split(',');
      }

      inst._tempSelected[optionWheelIdx] = arrayToObject(val);

      if (!temp) {
        inst._selected[optionWheelIdx] = arrayToObject(val);
      }

      val = val ? val[0] : null;

      if (hasGroupWheel) {
        var opt = options[val],
            gr = opt && opt.group;
        inst._tempSelected[groupWheelIdx] = arrayToObject([gr]);

        if (!temp) {
          inst._selected[groupWheelIdx] = arrayToObject([gr]);
        }
      }
    }

    inst._setVal(val, fill, change, temp, time);
  };

  inst.getVal = function (temp, group) {
    var val;

    if (tapSelect) {
      val = objectToArray(temp ? inst._tempSelected[optionWheelIdx] : inst._selected[optionWheelIdx]);
      val = multiple ? val : val.length ? val[0] : null;
    } else {
      val = temp ? inst._tempWheelArray : inst._hasValue ? inst._wheelArray : null;
      val = val ? val[optionWheelIdx] : null;
    }

    return multiple ? val : val !== undefined ? hasGroups && group ? [options[val] ? options[val].group : null, val] : val : null;
  };

  inst.refresh = function (data, filter, callback) {
    callback = callback || noop;

    if (data) {
      dataArray = data;

      if (!hasRemoteData) {
        // Save data, otherwise it will get lost on an option call,
        // and filtering does not work as well after async data update
        s.data = data;
      }
    } else if ($$1.isArray(s.data)) {
      dataArray = s.data;
    }

    if (!data && hasRemoteData && filter === undefined) {
      // reload the data from remote source
      getJson(s.data.url, function (data) {
        dataArray = getData(data);
        prepareWheels();
        callback();
      }, s.data.dataType);
    } else {
      prepareWheels(filter);
      callback();
    }
  }; // ---
  // Inits
  // ---


  if (!settings.invalid) {
    s.invalid = invalid;
  }

  if (hasGroupWheel) {
    groupWheelIdx = 0;
    optionWheelIdx = 1;
  } else {
    groupWheelIdx = -1;
    optionWheelIdx = 0;
  }

  if (tapSelect) {
    if (multiple && $elm.is('select')) {
      $elm.prop('multiple', true);
    }

    if (values && isString(values)) {
      values = values.split(',');
    }

    inst._selected[optionWheelIdx] = arrayToObject(values);
  } // Remove dummy element if exists


  if (inst._$input) {
    inst._$input.remove();
  } // Check if mobiscroll form already initialized this select


  if ($elm.next().is('.mbsc-select-input')) {
    $input = $elm.next().removeAttr('tabindex');
  } else {
    if (s.input) {
      $input = $$1(s.input);
    } else {
      // Create dummy input
      if (s.filter && s.display == 'inline') {
        inst._$input = $$1('<div class="mbsc-sel-input-wrap"><input type="text" id="' + id + '" class="mbsc-select-input mbsc-control ' + s.inputClass + '" readonly /></div>');
      } else {
        $input = $$1('<input type="text" id="' + id + '" class="mbsc-select-input mbsc-control ' + s.inputClass + '" readonly />');
        inst._$input = $input;
      }

      if (s.showInput) {
        inst._$input.insertAfter($elm);

        if (!$input) {
          $input = inst._$input.find('#' + id);
        }
      }
    }
  } // Show scroller on input tap


  inst.attachShow($input.attr('placeholder', s.placeholder || ''));

  if ($input[0] !== elm) {
    $elm.addClass('mbsc-sel-hdn').attr('tabindex', -1);

    if (!s.showInput) {
      $elm.attr('data-enhance', false);
    }
  }

  if (tapSelect && !(s.rows % 2)) {
    s.rows = s.rows - 1;
  }

  if (s.filter) {
    filterLength = s.filter.minLength || 0;
  }

  hasRemoteData = s.data && s.data.url;

  if (hasRemoteData) {
    inst.refresh();
  } else {
    if (hasData) {
      dataArray = s.data;
    }

    prepareData();
    getOption($elm.val());
  } // ---


  return {
    layout: layout,
    headerText: false,
    anchor: $input,
    compClass: 'mbsc-sc mbsc-sel' + (tapSelect ? ' mbsc-sel-multi' : ''),
    setOnTap: hasGroupWheel ? [false, true] : true,
    formatValue: formatValue,
    tapSelect: tapSelect,
    parseValue: function parseValue(val) {
      getOption(val === undefined ? $elm.val() : val);
      return hasGroupWheel ? [group, option] : [option];
    },
    validate: function validate(data) {
      var index = data.index,
          disabled = [];
      disabled[optionWheelIdx] = s.invalid;

      if (groupSep && !prevent && index === undefined) {
        changeWheel();
      }

      prevent = false;
      return {
        disabled: disabled
      };
    },
    onRead: onFill,
    onFill: onFill,
    onMarkupReady: function onMarkupReady(event, inst) {
      if (s.filter) {
        var $filterInput,
            debounce,
            filterInput,
            $cont = $$1('.mbsc-fr-w', event.target),
            $filterClear = $$1('<span class="mbsc-sel-filter-clear mbsc-ic mbsc-ic-' + s.filterClearIcon + '"></span>');

        if (s.display == 'inline') {
          $filterInput = $input;
          $input.parent().find('.mbsc-sel-filter-clear').remove();
        } else {
          $cont.find('.mbsc-fr-c').before('<div class="mbsc-input mbsc-sel-filter-cont mbsc-control-w mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + '"><span class="mbsc-input-wrap"><input tabindex="0" type="text" class="mbsc-sel-filter-input mbsc-control"/></span></div>');
          $filterInput = $cont.find('.mbsc-sel-filter-input');
        }

        filterText = null;
        filterInput = $filterInput[0];
        $filterInput.prop('readonly', false).attr('placeholder', s.filterPlaceholderText).parent().append($filterClear);
        $cont.find('.mbsc-fr-c').prepend($filterEmpty); // Will focus in the input on show

        inst._activeElm = filterInput;
        inst.tap($filterClear, function () {
          filterText = null;
          filterInput.value = '';
          inst.refresh();
          $filterClear.removeClass('mbsc-sel-filter-show-clear');
          triggerOnFilter('');
        });
        $filterInput.on('keydown', function (ev) {
          // Enter and Esc
          if (ev.keyCode == 13 || ev.keyCode == 27) {
            ev.stopPropagation();
            filterInput.blur();
          }
        }).on('input', function () {
          clearTimeout(debounce);

          if (filterInput.value.length) {
            $filterClear.addClass('mbsc-sel-filter-show-clear');
          } else {
            $filterClear.removeClass('mbsc-sel-filter-show-clear');
          }

          debounce = setTimeout(function () {
            if (filterText === filterInput.value || triggerOnFilter(filterInput.value) === false) {
              return;
            }

            filterText = filterInput.value;

            if (filterText.length >= filterLength || !filterText.length) {
              if (hasRemoteData && s.data.remoteFilter) {
                getJson(s.data.url + encodeURIComponent(filterText), function (data) {
                  inst.refresh(getData(data));
                }, s.data.dataType);
              } else {
                inst.refresh(undefined, filterText);
              }
            }
          }, 500);
        });
      }
    },
    onBeforeShow: function onBeforeShow() {
      if (multiple && s.counter) {
        s.headerText = function () {
          var length = 0;
          $$1.each(inst._tempSelected[optionWheelIdx], function () {
            length++;
          });
          return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);
        };
      }

      getOption($elm.val());

      if (tapSelect && hasGroupWheel) {
        inst._selected[groupWheelIdx] = arrayToObject([group]);
      }

      if (s.filter) {
        prepareData(undefined);
      }

      inst.settings.wheels = genWheels();
      prevent = true;
    },
    onWheelGestureStart: function onWheelGestureStart(ev) {
      if (ev.index == groupWheelIdx) {
        s.readonly = [false, true];
      }
    },
    onWheelAnimationEnd: function onWheelAnimationEnd(ev) {
      var values = inst.getArrayVal(true);

      if (ev.index == groupWheelIdx) {
        s.readonly = origReadOnly;

        if (!tapSelect) {
          loadGroupOptions(values);
        }
      } else if (ev.index == optionWheelIdx && values[optionWheelIdx] != option) {
        option = values[optionWheelIdx];

        if (hasGroupWheel && options[option] && options[option].group != group) {
          group = options[option].group;
          values[groupWheelIdx] = group;
          inst._tempSelected[groupWheelIdx] = arrayToObject([group]);
          inst.setArrayVal(values, false, false, true, animTime);
        }
      }
    },
    onItemTap: function onItemTap(ev) {
      var values;

      if (ev.index == optionWheelIdx) {
        selectedTexts[ev.value] = options[ev.value].text;

        if (tapSelect && !multiple && ev.selected) {
          inst._prevItemTap = true;
          return false;
        }
      }

      if (ev.index == groupWheelIdx && tapSelect) {
        if (ev.selected) {
          inst._prevItemTap = true;
          return false;
        }

        values = inst.getArrayVal(true);
        values[groupWheelIdx] = ev.value;
        loadGroupOptions(values);
      }
    },
    onClose: function onClose() {
      if (hasRemoteData && s.data.remoteFilter && filterText) {
        inst.refresh();
      }
    },
    onDestroy: function onDestroy() {
      // Remove dummy input
      if (inst._$input) {
        inst._$input.remove();
      } // Revert select attributes and classes


      $elm.removeClass('mbsc-sel-hdn').removeAttr('tabindex');
    }
  };
};

var MbscSelect = (function (_super) {
    __extends(MbscSelect, _super);
    function MbscSelect(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.placeholder = '';
        _this.onFilter = new EventEmitter();
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscSelect.prototype, "value", {
        set: function (v) {
            if (!this.control) {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscSelect.prototype.refreshData = function (newData) {
        this.instance.refresh(newData);
    };
    MbscSelect.prototype.initControl = function () {
        var target = this.target;
        if (target) {
            if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {
                target = target._elementRef.nativeElement;
                var inputUnder = $$1('input', target);
                if (inputUnder.length) {
                    target = inputUnder;
                }
            }
        }
        else {
            var contentInput = $$1('input', this.initialElem.nativeElement).length;
            if (contentInput) {
                target = this.element;
            }
            if (!target && this.initialElem.nativeElement.nodeName === 'ION-INPUT') {
                target = this.initialElem.nativeElement;
            }
        }
        var options = extend$1({ preset: 'select', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Select$1(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscSelect.prototype.setElement = function () {
        this.element = this.initialElem.nativeElement;
        var contentSelect = $$1('select', this.initialElem.nativeElement);
        if (contentSelect.length) {
            this.element = contentSelect[0];
        }
        else {
            _super.prototype.setElement.call(this);
        }
    };
    MbscSelect.prototype.ngOnInit = function () {
        this.isMulti = this.options && this.options.select && this.options.select !== 'single';
        this.cloneDictionary.data = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscSelect.prototype.setNewValue = function (v) {
        if (this.instance) {
            var changed = void 0;
            if (this.isMulti) {
                changed = !deepEqualsArray(v, this.instance.getVal());
            }
            else {
                var innerValue = this.instance.getVal();
                changed = innerValue !== v;
            }
            if (changed) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscSelect.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscSelect.propDecorators = {
        'counter': [{ type: Input$1 },],
        'data': [{ type: Input$1, args: ['mbsc-data',] },],
        'dataText': [{ type: Input$1 },],
        'dataGroup': [{ type: Input$1 },],
        'dataValue': [{ type: Input$1 },],
        'filter': [{ type: Input$1 },],
        'filterPlaceholderText': [{ type: Input$1 },],
        'filterEmptyText': [{ type: Input$1 },],
        'group': [{ type: Input$1 },],
        'groupLabel': [{ type: Input$1 },],
        'inputClass': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'label': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'select': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'onFilter': [{ type: Output },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'target': [{ type: Input$1, args: ['mbsc-target',] },],
        'value': [{ type: Input$1, args: ['mbsc-select',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-selectChange',] },],
    };
MbscSelect.ɵfac = function MbscSelect_Factory(t) { return new (t || MbscSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscSelect.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscSelect, selectors: [["", "mbsc-select", ""]], inputs: { value: ["mbsc-select", "value"], counter: "counter", data: ["mbsc-data", "data"], dataText: "dataText", dataGroup: "dataGroup", dataValue: "dataValue", filter: "filter", filterPlaceholderText: "filterPlaceholderText", filterEmptyText: "filterEmptyText", group: "group", groupLabel: "groupLabel", inputClass: "inputClass", invalid: "invalid", label: "label", placeholder: "placeholder", select: "select", showInput: "showInput", options: ["mbsc-options", "options"], target: ["mbsc-target", "target"] }, outputs: { onFilter: "onFilter", onChangeEmitter: "mbsc-selectChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSelect, [{
        type: Directive,
        args: [{
                selector: '[mbsc-select]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-select']
        }], counter: [{
            type: Input$1
        }], data: [{
            type: Input$1,
            args: ['mbsc-data']
        }], dataText: [{
            type: Input$1
        }], dataGroup: [{
            type: Input$1
        }], dataValue: [{
            type: Input$1
        }], filter: [{
            type: Input$1
        }], filterPlaceholderText: [{
            type: Input$1
        }], filterEmptyText: [{
            type: Input$1
        }], group: [{
            type: Input$1
        }], groupLabel: [{
            type: Input$1
        }], inputClass: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], label: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], select: [{
            type: Input$1
        }], showInput: [{
            type: Input$1
        }], onFilter: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], target: [{
            type: Input$1,
            args: ['mbsc-target']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-selectChange']
        }] }); })();
    return MbscSelect;
}(MbscScrollerBase));
var MbscSelectComponent = (function (_super) {
    __extends(MbscSelectComponent, _super);
    function MbscSelectComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.dropdown = true;
        _this.placeholder = '';
        return _this;
    }
    MbscSelectComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscSelectComponent.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        if (this.inline) {
            var showInput = this.showInput || (this.options && this.options.showInput);
            var filter = this.filter || (this.options && this.options.filter);
            if (showInput === undefined) {
                this.inlineOptionsObj.showInput = this.showInput = !!filter;
            }
        }
    };
    MbscSelectComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscSelectComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'data': [{ type: Input$1 },],
        'dropdown': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscSelectComponent.ɵfac = function MbscSelectComponent_Factory(t) { return new (t || MbscSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscSelectComponent, selectors: [["mbsc-select"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", data: "data", dropdown: "dropdown", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscSelectComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSelectComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-select',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], data: [{
            type: Input$1
        }], dropdown: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscSelectComponent;
}(MbscSelect));
var MbscSelectModule = (function () {
    function MbscSelectModule() {
    }
    MbscSelectModule.ctorParameters = function () { return []; };
MbscSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscSelectModule });
MbscSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscSelectModule_Factory(t) { return new (t || MbscSelectModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscSelectModule, { declarations: function () { return [MbscSelect, MbscSelectComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscSelect, MbscSelectComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscSelectModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscSelect, MbscSelectComponent],
                exports: [MbscSelect, MbscSelectComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscSelectModule;
}());

var Timer = Scroller;
var defaults$e = {
  autostart: false,
  step: 1,
  // in seconds
  useShortLabels: false,
  // Localization
  labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds', ''],
  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs', ''],
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Reset',
  lapText: 'Lap',
  hideText: 'Hide',
  mode: 'countdown'
};

presets.timer = function (inst) {
  /**
   * Converts a date to UTC
   * @param   d   (Date)  Date to convert
   * @return      (Date)  Date converted to UTC
   */
  function toUtc(d) {
    return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }
  /**
   * Calculates the parts of the time differnce
   * @param   time    (Integer)   Time in milliseconds
   * @return          (Object)    Time splitted to the required parts (years, months, days, hours, minutes, seconds)
   */


  function getParts(time) {
    var ret = {};

    if (dateMode && obj[max].index > obj.days.index) {
      var i,
          v,
          o,
          prev,
          now = new Date(),
          d2 = up ? now : origTime,
          d1 = up ? origTime : now;
      d1 = toUtc(d1);
      d2 = toUtc(d2);
      ret.years = d2.getFullYear() - d1.getFullYear();
      ret.months = d2.getMonth() - d1.getMonth();
      ret.days = d2.getDate() - d1.getDate();
      ret.hours = d2.getHours() - d1.getHours();
      ret.minutes = d2.getMinutes() - d1.getMinutes();
      ret.seconds = d2.getSeconds() - d1.getSeconds();
      ret.fract = (d2.getMilliseconds() - d1.getMilliseconds()) / 10;

      for (i = unique.length; i > 0; i--) {
        v = unique[i - 1];
        o = obj[v];
        prev = unique[$$1.inArray(v, unique) - 1];

        if (obj[prev] && ret[v] < 0) {
          ret[prev]--;
          ret[v] += prev == 'months' ? 32 - new Date(d2.getFullYear(), d2.getMonth(), 32).getDate() : o.until + 1;
        }
      }

      if (max == 'months') {
        ret.months += ret.years * 12;
        delete ret.years;
      }
    } else {
      $$1(unique).each(function (i, v) {
        if (obj[v].index <= obj[max].index) {
          ret[v] = Math.floor(time / obj[v].limit);
          time -= ret[v] * obj[v].limit;
        }
      });
    }

    return ret;
  }
  /**
   * Generates a specific wheel
   * @param   v   (String)  Unique identifier
   */


  function genWheel(v) {
    var st = 1,
        o = obj[v],
        wh = o.wheel,
        prefix = o.prefix,
        from = 0,
        until = o.until,
        next = obj[unique[$$1.inArray(v, unique) - 1]];

    if (o.index <= obj[max].index && (!next || next.limit > step)) {
      if (!wheels[v]) {
        w[0].push(wh);
      }

      wheels[v] = 1;
      wh.data = [];
      wh.label = o.label || '';
      wh.cssClass = 'mbsc-timer-whl-' + v;

      if (step >= o.limit) {
        // Calculate steps on last wheel
        st = Math.max(Math.round(step / o.limit), 1);
        tstep = st * o.limit; // Timer is calculated with rounded step
      }

      if (v == max) {
        wh.min = 0;

        wh.data = function (i) {
          return {
            value: i,
            display: genValue(i, prefix, o.label)
          };
        };

        wh.getIndex = function (v) {
          return v;
        };
      } else {
        for (i = from; i <= until; i += st) {
          wh.data.push({
            value: i,
            display: genValue(i, prefix, o.label)
          });
        }
      }
    }
  }

  function genValue(i, prefix, lbl) {
    return (prefix || '') + (i < 10 ? '0' : '') + i + '<span class="mbsc-timer-lbl">' + lbl + '</span>';
  }
  /**
   * Converts the time into array containing the parts
   * @param   time    (Integer)   Time in milliseconds
   * @return          (Array)     Time splitted to the required parts (years, months, days, hours, minutes, seconds)
   */


  function getArray(time) {
    var arr = [],
        st,
        p = getParts(time);
    $$1(unique).each(function (i, v) {
      if (wheels[v]) {
        st = Math.max(Math.round(step / obj[v].limit), 1);
        arr.push(Math.round(p[v] / st) * st);
      }
    });
    return arr;
  }
  /**
   * Calculates the time
   * @param   reset   (Boolean)   Reset the timer or not
   */


  function calcTime(reset) {
    if (dateMode) {
      time = origTime - new Date();

      if (time < 0) {
        time *= -1;
        up = true;
      } else {
        up = false;
      }

      timer = 0;
      infinit = true;
    } else if (origTime !== undefined) {
      infinit = false;
      time = origTime * 1000;
      up = s.mode != 'countdown';

      if (reset) {
        timer = 0;
      }
    } else {
      time = 0;
      up = s.mode != 'countdown';
      infinit = up;

      if (reset) {
        timer = 0;
      }
    }
  }

  function updateUI() {
    if (running) {
      $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-running mbsc-timer-locked');
      $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.stopText);

      if (inst.buttons.start.icon) {
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.start.icon);
      }

      if (inst.buttons.stop.icon) {
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.stop.icon);
      }

      if (s.mode == 'stopwatch') {
        $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.lapText);

        if (inst.buttons.reset.icon) {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.reset.icon);
        }

        if (inst.buttons.lap.icon) {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.lap.icon);
        }
      }
    } else {
      $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-running');
      $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.startText);

      if (inst.buttons.start.icon) {
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.start.icon);
      }

      if (inst.buttons.stop.icon) {
        $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.stop.icon);
      }

      if (s.mode == 'stopwatch') {
        $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.resetText);

        if (inst.buttons.reset.icon) {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.reset.icon);
        }

        if (inst.buttons.lap.icon) {
          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.lap.icon);
        }
      }
    }
  }

  var i,
      interval,
      tstep,
      startTime,
      started,
      ellapsed,
      time,
      timer,
      up,
      ctx,
      lap,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$e, orig),
      lbls = s.useShortLabels ? s.labelsShort : s.labels,
      animTime = 1000,
      buttons = ['resetlap', 'toggle'],
      unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds', 'fract'],
      obj = {
    'years': {
      index: 6,
      until: 10,
      limit: 1000 * 60 * 60 * 24 * 365,
      label: lbls[0],
      wheel: {}
    },
    'months': {
      index: 5,
      until: 11,
      limit: 1000 * 60 * 60 * 24 * 30,
      label: lbls[1],
      wheel: {}
    },
    'days': {
      index: 4,
      until: 31,
      limit: 1000 * 60 * 60 * 24,
      label: lbls[2],
      wheel: {}
    },
    'hours': {
      index: 3,
      until: 23,
      limit: 1000 * 60 * 60,
      label: lbls[3],
      wheel: {}
    },
    'minutes': {
      index: 2,
      until: 59,
      limit: 1000 * 60,
      label: lbls[4],
      wheel: {}
    },
    'seconds': {
      index: 1,
      until: 59,
      limit: 1000,
      label: lbls[5],
      wheel: {}
    },
    'fract': {
      index: 0,
      until: 99,
      limit: 10,
      label: lbls[6],
      prefix: '.',
      wheel: {}
    }
  },
      wheels = {},
      laps = [],
      lastLap = 0,
      running = false,
      stopped = true,
      infinit = false,
      step = Math.max(10, s.step * 1000),
      max = s.maxWheel,
      locked = s.mode == 'stopwatch' || dateMode,
      origTime = s.targetTime,
      dateMode = origTime && origTime.getTime !== undefined,
      w = [[]]; // Extended methods
  // ---
  // Start the counter

  inst.start = function () {
    if (stopped) {
      inst.reset();
    }

    if (!running) {
      calcTime();

      if (!infinit && timer >= time) {
        return;
      }

      running = true;
      stopped = false;
      started = new Date();
      startTime = timer;
      s.readonly = true;
      inst.setVal(getArray(up ? timer : time - timer), true, true, false, 100);
      interval = setInterval(function () {
        timer = new Date() - started + startTime;
        inst.setVal(getArray(up ? timer : time - timer), true, true, false, Math.min(100, tstep - 10));

        if (!infinit && timer + tstep >= time) {
          clearInterval(interval);
          setTimeout(function () {
            // Do last tick with precision
            inst.stop();
            timer = time;
            inst.setVal(getArray(up ? timer : 0), true, true, false, 100);
            inst.trigger('onFinish', {
              time: time
            });
            stopped = true;
          }, time - timer);
        }
      }, tstep);
      updateUI();
      inst.trigger('onStart');
    }
  }; // Stop the counter


  inst.stop = function () {
    if (running) {
      running = false;
      clearInterval(interval); // Time correction

      timer = new Date() - started + startTime;
      updateUI();
      inst.trigger('onStop', {
        ellapsed: timer
      });
    }
  };

  inst.toggle = function () {
    if (running) {
      inst.stop();
    } else {
      inst.start();
    }
  }; // Reset the counter


  inst.reset = function () {
    inst.stop();
    timer = 0;
    laps = [];
    lastLap = 0;
    inst.setVal(getArray(up ? 0 : time), true, true, false, animTime);
    inst.settings.readonly = locked;
    stopped = true;

    if (!locked) {
      $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-locked');
    }

    inst.trigger('onReset');
  }; // Lap


  inst.lap = function () {
    if (running) {
      ellapsed = new Date() - started + startTime;
      lap = ellapsed - lastLap;
      lastLap = ellapsed;
      laps.push(ellapsed);
      inst.trigger('onLap', {
        ellapsed: ellapsed,
        lap: lap,
        laps: laps
      });
    }
  };

  inst.resetlap = function () {
    if (running && s.mode == 'stopwatch') {
      inst.lap();
    } else {
      inst.reset();
    }
  };

  inst.getTime = function () {
    return time;
  };

  inst.setTime = function (t) {
    origTime = t / 1000;
    time = t;
  };

  inst.getEllapsedTime = function () {
    return stopped ? 0 : running ? new Date() - started + startTime : timer;
  };

  inst.setEllapsedTime = function (t, change) {
    if (!stopped) {
      startTime = timer = t;
      started = new Date();
      inst.setVal(getArray(up ? timer : time - timer), true, change, false, animTime);
    }
  }; // ---
  // Constructor


  calcTime(true);

  if (!max && !time) {
    max = 'minutes';
  }

  if (s.display !== 'inline') {
    buttons.unshift('hide');
  } // Determine maximum wheel


  if (!max) {
    $$1(unique).each(function (i, v) {
      if (!max && time >= obj[v].limit) {
        max = v;
        return false;
      }
    });
  } // Generate wheels


  $$1(unique).each(function (i, v) {
    genWheel(v);
  });
  tstep = Math.max(97, tstep); // timer step cannot be less then 100 ms

  if (s.autostart) {
    setTimeout(function () {
      inst.start();
    }, 0);
  }

  inst.handlers.toggle = inst.toggle;
  inst.handlers.start = inst.start;
  inst.handlers.stop = inst.stop;
  inst.handlers.resetlap = inst.resetlap;
  inst.handlers.reset = inst.reset;
  inst.handlers.lap = inst.lap;
  inst.buttons.toggle = {
    parentClass: 'mbsc-timer-btn-toggle-c',
    text: s.startText,
    icon: s.startIcon,
    handler: 'toggle'
  };
  inst.buttons.start = {
    text: s.startText,
    icon: s.startIcon,
    handler: 'start'
  };
  inst.buttons.stop = {
    text: s.stopText,
    icon: s.stopIcon,
    handler: 'stop'
  };
  inst.buttons.reset = {
    text: s.resetText,
    icon: s.resetIcon,
    handler: 'reset'
  };
  inst.buttons.lap = {
    text: s.lapText,
    icon: s.lapIcon,
    handler: 'lap'
  };
  inst.buttons.resetlap = {
    parentClass: 'mbsc-timer-btn-resetlap-c',
    text: s.resetText,
    icon: s.resetIcon,
    handler: 'resetlap'
  };
  inst.buttons.hide = {
    parentClass: 'mbsc-timer-btn-hide-c',
    text: s.hideText,
    icon: s.closeIcon,
    handler: 'cancel'
  }; // Return settings

  return {
    minWidth: 100,
    wheels: w,
    headerText: false,
    readonly: locked,
    buttons: buttons,
    compClass: 'mbsc-timer mbsc-sc',
    parseValue: function parseValue() {
      return getArray(up ? 0 : time);
    },
    formatValue: function formatValue(d) {
      var ret = '',
          j = 0;
      $$1(unique).each(function (i, v) {
        if (v == 'fract') {
          return;
        }

        if (wheels[v]) {
          ret += d[j] + (v == 'seconds' && wheels.fract ? '.' + d[j + 1] : '') + ' ' + lbls[i] + ' ';
          j++;
        }
      });
      return ret;
    },
    validate: function validate(data) {
      var values = data.values,
          i = data.index,
          j = 0;

      if (stopped && i !== undefined) {
        origTime = 0;
        $$1(unique).each(function (i, v) {
          if (wheels[v]) {
            origTime += obj[v].limit * values[j];
            j++;
          }
        });
        origTime /= 1000;
        calcTime(true);
      }
    },
    onBeforeShow: function onBeforeShow() {
      s.showLabel = true;
    },
    onMarkupReady: function onMarkupReady(ev) {
      ctx = $$1(ev.target);
      updateUI();

      if (locked) {
        $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-locked');
      }
    },
    onPosition: function onPosition(ev) {
      // Force width to fit buttons
      $$1('.mbsc-fr-w', ev.target).css('min-width', 0).css('min-width', $$1('.mbsc-fr-btn-cont', ev.target)[0].offsetWidth);
    },
    onDestroy: function onDestroy() {
      clearInterval(interval);
    }
  };
};

var MbscTimer = (function (_super) {
    __extends(MbscTimer, _super);
    function MbscTimer(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onLap = new EventEmitter();
        _this.onFinish = new EventEmitter();
        _this.onReset = new EventEmitter();
        _this.onStart = new EventEmitter();
        _this.onStop = new EventEmitter();
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscTimer.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscTimer.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (!this.instance._timer || Math.abs(this.instance._timer - v) > 10) {
                this.instance.setEllapsedTime(v, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscTimer.prototype.handleChange = function () {
        var that = this;
        $$1(this.element).on('change', function () {
            that.zone.run(function () {
                that.instance._timer = that.instance.getEllapsedTime();
                if (that.control) {
                    that.control.control.patchValue(that.instance._timer);
                }
                else {
                    that.onChangeEmitter.emit(that.instance._timer);
                }
            });
        });
    };
    MbscTimer.prototype.initControl = function () {
        var options = extend$1({ preset: 'timer' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Timer(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscTimer.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscTimer.propDecorators = {
        'autostart': [{ type: Input$1 },],
        'maxWheel': [{ type: Input$1 },],
        'mode': [{ type: Input$1 },],
        'step': [{ type: Input$1 },],
        'targetTime': [{ type: Input$1 },],
        'useShortLabels': [{ type: Input$1 },],
        'hideText': [{ type: Input$1 },],
        'labels': [{ type: Input$1 },],
        'labelsShort': [{ type: Input$1 },],
        'lapText': [{ type: Input$1 },],
        'resetText': [{ type: Input$1 },],
        'startText': [{ type: Input$1 },],
        'stopText': [{ type: Input$1 },],
        'onLap': [{ type: Output },],
        'onFinish': [{ type: Output },],
        'onReset': [{ type: Output },],
        'onStart': [{ type: Output },],
        'onStop': [{ type: Output },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-timer',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-timerChange',] },],
    };
MbscTimer.ɵfac = function MbscTimer_Factory(t) { return new (t || MbscTimer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscTimer.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscTimer, selectors: [["", "mbsc-timer", ""]], inputs: { value: ["mbsc-timer", "value"], autostart: "autostart", maxWheel: "maxWheel", mode: "mode", step: "step", targetTime: "targetTime", useShortLabels: "useShortLabels", hideText: "hideText", labels: "labels", labelsShort: "labelsShort", lapText: "lapText", resetText: "resetText", startText: "startText", stopText: "stopText", options: ["mbsc-options", "options"] }, outputs: { onLap: "onLap", onFinish: "onFinish", onReset: "onReset", onStart: "onStart", onStop: "onStop", onChangeEmitter: "mbsc-timerChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimer, [{
        type: Directive,
        args: [{
                selector: '[mbsc-timer]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-timer']
        }], autostart: [{
            type: Input$1
        }], maxWheel: [{
            type: Input$1
        }], mode: [{
            type: Input$1
        }], step: [{
            type: Input$1
        }], targetTime: [{
            type: Input$1
        }], useShortLabels: [{
            type: Input$1
        }], hideText: [{
            type: Input$1
        }], labels: [{
            type: Input$1
        }], labelsShort: [{
            type: Input$1
        }], lapText: [{
            type: Input$1
        }], resetText: [{
            type: Input$1
        }], startText: [{
            type: Input$1
        }], stopText: [{
            type: Input$1
        }], onLap: [{
            type: Output
        }], onFinish: [{
            type: Output
        }], onReset: [{
            type: Output
        }], onStart: [{
            type: Output
        }], onStop: [{
            type: Output
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-timerChange']
        }] }); })();
    return MbscTimer;
}(MbscScrollerBase));
var MbscTimerComponent = (function (_super) {
    __extends(MbscTimerComponent, _super);
    function MbscTimerComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscTimerComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscTimerComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscTimerComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscTimerComponent.ɵfac = function MbscTimerComponent_Factory(t) { return new (t || MbscTimerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTimerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTimerComponent, selectors: [["mbsc-timer"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscTimerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscTimerComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimerComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-timer',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscTimerComponent;
}(MbscTimer));
var MbscTimerModule = (function () {
    function MbscTimerModule() {
    }
    MbscTimerModule.ctorParameters = function () { return []; };
MbscTimerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscTimerModule });
MbscTimerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscTimerModule_Factory(t) { return new (t || MbscTimerModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTimerModule, { declarations: function () { return [MbscTimer, MbscTimerComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscTimer, MbscTimerComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimerModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscTimer, MbscTimerComponent],
                exports: [MbscTimer, MbscTimerComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscTimerModule;
}());

var Timespan = Scroller;
var defaults$f = {
  wheelOrder: 'hhiiss',
  useShortLabels: false,
  min: 0,
  max: Infinity,
  // Localization
  labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds'],
  //, ''],
  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'] //, '']

};

presets.timespan = function (inst) {
  /**
   * Calculates the parts of the time differnce.
   * @param {Integer} time - Time in milliseconds.
   * @return {Object} - Time splitted to the required parts (years, months, days, hours, minutes, seconds).
   */
  function getParts(time) {
    var ret = {};
    $$1(unique).each(function (i, v) {
      ret[v] = wheels[v] ? Math.floor(time / obj[v].limit) : 0;
      time -= ret[v] * obj[v].limit;
    });
    return ret;
  }
  /**
   * Generates a specific wheel.
   * @param {String} v - Unique identifier.
   */


  function genWheel(v) {
    var leading = false,
        st = steps[wheels[v] - 1] || 1,
        o = obj[v],
        lbl = o.label,
        w = o.wheel;
    w.data = [];
    w.label = o.label;

    if (ord.match(new RegExp(o.re + o.re, 'i'))) {
      leading = true;
    }

    if (v == max) {
      w.min = minParts[v];
      w.max = maxParts[v];

      w.data = function (i) {
        return {
          value: i * st,
          display: genValue(i * st, leading, lbl)
        };
      };

      w.getIndex = function (v) {
        return Math.round(v / st);
      };
    } else {
      for (i = 0; i <= o.until; i += st) {
        w.data.push({
          value: i,
          display: genValue(i, leading, lbl)
        });
      }
    }
  }

  function genValue(i, leading, lbl) {
    return (i < 10 && leading ? '0' : '') + i + '<span class="mbsc-ts-lbl">' + lbl + '</span>';
  }

  function calcTime(arr) {
    var j = 0,
        time = 0;
    $$1.each(o, function (i, v) {
      if (!isNaN(+arr[j])) {
        time += obj[v.v].limit * arr[i];
      }
    });
    return time;
  }

  function step(v, st) {
    return Math.floor(v / st) * st;
  }

  var i,
      j,
      p,
      minParts,
      maxParts,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$f, orig),
      ord = s.wheelOrder,
      lbls = s.useShortLabels ? s.labelsShort : s.labels,
      unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'],
      //, 'fract'],
  obj = {
    'years': {
      ord: 0,
      index: 6,
      until: 10,
      limit: 1000 * 60 * 60 * 24 * 365,
      label: lbls[0],
      re: 'y',
      wheel: {}
    },
    'months': {
      ord: 1,
      index: 5,
      until: 11,
      limit: 1000 * 60 * 60 * 24 * 30,
      label: lbls[1],
      re: 'm',
      wheel: {}
    },
    'days': {
      ord: 2,
      index: 4,
      until: 31,
      limit: 1000 * 60 * 60 * 24,
      label: lbls[2],
      re: 'd',
      wheel: {}
    },
    'hours': {
      ord: 3,
      index: 3,
      until: 23,
      limit: 1000 * 60 * 60,
      label: lbls[3],
      re: 'h',
      wheel: {}
    },
    'minutes': {
      ord: 4,
      index: 2,
      until: 59,
      limit: 1000 * 60,
      label: lbls[4],
      re: 'i',
      wheel: {}
    },
    'seconds': {
      ord: 5,
      index: 1,
      until: 59,
      limit: 1000,
      label: lbls[5],
      re: 's',
      wheel: {}
    } //,
    //'fract': { index: 0, until: 99, limit: 10, label: lbls[6], prefix: '.', short: 'u' }

  },
      o = [],
      steps = s.steps || [],
      wheels = {},
      max = 'seconds',
      defaultVal = s.defaultValue || Math.max(s.min, Math.min(0, s.max)),
      w = [[]]; // Constructor
  // Generate wheels

  $$1(unique).each(function (i, v) {
    j = ord.search(new RegExp(obj[v].re, 'i'));

    if (j > -1) {
      o.push({
        o: j,
        v: v
      });

      if (obj[v].index > obj[max].index) {
        max = v;
      }
    }
  });
  o.sort(function (a, b) {
    return a.o > b.o ? 1 : -1;
  });
  $$1.each(o, function (i, v) {
    wheels[v.v] = i + 1;
    w[0].push(obj[v.v].wheel);
  });
  minParts = getParts(s.min);
  maxParts = getParts(s.max);
  $$1.each(o, function (i, v) {
    genWheel(v.v);
  }); // Extended methods
  // ---

  inst.getVal = function (temp, formatted) {
    return formatted ? inst._getVal(temp) : inst._hasValue || temp ? calcTime(inst.getArrayVal(temp)) : null;
  }; // ---
  // Return settings


  return {
    minWidth: 100,
    showLabel: true,
    wheels: w,
    compClass: 'mbsc-ts mbsc-sc',
    parseValue: function parseValue(val) {
      var ret = [],
          m;

      if (isNumeric(val) || !val) {
        p = getParts(val || defaultVal);
        $$1.each(o, function (i, v) {
          ret.push(p[v.v]);
        });
      } else {
        $$1.each(o, function (i, v) {
          m = new RegExp('(\\d+)\\s?(' + s.labels[obj[v.v].ord] + '|' + s.labelsShort[obj[v.v].ord] + ')', 'gi').exec(val);
          ret.push(m ? m[1] : 0);
        });
      }

      $$1(ret).each(function (i, v) {
        // Steps
        ret[i] = step(v, steps[i] || 1);
      });
      return ret;
    },
    formatValue: function formatValue(d) {
      var ret = '';
      $$1.each(o, function (i, v) {
        ret += +d[i] ? d[i] + ' ' + obj[v.v].label + ' ' : '';
      });
      return ret ? ret.replace(/\s+$/g, '') : 0;
    },
    validate: function validate(data) {
      var p,
          i,
          index,
          dis,
          values = data.values,
          dir = data.direction,
          disabled = [],
          maxprop = true,
          minprop = true;
      $$1(unique).each(function (x, v) {
        if (wheels[v] !== undefined) {
          index = wheels[v] - 1;
          disabled[index] = [];
          dis = {};

          if (v != max) {
            if (maxprop) {
              for (i = maxParts[v] + 1; i <= obj[v].until; i++) {
                dis[i] = true;
              }
            }

            if (minprop) {
              for (i = 0; i < minParts[v]; i++) {
                dis[i] = true;
              }
            }
          }

          values[index] = inst.getValidValue(index, values[index], dir, dis);
          p = getParts(calcTime(values));
          maxprop = maxprop && p[v] == maxParts[v];
          minprop = minprop && p[v] == minParts[v];
          $$1.each(dis, function (i) {
            disabled[index].push(i);
          });
        }
      });
      return {
        disabled: disabled
      };
    }
  };
};

var MbscTimespan = (function (_super) {
    __extends(MbscTimespan, _super);
    function MbscTimespan(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscTimespan.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscTimespan.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if (innerValue !== v) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscTimespan.prototype.initControl = function () {
        var options = extend$1({ preset: 'timespan' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Timespan(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscTimespan.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscTimespan.propDecorators = {
        'defaultValue': [{ type: Input$1 },],
        'max': [{ type: Input$1 },],
        'min': [{ type: Input$1 },],
        'steps': [{ type: Input$1 },],
        'useShortLabels': [{ type: Input$1 },],
        'wheelOrder': [{ type: Input$1 },],
        'labels': [{ type: Input$1 },],
        'labelsShort': [{ type: Input$1 },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'value': [{ type: Input$1, args: ['mbsc-timespan',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-timespanChange',] },],
    };
MbscTimespan.ɵfac = function MbscTimespan_Factory(t) { return new (t || MbscTimespan)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscTimespan.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscTimespan, selectors: [["", "mbsc-timespan", ""]], inputs: { value: ["mbsc-timespan", "value"], defaultValue: "defaultValue", max: "max", min: "min", steps: "steps", useShortLabels: "useShortLabels", wheelOrder: "wheelOrder", labels: "labels", labelsShort: "labelsShort", options: ["mbsc-options", "options"] }, outputs: { onChangeEmitter: "mbsc-timespanChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimespan, [{
        type: Directive,
        args: [{
                selector: '[mbsc-timespan]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-timespan']
        }], defaultValue: [{
            type: Input$1
        }], max: [{
            type: Input$1
        }], min: [{
            type: Input$1
        }], steps: [{
            type: Input$1
        }], useShortLabels: [{
            type: Input$1
        }], wheelOrder: [{
            type: Input$1
        }], labels: [{
            type: Input$1
        }], labelsShort: [{
            type: Input$1
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-timespanChange']
        }] }); })();
    return MbscTimespan;
}(MbscScrollerBase));
var MbscTimespanComponent = (function (_super) {
    __extends(MbscTimespanComponent, _super);
    function MbscTimespanComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscTimespanComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscTimespanComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscTimespanComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
    };
MbscTimespanComponent.ɵfac = function MbscTimespanComponent_Factory(t) { return new (t || MbscTimespanComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTimespanComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTimespanComponent, selectors: [["mbsc-timespan"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscTimespanComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscTimespanComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimespanComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-timespan',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscTimespanComponent;
}(MbscTimespan));
var MbscTimespanModule = (function () {
    function MbscTimespanModule() {
    }
    MbscTimespanModule.ctorParameters = function () { return []; };
MbscTimespanModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscTimespanModule });
MbscTimespanModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscTimespanModule_Factory(t) { return new (t || MbscTimespanModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTimespanModule, { declarations: function () { return [MbscTimespan, MbscTimespanComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscTimespan, MbscTimespanComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTimespanModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscTimespan, MbscTimespanComponent],
                exports: [MbscTimespan, MbscTimespanComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscTimespanModule;
}());

var Treelist = Scroller;
presets.treelist = List;

var MbscTreelist = (function (_super) {
    __extends(MbscTreelist, _super);
    function MbscTreelist(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.placeholder = '';
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscTreelist.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscTreelist.prototype.initControl = function () {
        var _this = this;
        var target = this.target;
        if (target) {
            if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {
                target = target._elementRef.nativeElement;
            }
            else if (target.getInputElement) {
                target.getInputElement().then(function (inp) {
                    _this.updateOptions({ input: inp }, true, false, false);
                });
            }
        }
        var options = extend$1({ preset: 'treelist', input: target }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Treelist(this.element, options);
        if (this.initialValue !== undefined) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscTreelist.prototype.setNewValue = function (v) {
        if (this.instance && this.instance.getVal() !== v) {
            this.instance.setVal(v, true, false);
            if (this._inputService && this._inputService.input) {
                this._inputService.input.innerValue = this.instance._value;
            }
        }
    };
    MbscTreelist.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
        { type: ViewContainerRef, },
    ]; };
    MbscTreelist.propDecorators = {
        'defaultValue': [{ type: Input$1 },],
        'inputClass': [{ type: Input$1 },],
        'invalid': [{ type: Input$1 },],
        'labels': [{ type: Input$1 },],
        'placeholder': [{ type: Input$1 },],
        'showInput': [{ type: Input$1 },],
        'wheelArray': [{ type: Input$1, args: ['mbsc-data',] },],
        'options': [{ type: Input$1, args: ['mbsc-options',] },],
        'target': [{ type: Input$1, args: ['mbsc-target',] },],
        'value': [{ type: Input$1, args: ['mbsc-treelist',] },],
        'onChangeEmitter': [{ type: Output, args: ['mbsc-treelistChange',] },],
    };
MbscTreelist.ɵfac = function MbscTreelist_Factory(t) { return new (t || MbscTreelist)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MbscTreelist.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MbscTreelist, selectors: [["", "mbsc-treelist", ""]], inputs: { value: ["mbsc-treelist", "value"], defaultValue: "defaultValue", inputClass: "inputClass", invalid: "invalid", labels: "labels", placeholder: "placeholder", showInput: "showInput", wheelArray: ["mbsc-data", "wheelArray"], options: ["mbsc-options", "options"], target: ["mbsc-target", "target"] }, outputs: { onChangeEmitter: "mbsc-treelistChange" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTreelist, [{
        type: Directive,
        args: [{
                selector: '[mbsc-treelist]',
                exportAs: 'mobiscroll'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ViewContainerRef }]; }, { value: [{
            type: Input$1,
            args: ['mbsc-treelist']
        }], defaultValue: [{
            type: Input$1
        }], inputClass: [{
            type: Input$1
        }], invalid: [{
            type: Input$1
        }], labels: [{
            type: Input$1
        }], placeholder: [{
            type: Input$1
        }], showInput: [{
            type: Input$1
        }], wheelArray: [{
            type: Input$1,
            args: ['mbsc-data']
        }], options: [{
            type: Input$1,
            args: ['mbsc-options']
        }], target: [{
            type: Input$1,
            args: ['mbsc-target']
        }], onChangeEmitter: [{
            type: Output,
            args: ['mbsc-treelistChange']
        }] }); })();
    return MbscTreelist;
}(MbscScrollerBase));
var MbscTreelistComponent = (function (_super) {
    __extends(MbscTreelistComponent, _super);
    function MbscTreelistComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        _this.showInput = false;
        _this.inlineOptionsObj = {
            showInput: false
        };
        return _this;
    }
    MbscTreelistComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    MbscTreelistComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: NgControl, decorators: [{ type: Optional },] },
        { type: MbscInputService, decorators: [{ type: Optional },] },
        { type: MbscOptionsService, decorators: [{ type: Optional },] },
    ]; };
    MbscTreelistComponent.propDecorators = {
        'inputIcon': [{ type: Input$1, args: ['icon',] },],
        'iconAlign': [{ type: Input$1, args: ['icon-align',] },],
        'name': [{ type: Input$1 },],
        'error': [{ type: Input$1 },],
        'errorMessage': [{ type: Input$1 },],
        'options': [{ type: Input$1 },],
        'wheelArray': [{ type: Input$1, args: ['data',] },],
        'placeholder': [{ type: Input$1 },],
    };
MbscTreelistComponent.ɵfac = function MbscTreelistComponent_Factory(t) { return new (t || MbscTreelistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8)); };
MbscTreelistComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MbscTreelistComponent, selectors: [["mbsc-treelist"]], inputs: { inputIcon: ["icon", "inputIcon"], iconAlign: ["icon-align", "iconAlign"], name: "name", error: "error", errorMessage: "errorMessage", options: "options", wheelArray: ["data", "wheelArray"], placeholder: "placeholder" }, exportAs: ["mobiscroll"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 1, consts: [[3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align", 4, "ngIf"], [3, "controlNg", "name", "theme", "themeVariant", "label-style", "input-style", "disabled", "dropdown", "placeholder", "error", "errorMessage", "icon", "icon-align"]], template: function MbscTreelistComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, MbscTreelistComponent_mbsc_input_0_Template, 2, 13, "mbsc-input", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.inline || ctx.showInput);
    } }, directives: [ɵngcc2.NgIf, MbscInput], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTreelistComponent, [{
        type: Component,
        args: [{
                selector: 'mbsc-treelist',
                exportAs: 'mobiscroll',
                template: INPUT_TEMPLATE
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.NgControl, decorators: [{
                type: Optional
            }] }, { type: MbscInputService, decorators: [{
                type: Optional
            }] }, { type: MbscOptionsService, decorators: [{
                type: Optional
            }] }]; }, { inputIcon: [{
            type: Input$1,
            args: ['icon']
        }], iconAlign: [{
            type: Input$1,
            args: ['icon-align']
        }], name: [{
            type: Input$1
        }], error: [{
            type: Input$1
        }], errorMessage: [{
            type: Input$1
        }], options: [{
            type: Input$1
        }], wheelArray: [{
            type: Input$1,
            args: ['data']
        }], placeholder: [{
            type: Input$1
        }] }); })();
    return MbscTreelistComponent;
}(MbscTreelist));
var MbscTreelistModule = (function () {
    function MbscTreelistModule() {
    }
    MbscTreelistModule.ctorParameters = function () { return []; };
MbscTreelistModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscTreelistModule });
MbscTreelistModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscTreelistModule_Factory(t) { return new (t || MbscTreelistModule)(); }, imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTreelistModule, { declarations: function () { return [MbscTreelist, MbscTreelistComponent]; }, imports: function () { return [CommonModule, MbscScrollerBaseModule, MbscInputModule]; }, exports: function () { return [MbscTreelist, MbscTreelistComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscTreelistModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MbscScrollerBaseModule, MbscInputModule],
                declarations: [MbscTreelist, MbscTreelistComponent],
                exports: [MbscTreelist, MbscTreelistComponent]
            }]
    }], function () { return []; }, null); })();
    return MbscTreelistModule;
}());

var directives = [
    MbscInput,
    MbscCalendar, MbscCalendarComponent,
    MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardSubtitle, MbscCardTitle,
    MbscColor, MbscColorComponent,
    MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent,
    MbscEventcalendar, MbscEventcalendarComponent,
    MbscForm, MbscRating, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion,
    MbscImage, MbscImageComponent, MbscImageItem,
    MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader,
    MbscMeasurement, MbscDistance, MbscForce, MbscMass, MbscSpeed, MbscTemperature, MbscMeasurementComponent, MbscTemperatureComponent, MbscForceComponent, MbscSpeedComponent, MbscMassComponent, MbscDistanceComponent,
    MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav, MbscNavItem,
    MbscNumber, MbscNumberComponent,
    MbscNumpad, MbscNumpadDecimal, MbscNumpadDate, MbscNumpadTime, MbscNumpadTimespan, MbscNumpadComponent, MbscNumpadDateComponent, MbscNumpadDecimalComponent, MbscNumpadTimeComponent, MbscNumpadTimespanComponent,
    MbscOptionlist, MbscOptionItem,
    MbscPage, MbscNote, MbscAvatar,
    MbscPopup, MbscWidget,
    MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent,
    MbscScroller, MbscScrollerComponent,
    MbscScrollView, MbscScrollViewItem, MbscScrollViewComponent, MbscScrollViewItemComponent,
    MbscSelect, MbscSelectComponent,
    MbscTimer, MbscTimerComponent,
    MbscTimespan, MbscTimespanComponent,
    MbscTreelist, MbscTreelistComponent,
];
var modules = [
    MbscInputModule,
    MbscCalendarModule,
    MbscCardModule,
    MbscColorModule,
    MbscDatetimeModule,
    MbscEventcalendarModule,
    MbscFormsModule,
    MbscImageModule,
    MbscListviewModule,
    MbscMeasurementModule,
    MbscNavigationModule,
    MbscNumberModule,
    MbscNumpadModule,
    MbscOptionlistModule,
    MbscPageModule,
    MbscPopupModule,
    MbscRangeModule,
    MbscScrollerModule,
    MbscScrollViewModule,
    MbscSelectModule,
    MbscTimerModule,
    MbscTimespanModule,
    MbscTreelistModule
];
var MbscModule = (function () {
    function MbscModule() {
    }
    MbscModule.forRoot = function (config) {
        return {
            ngModule: MbscModule,
            providers: [{
                    provide: MbscRouterToken,
                    useExisting: config.angularRouter
                }]
        };
    };
    MbscModule.ctorParameters = function () { return []; };
MbscModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MbscModule });
MbscModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MbscModule_Factory(t) { return new (t || MbscModule)(); }, imports: [[FormsModule, CommonModule, modules], MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscModule, { imports: function () { return [FormsModule, CommonModule, MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule]; }, exports: function () { return [MbscInput, MbscCalendar, MbscCalendarComponent, MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardSubtitle, MbscCardTitle, MbscColor, MbscColorComponent, MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent, MbscEventcalendar, MbscEventcalendarComponent, MbscForm, MbscRating, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion, MbscImage, MbscImageComponent, MbscImageItem, MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader, MbscMeasurement, MbscDistance, MbscForce, MbscMass, MbscSpeed, MbscTemperature, MbscMeasurementComponent, MbscTemperatureComponent, MbscForceComponent, MbscSpeedComponent, MbscMassComponent, MbscDistanceComponent, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav, MbscNavItem, MbscNumber, MbscNumberComponent, MbscNumpad, MbscNumpadDecimal, MbscNumpadDate, MbscNumpadTime, MbscNumpadTimespan, MbscNumpadComponent, MbscNumpadDateComponent, MbscNumpadDecimalComponent, MbscNumpadTimeComponent, MbscNumpadTimespanComponent, MbscOptionlist, MbscOptionItem, MbscPage, MbscNote, MbscAvatar, MbscPopup, MbscWidget, MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent, MbscScroller, MbscScrollerComponent, MbscScrollView, MbscScrollViewItem, MbscScrollViewComponent, MbscScrollViewItemComponent, MbscSelect, MbscSelectComponent, MbscTimer, MbscTimerComponent, MbscTimespan, MbscTimespanComponent, MbscTreelist, MbscTreelistComponent, MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MbscModule, [{
        type: NgModule,
        args: [{
                imports: [FormsModule, CommonModule, modules],
                exports: [directives, modules]
            }]
    }], function () { return []; }, null); })();
    return MbscModule;
}());

// Arabic

function intPart(floatNum) {
  if (floatNum < -0.0000001) {
    return Math.ceil(floatNum - 0.0000001);
  }

  return Math.floor(floatNum + 0.0000001);
}

function hijriToGregorian(hY, hM, hD) {
  hY = parseInt(hY);
  hM = parseInt(hM);
  hD = parseInt(hD);
  var jd,
      l,
      j,
      n,
      i,
      k,
      gregDate = new Array(3);
  jd = intPart((11 * hY + 3) / 30) + 354 * hY + 30 * hM - intPart((hM - 1) / 2) + hD + 1948440 - 385;

  if (jd > 2299160) {
    l = jd + 68569;
    n = intPart(4 * l / 146097);
    l = l - intPart((146097 * n + 3) / 4);
    i = intPart(4000 * (l + 1) / 1461001);
    l = l - intPart(1461 * i / 4) + 31;
    j = intPart(80 * l / 2447);
    hD = l - intPart(2447 * j / 80);
    l = intPart(j / 11);
    hM = j + 2 - 12 * l;
    hY = 100 * (n - 49) + i + l;
  } else {
    j = jd + 1402;
    k = intPart((j - 1) / 1461);
    l = j - 1461 * k;
    n = intPart((l - 1) / 365) - intPart(l / 1461);
    i = l - 365 * n + 30;
    j = intPart(80 * i / 2447);
    hD = i - intPart(2447 * j / 80);
    i = intPart(j / 11);
    hM = j + 2 - 12 * i;
    hY = 4 * k + n + i - 4716;
  }

  gregDate[2] = hD;
  gregDate[1] = hM;
  gregDate[0] = hY;
  return gregDate;
}

function gregorianToHijri(gY, gM, gD) {
  gY = parseInt(gY);
  gM = parseInt(gM);
  gD = parseInt(gD);
  var jd,
      l,
      j,
      n,
      hijriDate = new Array(0, 0, 0);

  if (gY > 1582 || gY == 1582 && gM > 10 || gY == 1582 && gM == 10 && gD > 14) {
    jd = intPart(1461 * (gY + 4800 + intPart((gM - 14) / 12)) / 4) + intPart(367 * (gM - 2 - 12 * intPart((gM - 14) / 12)) / 12) - intPart(3 * intPart((gY + 4900 + intPart((gM - 14) / 12)) / 100) / 4) + gD - 32075;
  } else {
    jd = 367 * gY - intPart(7 * (gY + 5001 + intPart((gM - 9) / 7)) / 4) + intPart(275 * gM / 9) + gD + 1729777;
  }

  l = jd - 1948440 + 10632;
  n = intPart((l - 1) / 10631);
  l = l - 10631 * n + 354;
  j = intPart((10985 - l) / 5316) * intPart(50 * l / 17719) + intPart(l / 5670) * intPart(43 * l / 15238);
  l = l - intPart((30 - j) / 15) * intPart(17719 * j / 50) - intPart(j / 16) * intPart(15238 * j / 43) + 29;
  gM = intPart(24 * l / 709);
  gD = l - intPart(709 * gM / 24);
  gY = 30 * n + j - 30;
  hijriDate[2] = gD;
  hijriDate[1] = gM;
  hijriDate[0] = gY;
  return hijriDate;
}

calendars.hijri = {
  getYear: function getYear(date) {
    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
  },
  getMonth: function getMonth(date) {
    return --gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
  },
  getDay: function getDay(date) {
    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
  },
  getDate: function getDate(y, m, d, h, i, s, u) {
    if (m < 0) {
      y += Math.floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }

    if (m > 11) {
      y += Math.floor(m / 12);
      m = m % 12;
    }

    var gregorianDate = hijriToGregorian(y, +m + 1, d);
    return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
  },
  getMaxDayOfMonth: function getMaxDayOfMonth(hY, hM) {
    if (hM < 0) {
      hY += Math.floor(hM / 12);
      hM = hM % 12 ? 12 + hM % 12 : 0;
    }

    if (hM > 11) {
      hY += Math.floor(hM / 12);
      hM = hM % 12;
    }

    var daysPerMonth = [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
        leapYear = (hY * 11 + 14) % 30 < 11;
    return daysPerMonth[hM] + (hM === 11 && leapYear ? 1 : 0);
  }
};

// Arabic
mobiscroll.i18n.ar = {
  // Core
  rtl: true,
  // Right to left mode
  setText: 'تعيين',
  cancelText: 'إلغاء',
  clearText: 'مسح',
  selectedText: '{count} المحدد',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],
  dayNamesShort: ['أحد', 'اثنين', 'ثلاثاء', 'أربعاء', 'خميس', 'جمعة', 'سبت'],
  dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],
  dayText: 'يوم',
  hourText: 'ساعات',
  minuteText: 'الدقائق',
  monthNames: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
  monthNamesShort: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
  monthText: 'شهر',
  secText: 'ثواني',
  amText: 'ص',
  pmText: 'م',
  timeFormat: 'hh:ii A',
  yearText: 'عام',
  nowText: 'الآن',
  // Calendar component
  firstDay: 0,
  dateText: 'تاريخ',
  timeText: 'وقت',
  closeText: 'إغلاق',
  todayText: 'اليوم',
  prevMonthText: 'الشهر السابق',
  nextMonthText: 'الشهر القادم',
  prevYearText: 'السنه السابقة',
  nextYearText: 'العام القادم',
  allDayText: 'اليوم كله',
  noEventsText: 'لا توجد احداث',
  // Event calendar
  eventText: 'الحدث',
  eventsText: 'أحداث',
  moreEventsText: 'واحد آخر',
  moreEventsPluralText: 'اثنان آخران {count}',
  // Daterange component
  fromText: 'يبدا',
  toText: 'ينتهي',
  // Measurement components
  wholeText: 'كامل',
  fractionText: 'جزء',
  unitText: 'وحدة',
  // Numpad date
  delimiter: '/',
  // Numpad decimal
  decimalSeparator: '.',
  thousandsSeparator: ',',
  // Timer / Timespan component
  labels: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
  labelsShort: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],
  // Timer component
  startText: 'بدء',
  stopText: 'إيقاف',
  resetText: 'إعادة ضبط',
  lapText: 'الدورة',
  hideText: 'إخفاء',
  // Forms
  offText: 'إيقاف',
  onText: 'تشغيل',
  // Listview
  backText: 'رجوع',
  undoText: 'تراجع'
};

// Bulgarian
mobiscroll.i18n.bg = {
  // Core
  setText: 'Задаване',
  cancelText: 'Отмяна',
  clearText: 'Изчистване',
  selectedText: '{count} подбран',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Неделя', 'Понеделник', 'Вторник', 'Сряда', 'Четвъртък', 'Петък', 'Събота'],
  dayNamesShort: ['Нед', 'Пон', 'Вто', 'Сря', 'Чет', 'Пет', 'Съб'],
  dayNamesMin: ['Не', 'По', 'Вт', 'Ср', 'Че', 'Пе', 'Съ'],
  dayText: 'ден',
  delimiter: '.',
  hourText: 'час',
  minuteText: 'минута',
  monthNames: ['Януари', 'Февруари', 'Март', 'Април', 'Май', 'Юни', 'Юли', 'Август', 'Септември', 'Октомври', 'Ноември', 'Декември'],
  monthNamesShort: ['Яну', 'Фев', 'Мар', 'Апр', 'Май', 'Юни', 'Юли', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дек'],
  monthText: 'месец',
  secText: 'секунди',
  timeFormat: 'H:ii',
  yearText: 'година',
  nowText: 'Сега',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'път',
  todayText: 'днес',
  prevMonthText: 'Предишния месец',
  nextMonthText: 'Следващият месец',
  prevYearText: 'Предходната година',
  nextYearText: 'Следващата година',
  closeText: 'затвори',
  eventText: 'Събитие',
  eventsText: 'Събития',
  allDayText: 'Цял ден',
  noEventsText: 'Няма събития',
  moreEventsText: 'Още {count}',
  // Daterange component
  fromText: 'ОТ',
  toText: 'ДО',
  // Measurement components
  wholeText: 'цяло',
  fractionText: 'фракция',
  unitText: 'единица',
  // Time / Timespan component
  labels: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
  labelsShort: ['Години', 'месеца', 'дни', 'часа', 'минути', 'секунди', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: 'Нулиране',
  lapText: 'Обиколка',
  hideText: 'крия',
  // Listview
  backText: 'връщане',
  undoText: 'ОТМЯНА',
  // Form
  offText: 'ИЗКЛ',
  onText: 'ВКЛ',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Català
mobiscroll.i18n.ca = {
  // Core
  setText: 'Acceptar',
  cancelText: 'Cancel·lar',
  clearText: 'Esborrar',
  selectedText: '{count} seleccionat',
  selectedPluralText: '{count} seleccionats',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
  dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
  dayText: 'Dia',
  hourText: 'Hores',
  minuteText: 'Minuts',
  monthNames: ['Gener', 'Febrer', 'Març', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
  monthText: 'Mes',
  secText: 'Segons',
  timeFormat: 'HH:ii',
  yearText: 'Any',
  nowText: 'Ara',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Avui',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Temps',
  closeText: 'Tancar',
  allDayText: 'Tot el dia',
  noEventsText: 'Cap esdeveniment',
  eventText: 'Esdeveniments',
  eventsText: 'Esdeveniments',
  moreEventsText: '{count} més',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Sencer',
  fractionText: 'Fracció',
  unitText: 'Unitat',
  // Time / Timespan component
  labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
  labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Aturar',
  resetText: 'Reiniciar',
  lapText: 'Volta',
  hideText: 'Amagar',
  // Listview
  backText: 'Enrere',
  undoText: 'Desfés',
  // Form
  offText: 'No',
  onText: 'Si'
};

// Cestina
mobiscroll.i18n.cs = {
  // Core
  setText: 'Zadej',
  cancelText: 'Storno',
  clearText: 'Vymazat',
  selectedText: 'Označený: {count}',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Neděle', 'Pondělí', 'Úterý', 'Středa', 'Čtvrtek', 'Pátek', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 'Út', 'St', 'Čt', 'Pá', 'So'],
  dayNamesMin: ['N', 'P', 'Ú', 'S', 'Č', 'P', 'S'],
  dayText: 'Den',
  hourText: 'Hodiny',
  minuteText: 'Minuty',
  monthNames: ['Leden', 'Únor', 'Březen', 'Duben', 'Květen', 'Červen', 'Červenec', 'Srpen', 'Září', 'Říjen', 'Listopad', 'Prosinec'],
  monthNamesShort: ['Led', 'Úno', 'Bře', 'Dub', 'Kvě', 'Čer', 'Čvc', 'Spr', 'Zář', 'Říj', 'Lis', 'Pro'],
  monthText: 'Měsíc',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Teď',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Čas',
  closeText: 'Zavřít',
  allDayText: 'Celý den',
  noEventsText: 'Žádné události',
  eventText: 'Událostí',
  eventsText: 'Události',
  moreEventsText: '{count} další',
  // Daterange component
  fromText: 'Začátek',
  toText: 'Konec',
  // Measurement components
  wholeText: 'Celý',
  fractionText: 'Část',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Měsíce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Měs', 'Dny', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetovat',
  lapText: 'Etapa',
  hideText: 'Schovat',
  // Listview
  backText: 'Zpět',
  undoText: 'Zpět',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Dansk
mobiscroll.i18n.da = {
  // Core
  setText: 'Sæt',
  cancelText: 'Annuller',
  clearText: 'Ryd',
  selectedText: '{count} valgt',
  selectedPluralText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
  dayNamesShort: ['Søn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timer',
  minuteText: 'Minutter',
  monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Måned',
  secText: 'Sekunder',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH.ii',
  yearText: 'År',
  nowText: 'Nu',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Luk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen begivenheder',
  eventText: 'Begivenheder',
  eventsText: 'Begivenheder',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Dele',
  unitText: 'Enhed',
  // Time / Timespan component
  labels: ['År', 'Måneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['År', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Nulstil',
  lapText: 'Omgang',
  hideText: 'Skjul',
  // Forms
  offText: 'Fra',
  onText: 'Til',
  // Listview
  backText: 'Tilbage',
  undoText: 'Fortryd'
};

// Deutsch
mobiscroll.i18n.de = {
  // Core
  setText: 'OK',
  cancelText: 'Abbrechen',
  clearText: 'Löschen',
  selectedText: '{count} ausgewählt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
  dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
  dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
  dayText: 'Tag',
  delimiter: '.',
  hourText: 'Stunde',
  minuteText: 'Minuten',
  monthNames: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
  monthNamesShort: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
  monthText: 'Monat',
  secText: 'Sekunden',
  timeFormat: 'HH:ii',
  yearText: 'Jahr',
  nowText: 'Jetzt',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Heute',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Zeit',
  closeText: 'Schließen',
  allDayText: 'Ganztägig',
  noEventsText: 'Keine Ereignisse',
  eventText: 'Ereignis',
  eventsText: 'Ereignisse',
  moreEventsText: '{count} weiteres Element',
  moreEventsPluralText: '{count} weitere Elemente',
  // Daterange component
  fromText: 'Von',
  toText: 'Bis',
  // Measurement components
  wholeText: 'Ganze Zahl',
  fractionText: 'Bruchzahl',
  unitText: 'Maßeinheit',
  // Time / Timespan component
  labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
  labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
  // Timer component
  startText: 'Starten',
  stopText: 'Stoppen',
  resetText: 'Zurücksetzen',
  lapText: 'Lap',
  hideText: 'Ausblenden',
  // Listview
  backText: 'Zurück',
  undoText: 'Rückgängig machen',
  // Form
  offText: 'Aus',
  onText: 'Ein',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Greek
mobiscroll.i18n.el = {
  // Core
  setText: 'Ορισμος',
  cancelText: 'Ακυρωση',
  clearText: 'Διαγραφη',
  selectedText: '{count} επιλεγμένα',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Κυριακή', 'Δευτέρα', 'Τρίτη', 'Τετάρτη', 'Πέμπτη', 'Παρασκευή', 'Σάββατο'],
  dayNamesShort: ['Κυρ', 'Δευ', 'Τρι', 'Τετ', 'Πεμ', 'Παρ', 'Σαβ'],
  dayNamesMin: ['Κυ', 'Δε', 'Τρ', 'Τε', 'Πε', 'Πα', 'Σα'],
  dayText: 'ημέρα',
  delimiter: '/',
  hourText: 'ώρα',
  minuteText: 'λεπτό',
  monthNames: ['Ιανουάριος', 'Φεβρουάριος', 'Μάρτιος', 'Απρίλιος', 'Μάιος', 'Ιούνιος', 'Ιούλιος', 'Αύγουστος', 'Σεπτέμβριος', 'Οκτώβριος', 'Νοέμβριος', 'Δεκέμβριος'],
  monthNamesShort: ['Ιαν', 'Φεβ', 'Μαρ', 'Απρ', 'Μαι', 'Ιουν', 'Ιουλ', 'Αυγ', 'Σεπ', 'Οκτ', 'Νοε', 'Δεκ'],
  monthText: 'Μήνας',
  secText: 'δευτερόλεπτα',
  timeFormat: 'H:ii',
  yearText: 'έτος',
  nowText: 'τώρα',
  pmText: 'μμ',
  amText: 'πμ',
  // Calendar component
  firstDay: 1,
  dateText: 'Ημερομηνία',
  timeText: 'φορά',
  todayText: 'Σήμερα',
  prevMonthText: 'Προηγούμενο μήνα',
  nextMonthText: 'Επόμενο μήνα',
  prevYearText: 'Προηγούμενο έτος',
  nextYearText: 'Επόμενο έτος',
  closeText: 'Κλείσιμο',
  eventText: 'Γεγονότα',
  eventsText: 'Γεγονότα',
  allDayText: 'Ολοήμερο',
  noEventsText: 'Δεν υπάρχουν γεγονότα',
  moreEventsText: '{count} ακόμη',
  // Daterange component
  fromText: 'Αρχή',
  toText: 'Τέλος',
  // Measurement components
  wholeText: 'Ολόκληρος',
  fractionText: 'κλάσμα',
  unitText: 'Μονάδα',
  // Time / Timespan component
  labels: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτερόλεπτα', ''],
  labelsShort: ['Χρόνια', 'Μήνες', 'Ημέρες', 'Ωρες', 'Λεπτά', 'δευτ', ''],
  // Timer component
  startText: '΄Εναρξη',
  stopText: 'Διακοπή',
  resetText: 'Επαναφορά',
  lapText: 'Γύρος',
  hideText: 'κρύβω',
  // Listview
  backText: 'Πίσω',
  undoText: 'Αναιρεση',
  // Form
  offText: 'Ανενεργό',
  onText: 'Ενεργό',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// English (UK)
mobiscroll.i18n['en-GB'] = mobiscroll.i18n['en-UK'] = {
  dateFormat: 'dd/mm/yy',
  timeFormat: 'HH:ii'
};

// Español
mobiscroll.i18n.es = {
  // Core
  setText: 'Aceptar',
  cancelText: 'Cancelar',
  clearText: 'Borrar',
  selectedText: '{count} seleccionado',
  selectedPluralText: '{count} seleccionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Día',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
  monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
  monthText: 'Mes',
  secText: 'Segundos',
  timeFormat: 'HH:ii',
  yearText: 'A&ntilde;o',
  nowText: 'Ahora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Fecha',
  timeText: 'Tiempo',
  closeText: 'Cerrar',
  allDayText: 'Todo el día',
  noEventsText: 'No hay eventos',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: '{count} más',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Entero',
  fractionText: 'Fracción',
  unitText: 'Unidad',
  // Time / Timespan component
  labels: ['Años', 'Meses', 'Días', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Año', 'Mes', 'Día', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Deténgase',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Atrás',
  undoText: 'Deshacer',
  // Form
  offText: 'No',
  onText: 'Sí',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// فارسی
var gDaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    jDaysInMonth = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];

function jalaliToGregorian(jY, jM, jD) {
  jY = parseInt(jY);
  jM = parseInt(jM);
  jD = parseInt(jD);
  var i;
  var jy = jY - 979;
  var jm = jM - 1;
  var jd = jD - 1;
  var jDayNo = 365 * jy + parseInt(jy / 33) * 8 + parseInt((jy % 33 + 3) / 4);

  for (i = 0; i < jm; ++i) {
    jDayNo += jDaysInMonth[i];
  }

  jDayNo += jd;
  var gDayNo = jDayNo + 79;
  var gy = 1600 + 400 * parseInt(gDayNo / 146097);
  gDayNo = gDayNo % 146097;
  var leap = true;

  if (gDayNo >= 36525) {
    gDayNo--;
    gy += 100 * parseInt(gDayNo / 36524);
    gDayNo = gDayNo % 36524;

    if (gDayNo >= 365) {
      gDayNo++;
    } else {
      leap = false;
    }
  }

  gy += 4 * parseInt(gDayNo / 1461);
  gDayNo %= 1461;

  if (gDayNo >= 366) {
    leap = false;
    gDayNo--;
    gy += parseInt(gDayNo / 365);
    gDayNo = gDayNo % 365;
  }

  for (i = 0; gDayNo >= gDaysInMonth[i] + (i == 1 && leap); i++) {
    gDayNo -= gDaysInMonth[i] + (i == 1 && leap);
  }

  var gm = i + 1;
  var gd = gDayNo + 1;
  return [gy, gm, gd];
}

function checkDate(jY, jM, jD) {
  return !(jY < 0 || jY > 32767 || jM < 1 || jM > 12 || jD < 1 || jD > jDaysInMonth[jM - 1] + (jM == 12 && (jY - 979) % 33 % 4 === 0));
}

function gregorianToJalali(gY, gM, gD) {
  gY = parseInt(gY);
  gM = parseInt(gM);
  gD = parseInt(gD);
  var i;
  var gy = gY - 1600;
  var gm = gM - 1;
  var gd = gD - 1;
  var gDayNo = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400);

  for (i = 0; i < gm; ++i) {
    gDayNo += gDaysInMonth[i];
  }

  if (gm > 1 && (gy % 4 === 0 && gy % 100 !== 0 || gy % 400 === 0)) {
    ++gDayNo;
  }

  gDayNo += gd;
  var jDayNo = gDayNo - 79;
  var jNp = parseInt(jDayNo / 12053);
  jDayNo %= 12053;
  var jy = 979 + 33 * jNp + 4 * parseInt(jDayNo / 1461);
  jDayNo %= 1461;

  if (jDayNo >= 366) {
    jy += parseInt((jDayNo - 1) / 365);
    jDayNo = (jDayNo - 1) % 365;
  }

  for (i = 0; i < 11 && jDayNo >= jDaysInMonth[i]; ++i) {
    jDayNo -= jDaysInMonth[i];
  }

  var jm = i + 1;
  var jd = jDayNo + 1;
  return [jy, jm, jd];
}

calendars.jalali = {
  getYear: function getYear(date) {
    return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
  },
  getMonth: function getMonth(date) {
    return --gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
  },
  getDay: function getDay(date) {
    return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
  },
  getDate: function getDate(y, m, d, h, i, s, u) {
    if (m < 0) {
      y += Math.floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }

    if (m > 11) {
      y += Math.floor(m / 12);
      m = m % 12;
    }

    var gregorianDate = jalaliToGregorian(y, +m + 1, d);
    return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
  },
  getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
    var maxdays = 31;

    if (m < 0) {
      y += Math.floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }

    if (m > 11) {
      y += Math.floor(m / 12);
      m = m % 12;
    }

    while (checkDate(y, m + 1, maxdays) === false) {
      maxdays--;
    }

    return maxdays;
  }
};

// فارسی
mobiscroll.i18n.fa = {
  // Core
  setText: 'تاييد',
  cancelText: 'انصراف',
  clearText: 'واضح ',
  selectedText: '{count} منتخب',
  // Datetime component
  calendarSystem: 'jalali',
  dateFormat: 'yy/mm/dd',
  dayNames: ['يکشنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه'],
  dayNamesShort: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
  dayNamesMin: ['ی', 'د', 'س', 'چ', 'پ', 'ج', 'ش'],
  dayText: 'روز',
  hourText: 'ساعت',
  minuteText: 'دقيقه',
  monthNames: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
  monthNamesShort: ['فروردين', 'ارديبهشت', 'خرداد', 'تير', 'مرداد', 'شهريور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
  monthText: 'ماه',
  secText: 'ثانيه',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: 'سال',
  nowText: 'اکنون',
  amText: 'ب',
  pmText: 'ص',
  todayText: 'امروز',
  //getNumber: function (n) {
  //    var i,
  //        nums = ["۰", "۱", "۲", "۳", "۴", "۵", "۶", "۷", "۸", "۹"],
  //        res = '';
  //    n = n + '';
  //    for (i = 0; i < n.length; i++) {
  //        res += nums[+n[i]];
  //    }
  //    return res;
  //},
  // Calendar component
  firstDay: 6,
  rtl: true,
  dateText: 'تاریخ ',
  timeText: 'زمان ',
  closeText: 'نزدیک',
  allDayText: 'تمام روز',
  noEventsText: 'هیچ رویداد',
  eventText: 'رویداد',
  eventsText: 'رویدادها',
  moreEventsText: '{count} مورد دیگر',
  // Daterange component
  fromText: 'شروع ',
  toText: 'پایان',
  // Measurement components
  wholeText: 'تمام',
  fractionText: 'کسر',
  unitText: 'واحد',
  // Time / Timespan component
  labels: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
  labelsShort: ['سال', 'ماه', 'روز', 'ساعت', 'دقیقه', 'ثانیه', ''],
  // Timer component
  startText: 'شروع',
  stopText: 'پايان',
  resetText: 'تنظیم مجدد',
  lapText: 'Lap',
  hideText: 'پنهان کردن',
  // Listview
  backText: 'پشت',
  undoText: 'واچیدن'
};

// Suomi
mobiscroll.i18n.fi = {
  // Core
  setText: 'Aseta',
  cancelText: 'Peruuta',
  clearText: 'Tyhjennä',
  selectedText: '{count} valita',
  // Datetime component
  dateFormat: 'd. MM yy',
  dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
  dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
  dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
  dayText: 'Päivä',
  delimiter: '.',
  hourText: 'Tuntia',
  minuteText: 'Minuutti',
  monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Kesäkuu', 'Heinäkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
  monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
  monthText: 'Kuukausi',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Vuosi',
  nowText: 'Nyt',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Päiväys',
  timeText: 'Aika',
  todayText: 'Tänään',
  prevMonthText: 'Edellinen kuukausi',
  nextMonthText: 'Ensi kuussa',
  prevYearText: 'Edellinen vuosi',
  nextYearText: 'Ensi vuosi',
  closeText: 'Sulje',
  eventText: 'Tapahtumia',
  eventsText: 'Tapahtumia',
  allDayText: 'Koko päivä',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} muu',
  moreEventsPluralText: '{count} muuta',
  // Daterange component
  fromText: 'Alkaa',
  toText: 'Päättyy',
  // Measurement components
  wholeText: 'Kokonainen',
  fractionText: 'Murtoluku',
  unitText: 'Yksikkö',
  // Time / Timespan component
  labels: ['Vuosi', 'Kuukausi', 'Päivä', 'Tunnin', 'Minuutti', 'sekuntia', ''],
  labelsShort: ['Vuo', 'Kuu', 'Päi', 'Tun', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Käynnistys',
  stopText: 'Seis',
  resetText: 'Aseta uudelleen',
  lapText: 'Kierros',
  hideText: 'Vuota',
  // Listview
  backText: 'Edellinen',
  undoText: 'Kumoa',
  // Form
  offText: 'Pois',
  onText: 'Päällä',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Français
mobiscroll.i18n.fr = {
  // Core
  setText: 'Terminer',
  cancelText: 'Annuler',
  clearText: 'Effacer',
  selectedText: '{count} sélectionné',
  selectedPluralText: '{count} sélectionnés',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
  dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Jour',
  monthText: 'Mois',
  monthNames: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
  monthNamesShort: ['Janv.', 'Févr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Août', 'Sept.', 'Oct.', 'Nov.', 'Déc.'],
  hourText: 'Heures',
  minuteText: 'Minutes',
  secText: 'Secondes',
  timeFormat: 'HH:ii',
  yearText: 'Année',
  nowText: 'Maintenant',
  pmText: 'pm',
  amText: 'am',
  todayText: "Aujourd'hui",
  // Calendar component
  firstDay: 1,
  dateText: 'Date',
  timeText: 'Heure',
  closeText: 'Fermer',
  allDayText: 'Toute la journée',
  noEventsText: 'Aucun événement',
  eventText: 'Événement',
  eventsText: 'Événements',
  moreEventsText: '{count} autre',
  moreEventsPluralText: '{count} autres',
  // Daterange component
  fromText: 'Démarrer',
  toText: 'Fin',
  // Measurement components
  wholeText: 'Entier',
  fractionText: 'Fraction',
  unitText: 'Unité',
  // Time / Timespan component
  labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
  labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Démarrer',
  stopText: 'Arrêter',
  resetText: 'Réinitialiser',
  lapText: 'Lap',
  hideText: 'Cachez',
  // Listview
  backText: 'Retour',
  undoText: 'Annuler',
  // Form
  offText: 'Non',
  onText: 'Oui',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Hebrew
mobiscroll.i18n.he = {
  // Core
  rtl: true,
  // Right to left mode
  setText: 'שמירה',
  cancelText: 'ביטול',
  clearText: 'נקה',
  selectedText: '{count} נבחר',
  selectedPluralText: '{count} נבחרו',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['ראשון', 'שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת'],
  dayNamesShort: ["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "ש'"],
  dayNamesMin: ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ש'],
  dayText: 'יום',
  hourText: 'שעות',
  minuteText: 'דקות',
  monthNames: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
  monthNamesShort: ["ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ"],
  monthText: 'חודש',
  secText: 'שניות',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  timeWheels: 'iiHH',
  // Need this for correct RTL display
  yearText: 'שנה',
  nowText: 'עכשיו',
  // Calendar component
  firstDay: 0,
  dateText: 'תאריך',
  timeText: 'זמן',
  closeText: 'סגירה',
  todayText: 'היום',
  allDayText: 'כל היום',
  noEventsText: 'אין אירועים',
  // Event calendar
  eventText: 'מִקרֶה',
  eventsText: 'מִקרֶה',
  moreEventsText: 'אירוע אחד נוסף',
  moreEventsPluralText: '{count} אירועים נוספים',
  // Daterange component
  fromText: 'התחלה',
  toText: 'סיום',
  // Measurement components
  wholeText: 'כֹּל',
  fractionText: 'שבריר',
  unitText: 'יחידה',
  // Time / Timespan component
  labels: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
  labelsShort: ['שנים', 'חודשים', 'ימים', 'שעות', 'דקות', 'שניים', ''],
  // Timer component
  startText: 'התחל',
  stopText: 'עצור',
  resetText: 'אתחול',
  lapText: 'הקפה',
  hideText: 'הסתר',
  // Forms
  offText: 'כיבוי',
  onText: 'הפעלה',
  // Listview
  backText: 'חזור',
  undoText: 'ביטול פעולה'
};

// Hindi
mobiscroll.i18n.hi = {
  // Core
  setText: 'सैट करें',
  cancelText: 'रद्द करें',
  clearText: 'साफ़ को',
  selectedText: '{count} चयनित',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
  dayNamesShort: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
  dayNamesMin: ['रवि', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि'],
  dayText: 'दिन',
  delimiter: '.',
  hourText: 'घंटा',
  minuteText: 'मिनट',
  monthNames: ['जनवरी ', 'फरवरी', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अगस्त ', 'सितम्बर', 'अक्टूबर', 'नवम्बर', 'दिसम्बर'],
  monthNamesShort: ['जन', 'फर', 'मार्च', 'अप्रेल', 'मई', 'जून', 'जूलाई', 'अग', 'सित', 'अक्ट', 'नव', 'दि'],
  monthText: 'महीना',
  secText: 'सेकंड',
  timeFormat: 'H:ii',
  yearText: 'साल',
  nowText: 'अब',
  pmText: 'अपराह्न',
  amText: 'पूर्वाह्न',
  // Calendar component
  firstDay: 1,
  dateText: 'तिथि',
  timeText: 'समय',
  todayText: 'आज',
  prevMonthText: 'पिछ्ला महिना',
  nextMonthText: 'अगले महीने',
  prevYearText: 'पिछला साल',
  nextYearText: 'अगले वर्ष',
  closeText: 'बंद',
  eventText: 'इवेट३',
  eventsText: 'इवेट३',
  allDayText: 'पूरे दिन',
  noEventsText: 'Ei tapahtumia',
  moreEventsText: '{count} और',
  // Daterange component
  fromText: 'से',
  toText: 'तक',
  // Measurement components
  wholeText: 'समूचा',
  fractionText: 'अंश',
  unitText: 'इकाई',
  // Time / Timespan component
  labels: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
  labelsShort: ['साल', 'महीने', 'दिन', 'घंटे', 'मिनट', 'सेकंड', ''],
  // Timer component
  startText: 'प्रारंभ',
  stopText: 'रोकें',
  resetText: 'रीसेट करें',
  lapText: 'लैप',
  hideText: 'छिपाना',
  // Listview
  backText: 'वापस',
  // check
  undoText: 'वापस लाएं',
  // Form
  offText: 'बंद',
  onText: 'चालू',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Croatian
mobiscroll.i18n.hr = {
  // Core
  setText: 'Postavi',
  cancelText: 'Izlaz',
  clearText: 'Izbriši',
  selectedText: '{count} odabran',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'Četvrtak', 'Petak', 'Subota'],
  dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'Čet', 'Pet', 'Sub'],
  dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'Če', 'Pe', 'Su'],
  dayText: 'Dan',
  delimiter: '.',
  hourText: 'Sat',
  minuteText: 'Minuta',
  monthNames: ['Siječanj', 'Veljača', 'Ožujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
  monthNamesShort: ['Sij', 'Velj', 'Ožu', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
  monthText: 'Mjesec',
  secText: 'Sekunda',
  timeFormat: 'H:ii',
  yearText: 'Godina',
  nowText: 'Sada',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Vrijeme',
  todayText: 'Danas',
  prevMonthText: 'Prethodni mjesec',
  nextMonthText: 'Sljedeći mjesec',
  prevYearText: 'Prethodni godina',
  nextYearText: 'Slijedeće godine',
  closeText: 'Zatvori',
  eventText: 'Događaj',
  eventsText: 'događaja',
  allDayText: 'Cijeli dan',
  noEventsText: 'Bez događaja',
  moreEventsText: 'Još {count}',
  // Daterange component
  fromText: 'Počinje',
  toText: 'Završava',
  // Measurement components
  wholeText: 'Cjelina',
  fractionText: 'Frakcija',
  unitText: 'Jedinica',
  // Time / Timespan component
  labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
  labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
  // Timer component
  startText: 'Početak',
  stopText: 'Prekid',
  resetText: 'Resetiraj',
  lapText: 'Ciklus',
  hideText: 'Sakriti',
  // Listview
  backText: 'Natrag',
  undoText: 'Poništavanje',
  // Form
  offText: 'Uklj.',
  onText: 'Isklj.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Magyar
mobiscroll.i18n.hu = {
  // Core
  setText: 'OK',
  cancelText: 'Mégse',
  clearText: 'Törlés',
  selectedText: '{count} kiválasztva',
  // Datetime component
  dateFormat: 'yy.mm.dd.',
  dayNames: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
  dayNamesShort: ['Va', 'Hé', 'Ke', 'Sze', 'Csü', 'Pé', 'Szo'],
  dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
  dayText: 'Nap',
  delimiter: '.',
  hourText: 'Óra',
  minuteText: 'Perc',
  monthNames: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Hónap',
  secText: 'Másodperc',
  timeFormat: 'H:ii',
  yearText: 'Év',
  nowText: 'Most',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Dátum',
  timeText: 'Idő',
  todayText: 'Ma',
  prevMonthText: 'Előző hónap',
  nextMonthText: 'Következő hónap',
  prevYearText: 'Előző év',
  nextYearText: 'Következő év',
  closeText: 'Bezár',
  eventText: 'esemény',
  eventsText: 'esemény',
  allDayText: 'Egész nap',
  noEventsText: 'Nincs esemény',
  moreEventsText: '{count} további',
  // Daterange component
  fromText: 'Eleje',
  toText: 'Vége',
  // Measurement components
  wholeText: 'Egész',
  fractionText: 'Tört',
  unitText: 'Egység',
  // Time / Timespan component
  labels: ['Év', 'Hónap', 'Nap', 'Óra', 'Perc', 'Másodperc', ''],
  labelsShort: ['Év', 'Hó.', 'Nap', 'Óra', 'Perc', 'Mp.', ''],
  // Timer component
  startText: 'Indít',
  stopText: 'Megállít',
  resetText: 'Visszaállít',
  lapText: 'Lap',
  hideText: 'Elrejt',
  // Listview
  backText: 'Vissza',
  undoText: 'Visszavon',
  // Form
  offText: 'Ki',
  onText: 'Be',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Italiano 
mobiscroll.i18n.it = {
  // Core
  setText: 'OK',
  cancelText: 'Annulla',
  clearText: 'Chiarire',
  selectedText: '{count} selezionato',
  selectedPluralText: '{count} selezionati',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
  dayText: 'Giorno',
  hourText: 'Ore',
  minuteText: 'Minuti',
  monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
  monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
  monthText: 'Mese',
  secText: 'Secondi',
  timeFormat: 'HH:ii',
  yearText: 'Anno',
  nowText: 'Ora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Oggi',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Volta',
  closeText: 'Chiudere',
  allDayText: 'Tutto il giorno',
  noEventsText: 'Nessun evento',
  eventText: 'Evento',
  eventsText: 'Eventi',
  moreEventsText: '{count} altro',
  moreEventsPluralText: 'altri {count}',
  // Daterange component
  fromText: 'Inizio',
  toText: 'Fine',
  // Measurement components
  wholeText: 'Intero',
  fractionText: 'Frazione',
  unitText: 'Unità',
  // Time / Timespan component
  labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
  labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Inizio',
  stopText: 'Arresto',
  resetText: 'Ripristina',
  lapText: 'Lap',
  hideText: 'Nascondi',
  // Listview
  backText: 'Indietro',
  undoText: 'Annulla',
  // Form
  offText: 'Via',
  onText: 'Su',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// 日本語 - Japanese
mobiscroll.i18n.ja = {
  // Core
  setText: 'セット',
  cancelText: 'キャンセル',
  clearText: 'クリア',
  selectedText: '{count} 選択',
  // Datetime component
  dateFormat: 'yy年mm月dd日',
  dayNames: ['日', '月', '火', '水', '木', '金', '土'],
  dayNamesShort: ['日', '月', '火', '水', '木', '金', '土'],
  dayNamesMin: ['日', '月', '火', '水', '木', '金', '土'],
  dayText: '日',
  hourText: '時',
  minuteText: '分',
  monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthNamesShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthText: '月',
  secText: '秒',
  timeFormat: 'HH:ii',
  yearText: '年',
  nowText: '今',
  pmText: '午後',
  amText: '午前',
  yearSuffix: '年',
  monthSuffix: '月',
  daySuffix: '日',
  todayText: '今日',
  // Calendar component
  dateText: '日付',
  timeText: '時間',
  closeText: 'クローズ',
  allDayText: '終日',
  noEventsText: 'イベントはありません',
  eventText: 'イベント',
  eventsText: 'イベント',
  moreEventsText: '他 {count} 件',
  // Daterange component
  fromText: '開始',
  toText: '終わり',
  // Measurement components
  wholeText: '全数',
  fractionText: '分数',
  unitText: '単位',
  // Time / Timespan component
  labels: ['年間', '月間', '日間', '時間', '分', '秒', ''],
  labelsShort: ['年間', '月間', '日間', '時間', '分', '秒', ''],
  // Timer component
  startText: '開始',
  stopText: '停止',
  resetText: 'リセット',
  lapText: 'ラップ',
  hideText: '隠す',
  // Listview
  backText: 'バック',
  undoText: 'アンドゥ'
};

// Korean
mobiscroll.i18n.ko = {
  // Core
  setText: '설정',
  cancelText: '취소',
  clearText: '삭제',
  selectedText: '{count} 선택된',
  // Datetime component
  dateFormat: 'yy년mm월dd일',
  dayNames: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'],
  dayNamesShort: ['일', '월', '화', '수', '목', '금', '토'],
  dayNamesMin: ['일', '월', '화', '수', '목', '금', '토'],
  dayText: '일',
  delimiter: '-',
  hourText: '시간',
  minuteText: '분',
  monthNames: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
  monthNamesShort: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'],
  monthText: '달',
  secText: '초',
  timeFormat: 'H:ii',
  yearText: '년',
  nowText: '지금',
  pmText: '오후',
  amText: '오전',
  yearSuffix: '년',
  monthSuffix: '월',
  daySuffix: '일',
  // Calendar component
  firstDay: 0,
  dateText: '날짜',
  timeText: '시간',
  todayText: '오늘',
  prevMonthText: '이전 달',
  nextMonthText: '다음 달',
  prevYearText: '이전 년',
  nextYearText: '다음 년',
  closeText: '닫기',
  eventText: '이벤트',
  eventsText: '이벤트',
  allDayText: '종일',
  noEventsText: '이벤트 없음',
  moreEventsText: '{count}개 더보기',
  // Daterange component
  fromText: '시작',
  toText: '종료',
  // Measurement components
  wholeText: '정수',
  fractionText: '분수',
  unitText: '단위',
  // Time / Timespan component
  labels: ['년', '달', '일', '시간', '분', '초', ''],
  labelsShort: ['년', '달', '일', '시간', '분', '초', ''],
  // Timer component
  startText: '시작',
  stopText: '중지 ',
  resetText: '초기화',
  lapText: '기록',
  hideText: '숨는 장소',
  // Listview
  backText: '뒤로',
  undoText: '실행취소',
  // Form
  offText: '끔',
  onText: '켬',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Lietuvių
mobiscroll.i18n.lt = {
  // Core
  setText: 'OK',
  cancelText: 'Atšaukti',
  clearText: 'Išvalyti',
  selectedText: 'Pasirinktas {count}',
  selectedPluralText: 'Pasirinkti {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Trečiadienis', 'Ketvirtadienis', 'Penktadienis', 'Šeštadienis'],
  dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
  dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', 'Š'],
  dayText: 'Diena',
  hourText: 'Valanda',
  minuteText: 'Minutes',
  monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegužė', 'Birželis', 'Liepa', 'Rugpjūtis', 'Rugsėjis', 'Spalis', 'Lapkritis', 'Gruodis'],
  monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
  monthText: 'Mėnuo',
  secText: 'Sekundes',
  amText: 'am',
  pmText: 'pm',
  timeFormat: 'HH:ii',
  yearText: 'Metai',
  nowText: 'Dabar',
  todayText: 'Šiandien',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Laikas',
  closeText: 'Uždaryti',
  allDayText: 'Visą dieną',
  noEventsText: 'Nėra įvykių',
  eventText: 'Įvykių',
  eventsText: 'Įvykiai',
  moreEventsText: 'Dar {count}',
  // Daterange component
  fromText: 'Nuo',
  toText: 'Iki',
  // Measurement components
  wholeText: 'Visas',
  fractionText: 'Frakcija',
  unitText: 'Vienetas',
  // Time / Timespan component
  labels: ['Metai', 'Mėnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
  labelsShort: ['m', 'mėn.', 'd', 'h', 'min', 's', ''],
  // Timer component
  startText: 'Pradėti',
  stopText: 'Sustabdyti',
  resetText: 'Išnaujo',
  lapText: 'Ratas',
  hideText: 'Slėpti',
  // Listview
  backText: 'Atgal',
  undoText: 'Anuliuoti',
  // Form
  offText: 'Išj.',
  onText: 'Įj.',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Nederlands
mobiscroll.i18n.nl = {
  // Core
  setText: 'Instellen',
  cancelText: 'Annuleren',
  clearText: 'Leegmaken',
  selectedText: '{count} gekozen',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
  dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
  dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
  dayText: 'Dag',
  hourText: 'Uur',
  minuteText: 'Minuten',
  monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
  monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
  monthText: 'Maand',
  secText: 'Seconden',
  timeFormat: 'HH:ii',
  yearText: 'Jaar',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Vandaag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tijd',
  closeText: 'Sluiten',
  allDayText: 'Hele dag',
  noEventsText: 'Geen activiteiten',
  eventText: 'Activiteit',
  eventsText: 'Activiteiten',
  moreEventsText: 'nog {count}',
  // Daterange component
  fromText: 'Start',
  toText: 'Einde',
  // Measurement components
  wholeText: 'geheel',
  fractionText: 'fractie',
  unitText: 'eenheid',
  // Time / Timespan component
  labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
  labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Reset',
  lapText: 'Ronde',
  hideText: 'Verbergen',
  // Listview
  backText: 'Terug',
  undoText: 'Onged. maken',
  // Form
  offText: 'Uit',
  onText: 'Aan',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Norsk
mobiscroll.i18n.no = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Tømme',
  selectedText: '{count} valgt',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'],
  dayNamesShort: ['Sø', 'Ma', 'Ti', 'On', 'To', 'Fr', 'Lø'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  delimiter: '.',
  hourText: 'Time',
  minuteText: 'Minutt',
  monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
  monthText: 'Måned',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'År',
  nowText: 'Nå',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Dato',
  timeText: 'Tid',
  closeText: 'Lukk',
  allDayText: 'Hele dagen',
  noEventsText: 'Ingen hendelser',
  eventText: 'Hendelse',
  eventsText: 'Hendelser',
  moreEventsText: '{count} mere',
  // Daterange component
  fromText: 'Start',
  toText: 'End',
  // Measurement components
  wholeText: 'Hele',
  fractionText: 'Fraksjon',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['År', 'Måneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
  labelsShort: ['År', 'Mån', 'Dag', 'Time', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'Tilbakestille',
  lapText: 'Runde',
  hideText: 'Skjul',
  // Listview
  backText: 'Tilbake',
  undoText: 'Angre',
  // Form
  offText: 'Av',
  onText: 'På',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Polski
mobiscroll.i18n.pl = {
  // Core
  setText: 'Zestaw',
  cancelText: 'Anuluj',
  clearText: 'Oczyścić',
  selectedText: 'Wybór: {count}',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'],
  dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'Śr.', 'Czw.', 'Pt.', 'Sob.'],
  dayNamesMin: ['N', 'P', 'W', 'Ś', 'C', 'P', 'S'],
  dayText: 'Dzień',
  hourText: 'Godziny',
  minuteText: 'Minuty',
  monthNames: ['Styczeń', 'Luty', 'Marzec', 'Kwiecień', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpień', 'Wrzesień', 'Październik', 'Listopad', 'Grudzień'],
  monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Paź', 'Lis', 'Gru'],
  monthText: 'Miesiąc',
  secText: 'Sekundy',
  timeFormat: 'HH:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dzisiaj',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Czas',
  closeText: 'Zakończenie',
  allDayText: 'Cały dzień',
  noEventsText: 'Brak wydarzeń',
  eventText: 'Wydarzeń',
  eventsText: 'Wydarzenia',
  moreEventsText: 'Jeszcze {count}',
  // Daterange component
  fromText: 'Rozpoczęcie',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Cały',
  fractionText: 'Ułamek',
  unitText: 'Jednostka',
  // Time / Timespan component
  labels: ['Lata', 'Miesiąc', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
  labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Rozpoczęcie',
  stopText: 'Zatrzymać',
  resetText: 'Zresetować',
  lapText: 'Zakładka',
  hideText: 'Ukryć',
  // Listview
  backText: 'Wróć',
  undoText: 'Cofnij',
  // Form
  offText: 'Wył',
  onText: 'Wł',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Português Brasileiro
mobiscroll.i18n['pt-BR'] = {
  // Core
  setText: 'Selecionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Hora',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Mês',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Agora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoje',
  // Calendar component
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Dia inteiro',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'Mais {count}',
  // Daterange component
  fromText: 'In&iacute;cio',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Fração',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Começar',
  stopText: 'Pare',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Desfazer',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Português Europeu
mobiscroll.i18n['pt-PT'] = {
  // Core
  setText: 'Seleccionar',
  cancelText: 'Cancelar',
  clearText: 'Claro',
  selectedText: '{count} selecionado',
  selectedPluralText: '{count} selecionados',
  // Datetime component
  dateFormat: 'dd-mm-yy',
  dayNames: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
  dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'],
  dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
  dayText: 'Dia',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
  monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
  monthText: 'Mês',
  secText: 'Segundo',
  timeFormat: 'HH:ii',
  yearText: 'Ano',
  nowText: 'Actualizar',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Tempo',
  closeText: 'Fechar',
  allDayText: 'Todo o dia',
  noEventsText: 'Nenhum evento',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: 'mais {count}',
  // Daterange component
  fromText: 'Início',
  toText: 'Fim',
  // Measurement components
  wholeText: 'Inteiro',
  fractionText: 'Fracção',
  unitText: 'Unidade',
  // Time / Timespan component
  labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ano', 'Mês', 'Dia', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Começar',
  stopText: 'Parar',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Anterior',
  undoText: 'Anular',
  // Form
  offText: 'Desl',
  onText: 'Lig',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Română
mobiscroll.i18n.ro = {
  // Core
  setText: 'Setare',
  cancelText: 'Anulare',
  clearText: 'Ştergere',
  selectedText: '{count} selectat',
  selectedPluralText: '{count} selectate',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Duminică', 'Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă'],
  dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'Sâ'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: ' Ziua',
  delimiter: '.',
  hourText: ' Ore ',
  minuteText: 'Minute',
  monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
  monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
  monthText: 'Luna',
  secText: 'Secunde',
  timeFormat: 'HH:ii',
  yearText: 'Anul',
  nowText: 'Acum',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Astăzi',
  prevMonthText: 'Luna anterioară',
  nextMonthText: 'Luna următoare',
  prevYearText: 'Anul anterior',
  nextYearText: 'Anul următor',
  eventText: 'Eveniment',
  eventsText: 'Evenimente',
  allDayText: 'Toată ziua',
  noEventsText: 'Niciun eveniment',
  moreEventsText: 'Încă unul',
  moreEventsPluralText: 'Încă {count}',
  // Calendar component
  firstDay: 1,
  dateText: 'Data',
  timeText: 'Ora',
  closeText: 'Închidere',
  // Daterange component
  fromText: 'Start',
  toText: 'Final',
  // Measurement components
  wholeText: 'Complet',
  fractionText: 'Parţial',
  unitText: 'Unitate',
  // Time / Timespan component
  labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
  labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetare',
  lapText: 'Tură',
  hideText: 'Ascundere',
  // Listview
  backText: 'Înapoi',
  undoText: 'Anulează',
  // Form
  offText: 'Nu',
  onText: 'Da',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Русский (UA)
mobiscroll.i18n['ru-UA'] = {
  // Core
  setText: 'Установить',
  cancelText: 'Отменить',
  clearText: 'Очиститьr',
  selectedText: '{count} Вібрать',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
  dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
  dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
  dayText: 'День',
  delimiter: '.',
  hourText: 'Часы',
  minuteText: 'Минуты',
  monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
  monthNamesShort: ['Янв.', 'Февр.', 'Март', 'Апр.', 'Май', 'Июнь', 'Июль', 'Авг.', 'Сент.', 'Окт.', 'Нояб.', 'Дек.'],
  monthText: 'Месяцы',
  secText: 'Сикунды',
  timeFormat: 'HH:ii',
  yearText: 'Год',
  nowText: 'Сейчас',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Cегодня',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'Время',
  closeText: 'Закрыть',
  allDayText: 'Весь день',
  noEventsText: 'Нет событий',
  eventText: 'Мероприятия',
  eventsText: 'Мероприятия',
  moreEventsText: 'Ещё {count}',
  // Daterange component
  fromText: 'Начало',
  toText: 'Конец',
  // Measurement components
  wholeText: 'Весь',
  fractionText: 'Часть',
  unitText: 'Единица',
  // Time / Timespan component
  labels: ['Годы', ' Месяцы ', ' Дни ', ' Часы ', ' Минуты ', ' Секунды', ''],
  labelsShort: ['Год', 'Мес.', 'Дн.', 'Ч.', 'Мин.', 'Сек.', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: ' Сброс ',
  lapText: ' Этап ',
  hideText: ' Скрыть ',
  // Listview
  backText: 'назад',
  undoText: 'ОтменитЬ',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Русский
mobiscroll.i18n['ru-RU'] = mobiscroll.i18n.ru = {
  // Core
  setText: 'Установить',
  cancelText: 'Отмена',
  clearText: 'Очистить',
  selectedText: '{count} Выбрать',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['воскресенье', 'понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота'],
  dayNamesShort: ['вс', 'пн', 'вт', 'ср', 'чт', 'пт', 'сб'],
  dayNamesMin: ['в', 'п', 'в', 'с', 'ч', 'п', 'с'],
  dayText: 'День',
  delimiter: '.',
  hourText: 'Час',
  minuteText: 'Минут',
  monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
  monthNamesShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
  monthText: 'Месяц',
  secText: 'Секунд',
  timeFormat: 'HH:ii',
  yearText: 'Год',
  nowText: 'Сейчас',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Cегодня',
  // Calendar component
  firstDay: 1,
  dateText: 'Дата',
  timeText: 'Время',
  closeText: 'Закрыть',
  allDayText: 'Весь день',
  noEventsText: 'Нет событий',
  eventText: 'Мероприятия',
  eventsText: 'Мероприятия',
  moreEventsText: 'Ещё {count}',
  // Daterange component
  fromText: 'Начало',
  toText: 'Конец',
  // Measurement components
  wholeText: 'Целое',
  fractionText: 'Дробное',
  unitText: 'Единица',
  // Time / Timespan component
  labels: ['Лет', 'Месяцев', 'Дней', 'Часов', 'Минут', 'Секунд', ''],
  labelsShort: ['Лет', 'Мес', 'Дн', 'Час', 'Мин', 'Сек', ''],
  // Timer component
  startText: 'Старт',
  stopText: 'Стоп',
  resetText: 'Сбросить',
  lapText: 'Круг',
  hideText: 'Скрыть',
  // Listview
  backText: 'назад',
  undoText: 'ОтменитЬ',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Slovencina
mobiscroll.i18n.sk = {
  // Core
  setText: 'Zadaj',
  cancelText: 'Zrušiť',
  clearText: 'Vymazať',
  selectedText: 'Označený: {count}',
  // Datetime component
  dateFormat: 'd.m.yy',
  dayNames: ['Nedeľa', 'Pondelok', 'Utorok', 'Streda', 'Štvrtok', 'Piatok', 'Sobota'],
  dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 'Št', 'Pi', 'So'],
  dayNamesMin: ['N', 'P', 'U', 'S', 'Š', 'P', 'S'],
  dayText: 'Ďeň',
  hourText: 'Hodiny',
  minuteText: 'Minúty',
  monthNames: ['Január', 'Február', 'Marec', 'Apríl', 'Máj', 'Jún', 'Júl', 'August', 'September', 'Október', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Máj', 'Jún', 'Júl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Mesiac',
  secText: 'Sekundy',
  timeFormat: 'H:ii',
  yearText: 'Rok',
  nowText: 'Teraz',
  amText: 'am',
  pmText: 'pm',
  todayText: 'Dnes',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Čas',
  closeText: 'Zavrieť',
  allDayText: 'Celý deň',
  noEventsText: 'Žiadne udalosti',
  eventText: 'Udalostí',
  eventsText: 'Udalosti',
  moreEventsText: '{count} ďalšia',
  moreEventsPluralText: '{count} ďalšie',
  // Daterange component
  fromText: 'Začiatok',
  toText: 'Koniec',
  // Measurement components
  wholeText: 'Celý',
  fractionText: 'Časť',
  unitText: 'Jednotka',
  // Time / Timespan component
  labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minúty', 'Sekundy', ''],
  labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stop',
  resetText: 'Resetovať',
  lapText: 'Etapa',
  hideText: 'Schovať',
  // Listview
  backText: 'Späť',
  undoText: 'Späť',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Serbian
mobiscroll.i18n.sr = {
  // Core
  setText: 'Постави',
  cancelText: 'Откажи',
  clearText: 'Обриши',
  selectedText: '{count} изабрана',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Недеља', 'Понедељак', 'Уторак', 'Среда', 'Четвртак', 'Петак', 'Субота'],
  dayNamesShort: ['Нед', 'Пон', 'Уто', 'Сре', 'Чет', 'Пет', 'Суб'],
  dayNamesMin: ['Не', 'По', 'Ут', 'Ср', 'Че', 'Пе', 'Су'],
  dayText: 'Дан',
  delimiter: '.',
  hourText: 'Час',
  minuteText: 'Минут',
  monthNames: ['Јануар', 'Фебруар', 'Март', 'Април', 'Мај', 'Јун', 'Јул', 'Август', 'Септембар', 'Октобар', 'Новембар', 'Децембар'],
  monthNamesShort: ['Јан', 'Феб', 'Мар', 'Апр', 'Мај', 'Јун', 'Јул', 'Авг', 'Сеп', 'Окт', 'Нов', 'Дец'],
  monthText: 'месец',
  secText: 'Секунд',
  timeFormat: 'H:ii',
  yearText: 'година',
  nowText: 'сада',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'Датум',
  timeText: 'време',
  todayText: 'Данас',
  prevMonthText: 'Претходни мјесец',
  nextMonthText: 'Следећег месеца',
  prevYearText: 'Претходна године',
  nextYearText: 'Следеће године',
  closeText: 'Затвори',
  eventText: 'Догађај',
  eventsText: 'Догађаји',
  allDayText: 'Цео дан',
  noEventsText: 'Нема догађаја',
  moreEventsText: 'Још {count}',
  // Daterange component
  fromText: 'Од',
  toText: 'До',
  // Measurement components
  wholeText: 'цео',
  fractionText: 'Фракција',
  unitText: 'единица',
  // Time / Timespan component
  labels: ['Године', 'Месеци', 'Дана', 'Сати', 'Минута', 'Секунди', ''],
  labelsShort: ['Год', 'Мес', 'Дана', 'Сати', 'Мину', 'Секу', ''],
  // Timer component
  startText: 'Започни',
  stopText: 'Стоп',
  resetText: 'Ресетуј',
  lapText: 'Круг',
  hideText: 'Сакрити',
  // Listview
  backText: 'Повратак',
  undoText: 'Опозови',
  // Form
  offText: 'нe',
  onText: 'да',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Svenska
mobiscroll.i18n.sv = {
  // Core
  setText: 'OK',
  cancelText: 'Avbryt',
  clearText: 'Klara',
  selectedText: '{count} vald',
  // Datetime component
  dateFormat: 'yy-mm-dd',
  dayNames: ['Söndag', 'Måndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lördag'],
  dayNamesShort: ['Sö', 'Må', 'Ti', 'On', 'To', 'Fr', 'Lö'],
  dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
  dayText: 'Dag',
  hourText: 'Timme',
  minuteText: 'Minut',
  monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
  monthText: 'Månad',
  secText: 'Sekund',
  timeFormat: 'HH:ii',
  yearText: 'År',
  nowText: 'Nu',
  pmText: 'pm',
  amText: 'am',
  todayText: 'I dag',
  // Calendar component
  firstDay: 1,
  dateText: 'Datum',
  timeText: 'Tid',
  closeText: 'Stäng',
  allDayText: 'Heldag',
  noEventsText: 'Inga aktiviteter',
  eventText: 'Händelse',
  eventsText: 'Händelser',
  moreEventsText: '{count} till',
  // Daterange component
  fromText: 'Start',
  toText: 'Slut',
  // Measurement components
  wholeText: 'Hela',
  fractionText: 'Bråk',
  unitText: 'Enhet',
  // Time / Timespan component
  labels: ['År', 'Månader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
  labelsShort: ['År', 'Mån', 'Dag', 'Tim', 'Min', 'Sek', ''],
  // Timer component
  startText: 'Start',
  stopText: 'Stopp',
  resetText: 'Återställ',
  lapText: 'Varv',
  hideText: 'Dölj',
  // Listview
  backText: 'Tillbaka',
  undoText: 'Ångra',
  // Form
  offText: 'Av',
  onText: 'På'
};

// Thai
mobiscroll.i18n.th = {
  // Core
  setText: 'ตั้งค่า',
  cancelText: 'ยกเลิก',
  clearText: 'ล้าง',
  selectedText: '{count} เลือก',
  // Datetime component
  dateFormat: "dd/mm/yy",
  dayNames: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"],
  dayNamesShort: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  dayNamesMin: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  dayText: 'วัน',
  delimiter: '.',
  hourText: 'ชั่วโมง',
  minuteText: 'นาที',
  monthNames: ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"],
  monthNamesShort: ["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."],
  monthText: 'เดือน',
  secText: 'วินาที',
  timeFormat: 'HH:ii',
  yearText: 'ปี',
  nowText: 'ตอนนี้',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 0,
  dateText: 'วัน',
  timeText: 'เวลา',
  today: "วันนี้",
  prevMonthText: 'เดือนก่อนหน้า',
  nextMonthText: 'เดือนถัดไป',
  prevYearText: 'ปีก่อนหน้า',
  nextYearText: 'ปีถัดไป',
  closeText: "ปิด",
  eventText: 'เหตุการณ์',
  eventsText: 'เหตุการณ์',
  allDayText: 'ตลอดวัน',
  noEventsText: 'ไม่มีกิจกรรม',
  moreEventsText: 'อีก {count} กิจกรรม',
  // Daterange component
  fromText: 'จาก',
  toText: 'ถึง',
  // Measurement components
  wholeText: 'ทั้งหมด',
  fractionText: 'เศษส่วน',
  unitText: 'หน่วย',
  // Time / Timespan component
  labels: ['ปี', 'เดือน', 'วัน', 'ชั่วโมง', 'นาที', 'วินาที', ''],
  labelsShort: ['ปี', 'เดือน', 'วัน', 'ชั่วโมง', 'นาที', 'วินาที', ''],
  // Timer component
  startText: 'เริ่ม',
  stopText: 'หยุด',
  resetText: 'รีเซ็ต',
  lapText: 'รอบ',
  hideText: 'ซ่อน',
  // Listview
  backText: 'ย้อนกลับ',
  undoText: 'เลิกทา',
  // Form
  offText: 'ปิด',
  onText: 'เปิด',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Türkçe
mobiscroll.i18n.tr = {
  // Core
  setText: 'Seç',
  cancelText: 'İptal',
  clearText: 'Temizleyin',
  selectedText: '{count} seçilmiş',
  // Datetime component
  dateFormat: 'dd.mm.yy',
  dayNames: ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'],
  dayNamesShort: ['Paz', 'Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt'],
  dayNamesMin: ['P', 'P', 'S', 'Ç', 'P', 'C', 'C'],
  dayText: 'Gün',
  delimiter: '.',
  hourText: 'Saat',
  minuteText: 'Dakika',
  monthNames: ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'],
  monthNamesShort: ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara'],
  monthText: 'Ay',
  secText: 'Saniye',
  timeFormat: 'HH:ii',
  yearText: 'Yıl',
  nowText: 'Şimdi',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Bugün',
  // Calendar component
  firstDay: 1,
  dateText: 'Tarih',
  timeText: 'Zaman',
  closeText: 'Kapatmak',
  allDayText: 'Tüm gün',
  noEventsText: 'Etkinlik Yok',
  eventText: 'Etkinlik',
  eventsText: 'Etkinlikler',
  moreEventsText: '{count} tane daha',
  // Daterange component
  fromText: 'Başla',
  toText: 'Son',
  // Measurement components
  wholeText: 'Tam',
  fractionText: 'Kesir',
  unitText: 'Birim',
  // Time / Timespan component
  labels: ['Yıl', 'Ay', 'Gün', 'Saat', 'Dakika', 'Saniye', ''],
  labelsShort: ['Yıl', 'Ay', 'Gün', 'Sa', 'Dak', 'Sn', ''],
  // Timer component
  startText: 'Başla',
  stopText: 'Durdur',
  resetText: 'Sıfırla',
  lapText: 'Tur',
  hideText: 'Gizle',
  // Listview
  backText: 'Geri',
  undoText: 'Geri Al',
  // Form
  offText: 'O',
  onText: 'I',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: '.'
};

// Ukrainian
mobiscroll.i18n.ua = {
  // Core
  setText: 'встановити',
  cancelText: 'відміна',
  clearText: 'очистити',
  selectedText: '{count} вибрані',
  // Datetime component
  dateFormat: "dd.mm.yy",
  dayNames: ["неділя", "понеділок", "вівторок", "середа", "четвер", "п’ятниця", "субота"],
  dayNamesShort: ["нед", "пнд", "вів", "срд", "чтв", "птн", "сбт"],
  dayNamesMin: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
  dayText: 'День',
  delimiter: '.',
  hourText: 'година',
  minuteText: 'хвилина',
  monthNames: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"],
  monthNamesShort: ["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"],
  monthText: 'Місяць',
  secText: 'Секунд',
  timeFormat: 'H:ii',
  yearText: 'Рік',
  nowText: 'Зараз',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 1,
  dateText: 'дата',
  timeText: 'Час',
  todayText: 'Сьогодні',
  prevMonthText: 'Попередній місяць',
  nextMonthText: 'Наступного місяця',
  prevYearText: 'Попередній рік',
  nextYearText: 'Наступного року',
  closeText: "Закрити",
  eventText: 'подія',
  eventsText: 'події',
  allDayText: 'Увесь день',
  noEventsText: 'Жодної події',
  moreEventsText: 'та ще {count}',
  // Daterange component
  fromText: 'від',
  toText: 'кінець',
  // Measurement components
  wholeText: 'всі',
  fractionText: 'фракція',
  unitText: 'одиниця',
  // Time / Timespan component
  labels: ['Рік', 'Місяць', 'День', 'година', 'хвилина', 'Секунд', ''],
  labelsShort: ['Рік', 'Місяць', 'День', 'година', 'хвилина', 'Секунд', ''],
  // Timer component
  startText: 'Початок',
  stopText: 'СТОП',
  resetText: 'скинути',
  lapText: 'коло',
  hideText: 'сховати',
  // Listview
  backText: 'назад',
  undoText: 'відмінити',
  // Form
  offText: 'Вимикати',
  onText: 'Увімкнути',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Vietnamese 
mobiscroll.i18n.vi = {
  // Core
  setText: 'Đặt',
  cancelText: 'Hủy bò',
  clearText: 'Xóa',
  selectedText: '{count} chọn',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Chủ Nhật', 'Thứ Hai', 'Thứ Ba', 'Thứ Tư', 'Thứ Năm', 'Thứ Sáu', 'Thứ Bảy'],
  dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
  dayText: '',
  delimiter: '/',
  hourText: 'Giờ',
  minuteText: 'Phút',
  monthNames: ['Tháng Một', 'Tháng Hai', 'Tháng Ba', 'Tháng Tư', 'Tháng Năm', 'Tháng Sáu', 'Tháng Bảy', 'Tháng Tám', 'Tháng Chín', 'Tháng Mười', 'Tháng Mười Một', 'Tháng Mười Hai'],
  monthNamesShort: ['Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6', 'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'],
  monthText: 'Tháng',
  secText: 'Giây',
  timeFormat: 'H:ii',
  yearText: 'Năm',
  nowText: 'Bây giờ',
  pmText: 'pm',
  amText: 'am',
  // Calendar component
  firstDay: 0,
  dateText: 'Ngày',
  timeText: 'Hồi',
  todayText: 'Hôm nay',
  prevMonthText: 'Tháng trước',
  nextMonthText: 'Tháng tới',
  prevYearText: 'Măm trước',
  nextYearText: 'Năm tới',
  closeText: 'Đóng',
  eventText: 'Sự kiện',
  eventsText: 'Sự kiện',
  allDayText: 'Cả ngày',
  noEventsText: 'Không có sự kiện',
  moreEventsText: '{count} thẻ khác',
  // Daterange component
  fromText: 'Từ',
  toText: 'Tới',
  // Measurement components
  wholeText: 'Toàn thể',
  fractionText: 'Phân số',
  unitText: 'đơn vị',
  // Time / Timespan component
  labels: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
  labelsShort: ['Năm', 'Tháng', 'Ngày', 'Giờ', 'Phút', 'Giây', ''],
  // Timer component
  startText: 'Bắt đầu',
  stopText: 'Dừng',
  resetText: 'Đặt lại',
  lapText: 'Vòng',
  hideText: 'Giấu',
  // Listview
  backText: 'Quay lại',
  undoText: 'Hoàn tác',
  // Form
  offText: 'Tất',
  onText: 'Bật',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

// Chinese
mobiscroll.i18n.zh = {
  // Core
  setText: '确定',
  cancelText: '取消',
  clearText: '明确',
  selectedText: '{count} 选',
  // Datetime component
  dateFormat: 'yy年mm月d日',
  dayNames: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
  dayNamesShort: ['日', '一', '二', '三', '四', '五', '六'],
  dayNamesMin: ['日', '一', '二', '三', '四', '五', '六'],
  dayText: '日',
  hourText: '时',
  minuteText: '分',
  monthNames: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
  monthNamesShort: ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一', '十二'],
  monthText: '月',
  secText: '秒',
  timeFormat: 'HH:ii',
  yearText: '年',
  nowText: '当前',
  pmText: '下午',
  amText: '上午',
  yearSuffix: '年',
  monthSuffix: '月',
  daySuffix: '日',
  todayText: '今天',
  // Calendar component
  dateText: '日',
  timeText: '时间',
  closeText: '关闭',
  allDayText: '全天',
  noEventsText: '无事件',
  eventText: '活动',
  eventsText: '活动',
  moreEventsText: '他 {count} 件',
  // Daterange component
  fromText: '开始时间',
  toText: '结束时间',
  // Measurement components
  wholeText: '合计',
  fractionText: '分数',
  unitText: '单位',
  // Time / Timespan component
  labels: ['年', '月', '日', '小时', '分钟', '秒', ''],
  labelsShort: ['年', '月', '日', '点', '分', '秒', ''],
  // Timer component
  startText: '开始',
  stopText: '停止',
  resetText: '重置',
  lapText: '圈',
  hideText: '隐藏',
  // Listview
  backText: '返回',
  undoText: '复原',
  // Form
  offText: '关闭',
  onText: '开启',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

var themes$1 = mobiscroll.themes;
themes$1.frame.bootstrap = {
  disabledClass: 'disabled',
  selectedClass: 'btn-primary',
  selectedTabClass: 'active',
  tabLink: true,
  todayClass: 'text-primary mbsc-cal-today',
  onMarkupInserted: function onMarkupInserted(ev) {
    var dw = $$1(ev.target),
        calTabs = $$1('.mbsc-cal-tabs', dw);
    $$1('.mbsc-fr-popup', dw).addClass('popover');
    $$1('.mbsc-fr-w', dw).addClass('popover-content');
    $$1('.mbsc-fr-hdr', dw).addClass('popover-title popover-header');
    $$1('.mbsc-fr-arr-i', dw).addClass('popover');
    $$1('.mbsc-fr-arr', dw).addClass('arrow');
    $$1('.mbsc-fr-btn', dw).addClass('btn btn-default btn-secondary');
    $$1('.mbsc-fr-btn-s .mbsc-fr-btn', dw).removeClass('btn-default btn-secondary').addClass('btn btn-primary'); // Calendar tabs

    calTabs.addClass('nav nav-tabs');
    calTabs.find('.mbsc-cal-tab').addClass('nav-item'); // 4.x

    calTabs.find('a').addClass('nav-link'); // 4.x

    calTabs.find('.mbsc-cal-tab.active .nav-link').addClass('active'); // 4.x
    // Calendar year/month selector

    $$1('.mbsc-cal-picker', dw).addClass('popover'); // Rangepicker start/end buttons

    $$1('.mbsc-range-btn', dw).addClass('btn btn-sm btn-small btn-default'); // Numpad 

    $$1('.mbsc-np-btn', dw).addClass('btn btn-default'); // Select filter

    $$1('.mbsc-sel-filter-cont', dw).removeClass('mbsc-input');
    $$1('.mbsc-sel-filter-input', dw).addClass('form-control');
  },
  onTabChange: function onTabChange(ev, inst) {
    $$1('.mbsc-cal-tabs .nav-link', inst._markup).removeClass('active');
    $$1('.mbsc-cal-tab.active .nav-link', inst._markup).addClass('active');
  },
  onPosition: function onPosition(ev) {
    setTimeout(function () {
      $$1('.mbsc-fr-bubble-top, .mbsc-fr-bubble-top .mbsc-fr-arr-i', ev.target).removeClass('bottom bs-popover-bottom').addClass('top bs-popover-top');
      $$1('.mbsc-fr-bubble-bottom, .mbsc-fr-bubble-bottom .mbsc-fr-arr-i', ev.target).removeClass('top bs-popover-top').addClass('bottom  bs-popover-bottom');
    }, 10);
  }
};
themes$1.scroller.bootstrap = extend$1({}, themes$1.frame.bootstrap, {
  dateDisplay: 'Mddyy',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
  // calendar
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5 btn-light',
  // scroller
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5 btn-light',
  // scroller
  selectedLineHeight: true,
  onEventBubbleShow: function onEventBubbleShow(ev) {
    var evc = $$1(ev.eventList);
    $$1('.mbsc-cal-event-list', evc).addClass('list-group');
    $$1('.mbsc-cal-event', evc).addClass('list-group-item');
  }
});
themes$1.navigation.bootstrap = {
  wrapperClass: 'popover panel panel-default',
  groupClass: 'btn-group',
  activeClass: 'btn-primary',
  disabledClass: 'disabled',
  itemClass: 'btn btn-default'
};
themes$1.form.bootstrap = {};

var themes$2 = mobiscroll.themes;
themes$2.frame.ios = {
  display: 'bottom',
  // frame
  headerText: false,
  // frame
  btnWidth: false,
  // frame
  deleteIcon: 'ios-backspace',
  // numpad
  scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
};
themes$2.scroller.ios = extend$1({}, themes$2.frame.ios, {
  rows: 5,
  // scroller
  height: 34,
  // scroller
  minWidth: 55,
  // scroller
  selectedLineHeight: true,
  // scroller
  selectedLineBorder: 1,
  // scroller
  showLabel: false,
  // scroller
  useShortLabels: true,
  // timespan/timer
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  // scroller
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  // scroller
  checkIcon: 'ion-ios7-checkmark-empty',
  // select
  filterClearIcon: 'ion-close-circled',
  // select
  dateDisplay: 'MMdyy',
  // date
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

});
themes$2.listview.ios = {
  leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
  rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
};
themes$2.form.ios = {};

function _addRipple($control, ev) {
  var x = getCoord(ev, 'X', true),
      y = getCoord(ev, 'Y', true),
      control = $control[0],
      rect = $control.offset(),
      left = x - rect.left,
      top = y - rect.top,
      width = Math.max(left, control.offsetWidth - left),
      height = Math.max(top, control.offsetHeight - top),
      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

  _removeRipple($ripple);

  $ripple = $$1('<span class="mbsc-ripple"></span>').css({
    backgroundColor: getComputedStyle(control).color,
    width: size,
    height: size,
    top: y - rect.top - size / 2,
    left: x - rect.left - size / 2
  }).appendTo($control);
  setTimeout(function () {
    $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
  }, 10);
}

function _removeRipple($r) {
  setTimeout(function () {
    if ($r) {
      $r.removeClass('mbsc-ripple-visible');
      setTimeout(function () {
        $r.remove();
      }, 2000);
    }
  }, 100);
}

function initRipple($markup, selector, disabled, nohl) {
  var startX,
      startY,
      markup = $markup[0];

  function onStart(ev) {
    var target = closest(markup, ev.target, selector);

    if (target && testTouch(ev, target)) {
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      $active$1 = $$1(target);

      if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
        _addRipple($active$1, ev);
      } else {
        $active$1 = null;
      }
    }
  }

  function onMove(ev) {
    if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
      _removeRipple($ripple);

      $active$1 = null;
    }
  }

  function onEnd() {
    if ($active$1) {
      setTimeout(function () {
        _removeRipple($ripple);
      }, 100);
      $active$1 = null;
    }
  }

  if (markup) {
    if (markup.__mbscRippleOff) {
      markup.__mbscRippleOff();
    }

    listen(markup, 'touchstart', onStart, {
      passive: true
    });
    listen(markup, 'mousedown', onStart);
    listen(markup, 'touchmove', onMove, {
      passive: true
    });
    listen(markup, 'mousemove', onMove);
    listen(markup, 'touchend', onEnd);
    listen(markup, 'touchcancel', onEnd);
    listen(markup, 'mouseleave', onEnd);
    listen(markup, 'mouseup', onEnd);

    markup.__mbscRippleOff = function () {
      unlisten(markup, 'touchstart', onStart, {
        passive: true
      });
      unlisten(markup, 'mousedown', onStart);
      unlisten(markup, 'touchmove', onMove, {
        passive: true
      });
      unlisten(markup, 'mousemove', onMove);
      unlisten(markup, 'touchend', onEnd);
      unlisten(markup, 'touchcancel', onEnd);
      unlisten(markup, 'mouseleave', onEnd);
      unlisten(markup, 'mouseup', onEnd);
      delete markup.__mbscRippleOff;
    };
  }
}

var $active$1,
    $ripple,
    themes$3 = mobiscroll.themes;
themes$3.frame.material = {
  headerText: false,
  btnWidth: false,
  deleteIcon: 'material-backspace',
  onMarkupReady: function onMarkupReady(ev) {
    initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
  }
};
themes$3.scroller.material = extend$1({}, themes$3.frame.material, {
  showLabel: false,
  selectedLineBorder: 2,
  weekDays: 'min',
  icon: {
    filled: 'material-star',
    empty: 'material-star-outline'
  },
  checkIcon: 'material-check',
  btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
  btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
  btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
});
themes$3.listview.material = {
  leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
  rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
  onItemActivate: function onItemActivate(ev) {
    _addRipple($$1(ev.target), ev.domEvent);
  },
  onItemDeactivate: function onItemDeactivate() {
    _removeRipple($ripple);
  },
  onSlideStart: function onSlideStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  },
  onSortStart: function onSortStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  }
};
themes$3.navigation.material = {
  onInit: function onInit() {
    initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
  },
  onMarkupInit: function onMarkupInit() {
    $$1('.mbsc-ripple', this).remove();
  },
  onDestroy: function onDestroy() {
    if (this.__mbscRippleOff) {
      this.__mbscRippleOff();
    }
  }
};
themes$3.form.material = {
  addRipple: function addRipple(elm, ev) {
    _addRipple(elm, ev);
  },
  removeRipple: function removeRipple() {
    _removeRipple($ripple);
  }
};

var themes$4 = mobiscroll.themes;
themes$4.frame.windows = {
  headerText: false,
  deleteIcon: 'backspace4',
  //setIcon: 'material-check',
  //cancelIcon: 'material-close',
  //closeIcon: 'material-close',
  //clearIcon: 'material-close',
  //okIcon: 'material-check',
  //nowIcon: 'loop2',
  //startIcon: 'play3',
  //stopIcon: 'pause2',
  //resetIcon: 'stop2',
  //lapIcon: 'loop2',
  //btnWidth: false,
  btnReverse: true
};
themes$4.scroller.windows = extend$1({}, themes$4.frame.windows, {
  rows: 6,
  // scroller
  minWidth: 88,
  height: 44,
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  checkIcon: 'material-check',
  dateDisplay: 'MMdyy',
  // date
  showLabel: false,
  showScrollArrows: true,
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
  // calendar
  dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  useShortLabels: true // timespan/timer

});
themes$4.form.windows = {};

mobiscroll.customTheme('ios-dark', 'ios');

mobiscroll.customTheme('material-dark', 'material');

mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

mobiscroll.customTheme('windows-dark', 'windows');

var themes$5 = mobiscroll.themes;
var theme = 'mobiscroll';

if (os == 'android') {
  theme = 'material';
} else if (os == 'ios') {
  theme = 'ios';
} else if (os == 'wp') {
  theme = 'windows';
}

$$1.each(themes$5.frame, function (key, settings) {
  // Stop at the first custom theme with the OS base theme
  if (theme && settings.baseTheme == theme && key != theme + '-dark') {
    mobiscroll.autoTheme = key;
    return false;
  } else if (key == theme) {
    mobiscroll.autoTheme = key;
  }
});

mobiscroll.customTheme('ios-gray', 'ios');
mobiscroll.customTheme('material-indigo', 'material');
mobiscroll.customTheme('mobiscroll-lime', 'mobiscroll');
mobiscroll.customTheme('windows-yellow', 'windows');

mobiscroll.apiKey = 'f90c8752';
mobiscroll.apiUrl = 'https://trial.mobiscroll.com/';
mobiscroll.fw = 'angular';

export { MbscAccordion, MbscAvatar, MbscBottomNav, MbscButton, MbscCalendar, MbscCalendarComponent, MbscCalendarModule, MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardModule, MbscCardSubtitle, MbscCardTitle, MbscCheckbox, MbscColor, MbscColorComponent, MbscColorModule, MbscDate, MbscDateComponent, MbscDatetime, MbscDatetimeComponent, MbscDatetimeModule, MbscDistance, MbscDistanceComponent, MbscDropdown, MbscEventcalendar, MbscEventcalendarComponent, MbscEventcalendarModule, MbscForce, MbscForceComponent, MbscForm, MbscFormGroup, MbscFormGroupContent, MbscFormGroupTitle, MbscFormsModule, MbscHamburgerNav, MbscImage, MbscImageComponent, MbscImageItem, MbscImageModule, MbscInput, MbscInputModule, MbscListview, MbscListviewHeader, MbscListviewItem, MbscListviewModule, MbscListviewSublist, MbscMass, MbscMassComponent, MbscMeasurement, MbscMeasurementComponent, MbscMeasurementModule, MbscModule, MbscNav, MbscNavItem, MbscNavigationModule, MbscNote, MbscNumber, MbscNumberComponent, MbscNumberModule, MbscNumpad, MbscNumpadComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadModule, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent, MbscOptionItem, MbscOptionlist, MbscOptionlistModule, MbscPage, MbscPageModule, MbscPopup, MbscPopupModule, MbscProgress, MbscRadio, MbscRadioGroup, MbscRange, MbscRangeComponent, MbscRangeEndComponent, MbscRangeModule, MbscRangeStartComponent, MbscRating, MbscRouterToken, MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent, MbscScrollViewModule, MbscScroller, MbscScrollerComponent, MbscScrollerModule, MbscSegmented, MbscSegmentedGroup, MbscSelect, MbscSelectComponent, MbscSelectModule, MbscSlider, MbscSpeed, MbscSpeedComponent, MbscStepper, MbscSwitch, MbscTabNav, MbscTemperature, MbscTemperatureComponent, MbscTextarea, MbscTime, MbscTimeComponent, MbscTimer, MbscTimerComponent, MbscTimerModule, MbscTimespan, MbscTimespanComponent, MbscTimespanModule, MbscTreelist, MbscTreelistComponent, MbscTreelistModule, MbscWidget, mobiscroll, MbscOptionsService as ɵa, MbscInputService as ɵb, MbscCalBaseModule as ɵba, MbscDatetimeBase as ɵbb, MbscDatetimeBaseModule as ɵbc, MbscNavItemBase as ɵbd, MbscNavigationBase as ɵbe, MbscNavigationBaseModule as ɵbf, MbscNotifyItemService as ɵbg, MbscScrollItemBase as ɵbh, MbscScrollViewBase as ɵbi, MbscScrollViewBaseModule as ɵbj, MbscListService as ɵc, MbscBase as ɵd, MbscValueBase as ɵe, MbscCloneBase as ɵf, MbscControlBase as ɵg, MbscFrameBase as ɵh, MbscScrollerBase as ɵi, MbscBaseModule as ɵj, MbscFrameBaseModule as ɵk, MbscScrollerBaseModule as ɵl, INPUT_TEMPLATE as ɵm, MbscDateBase as ɵn, MbscFormBase as ɵo, MbscFormValueBase as ɵp, MbscInputBase as ɵq, MbscRadioService as ɵr, MbscRadioGroupBase as ɵs, MbscListviewService as ɵt, MbscSublistService as ɵu, MbscListitemService as ɵv, MbscMeasurementBase as ɵw, MbscMeasurementChild as ɵx, MbscNumpadBase as ɵy, MbscCalBase as ɵz };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9iaXNjcm9sbC5hbmd1bGFyLm1pbi5qcyIsInNvdXJjZXMiOlsibW9iaXNjcm9sbC5hbmd1bGFyLm1pbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUdNO0FBQ047Ozs7O2dEQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FHTTtBQUNOOzs7OztnREFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjs7Ozs7Z0RBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTs7Ozs7O29HQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7Ozs7OztvR0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU1NO0FBQ047Ozs7Ozs7Ozs7Z0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOOzs7Ozs7Ozs7O2dEQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBTU07QUFDTjs7Ozs7Ozs7OztnREFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFXTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOOzs7Ozs7Ozs7O2dEQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOOzs7Ozs7Ozs7O2dEQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOOzs7OztnREFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOOzs7OztnREFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOOzs7OztnREFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzswSUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BY007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FXTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQVlNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FVTTtBQUNOOzs7Ozs7Ozs7Ozs7Ozs7O2dEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBVU07QUFDTjs7Ozs7Ozs7Ozs7Ozs7OztnREFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVVNO0FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FVTTtBQUNOOzs7Ozs7Ozs7Ozs7Ozs7O2dEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBVU07QUFDTjs7Ozs7Ozs7Ozs7Ozs7OztnREFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztxRUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFRTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFRTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFTTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQVNNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFTTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BR007QUFDTjs7Ozs7Z0RBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJEQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BV007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVVNO0FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVVNO0FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVVNO0FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFRTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFVTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFHTTtBQUNOOzs7OztnREFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOOzs7Ozs7Ozs7O2dEQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FNTTtBQUNOOzs7Ozs7Ozs7O2dEQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BWU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BU007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FTTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FTTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FTTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOOzs7Ozs7Ozs7OztnREFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FZTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0R0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQVNNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQVFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BVU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBUU07QUFDTjs7Ozs7Ozs7Ozs7Ozs7OzBCQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFRTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs0R0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBUU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQVNNO0FBQ047QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzRHQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFPTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FPTTtBQUNOOzs7Ozs7Ozs7OztnREFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU1NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQU9NO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBT007QUFDTjs7Ozs7Ozs7Ozs7Z0RBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BT007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQU9NO0FBQ047Ozs7Ozs7Ozs7O2dEQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BTU07QUFDTjs7Ozs7Ozs7OztnREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBOZ1pvbmUsIElucHV0IGFzIElucHV0JDEsIE91dHB1dCwgVmlld0NvbnRhaW5lclJlZiwgRXZlbnRFbWl0dGVyLCBOZ01vZHVsZSwgVmlld0NoaWxkLCBPcHRpb25hbCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgVmlld0NoaWxkcmVuLCBJbmplY3RvciwgSW5qZWN0LCBmb3J3YXJkUmVmLCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ0NvbnRyb2wsIEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxudmFyIG1vYmlzY3JvbGwgPSBtb2Jpc2Nyb2xsIHx8IHt9LFxuICAgIHV0aWwgPSB7fSxcbiAgICBjYWxlbmRhcnMgPSB7fTtcblxudmFyIG9zLFxuICAgIHZlcnMsXG4gICAgbWFqb3JWZXJzaW9uLFxuICAgIG1pbm9yVmVyc2lvbixcbiAgICB2ZXJzaW9uID0gW10sXG4gICAgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgaXNEYXJrID0gaXNCcm93c2VyICYmIHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6ZGFyayknKS5tYXRjaGVzLFxuICAgIHVzZXJBZ2VudCA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci51c2VyQWdlbnQgOiAnJyxcbiAgICBwbGF0Zm9ybSA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci5wbGF0Zm9ybSA6ICcnLFxuICAgIG1heFRvdWNoUG9pbnRzID0gaXNCcm93c2VyID8gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIDogMCxcbiAgICBpc1NhZmFyaSA9IC9TYWZhcmkvLnRlc3QodXNlckFnZW50KSxcbiAgICBkZXZpY2UgPSB1c2VyQWdlbnQubWF0Y2goL0FuZHJvaWR8aVBob25lfGlQYWR8aVBvZHxXaW5kb3dzIFBob25lfFdpbmRvd3N8TVNJRS9pKSxcbiAgICByYWYgPSBpc0Jyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoZnVuYykge1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jLCAyMCk7XG59LFxuICAgIHJhZmMgPSBpc0Jyb3dzZXIgJiYgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChpZCkge1xuICBjbGVhclRpbWVvdXQoaWQpO1xufTtcblxuaWYgKC9BbmRyb2lkL2kudGVzdChkZXZpY2UpKSB7XG4gIG9zID0gJ2FuZHJvaWQnO1xuICB2ZXJzID0gdXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkXFxzKyhbXFxkLl0rKS9pKTtcblxuICBpZiAodmVycykge1xuICAgIHZlcnNpb24gPSB2ZXJzWzBdLnJlcGxhY2UoJ0FuZHJvaWQgJywgJycpLnNwbGl0KCcuJyk7XG4gIH1cbn0gZWxzZSBpZiAoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KGRldmljZSkgfHwgL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KHBsYXRmb3JtKSB8fCBwbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBtYXhUb3VjaFBvaW50cyA+IDEpIHtcbiAgLy8gT24gaVBhZCB3aXRoIGlPUyAxMyBkZXNrdG9wIHNpdGUgcmVxdWVzdCBpcyBhdXRvbWF0aWNhbGx5IGVuYWJsZWQgaW4gU2FmYXJpLFxuICAvLyBzbyAnaVBhZCcgaXMgbm8gbG9uZ2VyIHByZXNlbnQgaW4gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAvLyBJbiB0aGlzIGNhc2Ugd2UgY2hlY2sgYG5hdmlnYXRvci5wbGF0Zm9ybWAgYW5kIGBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHNgLlxuICAvLyBtYXhUb3VjaFBvaW50cyBpcyBuZWVkZWQgdG8gZXhjbHVkZSBkZXNrdG9wIE1hYyBPUyBYLlxuICBvcyA9ICdpb3MnO1xuICB2ZXJzID0gdXNlckFnZW50Lm1hdGNoKC9PU1xccysoW1xcZF9dKykvaSk7XG5cbiAgaWYgKHZlcnMpIHtcbiAgICB2ZXJzaW9uID0gdmVyc1swXS5yZXBsYWNlKC9fL2csICcuJykucmVwbGFjZSgnT1MgJywgJycpLnNwbGl0KCcuJyk7XG4gIH1cbn0gZWxzZSBpZiAoL1dpbmRvd3MgUGhvbmUvaS50ZXN0KGRldmljZSkpIHtcbiAgb3MgPSAnd3AnO1xufSBlbHNlIGlmICgvV2luZG93c3xNU0lFL2kudGVzdChkZXZpY2UpKSB7XG4gIG9zID0gJ3dpbmRvd3MnO1xufVxuXG5tYWpvclZlcnNpb24gPSB2ZXJzaW9uWzBdO1xubWlub3JWZXJzaW9uID0gdmVyc2lvblsxXTtcblxuZnVuY3Rpb24gdGVzdFByb3BzKHByb3BzKSB7XG4gIHZhciBpO1xuXG4gIGZvciAoaSBpbiBwcm9wcykge1xuICAgIGlmIChtb2RbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdGVzdFByZWZpeCgpIHtcbiAgdmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHByZWZpeGVzKSB7XG4gICAgaWYgKHRlc3RQcm9wcyhbcHJlZml4ZXNbcF0gKyAnVHJhbnNmb3JtJ10pKSB7XG4gICAgICByZXR1cm4gJy0nICsgcHJlZml4ZXNbcF0udG9Mb3dlckNhc2UoKSArICctJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHRlc3RUb3VjaChlLCBlbG0pIHtcbiAgaWYgKGUudHlwZSA9PSAndG91Y2hzdGFydCcpIHtcbiAgICBlbG0uX19tYnNjVG91Y2hlZCA9IDE7XG4gIH0gZWxzZSBpZiAoZWxtLl9fbWJzY1RvdWNoZWQpIHtcbiAgICBkZWxldGUgZWxtLl9fbWJzY1RvdWNoZWQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKHQsIHZlcnRpY2FsKSB7XG4gIHZhciBwcmVmaXhlcyA9IFsndCcsICd3ZWJraXRUJywgJ01velQnLCAnT1QnLCAnbXNUJ10sXG4gICAgICBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodFswXSksXG4gICAgICBpID0gMCxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHB4LFxuICAgICAgdjtcblxuICB3aGlsZSAoIW1hdHJpeCAmJiBpIDwgcHJlZml4ZXMubGVuZ3RoKSB7XG4gICAgdiA9IHByZWZpeGVzW2ldO1xuXG4gICAgaWYgKHN0eWxlW3YgKyAncmFuc2Zvcm0nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXRyaXggPSBzdHlsZVt2ICsgJ3JhbnNmb3JtJ107XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgbWF0cml4ID0gbWF0cml4LnNwbGl0KCcpJylbMF0uc3BsaXQoJywgJyk7XG4gIHB4ID0gdmVydGljYWwgPyBtYXRyaXhbMTNdIHx8IG1hdHJpeFs1XSA6IG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdO1xuICByZXR1cm4gcHg7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRDb2xvcihjb2xvcikge1xuICBpZiAoY29sb3IpIHtcbiAgICAvLyBDYWNoZSBjYWxjdWxhdGVkIHRleHQgY29sb3JzLCBiZWNhdXNlIGl0IGlzIHNsb3dcbiAgICBpZiAodGV4dENvbG9yc1tjb2xvcl0pIHtcbiAgICAgIHJldHVybiB0ZXh0Q29sb3JzW2NvbG9yXTtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybiAnI2ZmZic7XG4gICAgfSAvLyBVc2UgY2FudmFzIGVsZW1lbnQsIHNpbmNlIGl0IGRvZXMgbm90IHJlcXVpcmUgRE9NIGFwcGVuZFxuXG5cbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHZhciByZ2IgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgdmFyIGRlbHRhID0gK3JnYlswXSAqIDAuMjk5ICsgK3JnYlsxXSAqIDAuNTg3ICsgK3JnYlsyXSAqIDAuMTE0O1xuICAgIHZhciB0ZXh0Q29sb3IgPSBkZWx0YSA8IDEzMCA/ICcjZmZmJyA6ICcjMDAwJztcbiAgICB0ZXh0Q29sb3JzW2NvbG9yXSA9IHRleHRDb2xvcjtcbiAgICByZXR1cm4gdGV4dENvbG9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFN0ZXAoZWwsIHN0YXJ0VGltZSwgZnJvbSwgdG8sIGNhbGxiYWNrKSB7XG4gIHZhciBlbGFwc2VkID0gTWF0aC5taW4oMSwgKG5ldyBEYXRlKCkgLSBzdGFydFRpbWUpIC8gNDY4KSxcbiAgICAgIGVhc2VkID0gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogZWxhcHNlZCkpLFxuICAgICAgY3VycmVudCA9IGZyb20gKyAodG8gLSBmcm9tKSAqIGVhc2VkO1xuICBlbC5zY3JvbGxUb3AgPSBjdXJyZW50O1xuXG4gIGlmIChjdXJyZW50ICE9PSB0bykge1xuICAgIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgICBzY3JvbGxTdGVwKGVsLCBzdGFydFRpbWUsIGZyb20sIHRvLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgdG8sIHByZXZBbmltLCBjYWxsYmFjaykge1xuICBpZiAocHJldkFuaW0pIHtcbiAgICBlbC5zY3JvbGxUb3AgPSB0bztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2Nyb2xsU3RlcChlbCwgbmV3IERhdGUoKSwgZWwuc2Nyb2xsVG9wLCB0bywgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RlbihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdCkge1xuICBpZiAoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubGlzdGVuKGVsLCBldmVudCwgaGFuZGxlciwgb3B0KSB7XG4gIGlmIChlbCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yIHx8ICFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF0Y2hlc1NlbGVjdG9yID0gZWxlbWVudC5tYXRjaGVzIHx8IGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG4gIHJldHVybiBtYXRjaGVzU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoZWwsIHRhcmdldCwgc2VsZWN0b3IpIHtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmIChtYXRjaGVzKHRhcmdldCwgc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldCAhPT0gZWwgPyB0YXJnZXQucGFyZW50Tm9kZSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihlbG0sIG5hbWUsIGRhdGEpIHtcbiAgdmFyIGV2dDtcblxuICB0cnkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICBldnQuZGV0YWlsID0gZGF0YTtcbiAgfVxuXG4gIGVsbS5kaXNwYXRjaEV2ZW50KGV2dCk7XG59XG5cbmZ1bmN0aW9uIHNldEZvY3VzSW52aXNpYmxlKCkge1xuICB3aW4uX19tYnNjRm9jdXNWaXNpYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNldEZvY3VzVmlzaWJsZSgpIHtcbiAgd2luLl9fbWJzY0ZvY3VzVmlzaWJsZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGFkZFdpbmRvd0ZvY3VzKCkge1xuICB2YXIgZm9jdXNDb3VudCA9IHdpbi5fX21ic2NGb2N1c0NvdW50IHx8IDA7XG5cbiAgaWYgKGZvY3VzQ291bnQgPT09IDApIHtcbiAgICBsaXN0ZW4od2luLCAnbW91c2Vkb3duJywgc2V0Rm9jdXNJbnZpc2libGUsIHRydWUpO1xuICAgIGxpc3Rlbih3aW4sICdrZXlkb3duJywgc2V0Rm9jdXNWaXNpYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdpbi5fX21ic2NGb2N1c0NvdW50ID0gKytmb2N1c0NvdW50O1xufVxuXG5mdW5jdGlvbiByZW1vdmVXaW5kb3dGb2N1cygpIHtcbiAgdmFyIGZvY3VzQ291bnQgPSB3aW4uX19tYnNjRm9jdXNDb3VudCB8fCAwO1xuICB3aW4uX19tYnNjRm9jdXNDb3VudCA9IC0tZm9jdXNDb3VudDtcblxuICBpZiAod2luLl9fbWJzY0ZvY3VzQ291bnQgPT09IDApIHtcbiAgICB1bmxpc3Rlbih3aW4sICdtb3VzZWRvd24nLCBzZXRGb2N1c0ludmlzaWJsZSk7XG4gICAgdW5saXN0ZW4od2luLCAna2V5ZG93bicsIHNldEZvY3VzVmlzaWJsZSk7XG4gIH1cbn1cblxudmFyIGFuaW1FbmQsXG4gICAgY2FudmFzLFxuICAgIG1vZCxcbiAgICBjc3NQcmVmaXgsXG4gICAgaGFzR2hvc3RDbGljayxcbiAgICBoYXNUcmFuc2l0aW9uLFxuICAgIGlzV2ViVmlldyxcbiAgICBpc1drV2ViVmlldyxcbiAgICBqc1ByZWZpeCxcbiAgICB3aW4sXG4gICAgdGV4dENvbG9ycyA9IHt9O1xuXG5pZiAoaXNCcm93c2VyKSB7XG4gIHdpbiA9IHdpbmRvdztcbiAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIG1vZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21vZGVybml6cicpLnN0eWxlO1xuICBjc3NQcmVmaXggPSB0ZXN0UHJlZml4KCk7XG4gIGpzUHJlZml4ID0gY3NzUHJlZml4LnJlcGxhY2UoL14tLywgJycpLnJlcGxhY2UoLy0kLywgJycpLnJlcGxhY2UoJ21veicsICdNb3onKTtcbiAgYW5pbUVuZCA9IG1vZC5hbmltYXRpb24gIT09IHVuZGVmaW5lZCA/ICdhbmltYXRpb25lbmQnIDogJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIGhhc1RyYW5zaXRpb24gPSBtb2QudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkOyAvLyBVSVdlYlZpZXcgb24gaU9TIHN0aWxsIGhhcyB0aGUgZ2hvc3QgY2xpY2ssIFxuICAvLyBXa1dlYlZpZXcgZG9lcyBub3QgaGF2ZSBhIGdob3N0IGNsaWNrLCBidXQgaXQncyBoYXJkIHRvIHRlbGwgaWYgaXQncyBVSVdlYlZpZXcgb3IgV2tXZWJWaWV3XG4gIC8vIEluIGFkZGl0aW9uIGluIGlPUyAxMi4yIGlmIHdlIGVuYWJsZSB0YXAgaGFuZGxpbmcsIGl0IGJyYWtlcyB0aGUgZm9ybSBpbnB1dHNcbiAgLy8gKGtleWJvYXJkIGFwcGVhcnMsIGJ1dCB0aGUgY3Vyc29yIGlzIG5vdCBpbiB0aGUgaW5wdXQpLlxuXG4gIGlzV2ViVmlldyA9IG9zID09PSAnaW9zJyAmJiAhaXNTYWZhcmk7XG4gIGlzV2tXZWJWaWV3ID0gaXNXZWJWaWV3ICYmIHdpbi53ZWJraXQgJiYgd2luLndlYmtpdC5tZXNzYWdlSGFuZGxlcnM7XG4gIGhhc0dob3N0Q2xpY2sgPSBtb2QudG91Y2hBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBpc1dlYlZpZXcgJiYgIWlzV2tXZWJWaWV3O1xufVxuXG52YXIgY3NzTnVtYmVyID0ge1xuICAnY29sdW1uLWNvdW50JzogMSxcbiAgJ2NvbHVtbnMnOiAxLFxuICAnZm9udC13ZWlnaHQnOiAxLFxuICAnbGluZS1oZWlnaHQnOiAxLFxuICAnb3BhY2l0eSc6IDEsXG4gICd6LWluZGV4JzogMSxcbiAgJ3pvb20nOiAxXG59LFxuICAgIHByb3BNYXAgPSB7XG4gICdyZWFkb25seSc6ICdyZWFkT25seSdcbn0sXG4gICAgZW1wdHlBcnJheSA9IFtdLFxuICAgIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIjtcbn1cblxuZnVuY3Rpb24gbGlrZUFycmF5KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5sZW5ndGggPT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGNocikge1xuICAgIHJldHVybiBjaHIgPyBjaHIudG9VcHBlckNhc2UoKSA6ICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoZGVlcCAmJiAoJC5pc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCAkLmlzQXJyYXkoc291cmNlW2tleV0pKSkge1xuICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgISQuaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgfHwgJC5pc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhJC5pc0FycmF5KHRhcmdldFtrZXldKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC86Oi9nLCAnLycpLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csICckMV8kMicpLnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0pL2csICckMV8kMicpLnJlcGxhY2UoL18vZywgJy0nKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBtYXliZUFkZFB4KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0gPyB2YWx1ZSArIFwicHhcIiA6IHZhbHVlO1xufVxuXG52YXIgRG9tID0gZnVuY3Rpb24gKCkge1xuICB2YXIgRG9tID0gZnVuY3Rpb24gRG9tKGFycikge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGkgPSAwOyAvLyBDcmVhdGUgYXJyYXktbGlrZSBvYmplY3RcblxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgX3RoaXNbaV0gPSBhcnJbaV07XG4gICAgfVxuXG4gICAgX3RoaXMubGVuZ3RoID0gYXJyLmxlbmd0aDsgLy8gUmV0dXJuIGNvbGxlY3Rpb24gd2l0aCBtZXRob2RzXG5cbiAgICByZXR1cm4gJCh0aGlzKTtcbiAgfTtcblxuICB2YXIgJCA9IGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJyID0gW10sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgaWYgKHNlbGVjdG9yICYmICFjb250ZXh0KSB7XG4gICAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBEb20pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuICQoZG9jdW1lbnQpLnJlYWR5KHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIC8vIFN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGVscywgdGVtcFBhcmVudCwgaHRtbDtcbiAgICAgICAgc2VsZWN0b3IgPSBodG1sID0gc2VsZWN0b3IudHJpbSgpO1xuXG4gICAgICAgIGlmIChodG1sLmluZGV4T2YoJzwnKSA+PSAwICYmIGh0bWwuaW5kZXhPZignPicpID49IDApIHtcbiAgICAgICAgICB2YXIgdG9DcmVhdGUgPSAnZGl2JztcblxuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzxsaScpID09PSAwKSB7XG4gICAgICAgICAgICB0b0NyZWF0ZSA9ICd1bCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRyJykgPT09IDApIHtcbiAgICAgICAgICAgIHRvQ3JlYXRlID0gJ3Rib2R5JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8dGQnKSA9PT0gMCB8fCBodG1sLmluZGV4T2YoJzx0aCcpID09PSAwKSB7XG4gICAgICAgICAgICB0b0NyZWF0ZSA9ICd0cic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRib2R5JykgPT09IDApIHtcbiAgICAgICAgICAgIHRvQ3JlYXRlID0gJ3RhYmxlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8b3B0aW9uJykgPT09IDApIHtcbiAgICAgICAgICAgIHRvQ3JlYXRlID0gJ3NlbGVjdCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGVtcFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodG9DcmVhdGUpO1xuICAgICAgICAgIHRlbXBQYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY29udGV4dCAmJiBzZWxlY3RvclswXSA9PT0gJyMnICYmICFzZWxlY3Rvci5tYXRjaCgvWyAuPD46fl0vKSkge1xuICAgICAgICAgICAgLy8gUHVyZSBJRCBzZWxlY3RvclxuICAgICAgICAgICAgZWxzID0gW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yLnNwbGl0KCcjJylbMV0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBEb20pIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHRbMF07XG4gICAgICAgICAgICB9IC8vIE90aGVyIHNlbGVjdG9yc1xuXG5cbiAgICAgICAgICAgIGVscyA9IChjb250ZXh0IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZWxzW2ldKSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKGVsc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE5vZGUvZWxlbWVudFxuICAgICAgZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUgfHwgc2VsZWN0b3IgPT09IHdpbmRvdyB8fCBzZWxlY3RvciA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBhcnIucHVzaChzZWxlY3Rvcik7XG4gICAgICAgIH0gLy9BcnJheSBvZiBlbGVtZW50cyBvciBpbnN0YW5jZSBvZiBEb21cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubGVuZ3RoID4gMCAmJiBzZWxlY3RvclswXS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKHNlbGVjdG9yW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCQuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGFyciA9IHNlbGVjdG9yO1xuICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERvbShhcnIpO1xuICB9O1xuXG4gIERvbS5wcm90b3R5cGUgPSB7XG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQgPyBkb2N1bWVudC5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScgOiBkb2N1bWVudC5yZWFkeVN0YXRlICE9ICdsb2FkaW5nJykge1xuICAgICAgICBjYWxsYmFjaygkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soJCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb25jYXQ6IGVtcHR5QXJyYXkuY29uY2F0LFxuICAgIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVySFRNTCA9ICcnO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChmbikge1xuICAgICAgcmV0dXJuICQoJC5tYXAodGhpcywgZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGVsLCBpLCBlbCk7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICByZXR1cm4gJChfc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICAvLyBDbGFzc2VzIGFuZCBhdHRyaXV0ZXNcbiAgICAvLyBOT1RFOiBlbGVtZW50LmNsYXNzTGlzdCBhdHRyaWJ1cmUgaXMgbm90IHN1cHBvcnRlZCBvbiBhbmRyb2lkIDIuMyEhIVxuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tqXS5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXNbaV0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzW2pdLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3Nlc1tpXSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXNbal0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOiBmYWxzZTtcbiAgICB9LFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpc1tqXS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBub2RlID0gdGhpc1swXSxcbiAgICAgICAgICBjb2xsZWN0aW9uID0gZmFsc2U7XG5cbiAgICAgIGlmIChpc09iamVjdChzZWxlY3RvcikpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9ICQoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZSAmJiAhKGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmluZGV4T2Yobm9kZSkgPj0gMCA6IG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSkge1xuICAgICAgICBub2RlID0gbm9kZSAhPT0gY29udGV4dCAmJiBub2RlLm5vZGVUeXBlICE9PSBub2RlLkRPQ1VNRU5UX05PREUgJiYgbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChub2RlKTtcbiAgICB9LFxuICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoYXR0cnMsIHZhbHVlKSB7XG4gICAgICB2YXIgYXR0cjtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBHZXQgYXR0clxuICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICBhdHRyID0gdGhpc1swXS5nZXRBdHRyaWJ1dGUoYXR0cnMpO1xuICAgICAgICAgIHJldHVybiBhdHRyIHx8IGF0dHIgPT09ICcnID8gYXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IGF0dHJzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdcbiAgICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJzLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9iamVjdFxuICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgdGhpc1tpXVthdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihhdHRyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJvcDogZnVuY3Rpb24gcHJvcChwcm9wcywgdmFsdWUpIHtcbiAgICAgIHByb3BzID0gcHJvcE1hcFtwcm9wc10gfHwgcHJvcHM7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gR2V0IHByb3BcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdW3Byb3BzXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCBwcm9wc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzW2ldW3Byb3BzXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWw6IGZ1bmN0aW9uIHZhbCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIHRoaXNbMF0ubXVsdGlwbGUpIHtcbiAgICAgICAgICByZXR1cm4gJC5tYXAodGhpcy5maW5kKCdvcHRpb246Y2hlY2tlZCcpLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHYudmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0udmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLm11bHRpcGxlKSB7XG4gICAgICAgICQuZWFjaCh0aGlzWzBdLm9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZih0aGlzLnZhbHVlKSAhPSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzW2ldLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvL0V2ZW50c1xuICAgIG9uOiBmdW5jdGlvbiBvbihldmVudE5hbWUsIHRhcmdldFNlbGVjdG9yLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgICAgdmFyIGJvdW5kTGlzdGVuZXIsXG4gICAgICAgICAgZWxtLFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIGV2ZW50cyA9IGV2ZW50TmFtZS5zcGxpdCgnICcpLFxuICAgICAgICAgIGksXG4gICAgICAgICAgajtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTGl2ZUV2ZW50KGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgICAgIHdoaWxlICh0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoJCh0YXJnZXQpLmlzKHRhcmdldFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0YXJnZXQsIGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IHRhcmdldCAhPT0gdGhpcyA/IHRhcmdldC5wYXJlbnROb2RlIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVOYW1lc3BhY2VzKGVsLCBuYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgIGlmICghZWwuRG9tTmFtZVNwYWNlcykge1xuICAgICAgICAgIGVsLkRvbU5hbWVTcGFjZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLkRvbU5hbWVTcGFjZXMucHVzaCh7XG4gICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VbMV0sXG4gICAgICAgICAgZXZlbnQ6IG5hbWVzcGFjZVswXSxcbiAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgY2FwdHVyZTogY2FwdHVyZVxuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lc3BhY2VbMF0sIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxtID0gdGhpc1tpXTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbih0YXJnZXRTZWxlY3RvcikgfHwgdGFyZ2V0U2VsZWN0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gVXN1YWwgZXZlbnRzXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBjYXB0dXJlID0gbGlzdGVuZXIgfHwgZmFsc2U7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IHRhcmdldFNlbGVjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBldmVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW2pdOyAvLyBjaGVjayBmb3IgbmFtZXNwYWNlc1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQuaW5kZXhPZignLicpICE9IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZU5hbWVzcGFjZXMoZWxtLCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGl2ZSBldmVudHNcbiAgICAgICAgICBib3VuZExpc3RlbmVyID0gaGFuZGxlTGl2ZUV2ZW50LmJpbmQoZWxtKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBldmVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW2pdO1xuXG4gICAgICAgICAgICBpZiAoIWVsbS5Eb21MaXZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGVsbS5Eb21MaXZlTGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsbS5Eb21MaXZlTGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgIGxpdmVMaXN0ZW5lcjogYm91bmRMaXN0ZW5lclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChldmVudC5pbmRleE9mKCcuJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTmFtZXNwYWNlcyhlbG0sIGV2ZW50LCBib3VuZExpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBib3VuZExpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihldmVudE5hbWUsIHRhcmdldFNlbGVjdG9yLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgICAgdmFyIGVsbSxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGssXG4gICAgICAgICAgbGl2ZUxpc3RlbmVycyxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRzKGV2ZW50KSB7XG4gICAgICAgIHZhciBlbCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIG5hbWVTcGFjZXMsXG4gICAgICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KCcuJyksXG4gICAgICAgICAgICBuYW1lID0gcGFydHNbMF0sXG4gICAgICAgICAgICBucyA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGF0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZWwgPSB0aGF0W2ldO1xuICAgICAgICAgIG5hbWVTcGFjZXMgPSBlbC5Eb21OYW1lU3BhY2VzO1xuXG4gICAgICAgICAgaWYgKG5hbWVTcGFjZXMpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuYW1lU3BhY2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBuYW1lU3BhY2VzW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChpdGVtLm5hbWVzcGFjZSA9PSBucyAmJiAoaXRlbS5ldmVudCA9PSBuYW1lIHx8ICFuYW1lKSkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbS5ldmVudCwgaXRlbS5saXN0ZW5lciwgaXRlbS5jYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHJlbW92ZSB0aGUgZXZlbnRzIGZyb20gdGhlIERvbU5hbWVTcGFjZXMgYXJyYXlcblxuXG4gICAgICAgICAgICBmb3IgKGogPSBuYW1lU3BhY2VzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lU3BhY2VzW2pdLnJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBuYW1lU3BhY2VzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldmVudHMgPSBldmVudE5hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudCA9IGV2ZW50c1tpXTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVsbSA9IHRoaXNbal07XG4gICAgICAgICAgbGl2ZUxpc3RlbmVycyA9IGVsbS5Eb21MaXZlTGlzdGVuZXJzO1xuXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0U2VsZWN0b3IpIHx8IHRhcmdldFNlbGVjdG9yID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gVXN1YWwgZXZlbnRzXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0YXJnZXRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZSA9IGxpc3RlbmVyIHx8IGZhbHNlO1xuICAgICAgICAgICAgICBsaXN0ZW5lciA9IHRhcmdldFNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnQuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgZXZlbnRzXG4gICAgICAgICAgICAgIHJlbW92ZUV2ZW50cyhldmVudC5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTGl2ZSBldmVudFxuICAgICAgICAgICAgaWYgKGxpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGxpdmVMaXN0ZW5lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGl2ZUxpc3RlbmVyc1trXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXZlTGlzdGVuZXJzW2tdLmxpdmVMaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbG0uRG9tTmFtZVNwYWNlcyAmJiBlbG0uRG9tTmFtZVNwYWNlcy5sZW5ndGggJiYgZXZlbnQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyJDEoZXZlbnROYW1lLCBldmVudERhdGEpIHtcbiAgICAgIHZhciBldmVudHMgPSBldmVudE5hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdHJpZ2dlcih0aGlzW2pdLCBldmVudHNbaV0sIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBTaXppbmcvU3R5bGVzXG4gICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKGRpbSkge1xuICAgICAgaWYgKGRpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcygnd2lkdGgnLCBkaW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1swXSA9PT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAodGhpc1swXSA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgPyBwYXJzZUZsb2F0KHRoaXMuY3NzKCd3aWR0aCcpKSA6IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChkaW0pIHtcbiAgICAgIGlmIChkaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3MoJ2hlaWdodCcsIGRpbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzWzBdID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAodGhpc1swXSA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAwID8gcGFyc2VGbG9hdCh0aGlzLmNzcygnaGVpZ2h0JykpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlubmVyV2lkdGg6IGZ1bmN0aW9uIGlubmVyV2lkdGgoKSB7XG4gICAgICB2YXIgZWxtID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpc1swXS5pbm5lcldpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMF0uaW5uZXJXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXNbMF0ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgIHNpZGVzID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gICAgICAgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgc2l6ZSAtPSBwYXJzZUludChlbG0uY3NzKGNhbWVsaXplKCdib3JkZXItJyArIHNpZGUgKyAnLXdpZHRoJykpIHx8IDAsIDEwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW5uZXJIZWlnaHQ6IGZ1bmN0aW9uIGlubmVySGVpZ2h0KCkge1xuICAgICAgdmFyIGVsbSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXNbMF0uaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1swXS5pbm5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXNbMF0ub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICBzaWRlcyA9IFsndG9wJywgJ2JvdHRvbSddO1xuICAgICAgICAgIHNpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgIHNpemUgLT0gcGFyc2VJbnQoZWxtLmNzcyhjYW1lbGl6ZSgnYm9yZGVyLScgKyBzaWRlICsgJy13aWR0aCcpKSB8fCAwLCAxMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzWzBdLFxuICAgICAgICAgICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiBib3gudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gZG9jLmNsaWVudFRvcCxcbiAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCAtIGRvYy5jbGllbnRMZWZ0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXNbaV0sICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgIHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGNzczogZnVuY3Rpb24gY3NzKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzWzBdLFxuICAgICAgICAgIGNzcyA9ICcnO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJykuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShwcm9wZXJ0eSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzcyA9IGRhc2hlcml6ZShwcm9wZXJ0eSkgKyBcIjpcIiArIG1heWJlQWRkUHgocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5W2tleV0gJiYgcHJvcGVydHlba2V5XSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcyArPSBkYXNoZXJpemUoa2V5KSArICc6JyArIG1heWJlQWRkUHgoa2V5LCBwcm9wZXJ0eVtrZXldKSArICc7JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3M7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2FsbGJhY2suYXBwbHkodGhpc1tpXSwgW2ksIHRoaXNbaV1dKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbWF0Y2hlZEl0ZW1zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzW2ldLCBpLCB0aGlzW2ldKSkge1xuICAgICAgICAgICAgbWF0Y2hlZEl0ZW1zLnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXModGhpc1tpXSwgY2FsbGJhY2spKSB7XG4gICAgICAgICAgbWF0Y2hlZEl0ZW1zLnB1c2godGhpc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20obWF0Y2hlZEl0ZW1zKTtcbiAgICB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uIGh0bWwoX2h0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgX2h0bWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtcHR5KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpc1tpXS5pbm5lckhUTUwgPSBfaHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBfdGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKSA6IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzW2ldLnRleHRDb250ZW50ID0gX3RleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzOiBmdW5jdGlvbiBpcyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMCAmJiBtYXRjaGVzKHRoaXNbMF0sIHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gbm90KHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpICYmIHNlbGVjdG9yLmNhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgIGlmICghc2VsZWN0b3IuY2FsbCh0aGlzLCBpZHgpKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhjbHVkZXMgPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycgPyB0aGlzLmZpbHRlcihzZWxlY3RvcikgOiBsaWtlQXJyYXkoc2VsZWN0b3IpICYmIGlzRnVuY3Rpb24oc2VsZWN0b3IuaXRlbSkgPyBfc2xpY2UuY2FsbChzZWxlY3RvcikgOiAkKHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoaXNPYmplY3QoZXhjbHVkZXMpKSB7XG4gICAgICAgICAgZXhjbHVkZXMgPSAkLm1hcChleGNsdWRlcywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGVzLmluZGV4T2YoZWwpIDwgMCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQobm9kZXMpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldID09PSBlbCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQgPyB0aGlzLmluZGV4T2YoJChlbGVtZW50KVswXSkgOiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXhPZih0aGlzWzBdKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGlkeCkge1xuICAgICAgcmV0dXJuIGlkeCA9PT0gdW5kZWZpbmVkID8gX3NsaWNlLmNhbGwodGhpcykgOiB0aGlzW2lkeCA+PSAwID8gaWR4IDogaWR4ICsgdGhpcy5sZW5ndGhdO1xuICAgIH0sXG4gICAgZXE6IGZ1bmN0aW9uIGVxKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIHJldHVybkluZGV4O1xuXG4gICAgICBpZiAoaW5kZXggPiBsZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tKFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm5JbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgICAgICByZXR1cm4gcmV0dXJuSW5kZXggPCAwID8gbmV3IERvbShbXSkgOiBuZXcgRG9tKFt0aGlzW3JldHVybkluZGV4XV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERvbShbdGhpc1tpbmRleF1dKTtcbiAgICB9LFxuICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5ld0NoaWxkKSB7XG4gICAgICB2YXIgaSwgajtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gbmV3Q2hpbGQ7XG5cbiAgICAgICAgICB3aGlsZSAodGVtcERpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0NoaWxkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmFwcGVuZENoaWxkKG5ld0NoaWxkW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8ocGFyZW50KSB7XG4gICAgICAkKHBhcmVudCkuYXBwZW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKG5ld0NoaWxkKSB7XG4gICAgICB2YXIgaSwgajtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gbmV3Q2hpbGQ7XG5cbiAgICAgICAgICBmb3IgKGogPSB0ZW1wRGl2LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKHRlbXBEaXYuY2hpbGROb2Rlc1tqXSwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9IC8vIHRoaXNbaV0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV3Q2hpbGQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGQgaW5zdGFuY2VvZiBEb20pIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmV3Q2hpbGQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV0uaW5zZXJ0QmVmb3JlKG5ld0NoaWxkW2pdLCB0aGlzW2ldLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZShuZXdDaGlsZCwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHByZXBlbmRUbzogZnVuY3Rpb24gcHJlcGVuZFRvKHBhcmVudCkge1xuICAgICAgJChwYXJlbnQpLnByZXBlbmQodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgYmVmb3JlID0gJChzZWxlY3Rvcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmVmb3JlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGJlZm9yZVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLCBiZWZvcmVbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWZvcmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGJlZm9yZVtqXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSwgYmVmb3JlW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBhZnRlciA9ICQoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFmdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGFmdGVyWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXNbaV0sIGFmdGVyWzBdLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChhZnRlci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhZnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYWZ0ZXJbal0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXS5jbG9uZU5vZGUodHJ1ZSksIGFmdGVyW2pdLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgIGlmICh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyAmJiAkKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb20oW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tKFtdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5leHRBbGw6IGZ1bmN0aW9uIG5leHRBbGwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBuZXh0RWxzID0gW10sXG4gICAgICAgICAgZWwgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9tKFtdKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICB2YXIgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZztcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoJChuZXh0KS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEVscy5wdXNoKG5leHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERvbShuZXh0RWxzKTtcbiAgICB9LFxuICAgIHByZXY6IGZ1bmN0aW9uIHByZXYoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiAkKHRoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZykuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbdGhpc1swXS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb20oW3RoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZ10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmV2QWxsOiBmdW5jdGlvbiBwcmV2QWxsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcHJldkVscyA9IFtdO1xuICAgICAgdmFyIGVsID0gdGhpc1swXTtcblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHZhciBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcblxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoJChwcmV2KS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldkVscy5wdXNoKHByZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwgPSBwcmV2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERvbShwcmV2RWxzKTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXNbaV0ucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCQodGhpc1tpXS5wYXJlbnROb2RlKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHRoaXNbaV0ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJCgkLnVuaXF1ZShwYXJlbnRzKSk7XG4gICAgfSxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXNbaV0ucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoJChwYXJlbnQpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoJC51bmlxdWUocGFyZW50cykpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xuICAgICAgdmFyIGZvdW5kRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGZvdW5kRWxlbWVudHMucHVzaChmb3VuZFtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20oZm91bmRFbGVtZW50cyk7XG4gICAgfSxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzW2ldLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal0ubm9kZVR5cGUgPT09IDEgJiYgJChjaGlsZE5vZGVzW2pdKS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZE5vZGVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20oJC51bmlxdWUoY2hpbGRyZW4pKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIHZhciBkb20gPSB0aGlzO1xuICAgICAgdmFyIGksIGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvQWRkID0gJChhcmd1bWVudHNbaV0pO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0b0FkZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVtkb20ubGVuZ3RoXSA9IHRvQWRkW2pdO1xuICAgICAgICAgIGRvbS5sZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoZWxtKSB7XG4gICAgICAkKGVsbSkuaW5zZXJ0QmVmb3JlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWxtKSB7XG4gICAgICAkKGVsbSkuaW5zZXJ0QWZ0ZXIodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNjcm9sbFRvcDogZnVuY3Rpb24gc2Nyb2xsVG9wKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc1Njcm9sbFRvcCA9ICdzY3JvbGxUb3AnIGluIHRoaXNbMF07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNTY3JvbGxUb3AgPyB0aGlzWzBdLnNjcm9sbFRvcCA6IHRoaXNbMF0ucGFnZVlPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsVG9wID8gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlO1xuICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnNjcm9sbFgsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2Nyb2xsTGVmdDogZnVuY3Rpb24gc2Nyb2xsTGVmdCh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnIGluIHRoaXNbMF07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNTY3JvbGxMZWZ0ID8gdGhpc1swXS5zY3JvbGxMZWZ0IDogdGhpc1swXS5wYWdlWE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxMZWZ0ID8gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB2YWx1ZTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8odmFsdWUsIHRoaXMuc2Nyb2xsWSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNvbnRlbnRzOiBmdW5jdGlvbiBjb250ZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwodi5jaGlsZE5vZGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbmV4dFVudGlsOiBmdW5jdGlvbiBuZXh0VW50aWwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICBhcnJheSA9IFtdO1xuXG4gICAgICB3aGlsZSAobi5sZW5ndGggJiYgIW4uZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXkucHVzaChuWzBdKTtcbiAgICAgICAgbiA9IG4ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChhcnJheSk7XG4gICAgfSxcbiAgICBwcmV2VW50aWw6IGZ1bmN0aW9uIHByZXZVbnRpbChzZWxlY3Rvcikge1xuICAgICAgdmFyIG4gPSB0aGlzLFxuICAgICAgICAgIGFycmF5ID0gW107XG5cbiAgICAgIHdoaWxlIChuLmxlbmd0aCAmJiAhJChuKS5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCkge1xuICAgICAgICBhcnJheS5wdXNoKG5bMF0pO1xuICAgICAgICBuID0gbi5wcmV2KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKGFycmF5KTtcbiAgICB9LFxuICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICB9OyAvLyBMaW5rIHRvIHByb3RvdHlwZVxuXG4gICQuZm4gPSBEb20ucHJvdG90eXBlO1xuICByZXR1cm4gJDtcbn0oKTsgLy8gRXhwb3J0IHRvIGxvY2FsIHNjb3BlXG5cblxudmFyICQgPSBEb207IC8vIEV4cG9ydCB0byBtb2Jpc2Nyb2xsXG5cbm1vYmlzY3JvbGwuJCA9IERvbTsgLy8gRE9NIExpYnJhcnkgVXRpbGl0ZXNcblxuJC5pbkFycmF5ID0gZnVuY3Rpb24gKGVsZW0sIGFycmF5LCBpKSB7XG4gIHJldHVybiBlbXB0eUFycmF5LmluZGV4T2YuY2FsbChhcnJheSwgZWxlbSwgaSk7XG59O1xuXG4kLmV4dGVuZCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgdmFyIGRlZXAsXG4gICAgICBhcmdzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcbiAgICBkZWVwID0gdGFyZ2V0O1xuICAgIHRhcmdldCA9IGFyZ3Muc2hpZnQoKTtcbiAgfVxuXG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBleHRlbmQodGFyZ2V0LCBhcmcsIGRlZXApO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbiQuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbiQuaXNBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbiQuaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqICE9PSBudWxsICYmIG9iaiAhPT0gb2JqLndpbmRvdyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlO1xufTtcblxuJC5lYWNoID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIGksIHByb3A7XG5cbiAgaWYgKCFpc09iamVjdChvYmopIHx8ICFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgkLmlzQXJyYXkob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBEb20pIHtcbiAgICAvLyBBcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE9iamVjdFxuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgcHJvcCAhPT0gJ2xlbmd0aCcpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW3Byb3BdLCBwcm9wLCBvYmpbcHJvcF0pID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4kLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIHVuaXF1ZSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHVuaXF1ZS5pbmRleE9mKGFycltpXSkgPT09IC0xKSB7XG4gICAgICB1bmlxdWUucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmlxdWU7XG59O1xuXG4kLm1hcCA9IGZ1bmN0aW9uIChlbGVtZW50cywgY2FsbGJhY2spIHtcbiAgdmFyIHZhbHVlLFxuICAgICAgdmFsdWVzID0gW10sXG4gICAgICBpLFxuICAgICAga2V5O1xuXG4gIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChrZXkgaW4gZWxlbWVudHMpIHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbWVudHNba2V5XSwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDAgPyAkLmZuLmNvbmNhdC5hcHBseShbXSwgdmFsdWVzKSA6IHZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBvYmplY3RUb0FycmF5KG9iaikge1xuICB2YXIgYXJyID0gW10sXG4gICAgICBpO1xuXG4gIGZvciAoaSBpbiBvYmopIHtcbiAgICBhcnIucHVzaChvYmpbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgdmFyIG9iaiA9IHt9LFxuICAgICAgaTtcblxuICBpZiAoYXJyKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqW2FycltpXV0gPSBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gaXNOdW1lcmljKGEpIHtcbiAgcmV0dXJuIGEgLSBwYXJzZUZsb2F0KGEpID49IDA7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gY29uc3RyYWluKHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsLCBtYXgpKTtcbn1cblxuZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICBudW0gPSBudW0gKyAnJztcbiAgc2l6ZSA9IHNpemUgfHwgMjtcblxuICB3aGlsZSAobnVtLmxlbmd0aCA8IHNpemUpIHtcbiAgICBudW0gPSAnMCcgKyBudW07XG4gIH1cblxuICByZXR1cm4gbnVtO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgdGhyZXNoaG9sZCkge1xuICB2YXIgbGFzdCwgdGltZXI7XG4gIHRocmVzaGhvbGQgPSB0aHJlc2hob2xkIHx8IDEwMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIG5vdyA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIHRocmVzaGhvbGQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXN0ID0gbm93O1xuICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0sIHRocmVzaGhvbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2aWJyYXRlKHRpbWUpIHtcbiAgaWYgKCd2aWJyYXRlJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICBuYXZpZ2F0b3IudmlicmF0ZSh0aW1lIHx8IDUwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiAodiAtIG1pbikgKiAxMDAgLyAobWF4IC0gbWluKTtcbn1cblxuZnVuY3Rpb24gZ2V0Qm9vbEF0dHIoYXR0ciwgZGVmLCAkZWxtKSB7XG4gIHZhciB2ID0gJGVsbS5hdHRyKGF0dHIpO1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09ICcnID8gZGVmIDogdiA9PT0gJ3RydWUnO1xufVxuXG52YXIgdGFwcGVkID0gMDtcbnZhciBhbGxvd1F1aWNrO1xuXG5mdW5jdGlvbiBwcmV2ZW50Q2xpY2soKSB7XG4gIC8vIFByZXZlbnQgZ2hvc3QgY2xpY2tcbiAgdGFwcGVkKys7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRhcHBlZC0tO1xuICB9LCA1MDApO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyQ2xpY2soZXYsIGNvbnRyb2wpIHtcbiAgLy8gUHJldmVudCBkdXBsaWNhdGUgdHJpZ2dlcnMgb24gdGhlIHNhbWUgZWxlbWVudFxuICAvLyBlLmcuIGEgZm9ybSBjaGVja2JveCBpbnNpZGUgYSBsaXN0dmlldyBpdGVtXG4gIGlmIChjb250cm9sLm1ic2NDbGljaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0b3VjaCA9IChldi5vcmlnaW5hbEV2ZW50IHx8IGV2KS5jaGFuZ2VkVG91Y2hlc1swXSxcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICBldnQuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCB0b3VjaC5zY3JlZW5YLCB0b3VjaC5zY3JlZW5ZLCB0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gIGV2dC5pc01ic2NUYXAgPSB0cnVlOyAvLyBQcmV2ZW50IGlvbmljIHRvIGJ1c3Qgb3VyIGNsaWNrXG4gIC8vIFRoaXMgd29ya3MgZm9yIElvbmljIDEgLSAzLCBub3Qgc3VyZSBhYm91dCA0XG5cbiAgZXZ0LmlzSW9uaWNUYXAgPSB0cnVlOyAvLyBUaGlzIHdpbGwgYWxsb3cgYSBjbGljayBmaXJlZCB0b2dldGhlciB3aXRoIHRoaXMgY2xpY2tcbiAgLy8gV2UgbmVlZCB0aGlzLCBiZWNhdXNlIGNsaWNraW5nIG9uIGEgbGFiZWwgd2lsbCB0cmlnZ2VyIGEgY2xpY2tcbiAgLy8gb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgYXMgd2VsbCwgd2hpY2ggc2hvdWxkIG5vdCBiZSBidXN0ZWRcblxuICBhbGxvd1F1aWNrID0gdHJ1ZTtcbiAgY29udHJvbC5tYnNjQ2hhbmdlID0gdHJ1ZTtcbiAgY29udHJvbC5tYnNjQ2xpY2sgPSB0cnVlO1xuICBjb250cm9sLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgYWxsb3dRdWljayA9IGZhbHNlOyAvLyBQcmV2ZW50IGdob3N0IGNsaWNrXG5cbiAgcHJldmVudENsaWNrKCk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlbGV0ZSBjb250cm9sLm1ic2NDbGljaztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkKGUsIGMsIHBhZ2UpIHtcbiAgdmFyIGV2ID0gZS5vcmlnaW5hbEV2ZW50IHx8IGUsXG4gICAgICBwcm9wID0gKHBhZ2UgPyAncGFnZScgOiAnY2xpZW50JykgKyBjOyAvLyBNdWx0aSB0b3VjaCBzdXBwb3J0XG5cbiAgaWYgKGV2LnRhcmdldFRvdWNoZXMgJiYgZXYudGFyZ2V0VG91Y2hlc1swXSkge1xuICAgIHJldHVybiBldi50YXJnZXRUb3VjaGVzWzBdW3Byb3BdO1xuICB9XG5cbiAgaWYgKGV2LmNoYW5nZWRUb3VjaGVzICYmIGV2LmNoYW5nZWRUb3VjaGVzWzBdKSB7XG4gICAgcmV0dXJuIGV2LmNoYW5nZWRUb3VjaGVzWzBdW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIGVbcHJvcF07XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyb2xUeXBlKCRlbG0pIHtcbiAgdmFyIGF0dHJzID0gWydzd2l0Y2gnLCAncmFuZ2UnLCAncmF0aW5nJywgJ3NlZ21lbnRlZCcsICdzdGVwcGVyJ107XG4gIHZhciBlbG0gPSAkZWxtWzBdO1xuICB2YXIgcm9sZSA9ICRlbG0uYXR0cignZGF0YS1yb2xlJyk7XG4gIHZhciB0eXBlID0gJGVsbS5hdHRyKCd0eXBlJykgfHwgZWxtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKC8oc3dpdGNofHJhbmdlfHJhdGluZ3xzZWdtZW50ZWR8c3RlcHBlcnxzZWxlY3QpLy50ZXN0KHJvbGUpKSB7XG4gICAgdHlwZSA9IHJvbGU7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCRlbG0uaXMoJ1ttYnNjLScgKyBhdHRyc1tpXSArICddJykpIHtcbiAgICAgICAgdHlwZSA9IGF0dHJzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNvbnRyb2woY29udHJvbCwgdHlwZSwgZXYpIHtcbiAgY29udHJvbC5mb2N1cygpO1xuXG4gIGlmICgvKGJ1dHRvbnxzdWJtaXR8Y2hlY2tib3h8c3dpdGNofHJhZGlvKS8udGVzdCh0eXBlKSkge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBpZiAoIS9zZWxlY3QvLnRlc3QodHlwZSkpIHtcbiAgICB0cmlnZ2VyQ2xpY2soZXYsIGNvbnRyb2wpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRhcCh0aGF0LCBlbCwgaGFuZGxlciwgcHJldmVudCwgdG9sZXJhbmNlLCB0aW1lKSB7XG4gIHZhciBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICB0YXJnZXQsXG4gICAgICBtb3ZlZCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgICQgPSBtb2Jpc2Nyb2xsLiQsXG4gICAgICAkZWxtID0gJChlbCk7XG4gIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCA5O1xuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoZXYpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgLy8gQ2FuJ3QgYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgaGVyZSwgaXQga2lsbHMgcGFnZSBzY3JvbGxcbiAgICAgIC8vIGlmIChwcmV2ZW50KSB7XG4gICAgICAvLyAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIH1cbiAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICBzdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgbW92ZWQgPSBmYWxzZTtcbiAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgLy8gSWYgbW92ZW1lbnQgaXMgbW9yZSB0aGFuIDIwcHgsIGRvbid0IGZpcmUgdGhlIGNsaWNrIGV2ZW50IGhhbmRsZXJcbiAgICBpZiAodGFyZ2V0ICYmICFtb3ZlZCAmJiAoTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdYJykgLSBzdGFydFgpID4gdG9sZXJhbmNlIHx8IE1hdGguYWJzKGdldENvb3JkKGV2LCAnWScpIC0gc3RhcnRZKSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZChldikge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGlmICh0aW1lICYmIG5ldyBEYXRlKCkgLSBzdGFydFRpbWUgPCAxMDAgfHwgIW1vdmVkKSB7XG4gICAgICAgIC8vIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIGhhbmRsZXIuY2FsbCh0YXJnZXQsIGV2LCB0aGF0KTtcbiAgICAgICAgdHJpZ2dlckNsaWNrKGV2LCBldi50YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmVudENsaWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICBpZiAocHJldmVudCkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9IC8vIElmIGhhbmRsZXIgd2FzIG5vdCBjYWxsZWQgb24gdG91Y2hlbmQsIGNhbGwgaXQgb24gY2xpY2s7XG5cblxuICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldiwgdGhhdCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICB0YXJnZXQgPSBmYWxzZTtcbiAgfVxuXG4gICRlbG0uZWFjaChmdW5jdGlvbiAoaSwgZWxtKSB7XG4gICAgaWYgKHRoYXQuc2V0dGluZ3MudGFwKSB7XG4gICAgICBsaXN0ZW4oZWxtLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsaXN0ZW4oZWxtLCAndG91Y2hjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgICBsaXN0ZW4oZWxtLCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGVsbSwgJ3RvdWNoZW5kJywgb25FbmQpO1xuICAgIH1cblxuICAgIGxpc3RlbihlbG0sICdjbGljaycsIG9uQ2xpY2spO1xuXG4gICAgZWxtLl9fbWJzY09mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKGVsbSwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZWxtLCAndG91Y2hjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgICB1bmxpc3RlbihlbG0sICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihlbG0sICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKGVsbSwgJ2NsaWNrJywgb25DbGljayk7XG4gICAgICBkZWxldGUgZWxtLl9fbWJzY09mZjtcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGFwT2ZmKCRlbG0pIHtcbiAgaWYgKCRlbG0gJiYgJGVsbVswXSAmJiAkZWxtWzBdLl9fbWJzY09mZikge1xuICAgICRlbG1bMF0uX19tYnNjT2ZmKCk7XG4gIH1cbn0gLy8gUHJldmVudCBzdGFuZGFyZCBiZWhhdmlvdXIgb24gYm9keSBjbGlja1xuXG5cbmZ1bmN0aW9uIGJ1c3RDbGljayhldikge1xuICAvLyBUZXh0YXJlYSBuZWVkcyB0aGUgbW91c2Vkb3duIGV2ZW50XG4gIGlmICh0YXBwZWQgJiYgIWFsbG93UXVpY2sgJiYgIWV2LmlzTWJzY1RhcCAmJiAhKGV2LnRhcmdldC5ub2RlTmFtZSA9PSAnVEVYVEFSRUEnICYmIGV2LnR5cGUgPT0gJ21vdXNlZG93bicpKSB7XG4gICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuaWYgKGlzQnJvd3Nlcikge1xuICBbJ21vdXNlb3ZlcicsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdjbGljayddLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldiwgYnVzdENsaWNrLCB0cnVlKTtcbiAgfSk7XG5cbiAgaWYgKG9zID09ICdhbmRyb2lkJyAmJiBtYWpvclZlcnNpb24gPCA1KSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAodGFwcGVkICYmIGV2LnRhcmdldC50eXBlID09ICdjaGVja2JveCcgJiYgIWV2LnRhcmdldC5tYnNjQ2hhbmdlKSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZXYudGFyZ2V0Lm1ic2NDaGFuZ2U7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0ZWREYXRlKHksIG0sIGQsIGgsIGksIHMsIHUpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoIHx8IDAsIGkgfHwgMCwgcyB8fCAwLCB1IHx8IDApO1xuXG4gIGlmIChkYXRlLmdldEhvdXJzKCkgPT0gMjMgJiYgKGggfHwgMCkgPT09IDApIHtcbiAgICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIDIpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59XG4vKipcbiAqIEZvcm1hdCBhIGRhdGUgaW50byBhIHN0cmluZyB2YWx1ZSB3aXRoIGEgc3BlY2lmaWVkIGZvcm1hdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgT3V0cHV0IGZvcm1hdC5cbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBEYXRlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ3M9e31dIFNldHRpbmdzLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCFkYXRlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcyA9IGV4dGVuZCQxKHt9LCBkYXRlVGltZURlZmF1bHRzLCBzZXR0aW5ncyksXG4gICAgICBsb29rID0gZnVuY3Rpb24gbG9vayhtKSB7XG4gICAgLy8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuICAgIHZhciBuID0gMDtcblxuICAgIHdoaWxlIChpICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpICsgMSkgPT0gbSkge1xuICAgICAgbisrO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xuICB9LFxuICAgICAgZjEgPSBmdW5jdGlvbiBmMShtLCB2YWwsIGxlbikge1xuICAgIC8vIEZvcm1hdCBhIG51bWJlciwgd2l0aCBsZWFkaW5nIHplcm8gaWYgbmVjZXNzYXJ5XG4gICAgdmFyIG4gPSAnJyArIHZhbDtcblxuICAgIGlmIChsb29rKG0pKSB7XG4gICAgICB3aGlsZSAobi5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgbiA9ICcwJyArIG47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH0sXG4gICAgICBmMiA9IGZ1bmN0aW9uIGYyKG0sIHZhbCwgcywgbCkge1xuICAgIC8vIEZvcm1hdCBhIG5hbWUsIHNob3J0IG9yIGxvbmcgYXMgcmVxdWVzdGVkXG4gICAgcmV0dXJuIGxvb2sobSkgPyBsW3ZhbF0gOiBzW3ZhbF07XG4gIH0sXG4gICAgICBpLFxuICAgICAgeWVhcixcbiAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgaWYgKGZvcm1hdC5jaGFyQXQoaSkgPT0gXCInXCIgJiYgIWxvb2soXCInXCIpKSB7XG4gICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdkJywgcy5nZXREYXkoZGF0ZSksIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIG91dHB1dCArPSBmMignRCcsIGRhdGUuZ2V0RGF5KCksIHMuZGF5TmFtZXNTaG9ydCwgcy5kYXlOYW1lcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdvJywgKGRhdGUuZ2V0VGltZSgpIC0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKS5nZXRUaW1lKCkpIC8gODY0MDAwMDAsIDMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIG91dHB1dCArPSBmMSgnbScsIHMuZ2V0TW9udGgoZGF0ZSkgKyAxLCAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICBvdXRwdXQgKz0gZjIoJ00nLCBzLmdldE1vbnRoKGRhdGUpLCBzLm1vbnRoTmFtZXNTaG9ydCwgcy5tb250aE5hbWVzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICB5ZWFyID0gcy5nZXRZZWFyKGRhdGUpO1xuICAgICAgICAgIG91dHB1dCArPSBsb29rKCd5JykgPyB5ZWFyIDogKHllYXIgJSAxMDAgPCAxMCA/ICcwJyA6ICcnKSArIHllYXIgJSAxMDA7IC8vb3V0cHV0ICs9IChsb29rKCd5JykgPyBkYXRlLmdldEZ1bGxZZWFyKCkgOiAoZGF0ZS5nZXRZZWFyKCkgJSAxMDAgPCAxMCA/ICcwJyA6ICcnKSArIGRhdGUuZ2V0WWVhcigpICUgMTAwKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIHZhciBoID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgIG91dHB1dCArPSBmMSgnaCcsIGggPiAxMiA/IGggLSAxMiA6IGggPT09IDAgPyAxMiA6IGgsIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIG91dHB1dCArPSBmMSgnSCcsIGRhdGUuZ2V0SG91cnMoKSwgMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdpJywgZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIG91dHB1dCArPSBmMSgncycsIGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICBvdXRwdXQgKz0gZGF0ZS5nZXRIb3VycygpID4gMTEgPyBzLnBtVGV4dCA6IHMuYW1UZXh0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIG91dHB1dCArPSBkYXRlLmdldEhvdXJzKCkgPiAxMSA/IHMucG1UZXh0LnRvVXBwZXJDYXNlKCkgOiBzLmFtVGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgaWYgKGxvb2soXCInXCIpKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCInXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdGVyYWwgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIEVORCAtLS1cblxuLyoqXG4gKiBFeHRyYWN0IGEgZGF0ZSBmcm9tIGEgc3RyaW5nIHZhbHVlIHdpdGggYSBzcGVjaWZpZWQgZm9ybWF0LlxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBJbnB1dCBmb3JtYXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtzZXR0aW5ncz17fV0gU2V0dGluZ3MuXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBleHRyYWN0ZWQgZGF0ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuICB2YXIgcyA9IGV4dGVuZCQxKHt9LCBkYXRlVGltZURlZmF1bHRzLCBzZXR0aW5ncyksXG4gICAgICBkZWYgPSBtYWtlRGF0ZShzLmRlZmF1bHRWYWx1ZSB8fCBuZXcgRGF0ZSgpKTtcblxuICBpZiAoIWZvcm1hdCB8fCAhdmFsdWUpIHtcbiAgICByZXR1cm4gZGVmO1xuICB9IC8vIElmIGFscmVhZHkgYSBkYXRlIG9iamVjdFxuXG5cbiAgaWYgKHZhbHVlLmdldFRpbWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArICcnO1xuXG4gIHZhciBzaG9ydFllYXJDdXRvZmYgPSBzLnNob3J0WWVhckN1dG9mZixcbiAgICAgIHllYXIgPSBzLmdldFllYXIoZGVmKSxcbiAgICAgIG1vbnRoID0gcy5nZXRNb250aChkZWYpICsgMSxcbiAgICAgIGRheSA9IHMuZ2V0RGF5KGRlZiksXG4gICAgICBkb3kgPSAtMSxcbiAgICAgIGhvdXJzID0gZGVmLmdldEhvdXJzKCksXG4gICAgICBtaW51dGVzID0gZGVmLmdldE1pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSAwLFxuICAgICAgLy9kZWYuZ2V0U2Vjb25kcygpLFxuICBhbXBtID0gLTEsXG4gICAgICBsaXRlcmFsID0gZmFsc2UsXG4gICAgICAvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG4gIGxvb2tBaGVhZCA9IGZ1bmN0aW9uIGxvb2tBaGVhZChtYXRjaCkge1xuICAgIHZhciBtYXRjaGVzID0gaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09IG1hdGNoO1xuXG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIGlGb3JtYXQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfSxcbiAgICAgIGdldE51bWJlciA9IGZ1bmN0aW9uIGdldE51bWJlcihtYXRjaCkge1xuICAgIC8vIEV4dHJhY3QgYSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgbG9va0FoZWFkKG1hdGNoKTtcbiAgICB2YXIgc2l6ZSA9IG1hdGNoID09ICdAJyA/IDE0IDogbWF0Y2ggPT0gJyEnID8gMjAgOiBtYXRjaCA9PSAneScgPyA0IDogbWF0Y2ggPT0gJ28nID8gMyA6IDIsXG4gICAgICAgIGRpZ2l0cyA9IG5ldyBSZWdFeHAoJ15cXFxcZHsxLCcgKyBzaXplICsgJ30nKSxcbiAgICAgICAgbnVtID0gdmFsdWUuc3Vic3RyKGlWYWx1ZSkubWF0Y2goZGlnaXRzKTtcblxuICAgIGlmICghbnVtKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gcGFyc2VJbnQobnVtWzBdLCAxMCk7XG4gIH0sXG4gICAgICBnZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZShtYXRjaCwgcywgbCkge1xuICAgIC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuICAgIHZhciBuYW1lcyA9IGxvb2tBaGVhZChtYXRjaCkgPyBsIDogcyxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWVzW2ldLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PSBuYW1lc1tpXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGlWYWx1ZSArPSBuYW1lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgICAgIGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uIGNoZWNrTGl0ZXJhbCgpIHtcbiAgICBpVmFsdWUrKztcbiAgfSxcbiAgICAgIGlWYWx1ZSA9IDAsXG4gICAgICBpRm9ybWF0O1xuXG4gIGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcbiAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgaWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT0gXCInXCIgJiYgIWxvb2tBaGVhZChcIidcIikpIHtcbiAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBkYXkgPSBnZXROdW1iZXIoJ2QnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICBnZXROYW1lKCdEJywgcy5kYXlOYW1lc1Nob3J0LCBzLmRheU5hbWVzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICBkb3kgPSBnZXROdW1iZXIoJ28nKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBtb250aCA9IGdldE51bWJlcignbScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIG1vbnRoID0gZ2V0TmFtZSgnTScsIHMubW9udGhOYW1lc1Nob3J0LCBzLm1vbnRoTmFtZXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHllYXIgPSBnZXROdW1iZXIoJ3knKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBob3VycyA9IGdldE51bWJlcignSCcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgIGhvdXJzID0gZ2V0TnVtYmVyKCdoJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgbWludXRlcyA9IGdldE51bWJlcignaScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIHNlY29uZHMgPSBnZXROdW1iZXIoJ3MnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICBhbXBtID0gZ2V0TmFtZSgnYScsIFtzLmFtVGV4dCwgcy5wbVRleHRdLCBbcy5hbVRleHQsIHMucG1UZXh0XSkgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGFtcG0gPSBnZXROYW1lKCdBJywgW3MuYW1UZXh0LCBzLnBtVGV4dF0sIFtzLmFtVGV4dCwgcy5wbVRleHRdKSAtIDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICBpZiAobG9va0FoZWFkKFwiJ1wiKSkge1xuICAgICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdGVyYWwgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHllYXIgPCAxMDApIHtcbiAgICB5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArICh5ZWFyIDw9ICh0eXBlb2Ygc2hvcnRZZWFyQ3V0b2ZmICE9ICdzdHJpbmcnID8gc2hvcnRZZWFyQ3V0b2ZmIDogbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpID8gMCA6IC0xMDApO1xuICB9XG5cbiAgaWYgKGRveSA+IC0xKSB7XG4gICAgbW9udGggPSAxO1xuICAgIGRheSA9IGRveTtcblxuICAgIGRvIHtcbiAgICAgIHZhciBkaW0gPSAzMiAtIG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgMzIsIDEyKS5nZXREYXRlKCk7XG5cbiAgICAgIGlmIChkYXkgPiBkaW0pIHtcbiAgICAgICAgbW9udGgrKztcbiAgICAgICAgZGF5IC09IGRpbTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChkYXkgPiBkaW0pO1xuICB9XG5cbiAgaG91cnMgPSBhbXBtID09IC0xID8gaG91cnMgOiBhbXBtICYmIGhvdXJzIDwgMTIgPyBob3VycyArIDEyIDogIWFtcG0gJiYgaG91cnMgPT0gMTIgPyAwIDogaG91cnM7XG4gIHZhciBkYXRlID0gcy5nZXREYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VycywgbWludXRlcywgc2Vjb25kcyk7XG5cbiAgaWYgKHMuZ2V0WWVhcihkYXRlKSAhPSB5ZWFyIHx8IHMuZ2V0TW9udGgoZGF0ZSkgKyAxICE9IG1vbnRoIHx8IHMuZ2V0RGF5KGRhdGUpICE9IGRheSkge1xuICAgIHJldHVybiBkZWY7IC8vIEludmFsaWQgZGF0ZVxuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldERheURpZmYoZDEsIGQyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChkMiAtIGQxKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVPbmx5KGQpIHtcbiAgcmV0dXJuIGFkanVzdGVkRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlU3RyKGQpIHtcbiAgcmV0dXJuIGQuZ2V0RnVsbFllYXIoKSArICctJyArIChkLmdldE1vbnRoKCkgKyAxKSArICctJyArIGQuZ2V0RGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09TdHJpbmcoZCwgcGFydHMpIHtcbiAgdmFyIHJldCA9ICcnLFxuICAgICAgdGltZSA9ICcnO1xuXG4gIGlmIChkKSB7XG4gICAgaWYgKHBhcnRzLmgpIHtcbiAgICAgIHRpbWUgKz0gcGFkKGQuZ2V0SG91cnMoKSkgKyAnOicgKyBwYWQoZC5nZXRNaW51dGVzKCkpO1xuXG4gICAgICBpZiAocGFydHMucykge1xuICAgICAgICB0aW1lICs9ICc6JyArIHBhZChkLmdldFNlY29uZHMoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0cy51KSB7XG4gICAgICAgIHRpbWUgKz0gJy4nICsgcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFydHMudHopIHtcbiAgICAgICAgdGltZSArPSBwYXJ0cy50ejsgLy8gSnVzdCBwdXQgd2hhdCB3ZSBnb3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFydHMueSkge1xuICAgICAgcmV0ICs9IGQuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgaWYgKHBhcnRzLm0pIHtcbiAgICAgICAgcmV0ICs9ICctJyArIHBhZChkLmdldE1vbnRoKCkgKyAxKTtcblxuICAgICAgICBpZiAocGFydHMuZCkge1xuICAgICAgICAgIHJldCArPSAnLScgKyBwYWQoZC5nZXREYXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzLmgpIHtcbiAgICAgICAgICByZXQgKz0gJ1QnICsgdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFydHMuaCkge1xuICAgICAgcmV0ID0gdGltZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRJU09QYXJ0cyhwYXJzZWQsIG9mZnNldCwgcGFydHMpIHtcbiAgdmFyIHBhcnQsXG4gICAgICB2LFxuICAgICAgcCA9IHtcbiAgICB5OiAxLFxuICAgIG06IDIsXG4gICAgZDogMyxcbiAgICBoOiA0LFxuICAgIGk6IDUsXG4gICAgczogNixcbiAgICB1OiA3LFxuICAgIHR6OiA4XG4gIH07XG5cbiAgaWYgKHBhcnRzKSB7XG4gICAgZm9yIChwYXJ0IGluIHApIHtcbiAgICAgIHYgPSBwYXJzZWRbcFtwYXJ0XSAtIG9mZnNldF07XG5cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIHBhcnRzW3BhcnRdID0gcGFydCA9PSAndHonID8gdiA6IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHVybkRhdGUoZCwgcywgZGlzcGxheUZvcm1hdCkge1xuICB2YXIgbW9tZW50ID0gd2luZG93Lm1vbWVudCB8fCBzLm1vbWVudCxcbiAgICAgIGZvcm1hdCA9IHMucmV0dXJuRm9ybWF0O1xuXG4gIGlmIChkKSB7XG4gICAgaWYgKGZvcm1hdCA9PSAnbW9tZW50JyAmJiBtb21lbnQpIHtcbiAgICAgIHJldHVybiBtb21lbnQoZCk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PSAnbG9jYWxlJykge1xuICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGlzcGxheUZvcm1hdCwgZCwgcyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PSAnaXNvODYwMScpIHtcbiAgICAgIHJldHVybiBnZXRJU09TdHJpbmcoZCwgcy5pc29QYXJ0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VEYXRlKGQsIGZvcm1hdCwgcywgcGFydHMpIHtcbiAgdmFyIHBhcnNlO1xuXG4gIGlmICghZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIElmIGFscmVhZHkgZGF0ZSBvYmplY3RcblxuXG4gIGlmIChkLmdldFRpbWUpIHtcbiAgICByZXR1cm4gZDtcbiAgfSAvLyBNb21lbnQgb2JqZWN0XG5cblxuICBpZiAoZC50b0RhdGUpIHtcbiAgICByZXR1cm4gZC50b0RhdGUoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZCA9PSAnc3RyaW5nJykge1xuICAgIGQgPSBkLnRyaW0oKTtcbiAgfVxuXG4gIHBhcnNlID0gSVNPXzg2MDFfVElNRS5leGVjKGQpOyAvLyBJZiBJU08gODYwMSB0aW1lIHN0cmluZ1xuXG4gIGlmIChwYXJzZSkge1xuICAgIHNldElTT1BhcnRzKHBhcnNlLCAyLCBwYXJ0cyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIHBhcnNlWzJdID8gK3BhcnNlWzJdIDogMCwgcGFyc2VbM10gPyArcGFyc2VbM10gOiAwLCBwYXJzZVs0XSA/ICtwYXJzZVs0XSA6IDAsIHBhcnNlWzVdID8gK3BhcnNlWzVdIDogMCk7XG4gIH1cblxuICBpZiAoIXBhcnNlKSB7XG4gICAgcGFyc2UgPSBJU09fODYwMV9GVUxMLmV4ZWMoZCk7XG4gIH0gLy8gSWYgSVNPIDg2MDEgZGF0ZSBzdHJpbmdcblxuXG4gIGlmIChwYXJzZSkge1xuICAgIHNldElTT1BhcnRzKHBhcnNlLCAwLCBwYXJ0cyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlWzFdID8gK3BhcnNlWzFdIDogMTk3MCwgcGFyc2VbMl0gPyBwYXJzZVsyXSAtIDEgOiAwLCBwYXJzZVszXSA/ICtwYXJzZVszXSA6IDEsIHBhcnNlWzRdID8gK3BhcnNlWzRdIDogMCwgcGFyc2VbNV0gPyArcGFyc2VbNV0gOiAwLCBwYXJzZVs2XSA/ICtwYXJzZVs2XSA6IDAsIHBhcnNlWzddID8gK3BhcnNlWzddIDogMCk7XG4gIH0gLy8gUGFyc2UgZGF0ZSBiYXNlZCBvbiBmb3JtYXRcblxuXG4gIHJldHVybiBwYXJzZURhdGUoZm9ybWF0LCBkLCBzKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lRGF5KGQxLCBkMikge1xuICByZXR1cm4gZDEuZ2V0RnVsbFllYXIoKSA9PSBkMi5nZXRGdWxsWWVhcigpICYmIGQxLmdldE1vbnRoKCkgPT0gZDIuZ2V0TW9udGgoKSAmJiBkMS5nZXREYXRlKCkgPT0gZDIuZ2V0RGF0ZSgpO1xufVxuXG52YXIgSVNPXzg2MDFfRlVMTCA9IC9eKFxcZHs0fXxbKy1dXFxkezZ9KSg/Oi0oXFxkezJ9KSg/Oi0oXFxkezJ9KSk/KT8oPzpUKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oKFopfChbKy1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG52YXIgSVNPXzg2MDFfVElNRSA9IC9eKChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbKy1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG52YXIgREFZX09GX01PTlRIID0gL15cXGR7MSwyfShcXC9cXGR7MSwyfSk/JC87XG52YXIgREFZX09GX1dFRUsgPSAvXndcXGQkL2k7XG52YXIgZGF0ZVRpbWVEZWZhdWx0cyA9IHtcbiAgc2hvcnRZZWFyQ3V0b2ZmOiAnKzEwJyxcbiAgbW9udGhOYW1lczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICBkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICBkYXlOYW1lc01pbjogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gIGFtVGV4dDogJ2FtJyxcbiAgcG1UZXh0OiAncG0nLFxuICBnZXRZZWFyOiBmdW5jdGlvbiBnZXRZZWFyKGQpIHtcbiAgICByZXR1cm4gZC5nZXRGdWxsWWVhcigpO1xuICB9LFxuICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoZCkge1xuICAgIHJldHVybiBkLmdldE1vbnRoKCk7XG4gIH0sXG4gIGdldERheTogZnVuY3Rpb24gZ2V0RGF5KGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXRlKCk7XG4gIH0sXG4gIGdldERhdGU6IGFkanVzdGVkRGF0ZSxcbiAgZ2V0TWF4RGF5T2ZNb250aDogZnVuY3Rpb24gZ2V0TWF4RGF5T2ZNb250aCh5LCBtKSB7XG4gICAgcmV0dXJuIDMyIC0gbmV3IERhdGUoeSwgbSwgMzIsIDEyKS5nZXREYXRlKCk7XG4gIH0sXG4gIGdldFdlZWtOdW1iZXI6IGZ1bmN0aW9uIGdldFdlZWtOdW1iZXIoZCkge1xuICAgIC8vIENvcHkgZGF0ZSBzbyBkb24ndCBtb2RpZnkgb3JpZ2luYWxcbiAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgZC5zZXRIb3VycygwLCAwLCAwKTsgLy8gU2V0IHRvIG5lYXJlc3QgVGh1cnNkYXk6IGN1cnJlbnQgZGF0ZSArIDQgLSBjdXJyZW50IGRheSBudW1iZXJcbiAgICAvLyBNYWtlIFN1bmRheSdzIGRheSBudW1iZXIgN1xuXG4gICAgZC5zZXREYXRlKGQuZ2V0RGF0ZSgpICsgNCAtIChkLmdldERheSgpIHx8IDcpKTsgLy8gR2V0IGZpcnN0IGRheSBvZiB5ZWFyXG5cbiAgICB2YXIgeWVhclN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTsgLy8gQ2FsY3VsYXRlIGZ1bGwgd2Vla3MgdG8gbmVhcmVzdCBUaHVyc2RheVxuXG4gICAgcmV0dXJuIE1hdGguY2VpbCgoKGQgLSB5ZWFyU3RhcnQpIC8gODY0MDAwMDAgKyAxKSAvIDcpO1xuICB9XG59O1xudXRpbC5kYXRldGltZSA9IHtcbiAgZm9ybWF0RGF0ZTogZm9ybWF0RGF0ZSxcbiAgcGFyc2VEYXRlOiBwYXJzZURhdGVcbn07XG5cbi8qIVxuICogTW9iaXNjcm9sbCB2NC4xMC45XG4gKiBodHRwOi8vbW9iaXNjcm9sbC5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE4LCBBY2lkIE1lZGlhXG4gKlxuICovXG5jb25zb2xlLmluZm8oJ1RoZSB0cmlhbCBpcyBiZWluZyBhdXRoZW50aWNhdGVkIHdpdGggcmVtb3RlIGNhbGxzIG1hZGUgdG8gaHR0cHM6Ly90cmlhbC5tb2Jpc2Nyb2xsLmNvbS4gVGhpcyBpcyBzdHJpY3RseSBuZWNlc3NhcnkgZm9yIHRoZSB0cmlhbC4gTm8gcmVtb3RlIGNhbGxzIGFyZSBtYWRlIGZyb20gdGhlIGxpY2Vuc2VkIHZlcnNpb24uIE1vcmUgaW5mbyBvbiB0aGUgdHJpYWwgYW5kIGl0cyBsaW1pdGF0aW9uczogaHR0cDovL2hlbHAubW9iaXNjcm9sbC5jb20vdHJpYWxzL3doYXQtYXJlLXRoZS1saW1pdGF0aW9ucy1vZi10aGUtdHJpYWwnKTtcblxuZnVuY3Rpb24gZ2V0V2lkdGgoZWwpIHtcbiAgcmV0dXJuIGVsWzBdLmlubmVyV2lkdGggfHwgZWwuaW5uZXJXaWR0aCgpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVtZU5hbWUocykge1xuICB2YXIgdGhlbWVOYW1lID0gcy50aGVtZSxcbiAgICAgIHRoZW1lVmFyaWFudCA9IHMudGhlbWVWYXJpYW50O1xuXG4gIGlmICh0aGVtZU5hbWUgPT0gJ2F1dG8nIHx8ICF0aGVtZU5hbWUpIHtcbiAgICB0aGVtZU5hbWUgPSBtcy5hdXRvVGhlbWU7XG4gIH1cblxuICBpZiAodGhlbWVOYW1lID09ICdkZWZhdWx0Jykge1xuICAgIHRoZW1lTmFtZSA9ICdtb2Jpc2Nyb2xsJztcbiAgfVxuXG4gIGlmICgodGhlbWVWYXJpYW50ID09PSAnZGFyaycgfHwgaXNEYXJrICYmIHRoZW1lVmFyaWFudCA9PT0gJ2F1dG8nKSAmJiBtcy50aGVtZXMuZm9ybVt0aGVtZU5hbWUgKyAnLWRhcmsnXSkge1xuICAgIHRoZW1lTmFtZSA9IHRoZW1lTmFtZSArICctZGFyayc7XG4gIH0gZWxzZSBpZiAodGhlbWVWYXJpYW50ID09PSAnbGlnaHQnICYmIC8uKy1kYXJrJC8udGVzdCh0aGVtZU5hbWUpKSB7XG4gICAgdGhlbWVOYW1lID0gdGhlbWVOYW1lLnJlcGxhY2UoLy1kYXJrJC8sICcnKTtcbiAgfVxuXG4gIHJldHVybiB0aGVtZU5hbWU7XG59XG5cbmZ1bmN0aW9uIGF1dG9Jbml0KHNlbGVjdG9yLCBDb21wb25lbnQsIGhhc1JlZnJlc2gpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgICQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAkJDEoc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgQ29tcG9uZW50KHRoaXMsIHt9KTtcbiAgICAgIH0pO1xuICAgICAgJCQxKGRvY3VtZW50KS5vbignbWJzYy1lbmhhbmNlJywgZnVuY3Rpb24gKGV2LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoJCQxKGV2LnRhcmdldCkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgbmV3IENvbXBvbmVudChldi50YXJnZXQsIHNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJDEoc2VsZWN0b3IsIGV2LnRhcmdldCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50KHRoaXMsIHNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNSZWZyZXNoKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub24oJ21ic2MtcmVmcmVzaCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciBpbnN0O1xuXG4gICAgICAgICAgaWYgKCQkMShldi50YXJnZXQpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgaW5zdCA9IGluc3RhbmNlc1tldi50YXJnZXQuaWRdO1xuXG4gICAgICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgICAgICBpbnN0LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCQxKHNlbGVjdG9yLCBldi50YXJnZXQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbnN0ID0gaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgICAgICAgaW5zdC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIG1lc3NhZ2VTaG93LFxuICAgIG1zLFxuICAgICQkMSA9IG1vYmlzY3JvbGwuJCxcbiAgICBpZCA9ICtuZXcgRGF0ZSgpLFxuICAgIGluc3RhbmNlcyA9IHt9LFxuICAgIGNsYXNzZXMgPSB7fSxcbiAgICBlbXB0eSA9IHt9LFxuICAgIGJyZWFrcG9pbnRzID0ge1xuICB4c21hbGw6IDAsXG4gIHNtYWxsOiA1NzYsXG4gIG1lZGl1bTogNzY4LFxuICBsYXJnZTogOTkyLFxuICB4bGFyZ2U6IDEyMDBcbn0sXG4gICAgZXh0ZW5kJDEgPSAkJDEuZXh0ZW5kO1xuZXh0ZW5kJDEodXRpbCwge1xuICBnZXRDb29yZDogZ2V0Q29vcmQsXG4gIHByZXZlbnRDbGljazogcHJldmVudENsaWNrLFxuICB2aWJyYXRlOiB2aWJyYXRlXG59KTtcbm1zID0gZXh0ZW5kJDEobW9iaXNjcm9sbCwge1xuICAkOiAkJDEsXG4gIHZlcnNpb246ICc0LjEwLjknLFxuICBhdXRvVGhlbWU6ICdtb2Jpc2Nyb2xsJyxcbiAgdGhlbWVzOiB7XG4gICAgZm9ybToge30sXG4gICAgcGFnZToge30sXG4gICAgZnJhbWU6IHt9LFxuICAgIHNjcm9sbGVyOiB7fSxcbiAgICBsaXN0dmlldzoge30sXG4gICAgbmF2aWdhdGlvbjoge30sXG4gICAgcHJvZ3Jlc3M6IHt9LFxuICAgIGNhcmQ6IHt9XG4gIH0sXG4gIHBsYXRmb3JtOiB7XG4gICAgbmFtZTogb3MsXG4gICAgbWFqb3JWZXJzaW9uOiBtYWpvclZlcnNpb24sXG4gICAgbWlub3JWZXJzaW9uOiBtaW5vclZlcnNpb25cbiAgfSxcbiAgaTE4bjoge30sXG4gIGluc3RhbmNlczogaW5zdGFuY2VzLFxuICBjbGFzc2VzOiBjbGFzc2VzLFxuICB1dGlsOiB1dGlsLFxuICBzZXR0aW5nczoge30sXG4gIHNldERlZmF1bHRzOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvKSB7XG4gICAgZXh0ZW5kJDEodGhpcy5zZXR0aW5ncywgbyk7XG4gIH0sXG4gIGN1c3RvbVRoZW1lOiBmdW5jdGlvbiBjdXN0b21UaGVtZShuYW1lLCBiYXNlVGhlbWUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdGhlbWVzID0gbW9iaXNjcm9sbC50aGVtZXMsXG4gICAgICAgIGNvbXBzID0gWydmcmFtZScsICdzY3JvbGxlcicsICdsaXN0dmlldycsICduYXZpZ2F0aW9uJywgJ2Zvcm0nLCAncGFnZScsICdwcm9ncmVzcycsICdjYXJkJ107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoZW1lc1tjb21wc1tpXV1bbmFtZV0gPSBleHRlbmQkMSh7fSwgdGhlbWVzW2NvbXBzW2ldXVtiYXNlVGhlbWVdLCB7XG4gICAgICAgIGJhc2VUaGVtZTogYmFzZVRoZW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uIEJhc2UoZWwsIHNldHRpbmdzKSB7XG4gIHZhciBjdHgsXG4gICAgICBsYW5nLFxuICAgICAgcHJlc2V0LFxuICAgICAgcmVzcCxcbiAgICAgIHMsXG4gICAgICB0aGVtZSxcbiAgICAgIHRoZW1lTmFtZSxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIHRoYXQgPSB0aGlzO1xuICB0aGF0LnNldHRpbmdzID0ge307XG4gIHRoYXQuX2dldFRleHQgPSBuZXcgRnVuY3Rpb24oJ21vYmlzY3JvbGwsIHAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0S2V5KGVuY3J5cHRLZXkpIHtcbiAgICAgIHZhciBhID0gZW5jcnlwdEtleVswXSxcbiAgICAgICAgICBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBpZiAoYSAqIGkgJSAxNiA9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtpLCBlbmNyeXB0S2V5WzFdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFmZmluZShlbmMsIHN0ciwgYSwgYikge1xuICAgICAgdmFyIGFsZmIgPSAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gICAgICAgICAgbmV3c3RyID0gJycsXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgbmV3c3RyICs9IGVuYyA/IGFsZmJbKGEgKiBhbGZiLmluZGV4T2Yoc3RyW2ldKSArIGIpICUgMTZdIDogYWxmYlsoKGEgKiBhbGZiLmluZGV4T2Yoc3RyW2ldKSAtIGEgKiBiKSAlIDE2ICsgMTYpICUgMTZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3c3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY3J5cHQoc3RyLCBlbmNyeXB0S2V5KSB7XG4gICAgICB2YXIgZGVjcnlwdEtleSA9IGdldEtleShlbmNyeXB0S2V5KSxcbiAgICAgICAgICBkZWNyeXB0ZWRTdHIgPSBhZmZpbmUoMCwgc3RyLCBkZWNyeXB0S2V5WzBdLCBkZWNyeXB0S2V5WzFdKSxcbiAgICAgICAgICBsZW4gPSBkZWNyeXB0ZWRTdHIubGVuZ3RoLFxuICAgICAgICAgIGFyciA9IFtdLFxuICAgICAgICAgIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBhcnIucHVzaChkZWNyeXB0ZWRTdHJbaV0gKyBkZWNyeXB0ZWRTdHJbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICB2YXIgYSA9IGRlY3J5cHQoXCIzODM2MzUzN2E5YWJhNmE1M2ZhZjM2YWJhMGEwNjI4MWE5MzhhZThmZjlmZGY3MzZhMTM4MzEzNmEyNmM4OWFkMzhhYzYyMzZhZGEyYThhYmE5NmM2NWYwODlhZDM4YWM2MmE5YWQzYzZjZjQ2MmY0ZmE2MDM0NjVmYjYzZjBhOGE1M2E2NDNmMzgzNWEwYTFmOTY2NjM2N2FhMzFhMmFmMzhhNWFiYTI2Y2ExNjUzNzNhYWQzNjY0MzhmOWExNjJhMGExYTJhMzM4YWM2MGEyNjAzNmY3MzNhY2E1YTBhMTZjZjQ2ZGY5ZjkzODY1MzczNmY5ODlhZDM4YWM2MmFhYTBhYmFiMzY2Yzg5YWQzOGFjNjIzNmFkYTJhOGFiYTk2YzY1NmUzODY1ZjczODY5ZjlmZGY3YTJmOWExMTczODE5ZjdhMTE3MzgxOWY5YTExNzM2MTlmN2ExMTczNjE5ZjlhMjM5MzZhMTM4MzEzNmEyNjRhMTM5NmMxNzYzYThhNTNmMzRhMGFkMzVmZWE2YTBhYmFmYTc2ZGE1YTkzNGFiMzYzOGFkYTIzODYzNjA2MzM0YWIzZmE1MzhhNWFiYTJmZWFkYTYzZmFiYTAzMTM4YTE2ZGE1YTkzNGFiMzYzOGFkYTIzODYzNjA2MzNlNjlhNWEyYThhMTNjZmU2OWZkNjM2MDYzMzhhYjM0ZmVmNDZkYTVhOTM0YWIzNjM4YWRhMjM4NjM2MDYzYTBhMWFhMzhmZWY0NmRhNWE5MzRhYjM2MzhhZGEyMzg2MzYwNjNhNmFiMzgzOGFiYTlmZWY0NmRhNWE5MzRhYjM2MzhhZGEyMzg2MzYwNjMzNmE1YTNhYzM4ZmVmNDZkYTVhOTM0YWIzNjM4YWRhMjM4NjM2MDYzYTlhZDM2YTNhNWEyZmVmNDZkYTVhOTM0YWIzNjM4YWRhMjM4NjM2MDYzMzRhZGE4YThhNWEyYTNmZWY0NmRhNWE5MzRhYjM2MzhhZGEyMzg2MzYwNjNhYWFiYTIzODY5M2ZhNTNlYTFmZWZjMzQzYzZkYTVhOTM0YWIzNjM4YWRhMjM4NjM2MDYzYTBhNWEyYTE2OWFjYTFhNWEzYWMzOGZlZmRmNjM0M2M2MzYwNjMzOGExM2MzODY5YWRhMGE1YTNhMmZlYWZhMWEyMzhhMTM2NjM2MDYzYWIzNGFkYWZhNTM4MzVmZTYzNjc2Yzg5YWQzOGFjNjJhYWEwYWJhYjM2NmM4OWFkMzhhYzYyMzZhZGEyYThhYmE5NmM2NTZlZjZmNDY1NmJmZGY0ZjQ2N2Y0NjJmYzY1Njc2MzZkYTVhOTM0YWIzNjM4YWRhMjM4NjMxOTY1NjJhZWFiYTVhMjZjNjNmNzYzNjU2NzYzNjZmMjEwMzFmNGY0ZjFmODEwMzFmNGY0ZjFmNjEwMzFmNGY0ZjhmNTEwMzFmNGY0ZjhmZDEwMzFmNGY0ZjhhZmYwNmJhOGE1M2FmMjYzZmU2MzYzNjUzOWFmYWQzOGFmYWM2Y2ExNjUzNzM2YTEzODMxMzZhMjY0NjM2MzM5ZVwiLCBbOSwgNF0pLFxuICAgICAgICBiID0gJycsXG4gICAgICAgIGwgPSBhLmxlbmd0aCxcbiAgICAgICAgYztcblxuICAgIGZvciAoYyA9IDA7IGMgPCBsOyBjKyspIHtcbiAgICAgIGIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChhW2NdLCAxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBiO1xuICB9KCkpO1xuICB0aGF0LmVsZW1lbnQgPSBlbDtcbiAgdGhhdC5faW5pdCA9IG5vb3A7XG4gIHRoYXQuX2Rlc3Ryb3kgPSBub29wO1xuICB0aGF0Ll9wcm9jZXNzU2V0dGluZ3MgPSBub29wO1xuXG4gIHRoYXQuX2NoZWNrUmVzcCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIGlmICh0aGF0ICYmIHRoYXQuX3Jlc3BvbnNpdmUpIHtcbiAgICAgIHZhciBuZXdSZXNwID0gZ2V0UmVzcG9uc2l2ZVNldHRpbmdzKHdpZHRoKTtcblxuICAgICAgaWYgKHJlc3AgIT09IG5ld1Jlc3ApIHtcbiAgICAgICAgcmVzcCA9IG5ld1Jlc3A7XG4gICAgICAgIHRoYXQuaW5pdCh7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9nZXRSZXNwQ29udCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJCQxKHMuY29udGV4dCA9PSAnYm9keScgPyB3aW5kb3cgOiBzLmNvbnRleHQpO1xuICB9O1xuXG4gIHRoYXQuaW5pdCA9IGZ1bmN0aW9uIChuZXdTZXR0aW5ncywgbmV3VmFsdWUpIHtcbiAgICB2YXIga2V5LCB2YWx1ZTsgLy8gSW4gY2FzZSBvZiBzZXR0aW5ncyB1cGRhdGUgc2F2ZSB0aGUgb2xkIHZhbHVlXG5cbiAgICBpZiAobmV3U2V0dGluZ3MgJiYgdGhhdC5nZXRWYWwpIHtcbiAgICAgIHZhbHVlID0gdGhhdC5nZXRWYWwoKTtcbiAgICB9IC8vIFJlc2V0IHNldHRpbmdzIG9iamVjdFxuXG5cbiAgICBmb3IgKGtleSBpbiB0aGF0LnNldHRpbmdzKSB7XG4gICAgICBkZWxldGUgdGhhdC5zZXR0aW5nc1trZXldO1xuICAgIH1cblxuICAgIHMgPSB0aGF0LnNldHRpbmdzOyAvLyBVcGRhdGUgb3JpZ2luYWwgdXNlciBzZXR0aW5nc1xuXG4gICAgZXh0ZW5kJDEoc2V0dGluZ3MsIG5ld1NldHRpbmdzKTsgLy8gTG9hZCB1c2VyIGRlZmF1bHRzXG5cbiAgICBpZiAodGhhdC5faGFzRGVmKSB7XG4gICAgICBkZWZhdWx0cyA9IG1zLnNldHRpbmdzO1xuICAgIH0gLy8gQ3JlYXRlIHNldHRpbmdzIG9iamVjdFxuXG5cbiAgICBleHRlbmQkMShzLCB0aGF0Ll9kZWZhdWx0cywgZGVmYXVsdHMsIHNldHRpbmdzKTtcbiAgICBjdHggPSB0aGF0Ll9nZXRSZXNwQ29udCgpO1xuXG4gICAgaWYgKHRoYXQuX3Jlc3BvbnNpdmUpIHtcbiAgICAgIGlmICghcmVzcCkge1xuICAgICAgICByZXNwID0gZ2V0UmVzcG9uc2l2ZVNldHRpbmdzKCk7XG4gICAgICB9XG5cbiAgICAgIGV4dGVuZCQxKHMsIHJlc3ApO1xuICAgIH0gLy8gR2V0IHRoZW1lIGRlZmF1bHRzXG5cblxuICAgIGlmICh0aGF0Ll9oYXNUaGVtZSkge1xuICAgICAgdGhlbWVOYW1lID0gZ2V0VGhlbWVOYW1lKHMpO1xuICAgICAgc2V0dGluZ3MudGhlbWUgPSB0aGVtZU5hbWU7XG4gICAgICB0aGVtZSA9IG1zLnRoZW1lc1t0aGF0Ll9jbGFzc10gPyBtcy50aGVtZXNbdGhhdC5fY2xhc3NdW3RoZW1lTmFtZV0gOiB7fTtcbiAgICB9IC8vIEdldCBsYW5ndWFnZSBkZWZhdWx0c1xuXG5cbiAgICBpZiAodGhhdC5faGFzTGFuZykge1xuICAgICAgbGFuZyA9IG1zLmkxOG5bcy5sYW5nXTtcbiAgICB9IC8vIFVwZGF0ZSBzZXR0aW5ncyBvYmplY3RcblxuXG4gICAgZXh0ZW5kJDEocywgdGhlbWUsIGxhbmcsIGRlZmF1bHRzLCBzZXR0aW5ncywgcmVzcCk7XG5cbiAgICB0aGF0Ll9wcm9jZXNzU2V0dGluZ3MocmVzcCB8fCB7fSk7IC8vIC0tLSBSRU1PVEUgVFJJQUwgQ09ERSBTVEFSVCAtLS1cblxuXG4gICAgdmFyIG5vUmVtb3RlID0ge1xuICAgICAgZm9ybTogdHJ1ZSxcbiAgICAgIHBhZ2U6IHRydWUsXG4gICAgICBwcm9ncmVzczogdHJ1ZSxcbiAgICAgIHN3aXRjaDogdHJ1ZSxcbiAgICAgIHNsaWRlcjogdHJ1ZSxcbiAgICAgIHN0ZXBwZXI6IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9EYXRlU3RyKGQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZCA9PSAnc3RyaW5nJyA/IGQgOiBnZXRJU09TdHJpbmcobWFrZURhdGUoZCksIHtcbiAgICAgICAgeTogMSxcbiAgICAgICAgbTogMSxcbiAgICAgICAgZDogMSxcbiAgICAgICAgaDogMSxcbiAgICAgICAgaTogMSxcbiAgICAgICAgczogMSxcbiAgICAgICAgdTogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoYXQuX2luaXQobmV3U2V0dGluZ3MpOyAvLyBJbiBjYXNlIG9mIHNldHRpbmdzIHVwZGF0ZSByZXNldCB0aGUgdmFsdWUuXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhZGFwdCB0aGUgdmFsdWUgZm9yIHRoZSB1cGRhdGVkIHNldHRpbmdzXG4gICAgICAvLyBFLmcuIG1pbi9tYXgsIGRhdGUgZm9ybWF0LCBldGMuXG5cblxuICAgICAgaWYgKG5ld1NldHRpbmdzICYmIHRoYXQuc2V0VmFsKSB7XG4gICAgICAgIHRoYXQuc2V0VmFsKG5ld1ZhbHVlID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IG5ld1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcignb25Jbml0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGF0Ll9jbGFzcyB8fCBub1JlbW90ZVt0aGF0Ll9jbGFzc10pIHtcbiAgICAgIGluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtcy5md3YpIHtcbiAgICAgICAgdmFyIHZlcnM7XG5cbiAgICAgICAgc3dpdGNoIChtcy5mdykge1xuICAgICAgICAgIGNhc2UgJ2FuZ3VsYXInOlxuICAgICAgICAgICAgdmVycyA9ICQkMSgnW25nLXZlcnNpb25dJykuYXR0cignbmctdmVyc2lvbicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdqcXVlcnknOlxuICAgICAgICAgICAgdmVycyA9ICQkMS5mbiAmJiAkJDEuZm4uanF1ZXJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtcy5md3YgPSB2ZXJzIHx8ICdOL0EnO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBjbGFzc05hbWU6IHRoYXQuX2NsYXNzLFxuICAgICAgICBidXR0b25zOiB0aGF0LmJ1dHRvbnMsXG4gICAgICAgIHBsYXRmb3JtOiBtcy5wbGF0Zm9ybSxcbiAgICAgICAgdjogbXMudmVyc2lvbixcbiAgICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBkZWZTb3J0SGFuZGxlOiAkJDEoZWwpLmZpbmQocy5saXN0U2VsZWN0b3IgfHwgJ3VsLG9sJykubGVuZ3RoID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgLy8gRm9yIGxpc3R2aWV3XG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgYW1wbVRleHQ6IHMuYW1wbVRleHQsXG4gICAgICAgICAgYW1UZXh0OiBzLmFtVGV4dCxcbiAgICAgICAgICBhbmltYXRlSWNvbnM6IHMuYW5pbWF0ZUljb25zLFxuICAgICAgICAgIGJhY2tUZXh0OiBzLmJhY2tUZXh0LFxuICAgICAgICAgIGJhc2VUaGVtZTogcy5iYXNlVGhlbWUsXG4gICAgICAgICAgYnV0dG9uczogcy5idXR0b25zLFxuICAgICAgICAgIGJ0bkNsYXNzOiBzLmJ0bkNsYXNzLFxuICAgICAgICAgIGJ0bldpZHRoOiBzLmJ0bldpZHRoLFxuICAgICAgICAgIGJ0blJldmVyc2U6IHMuYnRuUmV2ZXJzZSxcbiAgICAgICAgICBjbG9zZUljb246IHMuY2xvc2VJY29uLFxuICAgICAgICAgIGNvbnRleHQ6IHMuY29udGV4dCA9PSAnYm9keScgPyAnYm9keScgOiAnJyxcbiAgICAgICAgICBjb250cm9sczogcy5jb250cm9scyxcbiAgICAgICAgICBjc3NDbGFzczogcy5jc3NDbGFzcyxcbiAgICAgICAgICBkYXRlRGlzcGxheTogcy5kYXRlRGlzcGxheSxcbiAgICAgICAgICBkYXRlRm9ybWF0OiBzLmRhdGVGb3JtYXQsXG4gICAgICAgICAgZGF0ZVdoZWVsczogcy5kYXRlV2hlZWxzLFxuICAgICAgICAgIGRheU5hbWVzOiBzLmRheU5hbWVzLFxuICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IHMuZGF5TmFtZXNTaG9ydCxcbiAgICAgICAgICBkYXlTdWZmaXg6IHMuZGF5U3VmZml4LFxuICAgICAgICAgIGRpc3BsYXk6IHMuZGlzcGxheSxcbiAgICAgICAgICBkYXlUZXh0OiBzLmRheVRleHQsXG4gICAgICAgICAgZW5kWWVhcjogcy5lbmRZZWFyLFxuICAgICAgICAgIGZpeGVkSGVhZGVyOiBzLmZpeGVkSGVhZGVyLFxuICAgICAgICAgIGhhbmRsZUNsYXNzOiBzLmhhbmRsZUNsYXNzLFxuICAgICAgICAgIGhhbmRsZU1hcmt1cDogcy5oYW5kbGVNYXJrdXAsXG4gICAgICAgICAgaGlkZVRleHQ6IHMuaGlkZVRleHQsXG4gICAgICAgICAgaG91clRleHQ6IHMuaG91clRleHQsXG4gICAgICAgICAgaXRlbU5vZGU6IHMuaXRlbU5vZGUsXG4gICAgICAgICAgaXRlbVdpZHRoOiBzLml0ZW1XaWR0aCxcbiAgICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgICAgbGFwSWNvbjogcy5sYXBJY29uLFxuICAgICAgICAgIGxhcFRleHQ6IHMubGFwVGV4dCxcbiAgICAgICAgICBsYXlvdXQ6IHMubGF5b3V0LFxuICAgICAgICAgIGxlZnRBcnJvd0NsYXNzOiBzLmxlZnRBcnJvd0NsYXNzLFxuICAgICAgICAgIG1heDogdG9EYXRlU3RyKHMubWF4KSxcbiAgICAgICAgICBtaW46IHRvRGF0ZVN0cihzLm1pbiksXG4gICAgICAgICAgbWludXRlVGV4dDogcy5taW51dGVUZXh0LFxuICAgICAgICAgIG1vbnRoTmFtZXM6IHMubW9udGhOYW1lcyxcbiAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IHMubW9udGhOYW1lc1Nob3J0LFxuICAgICAgICAgIG1vbnRoU3VmZml4OiBzLm1vbnRoU3VmZml4LFxuICAgICAgICAgIG1vbnRoVGV4dDogcy5tb250aFRleHQsXG4gICAgICAgICAgbm93SWNvbjogcy5ub3dJY29uLFxuICAgICAgICAgIG5vd1RleHQ6IHMubm93VGV4dCxcbiAgICAgICAgICBwbVRleHQ6IHMucG1UZXh0LFxuICAgICAgICAgIHByZXNldDogcy5wcmVzZXQsXG4gICAgICAgICAgcmVzZXRJY29uOiBzLnJlc2V0SWNvbixcbiAgICAgICAgICByZXNldFRleHQ6IHMucmVzZXRUZXh0LFxuICAgICAgICAgIHJpZ2h0QXJyb3dDbGFzczogcy5yaWdodEFycm93Q2xhc3MsXG4gICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICBzZWNUZXh0OiBzLnNlY1RleHQsXG4gICAgICAgICAgc2VsZWN0OiBzLnNlbGVjdCxcbiAgICAgICAgICBzaG93T3ZlcmxheTogcy5zaG93T3ZlcmxheSxcbiAgICAgICAgICBzbmFwOiBzLnNuYXAsXG4gICAgICAgICAgc29ydDogcy5zb3J0LFxuICAgICAgICAgIHNvcnRhYmxlOiBzLnNvcnRhYmxlLFxuICAgICAgICAgIHNvcnRIYW5kbGU6IHMuc29ydEhhbmRsZSxcbiAgICAgICAgICBzdGFydEljb246IHMuc3RhcnRJY29uLFxuICAgICAgICAgIHN0YXJ0VGV4dDogcy5zdGFydFRleHQsXG4gICAgICAgICAgc3RhcnRZZWFyOiBzLnN0YXJ0WWVhcixcbiAgICAgICAgICBzdGVwSG91cjogcy5zdGVwSG91cixcbiAgICAgICAgICBzdGVwTWludXRlOiBzLnN0ZXBNaW51dGUsXG4gICAgICAgICAgc3RlcFNlY29uZDogcy5zdGVwU2Vjb25kLFxuICAgICAgICAgIHN0ZXBzOiBzLnN0ZXBzLFxuICAgICAgICAgIHN0b3BJY29uOiBzLnN0b3BJY29uLFxuICAgICAgICAgIHN0b3BUZXh0OiBzLnN0b3BUZXh0LFxuICAgICAgICAgIHN0cmlwZWQ6IHMuc3RyaXBlZCxcbiAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICB0aW1lRm9ybWF0OiBzLnRpbWVGb3JtYXQsXG4gICAgICAgICAgdGltZVdoZWVsczogcy50aW1lV2hlZWxzLFxuICAgICAgICAgIHRvZGF5VGV4dDogcy50b2RheVRleHQsXG4gICAgICAgICAgdHlwZTogcy50eXBlLFxuICAgICAgICAgIHZhcmlhbnQ6IHMudmFyaWFudCxcbiAgICAgICAgICB3cmFwcGVyQ2xhc3M6IHMud3JhcHBlckNsYXNzLFxuICAgICAgICAgIHllYXJTdWZmaXg6IHMueWVhclN1ZmZpeCxcbiAgICAgICAgICB5ZWFyVGV4dDogcy55ZWFyVGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBwcm9wLFxuICAgICAgICAgIHEgPSBbXSxcbiAgICAgICAgICB0ZW1wSW5zdCA9IHt9LFxuICAgICAgICAgIHByZXNldEZ1bmN0aW9ucyA9IFsncmVmcmVzaCcsICdyZWRyYXcnLCAnbmF2aWdhdGUnLCAnY2hhbmdlVGFiJywgLy8gQ2FsZW5kYXIgQmFzZVxuICAgICAgJ2dldERhdGUnLCAnc2V0RGF0ZScsIC8vIERhdGV0aW1lXG4gICAgICAnYWRkRXZlbnQnLCAncmVtb3ZlRXZlbnQnLCAnZ2V0RXZlbnRzJywgJ3NldEV2ZW50cycsIC8vIEV2ZW50IGNhbGVuZGFyXG4gICAgICAnc2V0QWN0aXZlRGF0ZScsIC8vIFJhbmdlXG4gICAgICAnc3RhcnQnLCAnc3RvcCcsICdyZXNldCcsICdsYXAnLCAncmVzZXRsYXAnLCAnZ2V0VGltZScsICdzZXRUaW1lJywgJ2dldEVsbGFwc2VkVGltZScsICdzZXRFbGxhcHNlZFRpbWUnIC8vIFRpbWVyXG4gICAgICBdLFxuICAgICAgICAgIG5vUHJveHkgPSB7XG4gICAgICAgIGpzb25wOiAxLFxuICAgICAgICBnZXRJbnN0OiAxLFxuICAgICAgICBpbml0OiAxLFxuICAgICAgICBkZXN0cm95OiAxXG4gICAgICB9LFxuICAgICAgICAgIHByb3h5ID0gZnVuY3Rpb24gcHJveHkobmFtZSkge1xuICAgICAgICB0aGF0W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHEucHVzaCh7XG4gICAgICAgICAgICBmdW5jOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogYXJndW1lbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9OyAvLyBPdmVycmlkZSBhbGwgbWV0aG9kcyBvZiB0aGUgaW5zdGFuY2UgdG8gZGVsYXkgZXhlY3V0aW9uXG4gICAgICAvLyB1bnRpbCB0aGUgc2VydmVyIHNpZGUgaW5pdGlhbGl6YXRpb24gaXMgZG9uZS5cbiAgICAgIC8vIEZvciB0aGlzIHdlIGNyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGp1c3QgcHVzaGVzIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICAvLyBhbmQgYXJndW1lbnRzIGludG8gYSBxdWV1ZS5cblxuXG4gICAgICBmb3IgKHByb3AgaW4gdGhhdCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoYXRbcHJvcF0gPT09ICdmdW5jdGlvbicgJiYgIW5vUHJveHlbcHJvcF0pIHtcbiAgICAgICAgICB0ZW1wSW5zdFtwcm9wXSA9IHRoYXRbcHJvcF07XG4gICAgICAgICAgcHJveHkocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJveHkgcG9zc2libGUgcHJlc2V0IGZ1bmN0aW9ucywgd2hpY2ggZG9lcyBub3QgZXhpc3QgeWV0XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHByZXNldEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm94eShwcmVzZXRGdW5jdGlvbnNbaV0pO1xuICAgICAgfSAvLyBXb3JrYXJvdW5kIGZvciB0aW1lciBidXR0b25zXG5cblxuICAgICAgaWYgKHMucHJlc2V0ID09ICd0aW1lcicgJiYgIXNldHRpbmdzLmJ1dHRvbnMpIHtcbiAgICAgICAgY29uZmlnLnNldHRpbmdzLmJ1dHRvbnMgPSBbJ3Jlc2V0bGFwJywgJ3RvZ2dsZSddO1xuXG4gICAgICAgIGlmIChzLmRpc3BsYXkgIT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgY29uZmlnLnNldHRpbmdzLmJ1dHRvbnMudW5zaGlmdCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzLnByZXNldCA9PSAnZXZlbnRjYWxlbmRhcicgJiYgIXNldHRpbmdzLmJ1dHRvbnMgJiYgcy5kaXNwbGF5ICE9ICdpbmxpbmUnKSB7XG4gICAgICAgIGNvbmZpZy5zZXR0aW5ncy5idXR0b25zID0gWydjbG9zZSddO1xuICAgICAgfVxuXG4gICAgICBzLnpvbmUgPSBzLnpvbmUgfHwge1xuICAgICAgICBydW46IGZ1bmN0aW9uIHJ1bihmdW5jKSB7XG4gICAgICAgICAgZnVuYygpO1xuICAgICAgICB9LFxuICAgICAgICBydW5PdXRzaWRlQW5ndWxhcjogZnVuY3Rpb24gcnVuT3V0c2lkZUFuZ3VsYXIoZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1zLmFwaUtleSAhPT0gJ21ic2NkZW1vJykge1xuICAgICAgICBsb2dEYXRhLnRoZW1lID0gcy50aGVtZTtcbiAgICAgICAgbG9nRGF0YS5jb21wb25lbnRzID0gbG9nRGF0YS5jb21wb25lbnRzIHx8IFtdO1xuICAgICAgICBsb2dEYXRhLmNvbXBvbmVudHMucHVzaCh0aGF0Ll9jbGFzcyArICdfJyArIChzLnByZXNldCB8fCAnJykpO1xuICAgICAgICBzZW5kTG9nKCk7XG4gICAgICB9XG5cbiAgICAgIHRoYXQuanNvbnAoJ3JlbW90ZScsIGNvbmZpZywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCF0aGF0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC5yZW1vdGUgPSBkYXRhOyAvLyBDb3B5IGJhY2sgb3JpZ2luYWwgZnVuY3Rpb25zIGluIHBsYWNlIG9mIHRoZSBwcm94eVxuXG4gICAgICAgICAgZm9yIChwcm9wIGluIHRlbXBJbnN0KSB7XG4gICAgICAgICAgICB0aGF0W3Byb3BdID0gdGVtcEluc3RbcHJvcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRhdGEubm90aWZpY2F0aW9uICE9PSB1bmRlZmluZWQgJiYgIW1lc3NhZ2VTaG93KSB7XG4gICAgICAgICAgICBtZXNzYWdlU2hvdyA9IHRydWU7XG4gICAgICAgICAgICBtb2Jpc2Nyb2xsLnNuYWNrYmFyKGRhdGEubm90aWZpY2F0aW9uKTtcbiAgICAgICAgICB9IC8vIFdvcmthcm91bmQgZm9yIHJlbW90ZSBkYXRhIHVwZGF0ZXNcblxuXG4gICAgICAgICAgdmFyIHNldHRpbmdzQ29weSA9IGV4dGVuZCQxKHt9LCBzZXR0aW5ncyk7XG4gICAgICAgICAgZGVsZXRlIHNldHRpbmdzQ29weS5kYXRhOyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgRU5EIC0tLVxuICAgICAgICAgIC8vIExvYWQgcHJlc2V0IHNldHRpbmdzXG5cbiAgICAgICAgICBpZiAodGhhdC5fcHJlc2V0cykge1xuICAgICAgICAgICAgcHJlc2V0ID0gdGhhdC5fcHJlc2V0c1tzLnByZXNldF07XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXQpIHtcbiAgICAgICAgICAgICAgcHJlc2V0ID0gcHJlc2V0LmNhbGwoZWwsIHRoYXQsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgZXh0ZW5kJDEocywgcHJlc2V0LCBzZXR0aW5nc0NvcHksIHJlc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXQoKTsgLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIFNUQVJUIC0tLVxuICAgICAgICAgIC8vIEV4ZWN1dGUgZnVuY3Rpb25zIGluIHRoZSBxdWV1ZVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoYXRbcVtpXS5mdW5jXS5hcHBseSh0aGF0LCBxW2ldLmFyZ3MpO1xuICAgICAgICAgIH0gLy8gRW1wdHkgdGVtcG9yYXJ5IHZhcmlhYmxlc1xuXG5cbiAgICAgICAgICBxID0gbnVsbDtcbiAgICAgICAgICB0ZW1wSW5zdCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZ3VpZCk7XG4gICAgfSAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgRU5EIC0tLVxuXG4gIH07XG5cbiAgdGhhdC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGF0KSB7XG4gICAgICB0aGF0Ll9kZXN0cm95KCk7XG5cbiAgICAgIHRyaWdnZXIoJ29uRGVzdHJveScpOyAvLyBEZWxldGUgc2Nyb2xsZXIgaW5zdGFuY2VcblxuICAgICAgZGVsZXRlIGluc3RhbmNlc1tlbC5pZF07XG4gICAgICB0aGF0ID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBdHRhY2ggdGFwIGV2ZW50IHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cblxuXG4gIHRoYXQudGFwID0gZnVuY3Rpb24gKGVsLCBoYW5kbGVyLCBwcmV2ZW50LCB0b2xlcmFuY2UsIHRpbWUpIHtcbiAgICB0YXAodGhhdCwgZWwsIGhhbmRsZXIsIHByZXZlbnQsIHRvbGVyYW5jZSwgdGltZSk7XG4gIH07XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiBldmVudFxuICAgKi9cblxuXG4gIHRoYXQudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCBldikge1xuICAgIHZhciByZXQsXG4gICAgICAgIGksXG4gICAgICAgIHYsXG4gICAgICAgIHMgPSBbZGVmYXVsdHMsIHRoZW1lLCBwcmVzZXQsIHNldHRpbmdzXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHYgPSBzW2ldO1xuXG4gICAgICBpZiAodiAmJiB2W25hbWVdKSB7XG4gICAgICAgIHJldCA9IHZbbmFtZV0uY2FsbChlbCwgZXYgfHwge30sIHRoYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIC8qKlxuICAgKiBTZXRzIG9uZSBvcmUgbW9yZSBvcHRpb25zLlxuICAgKi9cblxuXG4gIHRoYXQub3B0aW9uID0gZnVuY3Rpb24gKG9wdCwgdmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9iaiA9IHt9LFxuICAgICAgICAvLyBwcmVzZXJ2ZSBzZXR0aW5ncyB0aGF0IGFyZSBwb3NzaWJsZSB0byBjaGFuZ2UgcnVudGltZVxuICAgIGR5bmFtaWMgPSBbJ2RhdGEnLCAnaW52YWxpZCcsICd2YWxpZCcsICdyZWFkb25seSddO1xuXG4gICAgaWYgKC9jYWxlbmRhcnxldmVudGNhbGVuZGFyfHJhbmdlLy50ZXN0KHMucHJlc2V0KSkge1xuICAgICAgZHluYW1pYy5wdXNoKCdtYXJrZWQnLCAnbGFiZWxzJywgJ2NvbG9ycycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnb2JqZWN0Jykge1xuICAgICAgb2JqID0gb3B0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbb3B0XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGR5bmFtaWMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgc2V0dGluZ3Nbdl0gPSBzW3ZdO1xuICAgIH0pO1xuICAgIHRoYXQuaW5pdChvYmosIG5ld1ZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vYmlzY3JvbGwgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgdGhhdC5nZXRJbnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGF0O1xuICB9OyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgU1RBUlQgLS0tXG5cblxuICB0aGF0Lmpzb25wID0ganNvbnA7XG4gIHZhciBndWlkID0gJ2NvbXBfJyArIChlbC5pZCB8fCArK3VpZCk7IC8vIC0tLSBSRU1PVEUgVFJJQUwgQ09ERSBFTkQgLS0tXG5cbiAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcblxuICBmdW5jdGlvbiBnZXRSZXNwb25zaXZlU2V0dGluZ3Modykge1xuICAgIHZhciByZXN1bHQgPSBlbXB0eSxcbiAgICAgICAgd2lkdGg7XG5cbiAgICBpZiAocy5yZXNwb25zaXZlKSB7XG4gICAgICB3aWR0aCA9IHcgfHwgZ2V0V2lkdGgoY3R4KTtcbiAgICAgICQkMS5lYWNoKHMucmVzcG9uc2l2ZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHdpZHRoID49ICh2YWx1ZS5icmVha3BvaW50IHx8IGJyZWFrcG9pbnRzW2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3QoKSB7XG4gICAgJCQxKGVsKS5hZGRDbGFzcygnbWJzYy1jb21wJyk7IC8vIEF1dG9nZW5lcmF0ZSBpZFxuXG4gICAgaWYgKCFlbC5pZCkge1xuICAgICAgZWwuaWQgPSAnbW9iaXNjcm9sbCcgKyArK2lkO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VzW2VsLmlkXSkge1xuICAgICAgaW5zdGFuY2VzW2VsLmlkXS5kZXN0cm95KCk7XG4gICAgfSAvLyBTYXZlIGluc3RhbmNlXG5cblxuICAgIGluc3RhbmNlc1tlbC5pZF0gPSB0aGF0O1xuICAgIHRoYXQuX19yZWFkeSA9IHRydWU7XG4gIH1cblxuICBpZiAoIXRoYXQuX19yZWFkeSkge1xuICAgIGNvbnN0cnVjdCgpO1xuICB9XG59OyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgU1RBUlQgLS0tXG5cblxudmFyIHVpZCA9IDA7XG52YXIgbG9nRGF0YSA9IHt9O1xudmFyIGxvZ1RpbWVyO1xuXG5mdW5jdGlvbiBzZW5kRXJyb3IoKSB7XG4gIHZhciBzZXNzaW9uSUQgPSBkb2N1bWVudC5jb29raWUucmVwbGFjZSgvKD86KD86XnwuKjtcXHMqKUFTUC5ORVRfU2Vzc2lvbklkXFxzKj1cXHMqKFteO10qKS4qJCl8Xi4qJC8sIFwiJDFcIik7XG4gIGRvY3VtZW50LmNvb2tpZSA9ICdtb2Jpc2Nyb2xsQ2xpZW50RXJyb3I9MTsgZXhwaXJlcz0nICsgbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAxMDAwICogNjAgKiA2MCAqIDI0KS50b1VUQ1N0cmluZygpICsgJzsgcGF0aD0vJzsgLy8gV29ya2Fyb3VuZCBmb3IgZmlsZSBwcm90b2NvbGxcblxuICB0cnkge1xuICAgIHdpbmRvdy5uYW1lID0gKHdpbmRvdy5uYW1lIHx8ICcnKSArICc7bW9iaXNjcm9sbENsaWVudEVycm9yJztcbiAgfSBjYXRjaCAoZSkgey8vIE1ha2UgZXNsaW50IGhhcHB5XG4gIH1cblxuICBqc29ucCgnZXJyb3InLCB7XG4gICAgdHJpYWxDb2RlOiBtcy5hcGlLZXksXG4gICAgc2Vzc2lvbklEOiBzZXNzaW9uSURcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmNvb2tpZSA9ICdtb2Jpc2Nyb2xsQ2xpZW50RXJyb3I9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDOyBwYXRoPS8nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5uYW1lID0gKHdpbmRvdy5uYW1lIHx8ICcnKS5yZXBsYWNlKC87bW9iaXNjcm9sbENsaWVudEVycm9yL2csICcnKTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gTWFrZSBlc2xpbnQgaGFwcHlcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZW5kTG9nKCkge1xuICBjbGVhclRpbWVvdXQobG9nVGltZXIpO1xuICBsb2dUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGV4dGVuZCQxKGxvZ0RhdGEsIHtcbiAgICAgIHRyaWFsQ29kZTogbXMuYXBpS2V5LFxuICAgICAgZnc6IG1zLmZ3ICsgKHdpbmRvdy5Jb25pYyB8fCB3aW5kb3cuaW9uaWMgPyAnLWlvbmljJyA6ICcnKSxcbiAgICAgIGZ3djogbXMuZnd2LFxuICAgICAgZGVtbzogISF3aW5kb3cuaXNNYnNjRGVtbyxcbiAgICAgIHY6IG1zLnZlcnNpb25cbiAgICB9KTtcbiAgICBqc29ucCgnbG9nJywgbG9nRGF0YSwgZnVuY3Rpb24gKCkge1xuICAgICAgbG9nRGF0YSA9IHt9O1xuICAgIH0pO1xuICB9LCA1MDAwKTtcbn1cblxuZnVuY3Rpb24ganNvbnAobWV0aG9kLCBkYXRhLCBjYWxsYmFjaywgdW5pcXVlSWQsIGF0dGVtcHRzKSB7XG4gIHZhciB0aW1lcixcbiAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgdW5pcXVlID0gJ21ic2NfanNvbnBfJyArICh1bmlxdWVJZCA/IHVuaXF1ZUlkIDogKytpZCk7XG4gIGF0dGVtcHRzID0gYXR0ZW1wdHMgfHwgMTtcblxuICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgIGlmICh3aW5kb3dbdW5pcXVlXSkge1xuICAgICAgd2luZG93W3VuaXF1ZV0oKTtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAncmVtb3RlJykge1xuICAgICAgaWYgKGF0dGVtcHRzIDwgNCkge1xuICAgICAgICBqc29ucChtZXRob2QsIGRhdGEsIGNhbGxiYWNrLCB1bmlxdWVJZCwgYXR0ZW1wdHMgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoIW1zLnRyaWFsRXJyb3IpIHtcbiAgICAgICAgbXMudHJpYWxFcnJvciA9IHRydWU7XG4gICAgICAgIHNlbmRFcnJvcigpO1xuXG4gICAgICAgIGlmIChtcy5hcGlLZXkgIT0gJ21ic2NkZW1vJykge1xuICAgICAgICAgIGFsZXJ0KCdNb2Jpc2Nyb2xsIHRyaWFsIG5vdCBsb2FkZWQuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24uIElmIHRoZSBwcm9ibGVtIHBlcnNpc3RzLCBjb250YWN0IHVzIGF0IHN1cHBvcnRAbW9iaXNjcm9sbC5jb20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvd1t1bmlxdWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgZGVsZXRlIHdpbmRvd1t1bmlxdWVdO1xuICAgIGNhbGxiYWNrKGRhdGEgPyBKU09OLnBhcnNlKGRhdGEsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCA4KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gd2luZG93LmV2YWwoJygnICsgdmFsdWUgKyAnKScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubWF0Y2goSVNPXzg2MDFfRlVMTCkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VEYXRlKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pIDoge30pO1xuICB9O1xuXG4gIHRpbWVyID0gc2V0VGltZW91dChvbkVycm9yLCA2MDAwKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICBzY3JpcHQuc3JjID0gbXMuYXBpVXJsICsgbXMuYXBpS2V5ICsgJy8nICsgbWV0aG9kICsgJz9jYWxsYmFjaz0nICsgdW5pcXVlICsgJyZkYXRhPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgJCQxKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZG9jdW1lbnQuY29va2llLnJlcGxhY2UoLyg/Oig/Ol58Lio7XFxzKiltb2Jpc2Nyb2xsQ2xpZW50RXJyb3JcXHMqPVxccyooW147XSopLiokKXxeLiokLywgXCIkMVwiKSB8fCAvbW9iaXNjcm9sbENsaWVudEVycm9yLy50ZXN0KHdpbmRvdy5uYW1lIHx8ICcnKSkge1xuICAgICAgc2VuZEVycm9yKCk7XG4gICAgfVxuICB9KTtcbn0gLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIEVORCAtLS1cblxudmFyIE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG4gICAgdGhpcy5rZXlDb3VudCA9IDA7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5Q291bnQrKztcbiAgICB0aGlzLnN1YnNjcmliZXJzLnNldChrZXksIGhhbmRsZXIpO1xuICAgIHJldHVybiBrZXk7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm91bmRLZXlfMSA9IG51bGw7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAgICAgaWYgKGZuID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgZm91bmRLZXlfMSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmb3VuZEtleV8xKTtcbiAgICB9XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbnZhciBNYnNjUm91dGVyVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NSb3V0ZXJUb2tlbigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1ic2NSb3V0ZXJUb2tlbjtcbn0oKSk7XG52YXIgTWJzY09wdGlvbnNTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjT3B0aW9uc1NlcnZpY2UoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjT3B0aW9uc1NlcnZpY2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gbztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY09wdGlvbnNTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgTWJzY09wdGlvbnNTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NPcHRpb25zU2VydmljZTtcbn0oKSk7XG52YXIgTWJzY0lucHV0U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0lucHV0U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFNldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjSW5wdXRTZXJ2aWNlLnByb3RvdHlwZSwgXCJpc0NvbnRyb2xTZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250cm9sU2V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sU2V0ID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NJbnB1dFNlcnZpY2UucHJvdG90eXBlLCBcImlucHV0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50UmVmO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjSW5wdXRTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgTWJzY0lucHV0U2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjSW5wdXRTZXJ2aWNlO1xufSgpKTtcbnZhciBNYnNjTGlzdFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NMaXN0U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5hZGRSZW1vdmVPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICB9XG4gICAgTWJzY0xpc3RTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlBZGRSZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB0aGlzLmFkZFJlbW92ZU9ic2VydmFibGUubmV4dChpdGVtKTtcbiAgICB9O1xuICAgIE1ic2NMaXN0U2VydmljZS5wcm90b3R5cGUub25BZGRSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJlbW92ZU9ic2VydmFibGU7XG4gICAgfTtcbiAgICBNYnNjTGlzdFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBNYnNjTGlzdFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0xpc3RTZXJ2aWNlO1xufSgpKTtcbnZhciBNYnNjQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0Jhc2UoaW5pdGlhbEVsZW0sIHpvbmUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsRWxlbSA9IGluaXRpYWxFbGVtO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbkluaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25EZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmogPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGhlbWVDbGFzc2VzU2V0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmouem9uZSA9IHpvbmU7XG4gICAgfVxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5nZXRJbmxpbmVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0aGlzXzFbcHJvcF0gaW5zdGFuY2VvZiAoRXZlbnRFbWl0dGVyKSAmJiAoIXRoaXNfMS5vcHRpb25zIHx8ICEodGhpc18xLm9wdGlvbnNbcHJvcF0pKSkge1xuICAgICAgICAgICAgICAgIHRoaXNfMS5pbmxpbmVPcHRpb25zT2JqW3Byb3BdID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lmluc3QgPSBpbnN0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1twcm9wXS5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzKSB7XG4gICAgICAgICAgICBfbG9vcF8xKHByb3ApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUuc2V0VGhlbWVDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkJDEodGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KS5hZGRDbGFzcyh0aGlzLmdldFRoZW1lQ2xhc3NlcygpKTtcbiAgICAgICAgdGhpcy50aGVtZUNsYXNzZXNTZXQgPSB0cnVlO1xuICAgIH07XG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLmNsZWFyVGhlbWVDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkJDEodGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyh0aGlzLmdldFRoZW1lQ2xhc3NlcygpKTtcbiAgICB9O1xuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5nZXRUaGVtZUNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbnN0YW5jZS5zZXR0aW5ncztcbiAgICAgICAgcmV0dXJuICdtYnNjLWNvbnRyb2wtbmcgbWJzYy0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJyk7XG4gICAgfTtcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgY29udGVudElucHV0ID0gJCQxKCdpbnB1dCcsIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChjb250ZW50SW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBjb250ZW50SW5wdXRbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnN0YXJ0SW5pdCgpO1xuICAgIH07XG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLnN0YXJ0SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5nZXRJbmxpbmVFdmVudHMoKTtcbiAgICAgICAgdmFyIGlvbklucHV0ID0gdGhpcy5nZXRJb25JbnB1dCgpO1xuICAgICAgICBpZiAoaW9uSW5wdXQgJiYgKGlvbklucHV0LmdldElucHV0RWxlbWVudCB8fCBpb25JbnB1dC50aGVuKSAmJiB0aGlzLmVsZW1lbnQubm9kZU5hbWUgIT09IFwiSU5QVVRcIikge1xuICAgICAgICAgICAgaWYgKGlvbklucHV0LmdldElucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlvbklucHV0LmdldElucHV0RWxlbWVudCgpLnRoZW4oZnVuY3Rpb24gKGlucCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluaXRDb250cm9sKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpb25JbnB1dC50aGVuKGZ1bmN0aW9uIChpb25JbnBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW9uSW5wQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW5wdXRFbGVtZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmluaXRDb250cm9sKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDb250cm9sKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5nZXRJb25JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl92aWV3O1xuICAgICAgICB2YXIgbmF0aXZlID0gdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgaW9uSW5wdXROb2RlID0gbmF0aXZlLm5vZGVOYW1lID09PSBcIklPTi1JTlBVVFwiO1xuICAgICAgICB2YXIgaW5wMSA9IGlvbklucHV0Tm9kZSAmJiB2ICYmIHYuX2RhdGEgJiYgdi5fZGF0YS5jb21wb25lbnRWaWV3ICYmIHYuX2RhdGEuY29tcG9uZW50Vmlldy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBpbnAyID0gaW9uSW5wdXROb2RlICYmIG5hdGl2ZS5jb21wb25lbnRPblJlYWR5ICYmIG5hdGl2ZS5jb21wb25lbnRPblJlYWR5KCk7XG4gICAgICAgIHJldHVybiBpbnAxIHx8IGlucDI7XG4gICAgfTtcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NCYXNlLnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24gKG5ld09wdGlvbnMsIG9wdGlvbkNoYW5nZWQsIGludmFsaWRDaGFuZ2VkLCBkYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9uQ2hhbmdlZCB8fCBpbnZhbGlkQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMudGhlbWUgJiYgX3RoaXMudGhlbWVDbGFzc2VzU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGhlbWVDbGFzc2VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLm9wdGlvbihuZXdPcHRpb25zLCB1bmRlZmluZWQsIF90aGlzLnBlbmRpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMudGhlbWUgJiYgX3RoaXMudGhlbWVDbGFzc2VzU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hEYXRhKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbnN0YW5jZS5yZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBvcHRpb25DaGFuZ2UgPSBmYWxzZSwgY2xvbmVDaGFuZ2UgPSBmYWxzZSwgaW52YWxpZENoYW5nZSA9IGZhbHNlLCBkYXRhQ2hhbmdlID0gZmFsc2UsIG5ld09wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZXNbcHJvcF0uZmlyc3RDaGFuZ2UgJiYgcHJvcCAhPT0gJ29wdGlvbnMnICYmIHByb3AgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9uZURpY3Rpb25hcnkgJiYgdGhpcy5jbG9uZURpY3Rpb25hcnlbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlQ2xvbmUocHJvcCwgY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXR0aW5nc1twcm9wXSA9IGNoYW5nZXNbcHJvcF0uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9uZUNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25zW3Byb3BdID0gY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbkNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNoYW5nZXNbcHJvcF0uZmlyc3RDaGFuZ2UgJiYgcHJvcCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBleHRlbmQkMShjaGFuZ2VzW3Byb3BdLmN1cnJlbnRWYWx1ZSwgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZXNbcHJvcF0uZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ29wdGlvbnMnICYmIHByb3AgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVPcHRpb25zT2JqW3Byb3BdID0gY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9uZUNoYW5nZSkge1xuICAgICAgICAgICAgZXh0ZW5kJDEobmV3T3B0aW9ucywgdGhpcy5jbG9uZURpY3Rpb25hcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25DaGFuZ2UgfHwgY2xvbmVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyhuZXdPcHRpb25zLCBvcHRpb25DaGFuZ2UsIGludmFsaWRDaGFuZ2UsIGRhdGFDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQmFzZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NCYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ2Nzc0NsYXNzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0aGVtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndGhlbWVWYXJpYW50JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdsYW5nJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdydGwnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Jlc3BvbnNpdmUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uSW5pdCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkRlc3Ryb3knOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NCYXNlO1xufSgpKTtcbnZhciBNYnNjVmFsdWVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1ZhbHVlQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjVmFsdWVCYXNlKGluaXRpYWxFbGVtLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY1ZhbHVlQmFzZS5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikgeyB9O1xuICAgIE1ic2NWYWx1ZUJhc2UucHJvdG90eXBlLnNldE5ld1ZhbHVlUHJveHkgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE5ld1ZhbHVlKHYpO1xuICAgIH07XG4gICAgTWJzY1ZhbHVlQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy12LWJdJyB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NWYWx1ZUJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY1ZhbHVlQmFzZTtcbn0oTWJzY0Jhc2UpKTtcbnZhciBNYnNjQ2xvbmVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0Nsb25lQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjQ2xvbmVCYXNlKGluaXRFbGVtLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRFbGVtLCB6b25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jbG9uZURpY3Rpb25hcnkgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQ2xvbmVCYXNlLnByb3RvdHlwZS5tYWtlQ2xvbmUgPSBmdW5jdGlvbiAoc2V0dGluZywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeVtzZXR0aW5nXSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5W3NldHRpbmddLnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnlbc2V0dGluZ10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0Nsb25lQmFzZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlLCBkYXRhID0gZmFsc2UsIGludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2xvbmVEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSB1bmRlZmluZWQgJiYgIWRlZXBFcXVhbHNBcnJheSh0aGlzW2tleV0sIHRoaXMuY2xvbmVEaWN0aW9uYXJ5W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlQ2xvbmUoa2V5LCB0aGlzW2tleV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0dGluZ3Nba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkICYmIHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyh0aGlzLmNsb25lRGljdGlvbmFyeSwgZmFsc2UsIGludmFsaWQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ2xvbmVCYXNlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2xvbmVEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VDbG9uZShrZXksIHRoaXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NDbG9uZUJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtYy1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2xvbmVCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1ic2NDbG9uZUJhc2U7XG59KE1ic2NWYWx1ZUJhc2UpKTtcbnZhciBNYnNjQ29udHJvbEJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjQ29udHJvbEJhc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0NvbnRyb2xCYXNlKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBfaW5wdXRTZXJ2aWNlLCBfdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICAgIF90aGlzLl9pbnB1dFNlcnZpY2UgPSBfaW5wdXRTZXJ2aWNlO1xuICAgICAgICBfdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICBfdGhpcy5fbmVlZHNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLm9uVG91Y2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub2xkQWNjZXNzb3IgPSBudWxsO1xuICAgICAgICBfdGhpcy5vdmVyd3JpdGVBY2Nlc3NvcigpO1xuICAgICAgICBpZiAoX2lucHV0U2VydmljZSkge1xuICAgICAgICAgICAgX2lucHV0U2VydmljZS5pc0NvbnRyb2xTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUsIFwib3B0aW9uRXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleHRlcm5hbE9uQ2xvc2UgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm9uQ2xvc2U7XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxPbkZpbGwgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm9uRmlsbDtcbiAgICAgICAgICAgIHZhciBvbkNsb3NlRW1pdHRlciA9IHRoaXMub25DbG9zZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25GaWxsOiBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9sZEFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbGRBY2Nlc3Nvci53cml0ZVZhbHVlKGV2ZW50LnZhbHVlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW9uSW5wdXQgPSBfdGhpcy5nZXRJb25JbnB1dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlvbklucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW9uSW5wdXQudmFsdWUgPSBldmVudC52YWx1ZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsT25GaWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbE9uRmlsbChldmVudCwgaW5zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblRvdWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbE9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsT25DbG9zZShldmVudCwgaW5zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQ2xvc2VFbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5pbnN0ID0gaW5zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2VFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUsIFwiZW5hYmxlTWFudWFsRWRpdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5zZiA9IHRoaXMuc2hvd09uRm9jdXMgPT09IGZhbHNlIHx8IHRoaXMub3B0aW9ucy5zaG93T25Gb2N1cyA9PT0gZmFsc2UsIG5zdCA9IHRoaXMuc2hvd09uVGFwID09PSBmYWxzZSB8fCB0aGlzLm9wdGlvbnMuc2hvd09uVGFwID09PSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBuc2YgJiYgbnN0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgJCQxKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsbVZhbHVlID0gdGhhdC5lbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0VmFsdWUgPSB0aGF0Lmluc3RhbmNlLl92YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtVmFsdWUgIT09IGluc3RWYWx1ZSAmJiAoaW5zdFZhbHVlICE9PSBudWxsIHx8IGVsbVZhbHVlICE9PSAnJykgJiYgdGhhdC5lbmFibGVNYW51YWxFZGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaW5zdGFuY2Uuc2V0VmFsKGVsbVZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXQuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVFcXVhbHModmFsdWUsIHRoYXQuY29udHJvbC5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub25DaGFuZ2VFbWl0dGVyLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB2YWx1ZUVxdWFscyh2MSwgdjIpIHtcbiAgICAgICAgICAgIGlmICh2MSA9PT0gdjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2MSBpbnN0YW5jZW9mIERhdGUgJiYgdjIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgrdjEpID09PSAoK3YyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0NvbnRyb2xCYXNlLnByb3RvdHlwZS5vdmVyd3JpdGVBY2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRBY2Nlc3NvciA9IHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5vdmVyd3JpdGVBY2Nlc3NvcigpO1xuICAgICAgICBpZiAodGhpcy5jb250cm9sICYmIHRoaXMuY29udHJvbC5fc2V0VXBDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgTWJzY0NvbnRyb2xCYXNlLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2ggPSBmbjtcbiAgICB9O1xuICAgIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICBpZiAodGhpcy5vbGRBY2Nlc3NvciAmJiB0aGlzLm9sZEFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub2xkQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLmRpc2FibGUgJiYgdGhpcy5pbnN0YW5jZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbmVlZHNUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdWYWx1ZSA9IHY7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ29udHJvbEJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtY2MtYl0nIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0NvbnRyb2xCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdsYWJlbFN0eWxlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydsYWJlbC1zdHlsZScsXSB9LF0sXG4gICAgICAgICdpbnB1dFN0eWxlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpbnB1dC1zdHlsZScsXSB9LF0sXG4gICAgICAgICdzaG93T25Gb2N1cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2hvd09uVGFwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NDb250cm9sQmFzZTtcbn0oTWJzY0Nsb25lQmFzZSkpO1xudmFyIE1ic2NGcmFtZUJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjRnJhbWVCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NGcmFtZUJhc2UoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIF9pbnB1dFNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIF9pbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9uQmVmb3JlQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQmVmb3JlU2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25DYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uRmlsbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25NYXJrdXBSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25Qb3NpdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25TaG93ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJpbmxpbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5kaXNwbGF5IHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmRpc3BsYXkpKSA9PT0gJ2lubGluZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5pbnZhbGlkID0gW107XG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5LnZhbGlkID0gW107XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NGcmFtZUJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtZnItYl0nIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0ZyYW1lQmFzZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY0ZyYW1lQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Ryb3Bkb3duJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdhbmNob3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2FuaW1hdGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2J1dHRvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Nsb3NlT25PdmVybGF5VGFwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjb250ZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkaXNwbGF5JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzaG93SW5wdXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ZvY3VzT25DbG9zZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZm9jdXNUcmFwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdoZWFkZXJUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzY3JvbGxMb2NrJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0b3VjaFVpJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvbkJlZm9yZUNsb3NlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQmVmb3JlU2hvdyc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNhbmNlbCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNsb3NlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uRmlsbCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbk1hcmt1cFJlYWR5JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uUG9zaXRpb24nOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25TaG93JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRnJhbWVCYXNlO1xufShNYnNjQ29udHJvbEJhc2UpKTtcbnZhciBNYnNjU2Nyb2xsZXJCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbGVyQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXJCYXNlKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBfaW5wdXRTZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBfaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbldoZWVsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25JdGVtVGFwID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkNsZWFyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NTY3JvbGxlckJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2Mtcy1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsZXJCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2Nyb2xsZXJCYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnY2lyY3VsYXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2hlaWdodCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGF5b3V0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXhXaWR0aCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWluV2lkdGgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ211bHRpbGluZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncmVhZG9ubHknOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Jvd3MnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Nob3dMYWJlbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2hvd1Njcm9sbEFycm93cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnd2hlZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd3aWR0aCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsaWRhdGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NhbmNlbFRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NsZWFyVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2VsZWN0ZWRUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzZXRUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdmb3JtYXRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGFyc2VWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25XaGVlbENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydvbkNoYW5nZScsXSB9LF0sXG4gICAgICAgICdvblNldCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkl0ZW1UYXAnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25DbGVhcic6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1Njcm9sbGVyQmFzZTtcbn0oTWJzY0ZyYW1lQmFzZSkpO1xudmFyIE1ic2NCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjQmFzZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY0Jhc2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NCYXNlLCBNYnNjVmFsdWVCYXNlLCBNYnNjQ2xvbmVCYXNlLCBNYnNjQ29udHJvbEJhc2VdLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Jhc2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0Jhc2VNb2R1bGU7XG59KCkpO1xudmFyIE1ic2NGcmFtZUJhc2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NGcmFtZUJhc2VNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NGcmFtZUJhc2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY0Jhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjRnJhbWVCYXNlXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NGcmFtZUJhc2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0ZyYW1lQmFzZU1vZHVsZTtcbn0oKSk7XG52YXIgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjRnJhbWVCYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1Njcm9sbGVyQmFzZV0sXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlckJhc2VNb2R1bGU7XG59KCkpO1xuZnVuY3Rpb24gZGVlcEVxdWFsc0FycmF5KGExLCBhMikge1xuICAgIGlmIChhMSA9PT0gYTIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhMSB8fCAhYTIgfHwgYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGExW2ldICE9PSBhMltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0RhdGVFcXVhbChkMSwgZDIpIHtcbiAgICBpZiAoKGQxICYmICFkMikgfHwgKGQyICYmICFkMSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghZDEgJiYgIWQyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGQxICYmIGQyICYmIGQxLnRvU3RyaW5nKCkgPT09IGQyLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW1wdHlPclRydWUodmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbCkgPT09ICdzdHJpbmcnICYmICh2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnKSkgfHwgISF2YWw7XG59XG52YXIgSU5QVVRfVEVNUExBVEUgPSBcIjxtYnNjLWlucHV0ICpuZ0lmPVxcXCIhaW5saW5lIHx8IHNob3dJbnB1dFxcXCJcXG4gICAgW2NvbnRyb2xOZ109XFxcImZhbHNlXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt0aGVtZV09XFxcInRoZW1lXFxcIiBbdGhlbWVWYXJpYW50XT1cXFwidGhlbWVWYXJpYW50XFxcIiBbbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIiBbaW5wdXQtc3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2Ryb3Bkb3duXT1cXFwiZHJvcGRvd25cXFwiIFtwbGFjZWhvbGRlcl09XFxcInBsYWNlaG9sZGVyXFxcIlxcbiAgICBbZXJyb3JdPVxcXCJlcnJvclxcXCIgW2Vycm9yTWVzc2FnZV09XFxcImVycm9yTWVzc2FnZVxcXCJcXG4gICAgW2ljb25dPVxcXCJpbnB1dEljb25cXFwiIFtpY29uLWFsaWduXT1cXFwiaWNvbkFsaWduXFxcIj5cXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbjwvbWJzYy1pbnB1dD5cIjtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG52YXIgd3JhcENsYXNzID0gJ21ic2MtaW5wdXQtd3JhcCc7XG52YXIgZXZlbnRzID0gWyd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnbW91c2VsZWF2ZSddO1xudmFyIGRlZmF1bHRzID0ge1xuICB0YXA6IGhhc0dob3N0Q2xpY2tcbn07XG52YXIgJGFjdGl2ZTtcblxuZnVuY3Rpb24gYWRkSWNvbigkY29udHJvbCwgaWMpIHtcbiAgdmFyIGljb25zID0ge30sXG4gICAgICBjb250cm9sID0gJGNvbnRyb2xbMF0sXG4gICAgICAkcGFyZW50ID0gJGNvbnRyb2wucGFyZW50KCksXG4gICAgICBlcnJvck1zZyA9ICRwYXJlbnQuZmluZCgnLm1ic2MtZXJyLW1zZycpLFxuICAgICAgYWxpZ24gPSAkY29udHJvbC5hdHRyKCdkYXRhLWljb24tYWxpZ24nKSB8fCAnbGVmdCcsXG4gICAgICBpY29uID0gJGNvbnRyb2wuYXR0cignZGF0YS1pY29uJyk7XG5cbiAgaWYgKCRwYXJlbnQuaGFzQ2xhc3Mod3JhcENsYXNzKSkge1xuICAgICRwYXJlbnQgPSAkcGFyZW50LnBhcmVudCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdyYXAgaW5wdXRcbiAgICAkJDEoJzxzcGFuIGNsYXNzPVwiJyArIHdyYXBDbGFzcyArICdcIj48L3NwYW4+JykuaW5zZXJ0QWZ0ZXIoJGNvbnRyb2wpLmFwcGVuZCgkY29udHJvbCk7XG4gIH1cblxuICBpZiAoZXJyb3JNc2cpIHtcbiAgICAkcGFyZW50LmZpbmQoJy4nICsgd3JhcENsYXNzKS5hcHBlbmQoZXJyb3JNc2cpO1xuICB9XG5cbiAgaWYgKGljb24pIHtcbiAgICBpZiAoaWNvbi5pbmRleE9mKCd7JykgIT09IC0xKSB7XG4gICAgICBpY29ucyA9IEpTT04ucGFyc2UoaWNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGljb25zW2FsaWduXSA9IGljb247XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRyb2wudHlwZSA9PSAnZmlsZScpIHtcbiAgICAvLyBTZXQgaWNvblxuICAgIGljb25zLnJpZ2h0ID0gJGNvbnRyb2wuYXR0cignZGF0YS1pY29uLXVwbG9hZCcpIHx8ICd1cGxvYWQnO1xuICB9XG5cbiAgaWYgKGljb24gfHwgaWMpIHtcbiAgICBleHRlbmQkMShpY29ucywgaWMpO1xuICAgICRwYXJlbnQuYWRkQ2xhc3MoKGljb25zLnJpZ2h0ID8gJ21ic2MtaWMtcmlnaHQgJyA6ICcnKSArIChpY29ucy5sZWZ0ID8gJyBtYnNjLWljLWxlZnQnIDogJycpKS5maW5kKCcuJyArIHdyYXBDbGFzcykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtaW5wdXQtZmlsbFwiPjwvc3Bhbj4nKS5hcHBlbmQoaWNvbnMubGVmdCA/ICc8c3BhbiBjbGFzcz1cIm1ic2MtaW5wdXQtaWMgbWJzYy1sZWZ0LWljIG1ic2MtaWMgbWJzYy1pYy0nICsgaWNvbnMubGVmdCArICdcIj48L3NwYW4+JyA6ICcnKS5hcHBlbmQoaWNvbnMucmlnaHQgPyAnPHNwYW4gY2xhc3M9XCJtYnNjLWlucHV0LWljIG1ic2MtcmlnaHQtaWMgbWJzYy1pYyBtYnNjLWljLScgKyBpY29ucy5yaWdodCArICdcIj48L3NwYW4+JyA6ICcnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJY29uVG9nZ2xlKHRoYXQsICRwYXJlbnQsICRjb250cm9sKSB7XG4gIHZhciBpY29ucyA9IHt9LFxuICAgICAgY29udHJvbCA9ICRjb250cm9sWzBdLFxuICAgICAgdG9nZ2xlID0gJGNvbnRyb2wuYXR0cignZGF0YS1wYXNzd29yZC10b2dnbGUnKSxcbiAgICAgIGljb25TaG93ID0gJGNvbnRyb2wuYXR0cignZGF0YS1pY29uLXNob3cnKSB8fCAnZXllJyxcbiAgICAgIGljb25IaWRlID0gJGNvbnRyb2wuYXR0cignZGF0YS1pY29uLWhpZGUnKSB8fCAnZXllLWJsb2NrZWQnO1xuXG4gIGlmICh0b2dnbGUpIHtcbiAgICBpY29ucy5yaWdodCA9IGNvbnRyb2wudHlwZSA9PSAncGFzc3dvcmQnID8gaWNvblNob3cgOiBpY29uSGlkZTtcbiAgfVxuXG4gIGFkZEljb24oJGNvbnRyb2wsIGljb25zKTtcblxuICBpZiAodG9nZ2xlKSB7XG4gICAgdGFwKHRoYXQsICRwYXJlbnQuZmluZCgnLm1ic2MtcmlnaHQtaWMnKS5hZGRDbGFzcygnbWJzYy1pbnB1dC10b2dnbGUnKSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbnRyb2wudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICBjb250cm9sLnR5cGUgPSBcInBhc3N3b3JkXCI7XG4gICAgICAgICQkMSh0aGlzKS5hZGRDbGFzcygnbWJzYy1pYy0nICsgaWNvblNob3cpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpY29uSGlkZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sLnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgJCQxKHRoaXMpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpY29uU2hvdykuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGljb25IaWRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwTGFiZWwoJHBhcmVudCwgdHlwZSwgaW5wdXRTdHlsZSwgbGFiZWxTdHlsZSwgZWxtKSB7XG4gIC8vIFdyYXAgbm9uLWVtcHR5IHRleHQgbm9kZXMgaW4gc3BhbiB3aXRoIG1ic2MtbGFiZWwgY2xhc3NcbiAgaWYgKHR5cGUgPT0gJ3NlZ21lbnRlZCcpIHtcbiAgICAkcGFyZW50LmNsb3Nlc3QoJy5tYnNjLXNlZ21lbnRlZCcpLmFkZENsYXNzKGlucHV0U3R5bGUgPT0gJ2JveCcgPyAnbWJzYy1pbnB1dC1ib3gnIDogJycpLmFkZENsYXNzKGlucHV0U3R5bGUgPT0gJ291dGxpbmUnID8gJ21ic2MtaW5wdXQtb3V0bGluZScgOiAnJyk7XG4gIH0gZWxzZSBpZiAodHlwZSAhPSAnYnV0dG9uJyAmJiB0eXBlICE9ICdzdWJtaXQnKSB7XG4gICAgJHBhcmVudC5hZGRDbGFzcygnbWJzYy1jb250cm9sLXcnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdib3gnID8gJ21ic2MtaW5wdXQtYm94JyA6ICcnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdvdXRsaW5lJyA/ICdtYnNjLWlucHV0LW91dGxpbmUnIDogJycpLmFkZENsYXNzKGxhYmVsU3R5bGUgPT0gJ2lubGluZScgPyAnbWJzYy1sYWJlbC1pbmxpbmUnIDogJycpLmFkZENsYXNzKGxhYmVsU3R5bGUgPT0gJ3N0YWNrZWQnID8gJ21ic2MtbGFiZWwtc3RhY2tlZCcgOiAnJykuYWRkQ2xhc3MobGFiZWxTdHlsZSA9PSAnZmxvYXRpbmcnID8gJ21ic2MtbGFiZWwtZmxvYXRpbmcnIDogJycpLmFkZENsYXNzKGxhYmVsU3R5bGUgPT0gJ2Zsb2F0aW5nJyAmJiBlbG0udmFsdWUgPyAnbWJzYy1sYWJlbC1mbG9hdGluZy1hY3RpdmUnIDogJycpLmZpbmQoJ2xhYmVsJykuYWRkQ2xhc3MoJ21ic2MtbGFiZWwnKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAkJDEodikuYXR0cigndGl0bGUnLCAkJDEodikudGV4dCgpKTtcbiAgICB9KTtcbiAgICAkcGFyZW50LmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlID09IDMgJiYgdGhpcy5ub2RlVmFsdWUgJiYgL1xcUy8udGVzdCh0aGlzLm5vZGVWYWx1ZSk7XG4gICAgfSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAkJDEoJzxzcGFuIGNsYXNzPVwibWJzYy1sYWJlbFwiIHRpdGxlPVwiJyArIHRoaXMudGV4dENvbnRlbnQudHJpbSgpICsgJ1wiPjwvc3Bhbj4nKS5pbnNlcnRBZnRlcih0aGlzKS5hcHBlbmQodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmlwcGxlKHRoZW1lKSB7XG4gIHZhciByaXBwbGUgPSBtb2Jpc2Nyb2xsLnRoZW1lcy5mb3JtW3RoZW1lXTtcbiAgcmV0dXJuIHJpcHBsZSAmJiByaXBwbGUuYWRkUmlwcGxlID8gcmlwcGxlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cigkZWxtLCBhdHRyLCBkZWYpIHtcbiAgdmFyIHYgPSAkZWxtLmF0dHIoYXR0cik7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gJycgPyBkZWYgOiB2O1xufVxuXG5mdW5jdGlvbiBnZXRDc3NDbGFzcyhzKSB7XG4gIHZhciB0aGVtZSA9IGdldFRoZW1lTmFtZShzKTtcbiAgdmFyIGJhc2VUaGVtZSA9IG1vYmlzY3JvbGwudGhlbWVzLmZvcm1bdGhlbWVdLmJhc2VUaGVtZTtcbiAgcmV0dXJuICdtYnNjLScgKyB0aGVtZSArIChiYXNlVGhlbWUgPyAnIG1ic2MtJyArIGJhc2VUaGVtZSA6ICcnKSArIChzLnJ0bCA/ICcgbWJzYy1ydGwnIDogJyBtYnNjLWx0cicpO1xufVxuXG52YXIgRm9ybUNvbnRyb2wgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtQ29udHJvbChlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzID0gZXh0ZW5kJDEoe30sIGRlZmF1bHRzLCBtb2Jpc2Nyb2xsLnNldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgdmFyICRlbG0gPSAkJDEoZWxtKTtcbiAgICB2YXIgJHAgPSAkZWxtLnBhcmVudCgpO1xuICAgIHZhciAkcGFyZW50ID0gJHAuaGFzQ2xhc3MoJ21ic2MtaW5wdXQtd3JhcCcpID8gJHAucGFyZW50KCkgOiAkcDsgLy8gQ2hlY2sgZm9yIGlubGluZSBtb2Jpc2Nyb2xsIGNvbXBvbmVudHNcblxuICAgIHZhciAkZnJhbWUgPSAkZWxtLm5leHQoKS5oYXNDbGFzcygnbWJzYy1mcicpID8gJGVsbS5uZXh0KCkgOiBudWxsO1xuICAgIHZhciB0eXBlID0gZ2V0Q29udHJvbFR5cGUoJGVsbSk7XG4gICAgdmFyIGlucHV0U3R5bGUgPSBnZXRBdHRyKCRlbG0sICdkYXRhLWlucHV0LXN0eWxlJywgcy5pbnB1dFN0eWxlKTtcbiAgICB2YXIgbGFiZWxTdHlsZSA9IGdldEF0dHIoJGVsbSwgJ2RhdGEtbGFiZWwtc3R5bGUnLCBzLmxhYmVsU3R5bGUpO1xuXG4gICAgaWYgKGVsbS5tYnNjSW5zdCkge1xuICAgICAgZWxtLm1ic2NJbnN0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBpZiAoJGZyYW1lKSB7XG4gICAgICAkZnJhbWUuaW5zZXJ0QWZ0ZXIoJHBhcmVudCk7XG4gICAgfVxuXG4gICAgcy50aGVtZSA9IGdldFRoZW1lTmFtZShzKTtcblxuICAgIGlmIChzLnJ0bCA9PT0gdW5kZWZpbmVkICYmIHMubGFuZyAmJiBtb2Jpc2Nyb2xsLmkxOG5bcy5sYW5nXSkge1xuICAgICAgcy5ydGwgPSBtb2Jpc2Nyb2xsLmkxOG5bcy5sYW5nXS5ydGw7XG4gICAgfVxuXG4gICAgd3JhcExhYmVsKCRwYXJlbnQsIHR5cGUsIGlucHV0U3R5bGUsIGxhYmVsU3R5bGUsIGVsbSk7XG4gICAgJGVsbS5hZGRDbGFzcygnbWJzYy1jb250cm9sJyk7IC8vIEF0dGFjaCBldmVudHNcblxuICAgIHRoaXMuX2hhbmRsZSA9IHRoaXMuX2hhbmRsZS5iaW5kKHRoaXMpOyAvLyBQcmV2ZW50IDMwMG1zIGNsaWNrIGxhdGVuY3lcblxuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgJGVsbS5vbihldiwgX3RoaXMuX2hhbmRsZSk7XG4gICAgfSk7IC8vIFRvdWNoIGV2ZW50cyBhcmUgYWRkZWQgc2VwYXJhdGVseSwgbmVlZHMgdG8gYmUgcGFzc2l2ZSBsaXN0ZW5lclxuXG4gICAgbGlzdGVuKGVsbSwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZWxtLCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHM7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZWxtID0gZWxtO1xuICAgIHRoaXMuXyRlbG0gPSAkZWxtO1xuICAgIHRoaXMuXyRwYXJlbnQgPSAkcGFyZW50O1xuICAgIHRoaXMuXyRmcmFtZSA9ICRmcmFtZTtcbiAgICB0aGlzLl9yaXBwbGUgPSBnZXRSaXBwbGUocy50aGVtZSk7XG4gICAgdGhpcy5faXNGbG9hdGluZyA9IGxhYmVsU3R5bGUgPT0gJ2Zsb2F0aW5nJyB8fCAkcGFyZW50Lmhhc0NsYXNzKCdtYnNjLWxhYmVsLWZsb2F0aW5nJyk7XG4gICAgdGhpcy5jc3NDbGFzcyA9IGdldENzc0NsYXNzKHMpO1xuICAgIHRoaXMuZ2V0Q2xhc3NFbG0oKS5hZGRDbGFzcyh0aGlzLmNzc0NsYXNzKTtcbiAgICBlbG0ubWJzY0luc3QgPSB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZvcm1Db250cm9sLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0Q2xhc3NFbG0gPSBmdW5jdGlvbiBnZXRDbGFzc0VsbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fJHBhcmVudDtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgJGVsbSA9IHRoaXMuXyRlbG07XG4gICAgdmFyIGVsbSA9IHRoaXMuX2VsbTtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbnRyb2wnKTtcbiAgICB0aGlzLmdldENsYXNzRWxtKCkucmVtb3ZlQ2xhc3ModGhpcy5jc3NDbGFzcyk7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAkZWxtLm9mZihldiwgX3RoaXMyLl9oYW5kbGUpO1xuICAgIH0pO1xuICAgIHVubGlzdGVuKGVsbSwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICB1bmxpc3RlbihlbG0sICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBkZWxldGUgZWxtLm1ic2NJbnN0O1xuICB9O1xuXG4gIF9wcm90by5vcHRpb24gPSBmdW5jdGlvbiBvcHRpb24ocykge1xuICAgIGV4dGVuZCQxKHRoaXMuc2V0dGluZ3MsIHMpO1xuICAgIHZhciBjbGFzc0VsbSA9IHRoaXMuZ2V0Q2xhc3NFbG0oKTtcblxuICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICBjbGFzc0VsbS5yZW1vdmVDbGFzcyh0aGlzLmNzc0NsYXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNzc0NsYXNzID0gZ2V0Q3NzQ2xhc3ModGhpcy5zZXR0aW5ncyk7XG4gICAgY2xhc3NFbG0uYWRkQ2xhc3ModGhpcy5jc3NDbGFzcyk7XG4gICAgdGhpcy5fcmlwcGxlID0gZ2V0UmlwcGxlKHRoaXMuc2V0dGluZ3MudGhlbWUpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlID0gZnVuY3Rpb24gX2hhbmRsZShldikge1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLl9vblN0YXJ0KGV2KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMuX29uTW92ZShldik7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgICAgIHRoaXMuX29uRW5kKGV2KTtcblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hZGRSaXBwbGUgPSBmdW5jdGlvbiBfYWRkUmlwcGxlKGV2KSB7XG4gICAgaWYgKHRoaXMuX3JpcHBsZSAmJiB0aGlzLl8kcmlwcGxlRWxtKSB7XG4gICAgICB0aGlzLl9yaXBwbGUuYWRkUmlwcGxlKHRoaXMuXyRyaXBwbGVFbG0sIGV2KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZW1vdmVSaXBwbGUgPSBmdW5jdGlvbiBfcmVtb3ZlUmlwcGxlKCkge1xuICAgIGlmICh0aGlzLl9yaXBwbGUgJiYgdGhpcy5fJHJpcHBsZUVsbSkge1xuICAgICAgdGhpcy5fcmlwcGxlLnJlbW92ZVJpcHBsZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX29uU3RhcnQgPSBmdW5jdGlvbiBfb25TdGFydChldikge1xuICAgIHZhciBlbG0gPSB0aGlzLl9lbG07XG5cbiAgICBpZiAodGVzdFRvdWNoKGV2LCBlbG0pKSB7XG4gICAgICB0aGlzLl9zdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIHRoaXMuX3N0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuXG4gICAgICBpZiAoJGFjdGl2ZSkge1xuICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsbS5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICRhY3RpdmUgPSB0aGlzLl8kZWxtO1xuICAgICAgICAkYWN0aXZlLmFkZENsYXNzKCdtYnNjLWFjdGl2ZScpO1xuXG4gICAgICAgIHRoaXMuX2FkZFJpcHBsZShldik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2LnR5cGUgPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICB0aGlzLl8kZWxtLmNsb3Nlc3QoJy5tYnNjLW5vLXRvdWNoJykucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9vbk1vdmUgPSBmdW5jdGlvbiBfb25Nb3ZlKGV2KSB7XG4gICAgLy8gSWYgbW92ZW1lbnQgaXMgbW9yZSB0aGFuIDlweCwgZG9uJ3QgZmlyZSB0aGUgY2xpY2sgZXZlbnQgaGFuZGxlclxuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSAmJiBNYXRoLmFicyhnZXRDb29yZChldiwgJ1gnKSAtIHRoaXMuX3N0YXJ0WCkgPiA5IHx8IE1hdGguYWJzKGdldENvb3JkKGV2LCAnWScpIC0gdGhpcy5fc3RhcnRZKSA+IDkpIHtcbiAgICAgIHRoaXMuXyRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZVJpcHBsZSgpO1xuXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX29uRW5kID0gZnVuY3Rpb24gX29uRW5kKGV2KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgY29udHJvbCA9IHRoaXMuX2VsbTtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cbiAgICBpZiAodGhpcy5faXNBY3RpdmUgJiYgdGhpcy5zZXR0aW5ncy50YXAgJiYgZXYudHlwZSA9PSAndG91Y2hlbmQnICYmICFjb250cm9sLnJlYWRPbmx5KSB7XG4gICAgICBhY3RpdmF0ZUNvbnRyb2woY29udHJvbCwgdHlwZSwgZXYpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5fJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcblxuICAgICAgICBfdGhpczMuX3JlbW92ZVJpcHBsZSgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICRhY3RpdmUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBGb3JtQ29udHJvbDtcbn0oKTtcbm1vYmlzY3JvbGwudGhlbWVzLmZvcm0ubW9iaXNjcm9sbCA9IHt9O1xuXG52YXIgZXZlbnRzJDEgPSBbJ2ZvY3VzJywgJ2NoYW5nZScsICdibHVyJywgJ2FuaW1hdGlvbnN0YXJ0J107XG52YXIgSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Gb3JtQ29udHJvbCkge1xuICBfaW5oZXJpdHNMb29zZShJbnB1dCwgX0Zvcm1Db250cm9sKTtcblxuICBmdW5jdGlvbiBJbnB1dChlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRm9ybUNvbnRyb2wuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgIHZhciAkZWxtID0gX3RoaXMuXyRlbG07XG4gICAgdmFyICRwYXJlbnQgPSBfdGhpcy5fJHBhcmVudDtcbiAgICB2YXIgJGR1bW15ID0gJHBhcmVudC5maW5kKCcubWJzYy1zZWxlY3QtaW5wdXQsIC5tYnNjLWNvbG9yLWlucHV0Jyk7XG4gICAgYWRkSWNvblRvZ2dsZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJHBhcmVudCwgJGVsbSk7XG4gICAgX3RoaXMuX2NoZWNrTGFiZWwgPSBfdGhpcy5fY2hlY2tMYWJlbC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5fbW91c2VEb3duID0gX3RoaXMuX21vdXNlRG93bi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5fc2V0VGV4dCA9IF90aGlzLl9zZXRUZXh0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgaWYgKGVsbS50eXBlID09ICdmaWxlJykge1xuICAgICAgLy8gQ29weSBhdHRyaWJ1dGVzIGFuZCBjcmVhdGUgZHVtbXkgaW5wdXRcbiAgICAgIHZhciAkZXhpc3RpbmcgPSAkcGFyZW50LmZpbmQoJy5tYnNjLWZpbGUtaW5wdXQnKTtcbiAgICAgIF90aGlzLl8kaW5wdXQgPSAkZXhpc3RpbmcubGVuZ3RoID8gJGV4aXN0aW5nIDogJCQxKCc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cIicgKyAoJGVsbS5hdHRyKCdjbGFzcycpIHx8ICcnKSArICcgbWJzYy1maWxlLWlucHV0XCIgcGxhY2Vob2xkZXI9XCInICsgKCRlbG0uYXR0cigncGxhY2Vob2xkZXInKSB8fCAnJykgKyAnXCIvPicpLmluc2VydEFmdGVyKCRlbG0pOyAvLyBDb3B5IHZhbHVlIG9uIGZpbGUgdXBsb2FkXG5cbiAgICAgICRlbG0ub24oJ2NoYW5nZScsIF90aGlzLl9zZXRUZXh0KTtcbiAgICB9XG5cbiAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLWlucHV0Jykub24oJ21vdXNlZG93bicsIF90aGlzLl9tb3VzZURvd24pOyAvLyBBdHRhY2ggZXZlbnRzXG5cbiAgICBldmVudHMkMS5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgJGVsbS5vbihldiwgX3RoaXMuX2NoZWNrTGFiZWwpO1xuICAgIH0pOyAvLyBNb3ZlIHRoZSBkdW1teSBpbnB1dCBhZnRlciB0aGUgZWxlbWVudCBmb3IgY29ycmVjdCBzdHlsaW5nXG5cbiAgICBpZiAoJGR1bW15Lmxlbmd0aCkge1xuICAgICAgJGVsbS5hZnRlcigkZHVtbXkpO1xuXG4gICAgICBpZiAoJGR1bW15Lmhhc0NsYXNzKCdtYnNjLXNlbGVjdC1pbnB1dCcpKSB7XG4gICAgICAgIF90aGlzLl9kZWxtID0gJGR1bW15WzBdO1xuXG4gICAgICAgIF90aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5fc2V0VGV4dCA9IGZ1bmN0aW9uIF9zZXRUZXh0KGV2KSB7XG4gICAgdmFyIGZpbGVzID0gZXYudGFyZ2V0LmZpbGVzO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgbmFtZXMucHVzaChmaWxlc1tpXS5uYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl8kaW5wdXQudmFsKG5hbWVzKTtcbiAgfTtcblxuICBfcHJvdG8uX2NoZWNrTGFiZWwgPSBmdW5jdGlvbiBfY2hlY2tMYWJlbChldikge1xuICAgIGlmICh0aGlzLl9pc0Zsb2F0aW5nKSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIHNlbGVjdCB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBkdW1teSBlbGVtZW50XG4gICAgICB2YXIgZWxtID0gdGhpcy5fZGVsbSB8fCB0aGlzLl9lbG07IC8vIEluIGNhc2Ugb2YgYXV0b2ZpbGwgaW4gd2Via2l0IGJyb3dzZXJzIHRoZSBhbmltYXRpb25zdGFydCBldmVudCB3aWxsIGZpcmUgXG4gICAgICAvLyBkdWUgdG8gdGhlIGVtcHR5IGFuaW1hdGlvbiBhZGRlZCBpbiB0aGUgY3NzLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIG90aGVyIGV2ZW50IGluIGNhc2Ugb2YgdGhlIGluaXRpYWwgYXV0b2ZpbGxcblxuICAgICAgaWYgKGVsbS52YWx1ZSB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbG0gfHwgZXYgJiYgKGV2LnR5cGUgPT0gJ2ZvY3VzJyB8fCBldi50eXBlID09ICdhbmltYXRpb25zdGFydCcgJiYgdGhpcy5fJGVsbS5pcygnKjotd2Via2l0LWF1dG9maWxsJykpKSB7XG4gICAgICAgIHRoaXMuXyRwYXJlbnQuYWRkQ2xhc3MoJ21ic2MtbGFiZWwtZmxvYXRpbmctYWN0aXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl8kcGFyZW50LnJlbW92ZUNsYXNzKCdtYnNjLWxhYmVsLWZsb2F0aW5nLWFjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX21vdXNlRG93biA9IGZ1bmN0aW9uIF9tb3VzZURvd24oZXYpIHtcbiAgICAvLyBXaWxsIHByZXZlbnQgZmxvYXRpbmcgbGFiZWwgYW5pbWF0aW9uIHdoZW4gbG9vc2luZyBmb2N1cyBvbmx5IGZvciBhIGJyaWVmIG1vbWVudFxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLl9lbG0gJiYgZXYudGFyZ2V0ICE9PSB0aGlzLl9lbG0pIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9jaGVja0xhYmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX0Zvcm1Db250cm9sLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl8kcGFyZW50Lm9mZignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duKS5yZW1vdmVDbGFzcygnbWJzYy1pYy1sZWZ0IG1ic2MtaWMtcmlnaHQnKS5maW5kKCcubWJzYy1pbnB1dC1pYycpLnJlbW92ZSgpO1xuXG4gICAgdGhpcy5fJHBhcmVudC5maW5kKCcubWJzYy1pbnB1dC1maWxsJykucmVtb3ZlKCk7XG5cbiAgICBldmVudHMkMS5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgX3RoaXMyLl8kZWxtLm9mZihldiwgX3RoaXMyLl9jaGVja0xhYmVsKTtcbiAgICB9KTtcblxuICAgIHRoaXMuXyRlbG0ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9zZXRUZXh0KTtcbiAgfTtcblxuICByZXR1cm4gSW5wdXQ7XG59KEZvcm1Db250cm9sKTsgLy8gSW5pdCBtYnNjLWlucHV0IGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtaW5wdXRdJywgSW5wdXQpO1xuXG52YXIgTWJzY0Zvcm1CYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0Zvcm1CYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NGb3JtQmFzZShob3N0RWxlbSwgX2Zvcm1TZXJ2aWNlLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtLCB6b25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZm9ybVNlcnZpY2UgPSBfZm9ybVNlcnZpY2U7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY0Zvcm1CYXNlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5oZXJpdGVkT3B0aW9ucyA9IHRoaXMuX2Zvcm1TZXJ2aWNlID8gdGhpcy5fZm9ybVNlcnZpY2Uub3B0aW9ucyA6IHt9O1xuICAgIH07XG4gICAgTWJzY0Zvcm1CYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1ttYnNjLWYtYl0nIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Zvcm1CYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NGb3JtQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnX2luaXRFbGVtJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2luaXRFbGVtZW50JywgeyBzdGF0aWM6IGZhbHNlIH0sXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0Zvcm1CYXNlO1xufShNYnNjQmFzZSkpO1xudmFyIE1ic2NGb3JtVmFsdWVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0Zvcm1WYWx1ZUJhc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0Zvcm1WYWx1ZUJhc2UoaG9zdEVsZW0sIF9mb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgX2NvbnRyb2wsIHpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW0sIF9mb3JtU2VydmljZSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NvbnRyb2wgPSBfY29udHJvbDtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLm9uVG91Y2ggPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy52YWx1ZUNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmIChfY29udHJvbCAmJiAoIV9pbnB1dFNlcnZpY2UgfHwgIV9pbnB1dFNlcnZpY2UuaXNDb250cm9sU2V0KSkge1xuICAgICAgICAgICAgaWYgKF9jb250cm9sLnZhbHVlQWNjZXNzb3IgJiYgX2NvbnRyb2wudmFsdWVBY2Nlc3Nvci5vbGRBY2Nlc3NvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRyb2wudmFsdWVBY2Nlc3Nvci5vbGRBY2Nlc3NvciA9IF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NGb3JtVmFsdWVCYXNlLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZG9ubHkgPSBlbXB0eU9yVHJ1ZSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcImlubmVyVmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh2KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VFbWl0dGVyLmVtaXQodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaCA9IGZuO1xuICAgIH07XG4gICAgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIE1ic2NGb3JtVmFsdWVCYXNlLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuICAgIE1ic2NGb3JtVmFsdWVCYXNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLnJlZnJlc2gpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmVlZFJlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fbmVlZFJlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1mdi1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NGb3JtVmFsdWVCYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAncmVhZG9ubHknOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd2YWx1ZUNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsndmFsdWVDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NGb3JtVmFsdWVCYXNlO1xufShNYnNjRm9ybUJhc2UpKTtcbnZhciBNYnNjSW5wdXRCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0lucHV0QmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjSW5wdXRCYXNlKGluaXRpYWxFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NJbnB1dEJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtaS1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjSW5wdXRCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgTWJzY0lucHV0QmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2F1dG9jb21wbGV0ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnYXV0b2NhcGl0YWxpemUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2F1dG9jb3JyZWN0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzcGVsbGNoZWNrJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdhdXRvZm9jdXMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pbmxlbmd0aCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4bGVuZ3RoJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ3R5cGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Bhc3N3b3JkVG9nZ2xlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydwYXNzd29yZC10b2dnbGUnLF0gfSxdLFxuICAgICAgICAnaWNvblNob3cnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tc2hvdycsXSB9LF0sXG4gICAgICAgICdpY29uSGlkZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1oaWRlJyxdIH0sXSxcbiAgICAgICAgJ2ljb25VcGxvYWQnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tdXBsb2FkJyxdIH0sXSxcbiAgICAgICAgJ2lucHV0U3R5bGUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2lucHV0LXN0eWxlJyxdIH0sXSxcbiAgICAgICAgJ2xhYmVsU3R5bGUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2xhYmVsLXN0eWxlJyxdIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0lucHV0QmFzZTtcbn0oTWJzY0Zvcm1WYWx1ZUJhc2UpKTtcbnZhciBNYnNjSW5wdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjSW5wdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0lucHV0KGluaXRpYWxFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5faW5wdXRTZXJ2aWNlID0gX2lucHV0U2VydmljZTtcbiAgICAgICAgX3RoaXMuY29udHJvbE5nID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuZHJvcGRvd24gPSBmYWxzZTtcbiAgICAgICAgX2lucHV0U2VydmljZS5pbnB1dCA9IF90aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NJbnB1dC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBJbnB1dCh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWJzY0lucHV0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1ic2MtY29udHJvbC1uZ10nOiAnY29udHJvbE5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWJzYy1lcnJdJzogJ2Vycm9yJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbFxcbiAgICAgICAgICAgIFtjbGFzcy5tYnNjLWVycl09XFxcImVycm9yXFxcIiBbY2xhc3MubWJzYy1zZWxlY3RdPVxcXCJkcm9wZG93blxcXCJcXG4gICAgICAgICAgICBbY2xhc3MubWJzYy1pbnB1dC1ib3hdPVxcXCJpbnB1dFN0eWxlID09ICdib3gnXFxcIlxcbiAgICAgICAgICAgIFtjbGFzcy5tYnNjLWlucHV0LW91dGxpbmVdPVxcXCJpbnB1dFN0eWxlID09ICdvdXRsaW5lJ1xcXCJcXG4gICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1zdGFja2VkXT1cXFwibGFiZWxTdHlsZSA9PSAnc3RhY2tlZCdcXFwiXFxuICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtaW5saW5lXT1cXFwibGFiZWxTdHlsZSA9PSAnaW5saW5lJ1xcXCJcXG4gICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1mbG9hdGluZ109XFxcImxhYmVsU3R5bGUgPT0gJ2Zsb2F0aW5nJ1xcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1ic2MtaW5wdXQtd3JhcFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnQgW3R5cGVdPVxcXCJ0eXBlXFxcIiBbcGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlclxcXCIgWyhuZ01vZGVsKV09XFxcImlubmVyVmFsdWVcXFwiIChibHVyKT1cXFwib25Ub3VjaCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb25dPVxcXCJpY29uID8gaWNvbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb24tYWxpZ25dPVxcXCJpY29uQWxpZ24gPyBpY29uQWxpZ24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1wYXNzd29yZC10b2dnbGVdPVxcXCJwYXNzd29yZFRvZ2dsZSA/ICd0cnVlJzogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi1zaG93XT1cXFwiaWNvblNob3cgPyBpY29uU2hvdyA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb24taGlkZV09XFxcImljb25IaWRlID8gaWNvbkhpZGUgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uLXVwbG9hZF09XFxcImljb25VcGxvYWQgPyBpY29uVXBsb2FkIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1pbl09XFxcIm1pblxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1heF09XFxcIm1heFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1pbmxlbmd0aF09XFxcIm1pbmxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1heGxlbmd0aF09XFxcIm1heGxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmF1dG9jb21wbGV0ZV09XFxcImF1dG9jb21wbGV0ZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmF1dG9jYXBpdGFsaXplXT1cXFwiYXV0b2NhcGl0YWxpemVcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvY29ycmVjdF09XFxcImF1dG9jb3JyZWN0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuc3BlbGxjaGVja109XFxcInNwZWxsY2hlY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvZm9jdXNdPVxcXCJhdXRvZm9jdXNcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5zdGVwXT1cXFwic3RlcFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnBhdHRlcm5dPVxcXCJwYXR0ZXJuXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmFjY2VwdF09XFxcImFjY2VwdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm11bHRpcGxlXT1cXFwibXVsdGlwbGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seV09XFxcIl9yZWFkb25seVxcXCIgLz5cXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcImRyb3Bkb3duXFxcIiBjbGFzcz1cXFwibWJzYy1zZWxlY3QtaWMgbWJzYy1pYyBtYnNjLWljLWFycm93LWRvd241XFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJlcnJvciAmJiBlcnJvck1lc3NhZ2VcXFwiIGNsYXNzPVxcXCJtYnNjLWVyci1tc2dcXFwiPnt7ZXJyb3JNZXNzYWdlfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NJbnB1dFNlcnZpY2VdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjSW5wdXQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjSW5wdXQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21heCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc3RlcCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGF0dGVybic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnYWNjZXB0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtdWx0aXBsZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnY29udHJvbE5nJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkcm9wZG93bic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NJbnB1dDtcbn0oTWJzY0lucHV0QmFzZSkpO1xudmFyIE1ic2NJbnB1dE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0lucHV0TW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjSW5wdXRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlLCBDb21tb25Nb2R1bGUsIE1ic2NCYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0lucHV0LCBNYnNjSW5wdXRCYXNlLCBNYnNjRm9ybUJhc2UsIE1ic2NGb3JtVmFsdWVCYXNlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01ic2NJbnB1dF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NJbnB1dE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjSW5wdXRNb2R1bGU7XG59KCkpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGVwcGVyKCRlbG0sIGFjdGlvbiwgZGVsYXksIGlzUmVhZE9ubHksIHN0b3BQcm9wLCByaXBwbGUpIHtcbiAgdmFyICRidG4sXG4gICAgICBjaGFuZ2VkLFxuICAgICAgaW5kZXgsXG4gICAgICBydW5uaW5nLFxuICAgICAgc291cmNlLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3RlcCxcbiAgICAgIHRpbWVyLFxuICAgICAgY2hlY2sgPSBpc1JlYWRPbmx5IHx8IG5vb3A7XG5cbiAgZnVuY3Rpb24gb25CdG5TdGFydChldikge1xuICAgIHZhciBwcm9jZWVkO1xuICAgICRidG4gPSAkJDEoZXYuY3VycmVudFRhcmdldCk7XG4gICAgc3RlcCA9ICskYnRuLmF0dHIoJ2RhdGEtc3RlcCcpO1xuICAgIGluZGV4ID0gKyRidG4uYXR0cignZGF0YS1pbmRleCcpO1xuICAgIGNoYW5nZWQgPSB0cnVlO1xuXG4gICAgaWYgKHN0b3BQcm9wKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSA9PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICRidG4uY2xvc2VzdCgnLm1ic2Mtbm8tdG91Y2gnKS5yZW1vdmVDbGFzcygnbWJzYy1uby10b3VjaCcpO1xuICAgIH1cblxuICAgIGlmIChldi50eXBlID09ICdtb3VzZWRvd24nKSB7XG4gICAgICAvLyBQcmV2ZW50IGZvY3VzXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChldi50eXBlICE9ICdrZXlkb3duJykge1xuICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgcHJvY2VlZCA9IHRlc3RUb3VjaChldiwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2NlZWQgPSBldi5rZXlDb2RlID09PSAzMjtcbiAgICB9XG5cbiAgICBpZiAoIXJ1bm5pbmcgJiYgcHJvY2VlZCAmJiAhJGJ0bi5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICBpZiAoc3RhcnQoaW5kZXgsIHN0ZXAsIGV2KSkge1xuICAgICAgICAkYnRuLmFkZENsYXNzKCdtYnNjLWFjdGl2ZScpO1xuXG4gICAgICAgIGlmIChyaXBwbGUpIHtcbiAgICAgICAgICByaXBwbGUuYWRkUmlwcGxlKCRidG4uZmluZCgnLm1ic2Mtc2VnbWVudGVkLWNvbnRlbnQnKSwgZXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldi50eXBlID09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNlbW92ZScsIG9uQnRuTW92ZSkub24oJ21vdXNldXAnLCBvbkJ0bkVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CdG5Nb3ZlKGV2KSB7XG4gICAgaWYgKE1hdGguYWJzKHN0YXJ0WCAtIGdldENvb3JkKGV2LCAnWCcpKSA+IDcgfHwgTWF0aC5hYnMoc3RhcnRZIC0gZ2V0Q29vcmQoZXYsICdZJykpID4gNykge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CdG5FbmQoZXYpIHtcbiAgICBpZiAoZXYudHlwZSA9PSAndG91Y2hlbmQnKSB7XG4gICAgICAvLyBQcmV2ZW50cyBpT1Mgc2Nyb2xsIG9uIGRvdWJsZSB0YXBcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgc3RvcCgpO1xuXG4gICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNldXAnKSB7XG4gICAgICAkJDEoZG9jdW1lbnQpLm9mZignbW91c2Vtb3ZlJywgb25CdG5Nb3ZlKS5vZmYoJ21vdXNldXAnLCBvbkJ0bkVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG5cbiAgICBpZiAoJGJ0bikge1xuICAgICAgJGJ0bi5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcblxuICAgICAgaWYgKHJpcHBsZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByaXBwbGUucmVtb3ZlUmlwcGxlKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoaSwgc3QsIGV2KSB7XG4gICAgaWYgKCFydW5uaW5nICYmICFjaGVjayhpKSkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgc3RlcCA9IHN0O1xuICAgICAgc291cmNlID0gZXY7XG4gICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQodGljaywgMTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVubmluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgaWYgKCRidG4gJiYgJGJ0bi5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICBzdG9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJ1bm5pbmcgfHwgIWNoYW5nZWQpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgYWN0aW9uKGluZGV4LCBzdGVwLCBzb3VyY2UsIHRpY2spO1xuICAgIH1cblxuICAgIGlmIChydW5uaW5nICYmIGRlbGF5KSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3Rpb24oaW5kZXgsIHN0ZXAsIHNvdXJjZSk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAkZWxtLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICB1bmxpc3RlbihlbCwgJ3RvdWNoc3RhcnQnLCBvbkJ0blN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZWwsICdtb3VzZWRvd24nLCBvbkJ0blN0YXJ0KTtcbiAgICAgIHVubGlzdGVuKGVsLCAna2V5ZG93bicsIG9uQnRuU3RhcnQpO1xuICAgICAgdW5saXN0ZW4oZWwsICd0b3VjaG1vdmUnLCBvbkJ0bk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihlbCwgJ3RvdWNoZW5kJywgb25CdG5FbmQpO1xuICAgICAgdW5saXN0ZW4oZWwsICd0b3VjaGNhbmNlbCcsIG9uQnRuRW5kKTtcbiAgICAgIHVubGlzdGVuKGVsLCAna2V5dXAnLCBvbkJ0bkVuZCk7XG4gICAgfSk7XG4gIH1cblxuICAkZWxtLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgbGlzdGVuKGVsLCAndG91Y2hzdGFydCcsIG9uQnRuU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZWwsICdtb3VzZWRvd24nLCBvbkJ0blN0YXJ0KTtcbiAgICBsaXN0ZW4oZWwsICdrZXlkb3duJywgb25CdG5TdGFydCk7XG4gICAgbGlzdGVuKGVsLCAndG91Y2htb3ZlJywgb25CdG5Nb3ZlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgbGlzdGVuKGVsLCAndG91Y2hlbmQnLCBvbkJ0bkVuZCk7XG4gICAgbGlzdGVuKGVsLCAndG91Y2hjYW5jZWwnLCBvbkJ0bkVuZCk7XG4gICAgbGlzdGVuKGVsLCAna2V5dXAnLCBvbkJ0bkVuZCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBzdG9wOiBzdG9wLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3lcbiAgfTtcbn1cblxudmFyIGlubmVyU3R5bGUgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG52YXIgc3R5bGUgPSBpbm5lclN0eWxlICsgJ3JpZ2h0OjA7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6LTE7JztcbnZhciBtYXJrdXAgPSAnPGRpdiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj48ZGl2IHN0eWxlPVwiJyArIGlubmVyU3R5bGUgKyAnXCI+PC9kaXY+PC9kaXY+JyArICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlICsgJ1wiPjxkaXYgc3R5bGU9XCInICsgaW5uZXJTdHlsZSArICd3aWR0aDoyMDAlO2hlaWdodDoyMDAlO1wiPjwvZGl2PjwvZGl2Pic7XG52YXIgb2JzZXJ2ZXI7XG52YXIgY291bnQgPSAwO1xuZnVuY3Rpb24gcmVzaXplT2JzZXJ2ZXIoZWwsIGNhbGxiYWNrLCB6b25lKSB7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gJzEwMDAwMHB4JztcbiAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAnMTAwMDAwcHgnO1xuICAgIGV4cGFuZC5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgIGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgc2hyaW5rLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgc2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSGlkZGVuKCkge1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGhpZGRlblJhZklkID0gMDtcblxuICAgIGlmICghc3RvcENoZWNrKSB7XG4gICAgICBpZiAobm93IC0gbGFzdENoZWNrID4gMjAwICYmICFleHBhbmQuc2Nyb2xsVG9wICYmICFleHBhbmQuc2Nyb2xsTGVmdCkge1xuICAgICAgICBsYXN0Q2hlY2sgPSBub3c7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGlkZGVuUmFmSWQpIHtcbiAgICAgICAgaGlkZGVuUmFmSWQgPSByYWYoY2hlY2tIaWRkZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICAgIGlmICghcmFmSWQpIHtcbiAgICAgIHJhZklkID0gcmFmKG9uUmVzaXplKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICByYWZJZCA9IDA7XG4gICAgcmVzZXQoKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgdmFyIGV4cGFuZDtcbiAgdmFyIGV4cGFuZENoaWxkO1xuICB2YXIgaGVscGVyO1xuICB2YXIgaGlkZGVuUmFmSWQ7XG4gIHZhciByYWZJZDtcbiAgdmFyIHNocmluaztcbiAgdmFyIHN0b3BDaGVjaztcbiAgdmFyIGxhc3RDaGVjayA9IDA7IC8vbGV0IGlzSGlkZGVuID0gdHJ1ZTtcblxuICBpZiAod2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgaWYgKCFvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZW50cmllcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbnRyeSA9IF9yZWY7XG5cbiAgICAgICAgICBlbnRyeS50YXJnZXQuX19tYnNjUmVzaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvdW50Kys7XG4gICAgZWwuX19tYnNjUmVzaXplID0gY2FsbGJhY2s7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG4gIH0gZWxzZSB7XG4gICAgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaGVscGVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICBoZWxwZXIuZGlyID0gJ2x0cic7IC8vIE5lZWQgdGhpcyB0byB3b3JrIGluIHJ0bCBhcyB3ZWxsO1xuXG4gICAgc2hyaW5rID0gaGVscGVyLmNoaWxkTm9kZXNbMV07XG4gICAgZXhwYW5kID0gaGVscGVyLmNoaWxkTm9kZXNbMF07XG4gICAgZXhwYW5kQ2hpbGQgPSBleHBhbmQuY2hpbGROb2Rlc1swXTtcbiAgICBlbC5hcHBlbmRDaGlsZChoZWxwZXIpO1xuICAgIGV4cGFuZC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgc2hyaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcblxuICAgIGlmICh6b25lKSB7XG4gICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmFmKGNoZWNrSGlkZGVuKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWYoY2hlY2tIaWRkZW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgY291bnQtLTtcbiAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsKTtcblxuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5yZW1vdmVDaGlsZChoZWxwZXIpO1xuICAgICAgICBzdG9wQ2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyICRhY3RpdmVFbG0sXG4gICAgcHJldmVudFNob3csXG4gICAgdGhlbWVzID0gbW9iaXNjcm9sbC50aGVtZXMsXG4gICAgbmVlZHNGaXhlZCA9IC8oaXBob25lfGlwb2QpL2kudGVzdCh1c2VyQWdlbnQpICYmIG1ham9yVmVyc2lvbiA+PSA3LFxuICAgIGlzQW5kcm9pZCA9IG9zID09ICdhbmRyb2lkJyxcbiAgICBpc0lPUyA9IG9zID09ICdpb3MnLFxuICAgIGlzSU9TOCA9IGlzSU9TICYmIG1ham9yVmVyc2lvbiA9PSA4LFxuICAgIGhhbGZCb3JkZXIgPSBpc0lPUyAmJiBtYWpvclZlcnNpb24gPiA3LFxuICAgIHByZXZkZWYgPSBmdW5jdGlvbiBwcmV2ZGVmKGV2KSB7XG4gIGV2LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG52YXIgRURJVEFCTEUgPSAnaW5wdXQsc2VsZWN0LHRleHRhcmVhLGJ1dHRvbic7XG52YXIgQUxMT1dfRU5URVIgPSAndGV4dGFyZWEsYnV0dG9uLGlucHV0W3R5cGU9XCJidXR0b25cIl0saW5wdXRbdHlwZT1cInN1Ym1pdFwiXSc7XG52YXIgRk9DVVNBQkxFID0gRURJVEFCTEUgKyAnLFt0YWJpbmRleD1cIjBcIl0nO1xudmFyIEZyYW1lID0gZnVuY3Rpb24gRnJhbWUoZWwsIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAvLyRhcmlhRGl2LFxuICAkY3R4LFxuICAgICAgJGhlYWRlcixcbiAgICAgICRsb2NrLFxuICAgICAgJG1hcmt1cCxcbiAgICAgICRvdmVybGF5LFxuICAgICAgJHBlcnNwLFxuICAgICAgJHBvcHVwLFxuICAgICAgJHduZCxcbiAgICAgICR3cmFwcGVyLFxuICAgICAgYnV0dG9ucyxcbiAgICAgIGJ0bixcbiAgICAgIGN0eCxcbiAgICAgIGRvQW5pbSxcbiAgICAgIGhhc0NvbnRleHQsXG4gICAgICBpc01vZGFsLFxuICAgICAgaXNJbnNlcnRlZCxcbiAgICAgIGlzUG9pbnRlcixcbiAgICAgIG1hcmt1cCxcbiAgICAgIG1vZGFsV2lkdGgsXG4gICAgICBtb2RhbEhlaWdodCxcbiAgICAgIG5lZWRzRGltZW5zaW9ucyxcbiAgICAgIG5lZWRzTG9jayxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgb3ZlcmxheSxcbiAgICAgIHBvcHVwLFxuICAgICAgcG9zRGVib3VuY2UsXG4gICAgICBwcmV2SW5zdCxcbiAgICAgIHMsXG4gICAgICBzY3JvbGxMb2NrLFxuICAgICAgdG91Y2hlZCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICB3bmRXaWR0aCxcbiAgICAgIHduZEhlaWdodCxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgJGVsbSA9ICQkMShlbCksXG4gICAgICBlbG1MaXN0ID0gW10sXG4gICAgICBsYXN0Rm9jdXMgPSBuZXcgRGF0ZSgpO1xuXG4gIGZ1bmN0aW9uIG9uQnRuU3RhcnQoZXYpIHtcbiAgICAvLyBOZWVkIHRoaXMgdG8gcHJldmVudCBvcGVuaW5nIG9mIHNpZGVtZW51cyBvciBzaW1pbGFyXG4gICAgaWYgKHMuc3RvcFByb3ApIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHZhciBiID0gY2xvc2VzdCh0aGlzLCBldi50YXJnZXQsICcubWJzYy1mci1idG4tZScpO1xuXG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDYW4ndCBjYWxsIHByZXZlbnREZWZhdWx0IGhlcmUsIGl0IGtpbGxzIHBhZ2Ugc2Nyb2xsXG5cblxuICAgIGlmIChidG4pIHtcbiAgICAgIGJ0bi5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICB9XG5cbiAgICBidG4gPSAkJDEoYik7IC8vIEFjdGl2ZSBidXR0b25cblxuICAgIGlmICghYnRuLmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykgJiYgIWJ0bi5oYXNDbGFzcygnbWJzYy1mci1idG4tbmhsJykpIHtcbiAgICAgIGJ0bi5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNldXAnLCBvbkJ0bkVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CdG5FbmQoZXYpIHtcbiAgICBpZiAoYnRuKSB7XG4gICAgICBidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgICBidG4gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChldi50eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgICQkMShkb2N1bWVudCkub2ZmKCdtb3VzZXVwJywgb25CdG5FbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2KSB7XG4gICAgaWYgKHNjcm9sbExvY2sgJiYgbWFya3VwLmNvbnRhaW5zKGV2LnRhcmdldCkpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25XbmRLZXlEb3duKGV2KSB7XG4gICAgaWYgKG1vYmlzY3JvbGwuYWN0aXZlSW5zdGFuY2UgPT0gdGhhdCkge1xuICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMTMgJiYgKCEkJDEoZXYudGFyZ2V0KS5pcyhBTExPV19FTlRFUikgfHwgZXYuc2hpZnRLZXkpKSB7XG4gICAgICAgIHRoYXQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgdGhhdC5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3cocHJldkZvY3VzKSB7XG4gICAgaWYgKCFwcmV2Rm9jdXMgJiYgIWlzQW5kcm9pZCAmJiB0aGF0Ll9hY3RpdmVFbG0pIHtcbiAgICAgIC8vb3ZlcmxheS5mb2N1cygpO1xuICAgICAgbGFzdEZvY3VzID0gbmV3IERhdGUoKTtcblxuICAgICAgdGhhdC5fYWN0aXZlRWxtLmZvY3VzKCk7XG4gICAgfSAvL3RoYXQuYXJpYU1lc3NhZ2Uocy5hcmlhTWVzc2FnZSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZShwcmV2QW5pbSkge1xuICAgIHZhciAkYWN0aXZlRWwgPSAkYWN0aXZlRWxtLFxuICAgICAgICBmb2N1cyA9IHMuZm9jdXNPbkNsb3NlO1xuXG4gICAgdGhhdC5fbWFya3VwUmVtb3ZlKCk7XG5cbiAgICAkbWFya3VwLnJlbW92ZSgpO1xuXG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgIGN0eC5tYnNjTW9kYWxzLS07XG5cbiAgICAgIGlmIChzLnNjcm9sbExvY2spIHtcbiAgICAgICAgY3R4Lm1ic2NMb2NrLS07XG4gICAgICB9XG5cbiAgICAgIGlmICghY3R4Lm1ic2NMb2NrKSB7XG4gICAgICAgICRsb2NrLnJlbW92ZUNsYXNzKCdtYnNjLWZyLWxvY2snKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRzTG9jaykge1xuICAgICAgICBjdHgubWJzY0lPU0xvY2stLTtcblxuICAgICAgICBpZiAoIWN0eC5tYnNjSU9TTG9jaykge1xuICAgICAgICAgICRsb2NrLnJlbW92ZUNsYXNzKCdtYnNjLWZyLWxvY2staW9zJyk7XG4gICAgICAgICAgJGN0eC5jc3Moe1xuICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgIGxlZnQ6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJHduZC5zY3JvbGxMZWZ0KGN0eC5tYnNjU2Nyb2xsTGVmdCk7XG4gICAgICAgICAgJHduZC5zY3JvbGxUb3AoY3R4Lm1ic2NTY3JvbGxUb3ApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBmb2xsd2luZyBzaG91bGQgYmUgZG9uZSBvbmx5IGlmIG5vIG90aGVyXG4gICAgICAvLyBpbnN0YW5jZSB3YXMgb3BlbmVkIGR1cmluZyB0aGUgaGlkZSBhbmltYXRpb25cblxuXG4gICAgICBpZiAoIWN0eC5tYnNjTW9kYWxzKSB7XG4gICAgICAgICRsb2NrLnJlbW92ZUNsYXNzKCdtYnNjLWZyLWxvY2stY3R4Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3R4Lm1ic2NNb2RhbHMgfHwgcHJldkluc3QpIHtcbiAgICAgICAgLy8gUHV0IGZvY3VzIGJhY2sgdG8gdGhlIGxhc3QgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgaWYgKCFwcmV2QW5pbSkge1xuICAgICAgICAgIGlmICghJGFjdGl2ZUVsKSB7XG4gICAgICAgICAgICAkYWN0aXZlRWwgPSAkZWxtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZvY3VzID09PSB1bmRlZmluZWQgfHwgZm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcHJldmVudFNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAkYWN0aXZlRWxbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgICAgJCQxKGZvY3VzKVswXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2SW5zdCA9IHVuZGVmaW5lZDtcbiAgICBpc0luc2VydGVkID0gZmFsc2U7XG4gICAgdHJpZ2dlcignb25IaWRlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBvblBvc2l0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dChwb3NEZWJvdW5jZSk7XG4gICAgcG9zRGVib3VuY2UgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGF0LnBvc2l0aW9uKHRydWUpKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgcmVmbG93LCBuZWVkZWQgb24gaU9TIHNhZmFyaSwgd2hlbiBvcmllbnRhdGlvbiBpcyBjaGFuZ2VkXG4gICAgICAgIHBvcHVwLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgcG9wdXAub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBwb3B1cC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoZXYpIHtcbiAgICBpZiAobW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZSA9PSB0aGF0ICYmIGV2LnRhcmdldC5ub2RlVHlwZSAmJiAhb3ZlcmxheS5jb250YWlucyhldi50YXJnZXQpICYmIG5ldyBEYXRlKCkgLSBsYXN0Rm9jdXMgPiAxMDApIHtcbiAgICAgIGxhc3RGb2N1cyA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIHRoYXQuX2FjdGl2ZUVsbS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE1hcmt1cChwcmV2QW5pbSwgcHJldkZvY3VzKSB7XG4gICAgZnVuY3Rpb24gb25BbmltRW5kKCkge1xuICAgICAgJG1hcmt1cC5vZmYoYW5pbUVuZCwgb25BbmltRW5kKS5yZW1vdmVDbGFzcygnbWJzYy1hbmltLWluIG1ic2MtYW5pbS10cmFucyBtYnNjLWFuaW0tdHJhbnMtJyArIGRvQW5pbSkuZmluZCgnLm1ic2MtZnItcG9wdXAnKS5yZW1vdmVDbGFzcygnbWJzYy1hbmltLScgKyBkb0FuaW0pO1xuICAgICAgb25TaG93KHByZXZGb2N1cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25PdmVybGF5U3RhcnQoZXYpIHtcbiAgICAgIGlmICghdGFyZ2V0ICYmIGV2LnRhcmdldCA9PSBvdmVybGF5KSB7XG4gICAgICAgIHRhcmdldCA9IHRydWU7XG4gICAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk92ZXJsYXlNb3ZlKGV2KSB7XG4gICAgICBpZiAodGFyZ2V0ICYmICFtb3ZlZCAmJiAoTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdYJykgLSBzdGFydFgpID4gOSB8fCBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHN0YXJ0WSkgPiA5KSkge1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBNaWdodCBiZSBub3QgdmlzaWJsZSBpZiBpbW1lZGlhdGVseSBoaWRkZW5cblxuXG4gICAgaWYgKCF0aGF0Ll9pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNob3dcblxuXG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgICRtYXJrdXAuYXBwZW5kVG8oJGN0eCk7XG4gICAgfSBlbHNlIGlmICgkZWxtLmlzKCdkaXYnKSAmJiAhdGhhdC5faGFzQ29udGVudCkge1xuICAgICAgLy8gSW5zZXJ0IGluc2lkZSB0aGUgZWxlbWVudCBvbiB3aGljaCB3YXMgaW5pdGlhbGl6ZWRcbiAgICAgICRlbG0uZW1wdHkoKS5hcHBlbmQoJG1hcmt1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydCBhZnRlciB0aGUgZWxlbWVudFxuICAgICAgaWYgKCRlbG0uaGFzQ2xhc3MoJ21ic2MtY29udHJvbCcpKSB7XG4gICAgICAgIHZhciAkd3JhcCA9ICRlbG0uY2xvc2VzdCgnLm1ic2MtY29udHJvbC13Jyk7XG4gICAgICAgICRtYXJrdXAuaW5zZXJ0QWZ0ZXIoJHdyYXApO1xuXG4gICAgICAgIGlmICgkd3JhcC5oYXNDbGFzcygnbWJzYy1zZWxlY3QnKSkge1xuICAgICAgICAgICR3cmFwLmFkZENsYXNzKCdtYnNjLXNlbGVjdC1pbmxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJG1hcmt1cC5pbnNlcnRBZnRlcigkZWxtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0luc2VydGVkID0gdHJ1ZTtcblxuICAgIHRoYXQuX21hcmt1cEluc2VydGVkKCRtYXJrdXApO1xuXG4gICAgdHJpZ2dlcignb25NYXJrdXBJbnNlcnRlZCcsIHtcbiAgICAgIHRhcmdldDogbWFya3VwXG4gICAgfSk7XG5cbiAgICBpZiAoaXNNb2RhbCAmJiBzLmNsb3NlT25PdmVybGF5VGFwKSB7XG4gICAgICB2YXIgbW92ZWQsIHRhcmdldCwgc3RhcnRYLCBzdGFydFk7XG4gICAgICBsaXN0ZW4ob3ZlcmxheSwgJ3RvdWNoc3RhcnQnLCBvbk92ZXJsYXlTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxpc3RlbihvdmVybGF5LCAndG91Y2htb3ZlJywgb25PdmVybGF5TW92ZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgICRvdmVybGF5Lm9uKCdtb3VzZWRvd24nLCBvbk92ZXJsYXlTdGFydCkub24oJ21vdXNlbW92ZScsIG9uT3ZlcmxheU1vdmUpLm9uKCd0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGFyZ2V0ID0gZmFsc2U7XG4gICAgICB9KS5vbigndG91Y2hlbmQgY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhbW92ZWQpIHtcbiAgICAgICAgICB0aGF0LmNhbmNlbCgpO1xuXG4gICAgICAgICAgaWYgKGV2LnR5cGUgPT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgcHJldmVudENsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkbWFya3VwLm9uKCdtb3VzZWRvd24nLCAnLm1ic2MtYnRuLWUsLm1ic2MtZnItYnRuLWUnLCBwcmV2ZGVmKS5vbigna2V5ZG93bicsICcubWJzYy1mci1idG4tZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgLy8gU3BhY2VcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgIH1cbiAgICB9KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgLy8gVHJhcCBmb2N1cyBpbnNpZGUgbW9kYWxcbiAgICAgIGlmIChldi5rZXlDb2RlID09IDMyICYmICEkJDEoZXYudGFyZ2V0KS5pcyhFRElUQUJMRSkpIHtcbiAgICAgICAgLy8gUHJldmVudCBwYWdlIHNjcm9sbCBvbiBzcGFjZSBwcmVzc1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDkgJiYgaXNNb2RhbCAmJiBzLmZvY3VzVHJhcCkge1xuICAgICAgICAvLyBUYWJcbiAgICAgICAgdmFyICRmb2N1c2FibGUgPSAkbWFya3VwLmZpbmQoRk9DVVNBQkxFKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldFdpZHRoID4gMCB8fCB0aGlzLm9mZnNldEhlaWdodCA+IDA7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXggPSAkZm9jdXNhYmxlLmluZGV4KCQkMSgnOmZvY3VzJywgJG1hcmt1cCkpLFxuICAgICAgICAgICAgaSA9ICRmb2N1c2FibGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHRhcmdldCA9IDA7XG5cbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgdGFyZ2V0ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IGkpIHtcbiAgICAgICAgICAkZm9jdXNhYmxlLmVxKHRhcmdldClbMF0uZm9jdXMoKTtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkub24oJ3RvdWNoZW5kJywgJy5tYnNjLWZyLWJ0bi1lJywgb25CdG5FbmQpO1xuICAgIGxpc3RlbihtYXJrdXAsICd0b3VjaHN0YXJ0Jywgb25CdG5TdGFydCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxpc3RlbihtYXJrdXAsICdtb3VzZWRvd24nLCBvbkJ0blN0YXJ0KTsgLy8gTmVlZCBldmVudCBjYXB0dXJlIGZvciB0aGlzXG5cbiAgICBsaXN0ZW4obWFya3VwLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdG91Y2hlZCkge1xuICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgJGN0eC5maW5kKCcubWJzYy1uby10b3VjaCcpLnJlbW92ZUNsYXNzKCdtYnNjLW5vLXRvdWNoJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTsgLy8gSW5pdCBidXR0b25zXG5cbiAgICAkJDEuZWFjaChidXR0b25zLCBmdW5jdGlvbiAoaSwgYikge1xuICAgICAgdGhhdC50YXAoJCQxKCcubWJzYy1mci1idG4nICsgaSwgJG1hcmt1cCksIGZ1bmN0aW9uIChldikge1xuICAgICAgICBiID0gaXNTdHJpbmcoYikgPyB0aGF0LmJ1dHRvbnNbYl0gOiBiO1xuICAgICAgICAoaXNTdHJpbmcoYi5oYW5kbGVyKSA/IHRoYXQuaGFuZGxlcnNbYi5oYW5kbGVyXSA6IGIuaGFuZGxlcikuY2FsbCh0aGlzLCBldiwgdGhhdCk7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9KTtcblxuICAgIHRoYXQuX2F0dGFjaEV2ZW50cygkbWFya3VwKTsgLy8gU2V0IHBvc2l0aW9uXG5cblxuICAgIGlmICh0aGF0LnBvc2l0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwgfHwgdGhhdC5fY2hlY2tTaXplKSB7XG4gICAgICBvYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKG1hcmt1cCwgb25Qb3NpdGlvbiwgcy56b25lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgJG1hcmt1cC5yZW1vdmVDbGFzcygnbWJzYy1mci1wb3MnKTtcblxuICAgICAgaWYgKGRvQW5pbSAmJiAhcHJldkFuaW0pIHtcbiAgICAgICAgJG1hcmt1cC5hZGRDbGFzcygnbWJzYy1hbmltLWluIG1ic2MtYW5pbS10cmFucyBtYnNjLWFuaW0tdHJhbnMtJyArIGRvQW5pbSkub24oYW5pbUVuZCwgb25BbmltRW5kKS5maW5kKCcubWJzYy1mci1wb3B1cCcpLmFkZENsYXNzKCdtYnNjLWFuaW0tJyArIGRvQW5pbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblNob3cocHJldkZvY3VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlnZ2VyKCdvblNob3cnLCB7XG4gICAgICB0YXJnZXQ6IG1hcmt1cCxcbiAgICAgIHZhbHVlVGV4dDogdGhhdC5fdGVtcFZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KGJlZm9yZVNob3csICRlbG0pIHtcbiAgICBpZiAodGhhdC5faXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZVNob3cpIHtcbiAgICAgIGJlZm9yZVNob3coKTtcbiAgICB9XG5cbiAgICBpZiAodGhhdC5zaG93KCkgIT09IGZhbHNlKSB7XG4gICAgICAkYWN0aXZlRWxtID0gJGVsbTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXQoKSB7XG4gICAgdGhhdC5fZmlsbFZhbHVlKCk7XG5cbiAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgIHZhbHVlVGV4dDogdGhhdC5fdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICB0cmlnZ2VyKCdvbkNhbmNlbCcsIHtcbiAgICAgIHZhbHVlVGV4dDogdGhhdC5fdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoYXQuc2V0VmFsKG51bGwsIHRydWUpO1xuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgQmFzZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8qKlxuICAgKiBQb3NpdGlvbnMgdGhlIHNjcm9sbGVyIG9uIHRoZSBzY3JlZW4uXG4gICAqL1xuXG4gIHRoYXQucG9zaXRpb24gPSBmdW5jdGlvbiAoY2hlY2spIHtcbiAgICB2YXIgYW5jaG9yLFxuICAgICAgICBhbmNob3JXaWR0aCxcbiAgICAgICAgYW5jaG9ySGVpZ2h0LFxuICAgICAgICBhbmNob3JQb3MsXG4gICAgICAgIGFuY2hvclRvcCxcbiAgICAgICAgYW5jaG9yTGVmdCxcbiAgICAgICAgYXJyb3csXG4gICAgICAgIGFycm93V2lkdGgsXG4gICAgICAgIGFycm93SGVpZ2h0LFxuICAgICAgICBkb2NIZWlnaHQsXG4gICAgICAgIGRvY1dpZHRoLFxuICAgICAgICBpc1dyYXBwZWQsXG4gICAgICAgIG5ld0hlaWdodCxcbiAgICAgICAgbmV3V2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCxcbiAgICAgICAgb2xkV2lkdGgsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIGNzcyA9IHt9LFxuICAgICAgICBzY3JvbGxMZWZ0ID0gMCxcbiAgICAgICAgc2Nyb2xsVG9wID0gMCxcbiAgICAgICAgbWluV2lkdGggPSAwLFxuICAgICAgICB0b3RhbFdpZHRoID0gMDtcblxuICAgIGlmICghaXNJbnNlcnRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9sZFdpZHRoID0gd25kV2lkdGg7XG4gICAgb2xkSGVpZ2h0ID0gd25kSGVpZ2h0O1xuICAgIG5ld0hlaWdodCA9IE1hdGgubWluKG1hcmt1cC5vZmZzZXRIZWlnaHQsIGhhc0NvbnRleHQgPyBJbmZpbml0eSA6IHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgbmV3V2lkdGggPSBNYXRoLm1pbihtYXJrdXAub2Zmc2V0V2lkdGgsIGhhc0NvbnRleHQgPyBJbmZpbml0eSA6IHdpbmRvdy5pbm5lcldpZHRoKTtcblxuICAgIGlmICghbmV3V2lkdGggfHwgIW5ld0hlaWdodCB8fCB3bmRXaWR0aCA9PT0gbmV3V2lkdGggJiYgd25kSGVpZ2h0ID09PSBuZXdIZWlnaHQgJiYgY2hlY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhhdC5fY2hlY2tSZXNwKG5ld1dpZHRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHduZFdpZHRoID0gbmV3V2lkdGg7XG4gICAgd25kSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXG4gICAgaWYgKHRoYXQuX2lzRnVsbFNjcmVlbiB8fCAvdG9wfGJvdHRvbS8udGVzdChzLmRpc3BsYXkpKSB7XG4gICAgICAvLyBTZXQgd2lkdGgsIGlmIGRvY3VtZW50IGlzIGxhcmdlciB0aGFuIHZpZXdwb3J0LCBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIG9uUG9zaXRpb24gKGZvciBjYWxlbmRhcilcbiAgICAgICRwb3B1cC53aWR0aChuZXdXaWR0aCk7XG4gICAgfSBlbHNlIGlmIChpc01vZGFsKSB7XG4gICAgICAvLyBSZXNldCB3aWR0aFxuICAgICAgJHdyYXBwZXIud2lkdGgoJycpO1xuICAgIH1cblxuICAgIHRoYXQuX3Bvc2l0aW9uKCRtYXJrdXApOyAvLyBDYWxsIHBvc2l0aW9uIGZvciBuZXN0ZWQgbW9iaXNjcm9sbCBjb21wb25lbnRzXG4gICAgLy8gJCgnLm1ic2MtY29tcCcsICRtYXJrdXApLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICB2YXIgaW5zdCA9IGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICAvLyAgICAgaWYgKGluc3QgJiYgaW5zdCAhPT0gdGhhdCAmJiBpbnN0LnBvc2l0aW9uKSB7XG4gICAgLy8gICAgICAgICBpbnN0LnBvc2l0aW9uKCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9KTtcblxuXG4gICAgaWYgKCF0aGF0Ll9pc0Z1bGxTY3JlZW4gJiYgL2NlbnRlcnxidWJibGUvLnRlc3Qocy5kaXNwbGF5KSkge1xuICAgICAgJCQxKCcubWJzYy13LXAnLCAkbWFya3VwKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTmVlZCBmcmFjdGlvbmFsIHZhbHVlcyBoZXJlLCBzbyBvZmZzZXRXaWR0aCBpcyBub3Qgb2tcbiAgICAgICAgd2lkdGggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB0b3RhbFdpZHRoICs9IHdpZHRoO1xuICAgICAgICBtaW5XaWR0aCA9IHdpZHRoID4gbWluV2lkdGggPyB3aWR0aCA6IG1pbldpZHRoO1xuICAgICAgfSk7XG4gICAgICBpc1dyYXBwZWQgPSB0b3RhbFdpZHRoID4gbmV3V2lkdGggLSAxNiB8fCBzLnRhYnMgPT09IHRydWU7XG4gICAgICAkd3JhcHBlci5jc3Moe1xuICAgICAgICAnd2lkdGgnOiB0aGF0Ll9pc0xpcXVpZCA/IE1hdGgubWluKHMubWF4UG9wdXBXaWR0aCwgbmV3V2lkdGggLSAxNikgOiBNYXRoLmNlaWwoaXNXcmFwcGVkID8gbWluV2lkdGggOiB0b3RhbFdpZHRoKSxcbiAgICAgICAgJ3doaXRlLXNwYWNlJzogaXNXcmFwcGVkID8gJycgOiAnbm93cmFwJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXIoJ29uUG9zaXRpb24nLCB7XG4gICAgICB0YXJnZXQ6IG1hcmt1cCxcbiAgICAgIHBvcHVwOiBwb3B1cCxcbiAgICAgIGhhc1RhYnM6IGlzV3JhcHBlZCxcbiAgICAgIG9sZFdpZHRoOiBvbGRXaWR0aCxcbiAgICAgIG9sZEhlaWdodDogb2xkSGVpZ2h0LFxuICAgICAgd2luZG93V2lkdGg6IG5ld1dpZHRoLFxuICAgICAgd2luZG93SGVpZ2h0OiBuZXdIZWlnaHRcbiAgICB9KSA9PT0gZmFsc2UgfHwgIWlzTW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNEaW1lbnNpb25zKSB7XG4gICAgICBzY3JvbGxMZWZ0ID0gJHduZC5zY3JvbGxMZWZ0KCk7XG4gICAgICBzY3JvbGxUb3AgPSAkd25kLnNjcm9sbFRvcCgpO1xuXG4gICAgICBpZiAod25kV2lkdGgpIHtcbiAgICAgICAgJHBlcnNwLmNzcyh7XG4gICAgICAgICAgd2lkdGg6ICcnLFxuICAgICAgICAgIGhlaWdodDogJydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kYWxXaWR0aCA9IHBvcHVwLm9mZnNldFdpZHRoO1xuICAgIG1vZGFsSGVpZ2h0ID0gcG9wdXAub2Zmc2V0SGVpZ2h0O1xuICAgIHNjcm9sbExvY2sgPSBtb2RhbEhlaWdodCA8PSBuZXdIZWlnaHQgJiYgbW9kYWxXaWR0aCA8PSBuZXdXaWR0aDtcblxuICAgIGlmIChzLmRpc3BsYXkgPT0gJ2NlbnRlcicpIHtcbiAgICAgIGxlZnQgPSBNYXRoLm1heCgwLCBzY3JvbGxMZWZ0ICsgKG5ld1dpZHRoIC0gbW9kYWxXaWR0aCkgLyAyKTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KDAsIHNjcm9sbFRvcCArIChuZXdIZWlnaHQgLSBtb2RhbEhlaWdodCkgLyAyKTtcbiAgICB9IGVsc2UgaWYgKHMuZGlzcGxheSA9PSAnYnViYmxlJykge1xuICAgICAgYW5jaG9yID0gcy5hbmNob3IgPT09IHVuZGVmaW5lZCA/ICRlbG0gOiAkJDEocy5hbmNob3IpO1xuICAgICAgYXJyb3cgPSAkJDEoJy5tYnNjLWZyLWFyci1pJywgJG1hcmt1cClbMF07XG4gICAgICBhbmNob3JQb3MgPSBhbmNob3Iub2Zmc2V0KCk7XG4gICAgICBhbmNob3JUb3AgPSBhbmNob3JQb3MudG9wICsgKGhhc0NvbnRleHQgPyBzY3JvbGxUb3AgLSAkY3R4Lm9mZnNldCgpLnRvcCA6IDApO1xuICAgICAgYW5jaG9yTGVmdCA9IGFuY2hvclBvcy5sZWZ0ICsgKGhhc0NvbnRleHQgPyBzY3JvbGxMZWZ0IC0gJGN0eC5vZmZzZXQoKS5sZWZ0IDogMCk7XG4gICAgICBhbmNob3JXaWR0aCA9IGFuY2hvclswXS5vZmZzZXRXaWR0aDtcbiAgICAgIGFuY2hvckhlaWdodCA9IGFuY2hvclswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICBhcnJvd1dpZHRoID0gYXJyb3cub2Zmc2V0V2lkdGg7XG4gICAgICBhcnJvd0hlaWdodCA9IGFycm93Lm9mZnNldEhlaWdodDsgLy8gSG9yaXpvbnRhbCBwb3NpdGlvbmluZ1xuXG4gICAgICBsZWZ0ID0gY29uc3RyYWluKGFuY2hvckxlZnQgLSAobW9kYWxXaWR0aCAtIGFuY2hvcldpZHRoKSAvIDIsIHNjcm9sbExlZnQgKyAzLCBzY3JvbGxMZWZ0ICsgbmV3V2lkdGggLSBtb2RhbFdpZHRoIC0gMyk7IC8vIFZlcnRpY2FsIHBvc2l0aW9uaW5nXG4gICAgICAvLyBCZWxvdyB0aGUgaW5wdXRcblxuICAgICAgdG9wID0gYW5jaG9yVG9wICsgYW5jaG9ySGVpZ2h0ICsgYXJyb3dIZWlnaHQgLyAyO1xuXG4gICAgICBpZiAodG9wICsgbW9kYWxIZWlnaHQgKyA4ID4gc2Nyb2xsVG9wICsgbmV3SGVpZ2h0ICYmIGFuY2hvclRvcCAtIG1vZGFsSGVpZ2h0IC0gYXJyb3dIZWlnaHQgLyAyID4gc2Nyb2xsVG9wKSB7XG4gICAgICAgICRwb3B1cC5yZW1vdmVDbGFzcygnbWJzYy1mci1idWJibGUtYm90dG9tJykuYWRkQ2xhc3MoJ21ic2MtZnItYnViYmxlLXRvcCcpOyAvLyBBYm92ZSB0aGUgaW5wdXRcblxuICAgICAgICB0b3AgPSBhbmNob3JUb3AgLSBtb2RhbEhlaWdodCAtIGFycm93SGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRwb3B1cC5yZW1vdmVDbGFzcygnbWJzYy1mci1idWJibGUtdG9wJykuYWRkQ2xhc3MoJ21ic2MtZnItYnViYmxlLWJvdHRvbScpO1xuICAgICAgfSAvLyBTZXQgYXJyb3cgcG9zaXRpb25cblxuXG4gICAgICAkJDEoJy5tYnNjLWZyLWFycicsICRtYXJrdXApLmNzcyh7XG4gICAgICAgIGxlZnQ6IGNvbnN0cmFpbihhbmNob3JMZWZ0ICsgYW5jaG9yV2lkdGggLyAyIC0gKGxlZnQgKyAobW9kYWxXaWR0aCAtIGFycm93V2lkdGgpIC8gMiksIDAsIGFycm93V2lkdGgpXG4gICAgICB9KTsgLy8gTG9jayBzY3JvbGwgb25seSBpZiBwb3B1cCBpcyBlbnRpcmVseSBpbiB0aGUgdmlld3BvcnRcblxuICAgICAgc2Nyb2xsTG9jayA9IHRvcCA+IHNjcm9sbFRvcCAmJiBsZWZ0ID4gc2Nyb2xsTGVmdCAmJiB0b3AgKyBtb2RhbEhlaWdodCA8PSBzY3JvbGxUb3AgKyBuZXdIZWlnaHQgJiYgbGVmdCArIG1vZGFsV2lkdGggPD0gc2Nyb2xsTGVmdCArIG5ld1dpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgIHRvcCA9IHMuZGlzcGxheSA9PSAndG9wJyA/IHNjcm9sbFRvcCA6IE1hdGgubWF4KDAsIHNjcm9sbFRvcCArIG5ld0hlaWdodCAtIG1vZGFsSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNEaW1lbnNpb25zKSB7XG4gICAgICAvLyBJZiB0b3AgKyBtb2RhbCBoZWlnaHQgPiBkb2MgaGVpZ2h0LCBpbmNyZWFzZSBkb2MgaGVpZ2h0XG4gICAgICBkb2NIZWlnaHQgPSBNYXRoLm1heCh0b3AgKyBtb2RhbEhlaWdodCwgaGFzQ29udGV4dCA/IGN0eC5zY3JvbGxIZWlnaHQgOiAkJDEoZG9jdW1lbnQpLmhlaWdodCgpKTtcbiAgICAgIGRvY1dpZHRoID0gTWF0aC5tYXgobGVmdCArIG1vZGFsV2lkdGgsIGhhc0NvbnRleHQgPyBjdHguc2Nyb2xsV2lkdGggOiAkJDEoZG9jdW1lbnQpLndpZHRoKCkpO1xuICAgICAgJHBlcnNwLmNzcyh7XG4gICAgICAgIHdpZHRoOiBkb2NXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkb2NIZWlnaHRcbiAgICAgIH0pOyAvLyBDaGVjayBpZiBzY3JvbGwgbmVlZGVkXG5cbiAgICAgIGlmIChzLnNjcm9sbCAmJiBzLmRpc3BsYXkgPT0gJ2J1YmJsZScgJiYgKHRvcCArIG1vZGFsSGVpZ2h0ICsgOCA+IHNjcm9sbFRvcCArIG5ld0hlaWdodCB8fCBhbmNob3JUb3AgPiBzY3JvbGxUb3AgKyBuZXdIZWlnaHQgfHwgYW5jaG9yVG9wICsgYW5jaG9ySGVpZ2h0IDwgc2Nyb2xsVG9wKSkge1xuICAgICAgICAkd25kLnNjcm9sbFRvcChNYXRoLm1pbihhbmNob3JUb3AsIHRvcCArIG1vZGFsSGVpZ2h0IC0gbmV3SGVpZ2h0ICsgOCwgZG9jSGVpZ2h0IC0gbmV3SGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3NzLnRvcCA9IE1hdGguZmxvb3IodG9wKTtcbiAgICBjc3MubGVmdCA9IE1hdGguZmxvb3IobGVmdCk7XG4gICAgJHBvcHVwLmNzcyhjc3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogU2hvdyBtb2Jpc2Nyb2xsIG9uIGZvY3VzIGFuZCBjbGljayBldmVudCBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbG0gLSBFdmVudHMgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtiZWZvcmVTaG93PXVuZGVmaW5lZF0gLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGJlZm9yZSBzaG93aW5nIG1vYmlzY3JvbGwuXG4gICAqL1xuXG5cbiAgdGhhdC5hdHRhY2hTaG93ID0gZnVuY3Rpb24gKGVsbSwgYmVmb3JlU2hvdykge1xuICAgIHZhciAkbGFiZWwsXG4gICAgICAgICRlbG0gPSAkJDEoZWxtKS5vZmYoJy5tYnNjJyksXG4gICAgICAgIHJlYWRPbmx5ID0gJGVsbS5wcm9wKCdyZWFkb25seScpO1xuICAgIHRhcE9mZigkZWxtKTtcblxuICAgIGlmIChzLmRpc3BsYXkgIT09ICdpbmxpbmUnKSB7XG4gICAgICBpZiAoKHMuc2hvd09uRm9jdXMgfHwgcy5zaG93T25UYXApICYmICRlbG0uaXMoJ2lucHV0LHNlbGVjdCcpKSB7XG4gICAgICAgICRlbG0ucHJvcCgncmVhZG9ubHknLCB0cnVlKS5vbignbW91c2Vkb3duLm1ic2MnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGlucHV0IHRvIGdldCBmb2N1cyBvbiB0YXAgKHZpcnR1YWwga2V5Ym9hcmQgcG9wcyB1cCBvbiBzb21lIGRldmljZXMpXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSkub24oJ2ZvY3VzLm1ic2MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoYXQuX2lzVmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgaW5wdXQgZm9jdXMgaWYgbW9iaXNjcm9sbCBpcyBiZWluZyBvcGVuZWRcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRsYWJlbCA9ICQkMSgnbGFiZWxbZm9yPVwiJyArICRlbG0uYXR0cignaWQnKSArICdcIl0nKTtcblxuICAgICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAkbGFiZWwgPSAkZWxtLmNsb3Nlc3QoJ2xhYmVsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEkZWxtLmlzKCdzZWxlY3QnKSkge1xuICAgICAgICBpZiAocy5zaG93T25Gb2N1cykge1xuICAgICAgICAgICRlbG0ub24oJ2ZvY3VzLm1ic2MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZlbnRTaG93KSB7XG4gICAgICAgICAgICAgIHNob3coYmVmb3JlU2hvdywgJGVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmV2ZW50U2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMuc2hvd09uVGFwKSB7XG4gICAgICAgICAgJGVsbS5vbigna2V5ZG93bi5tYnNjJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSAzMiB8fCBldi5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgIC8vIFNwYWNlIG9yIEVudGVyXG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBzaG93KGJlZm9yZVNob3csICRlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoYXQudGFwKCRlbG0sIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmlzTWJzY1RhcCkge1xuICAgICAgICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2hvdyhiZWZvcmVTaG93LCAkZWxtKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgkbGFiZWwgJiYgJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFwT2ZmKCRsYWJlbCk7XG4gICAgICAgICAgICB0aGF0LnRhcCgkbGFiZWwsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIGlmIChldi50YXJnZXQgIT09ICRlbG1bMF0pIHtcbiAgICAgICAgICAgICAgICBzaG93KGJlZm9yZVNob3csICRlbG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxtTGlzdC5wdXNoKHtcbiAgICAgICAgcmVhZE9ubHk6IHJlYWRPbmx5LFxuICAgICAgICBlbDogJGVsbSxcbiAgICAgICAgbGJsOiAkbGFiZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNldCBidXR0b24gaGFuZGxlci5cbiAgICovXG5cblxuICB0aGF0LnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgdGhhdC5oaWRlKGZhbHNlLCAnc2V0JywgZmFsc2UsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENhbmNlbCBhbmQgaGlkZSB0aGUgc2Nyb2xsZXIgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgdGhhdC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgIHRoYXQuaGlkZShmYWxzZSwgJ2NhbmNlbCcsIGZhbHNlLCBjYW5jZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBidXR0b24gaGFuZGxlci5cbiAgICovXG5cblxuICB0aGF0LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX2NsZWFyVmFsdWUoKTtcblxuICAgIHRyaWdnZXIoJ29uQ2xlYXInKTtcblxuICAgIGlmIChpc01vZGFsICYmIHRoYXQuX2lzVmlzaWJsZSAmJiAhdGhhdC5saXZlKSB7XG4gICAgICB0aGF0LmhpZGUoZmFsc2UsICdjbGVhcicsIGZhbHNlLCBjbGVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgc2Nyb2xsZXIgYW5kIHRoZSBhc3NvY2lhdGVkIGlucHV0LlxuICAgKi9cblxuXG4gIHRoYXQuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAkJDEuZWFjaChlbG1MaXN0LCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgaWYgKHYuZWwuaXMoJ2lucHV0LHNlbGVjdCcpKSB7XG4gICAgICAgIHYuZWxbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzY3JvbGxlciBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQuXG4gICAqL1xuXG5cbiAgdGhhdC5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICQkMS5lYWNoKGVsbUxpc3QsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICBpZiAodi5lbC5pcygnaW5wdXQsc2VsZWN0JykpIHtcbiAgICAgICAgdi5lbFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgc2Nyb2xsZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldkFuaW0gLSBQcmV2ZW50IGFuaW1hdGlvbiBpZiB0cnVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldkZvY3VzIC0gUHJldmVudCBmb2N1c2luZyBpZiB0cnVlXG4gICAqL1xuXG5cbiAgdGhhdC5zaG93ID0gZnVuY3Rpb24gKHByZXZBbmltLCBwcmV2Rm9jdXMpIHtcbiAgICB2YXIgaGFzQnV0dG9ucywgaHRtbCwgc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wO1xuXG4gICAgaWYgKHMuZGlzYWJsZWQgfHwgdGhhdC5faXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQYXJzZSB2YWx1ZSBmcm9tIGlucHV0XG5cblxuICAgIHRoYXQuX3JlYWRWYWx1ZSgpO1xuXG4gICAgaWYgKHRyaWdnZXIoJ29uQmVmb3JlU2hvdycpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgICRhY3RpdmVFbG0gPSBudWxsO1xuICAgIGRvQW5pbSA9IHMuYW5pbWF0ZTtcbiAgICBidXR0b25zID0gcy5idXR0b25zIHx8IFtdO1xuICAgIG5lZWRzRGltZW5zaW9ucyA9IGhhc0NvbnRleHQgfHwgcy5kaXNwbGF5ID09ICdidWJibGUnO1xuICAgIG5lZWRzTG9jayA9IG5lZWRzRml4ZWQgJiYgIW5lZWRzRGltZW5zaW9ucyAmJiBzLnNjcm9sbExvY2s7XG4gICAgaGFzQnV0dG9ucyA9IGJ1dHRvbnMubGVuZ3RoID4gMDsgLy90b3VjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZG9BbmltICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHMuZGlzcGxheSA9PSAndG9wJykge1xuICAgICAgICBkb0FuaW0gPSBkb0FuaW0gfHwgJ3NsaWRlZG93bic7XG4gICAgICB9IGVsc2UgaWYgKHMuZGlzcGxheSA9PSAnYm90dG9tJykge1xuICAgICAgICBkb0FuaW0gPSBkb0FuaW0gfHwgJ3NsaWRldXAnO1xuICAgICAgfSBlbHNlIGlmIChzLmRpc3BsYXkgPT0gJ2NlbnRlcicgfHwgcy5kaXNwbGF5ID09ICdidWJibGUnKSB7XG4gICAgICAgIGRvQW5pbSA9IGRvQW5pbSB8fCAncG9wJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgd25kV2lkdGggPSAwO1xuICAgICAgd25kSGVpZ2h0ID0gMDtcblxuICAgICAgaWYgKG5lZWRzTG9jayAmJiAhJGxvY2suaGFzQ2xhc3MoJ21ic2MtZnItbG9jay1pb3MnKSkge1xuICAgICAgICAvLyRsb2NrLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgY3R4Lm1ic2NTY3JvbGxUb3AgPSBzY3JvbGxUb3AgPSBNYXRoLm1heCgwLCAkd25kLnNjcm9sbFRvcCgpKTtcbiAgICAgICAgY3R4Lm1ic2NTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsICR3bmQuc2Nyb2xsTGVmdCgpKTtcbiAgICAgICAgJGN0eC5jc3Moe1xuICAgICAgICAgIHRvcDogLXNjcm9sbFRvcCArICdweCcsXG4gICAgICAgICAgbGVmdDogLXNjcm9sbExlZnQgKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkbG9jay5hZGRDbGFzcygocy5zY3JvbGxMb2NrID8gJ21ic2MtZnItbG9jaycgOiAnJykgKyAobmVlZHNMb2NrID8gJyBtYnNjLWZyLWxvY2staW9zJyA6ICcnKSArIChoYXNDb250ZXh0ID8gJyBtYnNjLWZyLWxvY2stY3R4JyA6ICcnKSk7IC8vIEhpZGUgdmlydHVhbCBrZXlib2FyZFxuXG4gICAgICBpZiAoJCQxKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKCdpbnB1dCx0ZXh0YXJlYScpKSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfSAvLyBTYXZlIGFjdGl2ZSBpbnN0YW5jZSB0byBwcmV2aW91c1xuXG5cbiAgICAgIHByZXZJbnN0ID0gbW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZTsgLy8gU2V0IGFjdGl2ZSBpbnN0YW5jZVxuXG4gICAgICBtb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID0gdGhhdDsgLy8gS2VlcCB0cmFjayBvZiBtb2RhbHMgb3BlbmVkIHBlciBjb250ZXh0XG5cbiAgICAgIGN0eC5tYnNjTW9kYWxzID0gKGN0eC5tYnNjTW9kYWxzIHx8IDApICsgMTtcblxuICAgICAgaWYgKG5lZWRzTG9jaykge1xuICAgICAgICBjdHgubWJzY0lPU0xvY2sgPSAoY3R4Lm1ic2NJT1NMb2NrIHx8IDApICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMuc2Nyb2xsTG9jaykge1xuICAgICAgICBjdHgubWJzY0xvY2sgPSAoY3R4Lm1ic2NMb2NrIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAvLyBDcmVhdGUgd2hlZWxzIGNvbnRhaW5lcnNcbiAgICBodG1sID0gJzxkaXYgbGFuZz1cIicgKyBzLmxhbmcgKyAnXCIgY2xhc3M9XCJtYnNjLWZyIG1ic2MtJyArIHMudGhlbWUgK1xuICAgICAgICAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpICsgJyBtYnNjLWZyLScgKyBzLmRpc3BsYXkgKyAnICcgK1xuICAgICAgICAocy5jc3NDbGFzcyB8fCAnJykgKyAnICcgK1xuICAgICAgICAocy5jb21wQ2xhc3MgfHwgJycpICtcbiAgICAgICAgKHRoYXQuX2lzTGlxdWlkID8gJyBtYnNjLWZyLWxpcScgOiAnJykgK1xuICAgICAgICAoaXNNb2RhbCA/ICcgbWJzYy1mci1wb3MnICsgKChzLnNob3dPdmVybGF5ID8gJycgOiAnIG1ic2MtZnItbm8tb3ZlcmxheScpKSA6ICcnKSArXG4gICAgICAgIChpc1BvaW50ZXIgPyAnIG1ic2MtZnItcG9pbnRlcicgOiAnJykgK1xuICAgICAgICAoaGFsZkJvcmRlciA/ICcgbWJzYy1mci1oYicgOiAnJykgK1xuICAgICAgICAodG91Y2hlZCA/ICcnIDogJyBtYnNjLW5vLXRvdWNoJykgK1xuICAgICAgICAobmVlZHNMb2NrID8gJyBtYnNjLXBsYXRmb3JtLWlvcycgOiAnJykgK1xuICAgICAgICAoaGFzQnV0dG9ucyA/IChidXR0b25zLmxlbmd0aCA+PSAzID8gJyBtYnNjLWZyLWJ0bi1ibG9jayAnIDogJycpIDogJyBtYnNjLWZyLW5vYnRuJykgKyAnXCI+JyArXG4gICAgICAgIChpc01vZGFsID8gJzxkaXYgY2xhc3M9XCJtYnNjLWZyLXBlcnNwXCI+JyArXG4gICAgICAgICAgICAocy5zaG93T3ZlcmxheSA/ICc8ZGl2IGNsYXNzPVwibWJzYy1mci1vdmVybGF5XCI+PC9kaXY+JyA6ICcnKSArIC8vIE92ZXJsYXlcbiAgICAgICAgICAgICc8ZGl2IHJvbGU9XCJkaWFsb2dcIiBjbGFzcz1cIm1ic2MtZnItc2Nyb2xsXCI+JyA6ICcnKSArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwibWJzYy1mci1wb3B1cCcgK1xuICAgICAgICAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKSArXG4gICAgICAgIChzLmhlYWRlclRleHQgPyAnIG1ic2MtZnItaGFzLWhkcicgOiAnJykgK1xuICAgICAgICAnXCI+JyArIC8vIFBvcHVwXG4gICAgICAgIChzLmRpc3BsYXkgPT09ICdidWJibGUnID8gJzxkaXYgY2xhc3M9XCJtYnNjLWZyLWFyci13XCI+PGRpdiBjbGFzcz1cIm1ic2MtZnItYXJyLWlcIj48ZGl2IGNsYXNzPVwibWJzYy1mci1hcnJcIj48L2Rpdj48L2Rpdj48L2Rpdj4nIDogJycpICsgLy8gQnViYmxlIGFycm93XG4gICAgICAgIChpc01vZGFsID8gJzxkaXYgY2xhc3M9XCJtYnNjLWZyLWZvY3VzXCIgdGFiaW5kZXg9XCItMVwiPjwvZGl2PicgOiAnJykgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cIm1ic2MtZnItd1wiPicgKyAvLyBQb3B1cCBjb250ZW50XG4gICAgICAgIC8vJzxkaXYgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgY2xhc3M9XCJtYnNjLWZyLWFyaWEgbWJzYy1mci1oZG5cIj48L2Rpdj4nICtcbiAgICAgICAgKHMuaGVhZGVyVGV4dCA/ICc8ZGl2IGNsYXNzPVwibWJzYy1mci1oZHJcIj4nICsgKGlzU3RyaW5nKHMuaGVhZGVyVGV4dCkgPyBzLmhlYWRlclRleHQgOiAnJykgKyAnPC9kaXY+JyA6ICcnKSArIC8vIEhlYWRlclxuICAgICAgICAnPGRpdiBjbGFzcz1cIm1ic2MtZnItY1wiPic7IC8vIFdoZWVsIGdyb3VwIGNvbnRhaW5lclxuICAgICovXG4gICAgLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgICBodG1sID0gdGhhdC5yZW1vdGUuaHRtbDEucmVwbGFjZSgnbWJzYy1uby10b3VjaCcsICcnKSArICcgbWJzYy1mci0nICsgcy5kaXNwbGF5ICsgJyAnICsgKHMuY3NzQ2xhc3MgfHwgJycpICsgJyAnICsgKHMuY29tcENsYXNzIHx8ICcnKSArIChpc01vZGFsID8gJyBtYnNjLWZyLXBvcycgKyAocy5zaG93T3ZlcmxheSA/ICcnIDogJyBtYnNjLWZyLW5vLW92ZXJsYXknKSA6ICcnKSArIChpc1BvaW50ZXIgPyAnIG1ic2MtZnItcG9pbnRlcicgOiAnJykgKyAodGhhdC5faXNMaXF1aWQgPyAnIG1ic2MtZnItbGlxJyA6ICcnKSArIChoYWxmQm9yZGVyID8gJyBtYnNjLWZyLWhiJyA6ICcnKSArICh0b3VjaGVkID8gJycgOiAnIG1ic2Mtbm8tdG91Y2gnKSArIHRoYXQucmVtb3RlLmh0bWwyICsgKHMuaGVhZGVyVGV4dCA/ICcgbWJzYy1mci1oYXMtaGRyJyA6ICcnKSArICdcIj4nICsgKCAvLyBQb3B1cFxuICAgIHMuZGlzcGxheSA9PT0gJ2J1YmJsZScgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItYXJyLXdcIj48ZGl2IGNsYXNzPVwibWJzYy1mci1hcnItaVwiPjxkaXYgY2xhc3M9XCJtYnNjLWZyLWFyclwiPjwvZGl2PjwvZGl2PjwvZGl2PicgOiAnJykgKyAvLyBCdWJibGUgYXJyb3dcbiAgICB0aGF0LnJlbW90ZS5odG1sMyArIChzLmhlYWRlclRleHQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItaGRyXCI+JyArIChpc1N0cmluZyhzLmhlYWRlclRleHQpID8gcy5oZWFkZXJUZXh0IDogJycpICsgJzwvZGl2PicgOiAnJykgKyAvLyBIZWFkZXJcbiAgICAnPGRpdiBjbGFzcz1cIm1ic2MtZnItY1wiPic7IC8vIFdoZWVsIGdyb3VwIGNvbnRhaW5lclxuICAgIC8vIC0tLSBSRU1PVEUgVFJJQUwgQ09ERSBFTkQgLS0tXG5cbiAgICBodG1sICs9IHRoYXQuX2dlbmVyYXRlQ29udGVudCgpOyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgU1RBUlQgLS0tXG5cbiAgICBodG1sICs9IHRoYXQucmVtb3RlLmh0bWw0OyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgRU5EIC0tLVxuXG4gICAgLypcbiAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICBpZiAoaGFzQnV0dG9ucykge1xuICAgICAgICB2YXIgYixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgbCA9IGJ1dHRvbnMubGVuZ3RoO1xuICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtZnItYnRuLWNvbnRcIj4nO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaiA9IHMuYnRuUmV2ZXJzZSA/IGwgLSBpIC0gMSA6IGk7XG4gICAgICAgICAgICBiID0gYnV0dG9uc1tqXTtcbiAgICAgICAgICAgIGIgPSBpc1N0cmluZyhiKSA/IHRoYXQuYnV0dG9uc1tiXSA6IGI7XG4gICAgICAgICAgICAgaWYgKGIuaGFuZGxlciA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBiLnBhcmVudENsYXNzID0gJ21ic2MtZnItYnRuLXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGlmIChiLmhhbmRsZXIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgYi5wYXJlbnRDbGFzcyA9ICdtYnNjLWZyLWJ0bi1jJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBodG1sICs9ICc8ZGl2JyArIChzLmJ0bldpZHRoID8gJyBzdHlsZT1cIndpZHRoOicgKyAoMTAwIC8gYnV0dG9ucy5sZW5ndGgpICsgJyVcIicgOiAnJykgK1xuICAgICAgICAgICAgICAgICcgY2xhc3M9XCJtYnNjLWZyLWJ0bi13ICcgKyAoYi5wYXJlbnRDbGFzcyB8fCAnJykgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgJzxkaXYgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwibWJzYy1mci1idG4nICsgaiArICcgbWJzYy1mci1idG4tZSAnICtcbiAgICAgICAgICAgICAgICAoYi5jc3NDbGFzcyA9PT0gdW5kZWZpbmVkID8gcy5idG5DbGFzcyA6IGIuY3NzQ2xhc3MpICtcbiAgICAgICAgICAgICAgICAoYi5pY29uID8gJyBtYnNjLWljIG1ic2MtaWMtJyArIGIuaWNvbiA6ICcnKSArICdcIj4nICsgKGIudGV4dCB8fCAnJykgKyAnPC9kaXY+PC9kaXY+JztcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH1cbiAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nICsgKGlzTW9kYWwgPyAnPC9kaXY+PC9kaXY+JyA6ICcnKTtcbiAgICAqL1xuXG4gICAgJG1hcmt1cCA9ICQkMShodG1sKTtcbiAgICAkcGVyc3AgPSAkJDEoJy5tYnNjLWZyLXBlcnNwJywgJG1hcmt1cCk7XG4gICAgJG92ZXJsYXkgPSAkJDEoJy5tYnNjLWZyLXNjcm9sbCcsICRtYXJrdXApO1xuICAgICR3cmFwcGVyID0gJCQxKCcubWJzYy1mci13JywgJG1hcmt1cCk7XG4gICAgJHBvcHVwID0gJCQxKCcubWJzYy1mci1wb3B1cCcsICRtYXJrdXApO1xuICAgICRoZWFkZXIgPSAkJDEoJy5tYnNjLWZyLWhkcicsICRtYXJrdXApOyAvLyRhcmlhRGl2ID0gJCgnLm1ic2MtZnItYXJpYScsICRtYXJrdXApO1xuXG4gICAgbWFya3VwID0gJG1hcmt1cFswXTtcbiAgICBvdmVybGF5ID0gJG92ZXJsYXlbMF07XG4gICAgcG9wdXAgPSAkcG9wdXBbMF07XG4gICAgdGhhdC5fYWN0aXZlRWxtID0gJCQxKCcubWJzYy1mci1mb2N1cycsICRtYXJrdXApWzBdO1xuICAgIHRoYXQuX21hcmt1cCA9ICRtYXJrdXA7XG4gICAgdGhhdC5faXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGF0Lm1hcmt1cCA9IG1hcmt1cDtcblxuICAgIHRoYXQuX21hcmt1cFJlYWR5KCRtYXJrdXApO1xuXG4gICAgdHJpZ2dlcignb25NYXJrdXBSZWFkeScsIHtcbiAgICAgIHRhcmdldDogbWFya3VwXG4gICAgfSk7IC8vIEF0dGFjaCBldmVudHNcblxuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICAvLyBFbnRlciAvIEVTQ1xuICAgICAgJCQxKHdpbmRvdykub24oJ2tleWRvd24nLCBvblduZEtleURvd24pOyAvLyBQcmV2ZW50IHNjcm9sbCBpZiBub3Qgc3BlY2lmaWVkIG90aGVyd2lzZVxuXG4gICAgICBpZiAocy5zY3JvbGxMb2NrKSB7XG4gICAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsLCB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ21vdXNld2hlZWwnLCBvblNjcm9sbCwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0ZW4oZG9jdW1lbnQsICd3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmZvY3VzVHJhcCkge1xuICAgICAgICAkd25kLm9uKCdmb2N1c2luJywgb25Gb2N1cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB0b29sYmFyIGFuZCBhZGRyZXNzYmFyIHRvIGFwcGVhciBvbiBpT1NcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnNlcnRNYXJrdXAocHJldkFuaW0sIHByZXZGb2N1cyk7XG4gICAgICB9LCBuZWVkc0xvY2sgPyAxMDAgOiAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0TWFya3VwKHByZXZBbmltLCBwcmV2Rm9jdXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBzY3JvbGxlciBpbnN0YW5jZS5cbiAgICovXG5cblxuICB0aGF0LmhpZGUgPSBmdW5jdGlvbiAocHJldkFuaW0sIGJ0biwgZm9yY2UsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gb25BbmltRW5kKCkge1xuICAgICAgJG1hcmt1cC5vZmYoYW5pbUVuZCwgb25BbmltRW5kKTtcbiAgICAgIG9uSGlkZShwcmV2QW5pbSk7XG4gICAgfSAvLyBJZiBvbkNsb3NlIGhhbmRsZXIgcmV0dXJucyBmYWxzZSwgcHJldmVudCBoaWRlXG5cblxuICAgIGlmICghdGhhdC5faXNWaXNpYmxlIHx8ICFmb3JjZSAmJiAhdGhhdC5faXNWYWxpZCAmJiBidG4gPT0gJ3NldCcgfHwgIWZvcmNlICYmIHRyaWdnZXIoJ29uQmVmb3JlQ2xvc2UnLCB7XG4gICAgICB2YWx1ZVRleHQ6IHRoYXQuX3RlbXBWYWx1ZSxcbiAgICAgIGJ1dHRvbjogYnRuXG4gICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhhdC5faXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyLmRldGFjaCgpO1xuICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICBpZiAoJCQxKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKCdpbnB1dCx0ZXh0YXJlYScpICYmIHBvcHVwLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZSA9PSB0aGF0KSB7XG4gICAgICAgIG1vYmlzY3JvbGwuYWN0aXZlSW5zdGFuY2UgPSBwcmV2SW5zdDtcbiAgICAgIH1cblxuICAgICAgJCQxKHdpbmRvdykub2ZmKCdrZXlkb3duJywgb25XbmRLZXlEb3duKTtcbiAgICAgICR3bmQub2ZmKCdmb2N1c2luJywgb25Gb2N1cyk7XG4gICAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAnbW91c2V3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAnd2hlZWwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSAvLyBIaWRlIHdoZWVscyBhbmQgb3ZlcmxheVxuXG5cbiAgICBpZiAoJG1hcmt1cCkge1xuICAgICAgaWYgKGlzTW9kYWwgJiYgaXNJbnNlcnRlZCAmJiBkb0FuaW0gJiYgIXByZXZBbmltKSB7XG4gICAgICAgICRtYXJrdXAuYWRkQ2xhc3MoJ21ic2MtYW5pbS1vdXQgbWJzYy1hbmltLXRyYW5zIG1ic2MtYW5pbS10cmFucy0nICsgZG9BbmltKS5vbihhbmltRW5kLCBvbkFuaW1FbmQpLmZpbmQoJy5tYnNjLWZyLXBvcHVwJykuYWRkQ2xhc3MoJ21ic2MtYW5pbS0nICsgZG9BbmltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uSGlkZShwcmV2QW5pbSk7XG4gICAgICB9XG5cbiAgICAgIHRoYXQuX2RldGFjaEV2ZW50cygkbWFya3VwKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBGb3IgdmFsaWRhdGlvblxuXG5cbiAgICAkZWxtLnRyaWdnZXIoJ2JsdXInKTtcbiAgICB0cmlnZ2VyKCdvbkNsb3NlJywge1xuICAgICAgdmFsdWVUZXh0OiB0aGF0Ll92YWx1ZVxuICAgIH0pO1xuICB9OyAvLyB0aGF0LmFyaWFNZXNzYWdlID0gZnVuY3Rpb24gKHR4dCkge1xuICAvLyAgICAgJGFyaWFEaXYuaHRtbCgnJyk7XG4gIC8vICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgICAgICAkYXJpYURpdi5odG1sKHR4dCk7XG4gIC8vICAgICB9LCAxMDApO1xuICAvLyB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgc2Nyb2xsZXIgaXMgY3VycmVudGx5IHZpc2libGUuXG4gICAqL1xuXG5cbiAgdGhhdC5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoYXQuX2lzVmlzaWJsZTtcbiAgfTsgLy8gUHJvdGVjdGVkIGZ1bmN0aW9ucyB0byBvdmVycmlkZVxuXG5cbiAgdGhhdC5zZXRWYWwgPSBub29wO1xuICB0aGF0LmdldFZhbCA9IG5vb3A7XG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IG5vb3A7XG4gIHRoYXQuX2F0dGFjaEV2ZW50cyA9IG5vb3A7XG4gIHRoYXQuX2RldGFjaEV2ZW50cyA9IG5vb3A7XG4gIHRoYXQuX3JlYWRWYWx1ZSA9IG5vb3A7XG4gIHRoYXQuX2NsZWFyVmFsdWUgPSBub29wO1xuICB0aGF0Ll9maWxsVmFsdWUgPSBub29wO1xuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IG5vb3A7XG4gIHRoYXQuX21hcmt1cEluc2VydGVkID0gbm9vcDtcbiAgdGhhdC5fbWFya3VwUmVtb3ZlID0gbm9vcDtcbiAgdGhhdC5fcG9zaXRpb24gPSBub29wO1xuICB0aGF0Ll9fcHJvY2Vzc1NldHRpbmdzID0gbm9vcDtcbiAgdGhhdC5fX2luaXQgPSBub29wO1xuICB0aGF0Ll9fZGVzdHJveSA9IG5vb3A7IC8vIEdlbmVyaWMgZnJhbWUgZnVuY3Rpb25zXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBtb2Jpc2Nyb2xsIGluc3RhbmNlLlxuICAgKi9cblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZvcmNlIGhpZGUgd2l0aG91dCBhbmltYXRpb25cbiAgICB0aGF0LmhpZGUodHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICRlbG0ub2ZmKCcubWJzYycpO1xuICAgIHRhcE9mZigkZWxtKTsgLy8gUmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50c1xuXG4gICAgJCQxLmVhY2goZWxtTGlzdCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgIHYuZWwub2ZmKCcubWJzYycpLnByb3AoJ3JlYWRvbmx5Jywgdi5yZWFkT25seSk7XG4gICAgICB0YXBPZmYodi5lbCk7XG5cbiAgICAgIGlmICh2LmxibCkge1xuICAgICAgICB2LmxibC5vZmYoJy5tYnNjJyk7XG4gICAgICAgIHRhcE9mZih2LmxibCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGF0Ll9fZGVzdHJveSgpO1xuICB9O1xuXG4gIHRoYXQuX3VwZGF0ZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IHMuaGVhZGVyVGV4dCxcbiAgICAgICAgdHh0ID0gdCA/IHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nID8gdC5jYWxsKGVsLCB0aGF0Ll90ZW1wVmFsdWUpIDogdC5yZXBsYWNlKC9cXHt2YWx1ZVxcfS9pLCB0aGF0Ll90ZW1wVmFsdWUpIDogJyc7XG4gICAgJGhlYWRlci5odG1sKHR4dCB8fCAnJm5ic3A7Jyk7XG4gIH07XG5cbiAgdGhhdC5fZ2V0UmVzcENvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaGFzQ29udGV4dCA9IHMuY29udGV4dCAhPSAnYm9keSc7XG4gICAgJHduZCA9ICQkMShoYXNDb250ZXh0ID8gcy5jb250ZXh0IDogd2luZG93KTtcbiAgICByZXR1cm4gcy5kaXNwbGF5ID09ICdpbmxpbmUnID8gJGVsbS5pcygnZGl2JykgPyAkZWxtIDogJGVsbS5wYXJlbnQoKSA6ICR3bmQ7XG4gIH07XG5cbiAgdGhhdC5fcHJvY2Vzc1NldHRpbmdzID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICB2YXIgYiwgaTtcblxuICAgIHRoYXQuX19wcm9jZXNzU2V0dGluZ3MocmVzcCk7XG5cbiAgICBpc1BvaW50ZXIgPSAhcy50b3VjaFVpO1xuXG4gICAgaWYgKGlzUG9pbnRlcikge1xuICAgICAgcy5kaXNwbGF5ID0gcmVzcC5kaXNwbGF5IHx8IHNldHRpbmdzLmRpc3BsYXkgfHwgJ2J1YmJsZSc7XG4gICAgICBzLmJ1dHRvbnMgPSByZXNwLmJ1dHRvbnMgfHwgc2V0dGluZ3MuYnV0dG9ucyB8fCBbXTtcbiAgICAgIHMuc2hvd092ZXJsYXkgPSByZXNwLnNob3dPdmVybGF5IHx8IHNldHRpbmdzLnNob3dPdmVybGF5IHx8IGZhbHNlO1xuICAgIH0gLy8gQWRkIGRlZmF1bHQgYnV0dG9uc1xuXG5cbiAgICBzLmJ1dHRvbnMgPSBzLmJ1dHRvbnMgfHwgKHMuZGlzcGxheSAhPT0gJ2lubGluZScgPyBbJ2NhbmNlbCcsICdzZXQnXSA6IFtdKTsgLy8gSGlkZSBoZWFkZXIgdGV4dCBpbiBpbmxpbmUgbW9kZSBieSBkZWZhdWx0XG5cbiAgICBzLmhlYWRlclRleHQgPSBzLmhlYWRlclRleHQgPT09IHVuZGVmaW5lZCA/IHMuZGlzcGxheSAhPT0gJ2lubGluZScgPyAne3ZhbHVlfScgOiBmYWxzZSA6IHMuaGVhZGVyVGV4dDtcbiAgICBidXR0b25zID0gcy5idXR0b25zIHx8IFtdO1xuICAgIGlzTW9kYWwgPSBzLmRpc3BsYXkgIT09ICdpbmxpbmUnO1xuICAgICRjdHggPSAkJDEocy5jb250ZXh0KTtcbiAgICAkbG9jayA9IGhhc0NvbnRleHQgPyAkY3R4IDogJCQxKCdib2R5LGh0bWwnKTtcbiAgICBjdHggPSAkY3R4WzBdO1xuICAgIHRoYXQubGl2ZSA9IHRydWU7IC8vIElmIG5vIHNldCBidXR0b24gaXMgZm91bmQsIGxpdmUgbW9kZSBpcyBhY3RpdmF0ZWRcblxuICAgIGZvciAoaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiID0gYnV0dG9uc1tpXTtcblxuICAgICAgaWYgKGIgPT0gJ29rJyB8fCBiID09ICdzZXQnIHx8IGIuaGFuZGxlciA9PSAnc2V0Jykge1xuICAgICAgICB0aGF0LmxpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGF0LmJ1dHRvbnMuc2V0ID0ge1xuICAgICAgdGV4dDogcy5zZXRUZXh0LFxuICAgICAgaWNvbjogcy5zZXRJY29uLFxuICAgICAgaGFuZGxlcjogJ3NldCdcbiAgICB9O1xuICAgIHRoYXQuYnV0dG9ucy5jYW5jZWwgPSB7XG4gICAgICB0ZXh0OiBzLmNhbmNlbFRleHQsXG4gICAgICBpY29uOiBzLmNhbmNlbEljb24sXG4gICAgICBoYW5kbGVyOiAnY2FuY2VsJ1xuICAgIH07XG4gICAgdGhhdC5idXR0b25zLmNsb3NlID0ge1xuICAgICAgdGV4dDogcy5jbG9zZVRleHQsXG4gICAgICBpY29uOiBzLmNsb3NlSWNvbixcbiAgICAgIGhhbmRsZXI6ICdjYW5jZWwnXG4gICAgfTtcbiAgICB0aGF0LmJ1dHRvbnMuY2xlYXIgPSB7XG4gICAgICB0ZXh0OiBzLmNsZWFyVGV4dCxcbiAgICAgIGljb246IHMuY2xlYXJJY29uLFxuICAgICAgaGFuZGxlcjogJ2NsZWFyJ1xuICAgIH07XG4gICAgdGhhdC5faXNJbnB1dCA9ICRlbG0uaXMoJ2lucHV0Jyk7XG4gIH07XG4gIC8qKlxuICAgKiBTY3JvbGxlciBpbml0aWFsaXphdGlvbi5cbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKG5ld1NldHRpbmdzKSB7XG4gICAgdmFyIHdhc1Zpc2libGUgPSB0aGF0Ll9pc1Zpc2libGUsXG4gICAgICAgIHdhc1JlYWR5ID0gd2FzVmlzaWJsZSAmJiAhJG1hcmt1cC5oYXNDbGFzcygnbWJzYy1mci1wb3MnKTtcblxuICAgIGlmICh3YXNWaXNpYmxlKSB7XG4gICAgICB0aGF0LmhpZGUodHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgIH0gLy8gVW5iaW5kIGFsbCBldmVudHMgKGlmIHJlLWluaXQpXG5cblxuICAgICRlbG0ub2ZmKCcubWJzYycpO1xuICAgIHRhcE9mZigkZWxtKTtcblxuICAgIHRoYXQuX19pbml0KG5ld1NldHRpbmdzKTtcblxuICAgIHRoYXQuX2lzTGlxdWlkID0gcy5sYXlvdXQgPT0gJ2xpcXVpZCc7XG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgdGhhdC5fcmVhZFZhbHVlKCk7XG5cbiAgICAgIGlmICghdGhhdC5faGFzQ29udGVudCAmJiAhcy5za2lwU2hvdykge1xuICAgICAgICB0aGF0LmF0dGFjaFNob3coJGVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNWaXNpYmxlKSB7XG4gICAgICAgIHRoYXQuc2hvdyh3YXNSZWFkeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuc2hvdygpO1xuICAgIH1cblxuICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtY2xvYWsnKS5maWx0ZXIoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykub24oJ2NoYW5nZS5tYnNjJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGF0Ll9wcmV2ZW50Q2hhbmdlKSB7XG4gICAgICAgIHRoYXQuc2V0VmFsKCRlbG0udmFsKCksIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoYXQuYnV0dG9ucyA9IHt9O1xuICB0aGF0LmhhbmRsZXJzID0ge1xuICAgIHNldDogdGhhdC5zZWxlY3QsXG4gICAgY2FuY2VsOiB0aGF0LmNhbmNlbCxcbiAgICBjbGVhcjogdGhhdC5jbGVhclxuICB9O1xuICB0aGF0Ll92YWx1ZSA9IG51bGw7XG4gIHRoYXQuX2lzVmFsaWQgPSB0cnVlO1xuICB0aGF0Ll9pc1Zpc2libGUgPSBmYWxzZTsgLy8gQ29uc3RydWN0b3JcblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTtcbkZyYW1lLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gIC8vIExvY2FsaXphdGlvblxuICBsYW5nOiAnZW4nLFxuICBzZXRUZXh0OiAnU2V0JyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBzZWxlY3RlZCcsXG4gIGNsb3NlVGV4dDogJ0Nsb3NlJyxcbiAgY2FuY2VsVGV4dDogJ0NhbmNlbCcsXG4gIGNsZWFyVGV4dDogJ0NsZWFyJyxcbiAgLy8gT3B0aW9uc1xuICBjb250ZXh0OiAnYm9keScsXG4gIG1heFBvcHVwV2lkdGg6IDYwMCxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBjbG9zZU9uT3ZlcmxheVRhcDogdHJ1ZSxcbiAgc2hvd09uRm9jdXM6IGlzQW5kcm9pZCB8fCBpc0lPUyxcbiAgLy8gTmVlZGVkIGZvciBpb24taW5wdXRcbiAgc2hvd09uVGFwOiB0cnVlLFxuICBkaXNwbGF5OiAnY2VudGVyJyxcbiAgc2Nyb2xsOiB0cnVlLFxuICBzY3JvbGxMb2NrOiB0cnVlLFxuICBzaG93T3ZlcmxheTogdHJ1ZSxcbiAgdGFwOiB0cnVlLFxuICB0b3VjaFVpOiB0cnVlLFxuICBidG5DbGFzczogJ21ic2MtZnItYnRuJyxcbiAgYnRuV2lkdGg6IHRydWUsXG4gIGZvY3VzVHJhcDogdHJ1ZSxcbiAgZm9jdXNPbkNsb3NlOiAhaXNJT1M4IC8vIFRlbXBvcmFyeSBmb3IgaU9TOFxuXG59O1xuY2xhc3Nlcy5GcmFtZSA9IEZyYW1lO1xudGhlbWVzLmZyYW1lLm1vYmlzY3JvbGwgPSB7XG4gIGhlYWRlclRleHQ6IGZhbHNlLFxuICBidG5XaWR0aDogZmFsc2Vcbn07XG50aGVtZXMuc2Nyb2xsZXIubW9iaXNjcm9sbCA9IGV4dGVuZCQxKHt9LCB0aGVtZXMuZnJhbWUubW9iaXNjcm9sbCwge1xuICByb3dzOiA1LFxuICBzaG93TGFiZWw6IGZhbHNlLFxuICBzZWxlY3RlZExpbmVCb3JkZXI6IDEsXG4gIHdlZWtEYXlzOiAnbWluJyxcbiAgY2hlY2tJY29uOiAnaW9uLWlvczctY2hlY2ttYXJrLWVtcHR5JyxcbiAgYnRuUGx1c0NsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWRvd241JyxcbiAgYnRuTWludXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy11cDUnLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctbGVmdDUnLFxuICBidG5DYWxOZXh0Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctcmlnaHQ1J1xufSk7XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgLy8gUHJldmVudCByZS1zaG93IG9uIHdpbmRvdyBmb2N1c1xuICAkJDEod2luZG93KS5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCRhY3RpdmVFbG0pIHtcbiAgICAgIHByZXZlbnRTaG93ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBpc0lPUyQxID0gb3MgPT0gJ2lvcyc7XG52YXIgU2Nyb2xsVmlld0Jhc2UgPSBmdW5jdGlvbiBTY3JvbGxWaWV3QmFzZShlbCwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRidG4sXG4gICAgICAkc2Nyb2xsYmFyLFxuICAgICAgJHNjcm9sbGJhclRyYWNrLFxuICAgICAgYnRuVGltZXIsXG4gICAgICBjb250U2l6ZSxcbiAgICAgIGRpZmZYLFxuICAgICAgZGlmZlksXG4gICAgICBkaWZmLFxuICAgICAgZGlyLFxuICAgICAgZWFzaW5nLFxuICAgICAgZWxhc3RpYyxcbiAgICAgIGVuZFgsXG4gICAgICBlbmRZLFxuICAgICAgZXZlbnRPYmosXG4gICAgICBpc0J0bixcbiAgICAgIGlzSW5maW5pdGUsXG4gICAgICBtYXhTY3JvbGwsXG4gICAgICBtYXhTbmFwU2Nyb2xsLFxuICAgICAgbWluU2Nyb2xsLFxuICAgICAgbW92ZSxcbiAgICAgIG1vdmluZyxcbiAgICAgIG5hdGl2ZVNjcm9sbCxcbiAgICAgIHJhZklELFxuICAgICAgLy9yYWZNb3ZlSUQsXG4gIHJhZlJ1bm5pbmcsXG4gICAgICBzY3JvbGxiYXIsXG4gICAgICBzY3JvbGxiYXJIZWlnaHQsXG4gICAgICBzY3JvbGxiYXJPZmZzZXQsXG4gICAgICBzY3JvbGxiYXJUcmFjayxcbiAgICAgIHNjcm9sbGVkLFxuICAgICAgc2Nyb2xsRGVib3VuY2UsXG4gICAgICBzY3JvbGxTbmFwLFxuICAgICAgc2Nyb2xsVGltZXIsXG4gICAgICBzbmFwLFxuICAgICAgc25hcFBvaW50cyxcbiAgICAgIHN0YXJ0UG9zLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3R5bGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0cmFuc1RpbWVyLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIHZlcnRpY2FsLFxuICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICBjdXJyUG9zLFxuICAgICAgY3VyclNuYXAgPSAwLFxuICAgICAgY3VyclNuYXBEaXIgPSAxLFxuICAgICAgcyA9IHNldHRpbmdzLFxuICAgICAgJGVsbSA9ICQkMShlbCk7XG5cbiAgZnVuY3Rpb24gb25TdGFydChldikge1xuICAgIHRyaWdnZXIoJ29uU3RhcnQnLCB7XG4gICAgICBkb21FdmVudDogZXZcbiAgICB9KTsgLy8gQmV0dGVyIHBlcmZvcm1hbmNlIGlmIHRoZXJlIGFyZSB0YXAgZXZlbnRzIG9uIGRvY3VtZW50XG5cbiAgICBpZiAocy5zdG9wUHJvcCkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSAvL2lmIChzLnByZXZEZWYgfHwgZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuXG5cbiAgICBpZiAocy5wcmV2RGVmICYmIGV2LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgIC8vIFByZXZlbnQgdG91Y2ggaGlnaGxpZ2h0IGFuZCBmb2N1c1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAocy5yZWFkb25seSB8fCBzLmxvY2sgJiYgbW92aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRlc3RUb3VjaChldiwgdGhpcykgJiYgIW1vdmUgJiYgbW9iaXNjcm9sbC5FbXRqQykge1xuICAgICAgaWYgKCRidG4pIHtcbiAgICAgICAgJGJ0bi5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgIH0gLy8gSGlnaGxpZ2h0IGJ1dHRvblxuXG5cbiAgICAgIGlzQnRuID0gZmFsc2U7XG5cbiAgICAgIGlmICghbW92aW5nKSB7XG4gICAgICAgICRidG4gPSAkJDEoZXYudGFyZ2V0KS5jbG9zZXN0KCcubWJzYy1idG4tZScsIHRoaXMpO1xuXG4gICAgICAgIGlmICgkYnRuLmxlbmd0aCAmJiAhJGJ0bi5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgaXNCdG4gPSB0cnVlO1xuICAgICAgICAgIGJ0blRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkYnRuLmFkZENsYXNzKCdtYnNjLWFjdGl2ZScpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW92ZSA9IHRydWU7XG4gICAgICBzY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgbmF0aXZlU2Nyb2xsID0gZmFsc2U7XG4gICAgICB0aGF0LnNjcm9sbGVkID0gbW92aW5nO1xuICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIGVuZFggPSBzdGFydFg7XG4gICAgICBkaWZmWCA9IDA7XG4gICAgICBkaWZmWSA9IDA7XG4gICAgICBkaWZmID0gMDtcbiAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICBzdGFydFBvcyA9ICtnZXRQb3NpdGlvbih0YXJnZXQsIHZlcnRpY2FsKSB8fCAwOyAvLyBTdG9wIHNjcm9sbGluZyBhbmltYXRpb24sIDFtcyBpcyBuZWVkZWQgZm9yIEFuZHJvaWQgNC4wXG5cbiAgICAgIGlmIChtb3ZpbmcpIHtcbiAgICAgICAgc2Nyb2xsKHN0YXJ0UG9zLCBpc0lPUyQxID8gMCA6IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vbignbW91c2V1cCcsIG9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICBpZiAobW92ZSkge1xuICAgICAgaWYgKHMuc3RvcFByb3ApIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGVuZFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIGVuZFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIGRpZmZYID0gZW5kWCAtIHN0YXJ0WDtcbiAgICAgIGRpZmZZID0gZW5kWSAtIHN0YXJ0WTtcbiAgICAgIGRpZmYgPSB2ZXJ0aWNhbCA/IGRpZmZZIDogZGlmZlg7XG5cbiAgICAgIGlmIChpc0J0biAmJiAoTWF0aC5hYnMoZGlmZlkpID4gcy50aHJlc2hvbGRZIHx8IE1hdGguYWJzKGRpZmZYKSA+IHMudGhyZXNob2xkWCkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGJ0blRpbWVyKTtcbiAgICAgICAgJGJ0bi5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgICAgaXNCdG4gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoYXQuc2Nyb2xsZWQgfHwgIW5hdGl2ZVNjcm9sbCAmJiBNYXRoLmFicyhkaWZmKSA+IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIXNjcm9sbGVkKSB7XG4gICAgICAgICAgdHJpZ2dlcignb25HZXN0dXJlU3RhcnQnLCBldmVudE9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LnNjcm9sbGVkID0gc2Nyb2xsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICghcmFmUnVubmluZykge1xuICAgICAgICAgIHJhZlJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgIHJhZklEID0gcmFmKG9uTW92aW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWwgfHwgcy5zY3JvbGxMb2NrKSB7XG4gICAgICAgIC8vIEFsd2F5cyBwcmV2ZW50IG5hdGl2ZSBzY3JvbGwsIGlmIHZlcnRpY2FsXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhhdC5zY3JvbGxlZCkge1xuICAgICAgICAgIC8vIFByZXZlbnQgbmF0aXZlIHNjcm9sbFxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGlmZlkpID4gNykge1xuICAgICAgICAgIG5hdGl2ZVNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgdGhhdC5zY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW92aW5nKCkge1xuICAgIC8vdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIGlmIChtYXhTbmFwU2Nyb2xsKSB7XG4gICAgICBkaWZmID0gY29uc3RyYWluKGRpZmYsIC1zbmFwICogbWF4U25hcFNjcm9sbCwgc25hcCAqIG1heFNuYXBTY3JvbGwpO1xuICAgIH1cblxuICAgIHNjcm9sbChjb25zdHJhaW4oc3RhcnRQb3MgKyBkaWZmLCBtaW5TY3JvbGwgLSBlbGFzdGljLCBtYXhTY3JvbGwgKyBlbGFzdGljKSk7IC8vaWYgKHMubW9tZW50dW0pIHtcbiAgICAvLyAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgIC8vICAgIGxhc3RYID0gZW5kWDtcbiAgICAvL31cblxuICAgIHJhZlJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kKGV2KSB7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgIHZhciBzcGVlZCxcbiAgICAgICAgICB0aW1lID0gbmV3IERhdGUoKSAtIHN0YXJ0VGltZTsgLy8gQmV0dGVyIHBlcmZvcm1hbmNlIGlmIHRoZXJlIGFyZSB0YXAgZXZlbnRzIG9uIGRvY3VtZW50XG5cbiAgICAgIGlmIChzLnN0b3BQcm9wICYmIGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByYWZjKHJhZklEKTtcbiAgICAgIHJhZlJ1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKCFuYXRpdmVTY3JvbGwgJiYgdGhhdC5zY3JvbGxlZCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbW9tZW50dW0gZGlzdGFuY2VcbiAgICAgICAgaWYgKHMubW9tZW50dW0gJiYgdGltZSA8IDMwMCkge1xuICAgICAgICAgIHNwZWVkID0gZGlmZiAvIHRpbWU7IC8vc3BlZWQgPSBNYXRoLmFicyhsYXN0WCAtIGVuZFgpIC8gdGltZTtcblxuICAgICAgICAgIGRpZmYgPSBNYXRoLm1heChNYXRoLmFicyhkaWZmKSwgc3BlZWQgKiBzcGVlZCAvIHMuc3BlZWRVbml0KSAqIChkaWZmIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGl6ZShkaWZmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQnRuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChidG5UaW1lcik7XG4gICAgICAgICRidG4uYWRkQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgaWYgKCFuYXRpdmVTY3JvbGwgJiYgIXRoYXQuc2Nyb2xsZWQpIHtcbiAgICAgICAgICB0cmlnZ2VyKCdvbkJ0blRhcCcsIHtcbiAgICAgICAgICAgIHRhcmdldDogJGJ0blswXSxcbiAgICAgICAgICAgIGRvbUV2ZW50OiBldlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIERldGFjaCBkb2N1bWVudCBldmVudHNcblxuXG4gICAgICBpZiAoZXYgJiYgZXYudHlwZSA9PSAnbW91c2V1cCcpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vZmYoJ21vdXNlbW92ZScsIG9uTW92ZSkub2ZmKCdtb3VzZXVwJywgb25FbmQpO1xuICAgICAgfVxuXG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgIGlmICh0aGF0LnNjcm9sbGVkKSB7XG4gICAgICB0aGF0LnNjcm9sbGVkID0gZmFsc2U7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGwoZXYpIHtcbiAgICBpZiAoIWVsLmNvbnRhaW5zKGV2LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldiA9IGV2Lm9yaWdpbmFsRXZlbnQgfHwgZXY7XG4gICAgZGlmZiA9IHZlcnRpY2FsID8gZXYuZGVsdGFZID09IHVuZGVmaW5lZCA/IGV2LndoZWVsRGVsdGEgfHwgZXYuZGV0YWlsIDogZXYuZGVsdGFZIDogZXYuZGVsdGFYO1xuICAgIHRyaWdnZXIoJ29uU3RhcnQnLCB7XG4gICAgICBkb21FdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChzLnN0b3BQcm9wKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoZGlmZiAmJiBtb2Jpc2Nyb2xsLkVtdGpDKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvL2RpZmYgPSBkaWZmIDwgMCA/IDIwIDogLTIwO1xuXG4gICAgICBpZiAoZXYuZGVsdGFNb2RlICYmIGV2LmRlbHRhTW9kZSA9PSAxKSB7XG4gICAgICAgIGRpZmYgKj0gMTU7XG4gICAgICB9XG5cbiAgICAgIGRpZmYgPSBjb25zdHJhaW4oLWRpZmYsIC1zY3JvbGxTbmFwLCBzY3JvbGxTbmFwKTtcbiAgICAgIHN0YXJ0UG9zID0gY3VyclBvcztcblxuICAgICAgaWYgKHMucmVhZG9ubHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNjcm9sbGVkKSB7XG4gICAgICAgIGdlc3R1cmVTdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRQb3MgKyBkaWZmIDwgbWluU2Nyb2xsKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gbWluU2Nyb2xsO1xuICAgICAgICBkaWZmID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0UG9zICsgZGlmZiA+IG1heFNjcm9sbCkge1xuICAgICAgICBzdGFydFBvcyA9IG1heFNjcm9sbDtcbiAgICAgICAgZGlmZiA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmFmUnVubmluZykge1xuICAgICAgICByYWZSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgcmFmSUQgPSByYWYob25Nb3ZpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZmYgJiYgc2Nyb2xsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsRGVib3VuY2UpO1xuICAgICAgc2Nyb2xsRGVib3VuY2UgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmFmYyhyYWZJRCk7XG4gICAgICAgIHJhZlJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgZmluYWxpemUoZGlmZik7XG4gICAgICB9LCAyMDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsQmFyU3RhcnQoZXYpIHtcbiAgICB0cmlnZ2VyKCdvblN0YXJ0Jywge1xuICAgICAgZG9tRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocy5yZWFkb25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHN0YXJ0UG9zID0gY3VyclBvcztcbiAgICBzY3JvbGxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGV2LnRhcmdldCA9PSBzY3JvbGxiYXIpIHtcbiAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScsIHRydWUpO1xuICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25TY3JvbGxCYXJNb3ZlKS5vbignbW91c2V1cCcsIG9uU2Nyb2xsQmFyRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRZID0gJHNjcm9sbGJhci5vZmZzZXQoKS50b3A7XG4gICAgICBvblNjcm9sbEJhck1vdmUoZXYpO1xuICAgICAgb25TY3JvbGxCYXJFbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbEJhck1vdmUoZXYpIHtcbiAgICB2YXIgcGVyY2VudCA9IChnZXRDb29yZChldiwgJ1knLCB0cnVlKSAtIHN0YXJ0WSkgLyBjb250U2l6ZTtcblxuICAgIGlmIChpc0luZmluaXRlKSB7XG4gICAgICBkaWZmID0gLShtYXhTbmFwU2Nyb2xsICogc25hcCAqIDIgKyBjb250U2l6ZSkgKiBwZXJjZW50O1xuICAgICAgZGlmZiA9IGNvbnN0cmFpbihkaWZmLCAtc25hcCAqIG1heFNuYXBTY3JvbGwsIHNuYXAgKiBtYXhTbmFwU2Nyb2xsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlmZiA9IChtaW5TY3JvbGwgLSBtYXhTY3JvbGwgLSBjb250U2l6ZSkgKiBwZXJjZW50O1xuICAgIH1cblxuICAgIGlmICghc2Nyb2xsZWQpIHtcbiAgICAgIGdlc3R1cmVTdGFydCgpO1xuICAgIH1cblxuICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICBzY3JvbGwoY29uc3RyYWluKHN0YXJ0UG9zICsgZGlmZiwgbWluU2Nyb2xsIC0gZWxhc3RpYywgbWF4U2Nyb2xsICsgZWxhc3RpYykpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxCYXJFbmQoKSB7XG4gICAgc3RhcnRQb3MgPSBjdXJyUG9zO1xuICAgIGZpbmFsaXplKDApO1xuICAgICQkMShkb2N1bWVudCkub2ZmKCdtb3VzZW1vdmUnLCBvblNjcm9sbEJhck1vdmUpLm9mZignbW91c2V1cCcsIG9uU2Nyb2xsQmFyRW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsQmFyQ2xpY2soZXYpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmVTdGFydCgpIHtcbiAgICBldmVudE9iaiA9IHtcbiAgICAgIHBvc1g6IHZlcnRpY2FsID8gMCA6IGN1cnJQb3MsXG4gICAgICBwb3NZOiB2ZXJ0aWNhbCA/IGN1cnJQb3MgOiAwLFxuICAgICAgb3JpZ2luWDogdmVydGljYWwgPyAwIDogc3RhcnRQb3MsXG4gICAgICBvcmlnaW5ZOiB2ZXJ0aWNhbCA/IHN0YXJ0UG9zIDogMCxcbiAgICAgIGRpcmVjdGlvbjogZGlmZiA+IDAgPyB2ZXJ0aWNhbCA/IDI3MCA6IDM2MCA6IHZlcnRpY2FsID8gOTAgOiAxODBcbiAgICB9O1xuICAgIHRyaWdnZXIoJ29uR2VzdHVyZVN0YXJ0JywgZXZlbnRPYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxpemUoZGlmZikge1xuICAgIHZhciBpLCB0aW1lLCBuZXdQb3M7IC8vIExpbWl0IHNjcm9sbCB0byBzbmFwIHNpemVcblxuICAgIGlmIChtYXhTbmFwU2Nyb2xsKSB7XG4gICAgICBkaWZmID0gY29uc3RyYWluKGRpZmYsIC1zbmFwICogbWF4U25hcFNjcm9sbCwgc25hcCAqIG1heFNuYXBTY3JvbGwpO1xuICAgIH0gLy8gQ2FsY3VsYXRlIHNuYXAgYW5kIGxpbWl0IGJldHdlZW4gbWluIGFuZCBtYXhcblxuXG4gICAgbmV3UG9zID0gY29uc3RyYWluKE1hdGgucm91bmQoKHN0YXJ0UG9zICsgZGlmZikgLyBzbmFwKSAqIHNuYXAsIG1pblNjcm9sbCwgbWF4U2Nyb2xsKTsgLy8gU25hcCB0byBuZWFyZXN0IGVsZW1lbnRcblxuICAgIGlmIChzbmFwUG9pbnRzKSB7XG4gICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgZm9yIChpID0gc25hcFBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdQb3MpICsgY29udFNpemUgPj0gc25hcFBvaW50c1tpXS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICBjdXJyU25hcCA9IGk7XG4gICAgICAgICAgICBjdXJyU25hcERpciA9IDI7XG4gICAgICAgICAgICBuZXdQb3MgPSBzbmFwUG9pbnRzW2ldLnNuYXAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpZmYgPj0gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc25hcFBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdQb3MpIDw9IHNuYXBQb2ludHNbaV0uYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgY3VyclNuYXAgPSBpO1xuICAgICAgICAgICAgY3VyclNuYXBEaXIgPSAxO1xuICAgICAgICAgICAgbmV3UG9zID0gc25hcFBvaW50c1tpXS5zbmFwMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdQb3MgPSBjb25zdHJhaW4obmV3UG9zLCBtaW5TY3JvbGwsIG1heFNjcm9sbCk7XG4gICAgfVxuXG4gICAgdGltZSA9IHMudGltZSB8fCAoY3VyclBvcyA8IG1pblNjcm9sbCB8fCBjdXJyUG9zID4gbWF4U2Nyb2xsID8gMTAwMCA6IE1hdGgubWF4KDEwMDAsIE1hdGguYWJzKG5ld1BvcyAtIGN1cnJQb3MpICogcy50aW1lVW5pdCkpO1xuICAgIGV2ZW50T2JqLmRlc3RpbmF0aW9uWCA9IHZlcnRpY2FsID8gMCA6IG5ld1BvcztcbiAgICBldmVudE9iai5kZXN0aW5hdGlvblkgPSB2ZXJ0aWNhbCA/IG5ld1BvcyA6IDA7XG4gICAgZXZlbnRPYmouZHVyYXRpb24gPSB0aW1lO1xuICAgIGV2ZW50T2JqLnRyYW5zaXRpb25UaW1pbmcgPSBlYXNpbmc7XG4gICAgdHJpZ2dlcignb25HZXN0dXJlRW5kJywgZXZlbnRPYmopOyAvLyBTY3JvbGwgdG8gdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb25cblxuICAgIHRoYXQuc2Nyb2xsKG5ld1BvcywgdGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGwocG9zLCB0aW1lLCB0YXAsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBlcmNlbnQsXG4gICAgICAgIGNoYW5nZWQgPSBwb3MgIT0gY3VyclBvcyxcbiAgICAgICAgYW5pbSA9IHRpbWUgPiAxLFxuICAgICAgICB0aW1pbmcgPSB0aW1lID8gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSAnICsgTWF0aC5yb3VuZCh0aW1lKSArICdtcyAnICsgZWFzaW5nIDogJycsXG4gICAgICAgIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxUaW1lcik7XG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNUaW1lcik7IC8vcmFmYyhyYWZNb3ZlSUQpO1xuXG4gICAgICBtb3ZpbmcgPSBmYWxzZTtcbiAgICAgIGN1cnJQb3MgPSBwb3M7XG4gICAgICBldmVudE9iai5wb3NYID0gdmVydGljYWwgPyAwIDogcG9zO1xuICAgICAgZXZlbnRPYmoucG9zWSA9IHZlcnRpY2FsID8gcG9zIDogMDtcblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdHJpZ2dlcignb25Nb3ZlJywgZXZlbnRPYmopO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbSkge1xuICAgICAgICAvL3RoYXQuc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgdHJpZ2dlcignb25BbmltYXRpb25FbmQnLCBldmVudE9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudE9iaiA9IHtcbiAgICAgIHBvc1g6IHZlcnRpY2FsID8gMCA6IGN1cnJQb3MsXG4gICAgICBwb3NZOiB2ZXJ0aWNhbCA/IGN1cnJQb3MgOiAwLFxuICAgICAgb3JpZ2luWDogdmVydGljYWwgPyAwIDogc3RhcnRQb3MsXG4gICAgICBvcmlnaW5ZOiB2ZXJ0aWNhbCA/IHN0YXJ0UG9zIDogMCxcbiAgICAgIGRpcmVjdGlvbjogcG9zIC0gY3VyclBvcyA+IDAgPyB2ZXJ0aWNhbCA/IDI3MCA6IDM2MCA6IHZlcnRpY2FsID8gOTAgOiAxODBcbiAgICB9O1xuICAgIGN1cnJQb3MgPSBwb3M7XG5cbiAgICBpZiAoYW5pbSkge1xuICAgICAgZXZlbnRPYmouZGVzdGluYXRpb25YID0gdmVydGljYWwgPyAwIDogcG9zO1xuICAgICAgZXZlbnRPYmouZGVzdGluYXRpb25ZID0gdmVydGljYWwgPyBwb3MgOiAwO1xuICAgICAgZXZlbnRPYmouZHVyYXRpb24gPSB0aW1lO1xuICAgICAgZXZlbnRPYmoudHJhbnNpdGlvblRpbWluZyA9IGVhc2luZztcbiAgICAgIHRyaWdnZXIoJ29uQW5pbWF0aW9uU3RhcnQnLCBldmVudE9iaik7XG4gICAgfVxuXG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNpdGlvbiddID0gdGltaW5nO1xuICAgIHN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zZm9ybSddID0gJ3RyYW5zbGF0ZTNkKCcgKyAodmVydGljYWwgPyAnMCwnICsgcG9zICsgJ3B4LCcgOiBwb3MgKyAncHgsJyArICcwLCcpICsgJzApJztcblxuICAgIGlmIChzY3JvbGxiYXIgJiYgc2Nyb2xsYmFySGVpZ2h0KSB7XG4gICAgICBwZXJjZW50ID0gaXNJbmZpbml0ZSA/IChzY3JvbGxiYXJPZmZzZXQgLSBwb3MpIC8gKG1heFNuYXBTY3JvbGwgKiBzbmFwICogMikgOiAocG9zIC0gbWF4U2Nyb2xsKSAvIChtaW5TY3JvbGwgLSBtYXhTY3JvbGwpO1xuICAgICAgc2Nyb2xsYmFyLnN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9IHRpbWluZztcbiAgICAgIHNjcm9sbGJhci5zdHlsZVtqc1ByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzZCgwLCcgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigoY29udFNpemUgLSBzY3JvbGxiYXJIZWlnaHQpICogcGVyY2VudCwgY29udFNpemUgLSBzY3JvbGxiYXJIZWlnaHQpKSArICdweCwwKSc7XG4gICAgfVxuXG4gICAgaWYgKCFjaGFuZ2VkICYmICFtb3ZpbmcgfHwgIXRpbWUgfHwgdGltZSA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfSBlbHNlIGlmICh0aW1lKSB7XG4gICAgICBtb3ZpbmcgPSAhdGFwO1xuICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxUaW1lcik7XG4gICAgICBzY3JvbGxUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9yYWZNb3ZlSUQgPSByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9ICtnZXRQb3NpdGlvbih0YXJnZXQsIHZlcnRpY2FsKSB8fCAwO1xuICAgICAgICBldmVudE9iai5wb3NYID0gdmVydGljYWwgPyAwIDogcDtcbiAgICAgICAgZXZlbnRPYmoucG9zWSA9IHZlcnRpY2FsID8gcCA6IDA7XG4gICAgICAgIHRyaWdnZXIoJ29uTW92ZScsIGV2ZW50T2JqKTsgLy8gVHJpZ2dlciBkb25lIGlmIGNsb3NlIHRvIHRoZSBlbmRcblxuICAgICAgICBpZiAoTWF0aC5hYnMocCAtIHBvcykgPCAyKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9IC8vfSk7XG5cbiAgICAgIH0sIDEwMCk7XG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNUaW1lcik7XG4gICAgICB0cmFuc1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKTsgLy9zdHlsZVtwciArICdUcmFuc2l0aW9uJ10gPSAnJztcbiAgICAgIH0sIHRpbWUpOyAvLyB0YXJnZXQub2ZmKHRyYW5zRW5kKS5vbih0cmFuc0VuZCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vICAgICBpZiAoZS50YXJnZXQgPT09IHRhcmdldFswXSkge1xuICAgICAgLy8gICAgICAgICB0YXJnZXQub2ZmKHRyYW5zRW5kKTtcbiAgICAgIC8vICAgICAgICAgc3R5bGVbcHIgKyAnVHJhbnNpdGlvbiddID0gJyc7XG4gICAgICAvLyAgICAgICAgIGRvbmUoKTtcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyB9KTtcbiAgICB9XG5cbiAgICBpZiAocy5zeW5jKSB7XG4gICAgICBzLnN5bmMocG9zLCB0aW1lLCBlYXNpbmcpO1xuICAgIH1cbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuICB0aGF0LnNjcm9sbGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGVsZW1lbnRcbiAgICovXG5cbiAgdGhhdC5zY3JvbGwgPSBmdW5jdGlvbiAocG9zLCB0aW1lLCB0YXAsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgcG9zaXRpb24gaXMgbm90IG51bWVyaWMsIHNjcm9sbCB0byBlbGVtZW50XG4gICAgaWYgKCFpc051bWVyaWMocG9zKSkge1xuICAgICAgcG9zID0gTWF0aC5jZWlsKCgkJDEocG9zLCBlbCkubGVuZ3RoID8gTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0KClbZGlyXSAtICQkMShwb3MsIGVsKS5vZmZzZXQoKVtkaXJdKSA6IGN1cnJQb3MpIC8gc25hcCkgKiBzbmFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBNYXRoLnJvdW5kKHBvcyAvIHNuYXApICogc25hcDtcbiAgICB9XG5cbiAgICBwb3MgPSBjb25zdHJhaW4ocG9zLCBtaW5TY3JvbGwsIG1heFNjcm9sbCk7XG4gICAgY3VyclNuYXAgPSBNYXRoLnJvdW5kKHBvcyAvIHNuYXApO1xuICAgIHN0YXJ0UG9zID0gY3VyclBvcztcbiAgICBzY3JvbGxiYXJPZmZzZXQgPSBtYXhTbmFwU2Nyb2xsICogc25hcCArIHBvcztcbiAgICBzY3JvbGwocG9zLCB0aW1lLCB0YXAsIGNhbGxiYWNrKTtcbiAgfTtcblxuICB0aGF0LnJlZnJlc2ggPSBmdW5jdGlvbiAobm9TY3JvbGwpIHtcbiAgICB2YXIgdGVtcFNjcm9sbDtcbiAgICBjb250U2l6ZSA9IChzLmNvbnRTaXplID09PSB1bmRlZmluZWQgPyB2ZXJ0aWNhbCA/ICRlbG0uaGVpZ2h0KCkgOiAkZWxtLndpZHRoKCkgOiBzLmNvbnRTaXplKSB8fCAwO1xuICAgIG1heFNjcm9sbCA9IChzLm1heFNjcm9sbCA9PT0gdW5kZWZpbmVkID8gMCA6IHMubWF4U2Nyb2xsKSB8fCAwO1xuICAgIG1pblNjcm9sbCA9IE1hdGgubWluKG1heFNjcm9sbCwgcy5taW5TY3JvbGwgPT09IHVuZGVmaW5lZCA/IE1hdGgubWluKDAsIHZlcnRpY2FsID8gY29udFNpemUgLSB0YXJnZXQuaGVpZ2h0KCkgOiBjb250U2l6ZSAtIHRhcmdldC53aWR0aCgpKSA6IHMubWluU2Nyb2xsKSB8fCAwO1xuICAgIHNuYXBQb2ludHMgPSBudWxsO1xuXG4gICAgaWYgKCF2ZXJ0aWNhbCAmJiBzLnJ0bCkge1xuICAgICAgdGVtcFNjcm9sbCA9IG1heFNjcm9sbDtcbiAgICAgIG1heFNjcm9sbCA9IC1taW5TY3JvbGw7XG4gICAgICBtaW5TY3JvbGwgPSAtdGVtcFNjcm9sbDtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcocy5zbmFwKSkge1xuICAgICAgc25hcFBvaW50cyA9IFtdO1xuICAgICAgdGFyZ2V0LmZpbmQocy5zbmFwKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHZlcnRpY2FsID8gdGhpcy5vZmZzZXRUb3AgOiB0aGlzLm9mZnNldExlZnQsXG4gICAgICAgICAgICBzaXplID0gdmVydGljYWwgPyB0aGlzLm9mZnNldEhlaWdodCA6IHRoaXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgYnJlYWtwb2ludDogb2Zmc2V0ICsgc2l6ZSAvIDIsXG4gICAgICAgICAgc25hcDE6IC1vZmZzZXQsXG4gICAgICAgICAgc25hcDI6IGNvbnRTaXplIC0gb2Zmc2V0IC0gc2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNuYXAgPSBpc051bWVyaWMocy5zbmFwKSA/IHMuc25hcCA6IDE7XG4gICAgbWF4U25hcFNjcm9sbCA9IHMuc25hcCA/IHMubWF4U25hcFNjcm9sbCA6IDA7XG4gICAgZWFzaW5nID0gcy5lYXNpbmc7XG4gICAgZWxhc3RpYyA9IHMuZWxhc3RpYyA/IGlzTnVtZXJpYyhzLnNuYXApID8gc25hcCA6IGlzTnVtZXJpYyhzLmVsYXN0aWMpID8gcy5lbGFzdGljIDogMCA6IDA7IC8vICYmIHMuc25hcCA/IHNuYXAgOiAwO1xuXG4gICAgc2Nyb2xsU25hcCA9IHNuYXA7XG5cbiAgICB3aGlsZSAoc2Nyb2xsU25hcCA+IDQ0KSB7XG4gICAgICBzY3JvbGxTbmFwIC89IDI7XG4gICAgfVxuXG4gICAgc2Nyb2xsU25hcCA9IE1hdGgucm91bmQoNDQgLyBzY3JvbGxTbmFwKSAqIHNjcm9sbFNuYXA7XG5cbiAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICBpc0luZmluaXRlID0gbWluU2Nyb2xsID09IC1JbmZpbml0eSB8fCBtYXhTY3JvbGwgPT0gSW5maW5pdHk7XG4gICAgICBzY3JvbGxiYXJIZWlnaHQgPSBtaW5TY3JvbGwgPCBtYXhTY3JvbGwgPyBNYXRoLm1heCgyMCwgY29udFNpemUgKiBjb250U2l6ZSAvIChtYXhTY3JvbGwgLSBtaW5TY3JvbGwgKyBjb250U2l6ZSkpIDogMDtcbiAgICAgIHNjcm9sbGJhci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxiYXJIZWlnaHQgKyAncHgnO1xuICAgICAgc2Nyb2xsYmFyVHJhY2suc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsYmFySGVpZ2h0ID8gJycgOiAwO1xuICAgIH1cblxuICAgIGlmIChjdXJyUG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJQb3MgPSBzLmluaXRpYWxQb3M7XG4gICAgICBjdXJyU25hcCA9IE1hdGgucm91bmQoY3VyclBvcyAvIHNuYXApO1xuICAgIH1cblxuICAgIGlmICghbm9TY3JvbGwpIHtcbiAgICAgIHRoYXQuc2Nyb2xsKHMuc25hcCA/IHNuYXBQb2ludHMgJiYgc25hcFBvaW50c1tjdXJyU25hcF0gPyBzbmFwUG9pbnRzW2N1cnJTbmFwXVsnc25hcCcgKyBjdXJyU25hcERpcl0gOiBjdXJyU25hcCAqIHNuYXAgOiBjdXJyUG9zKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fcHJvY2Vzc1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHZlcnRpY2FsID0gcy5heGlzID09ICdZJztcbiAgICBkaXIgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIHRhcmdldCA9IHMubW92ZUVsZW1lbnQgfHwgJGVsbS5jaGlsZHJlbigpLmVxKDApO1xuICAgIHN0eWxlID0gdGFyZ2V0WzBdLnN0eWxlO1xuICAgIHRocmVzaG9sZCA9IHZlcnRpY2FsID8gcy50aHJlc2hvbGRZIDogcy50aHJlc2hvbGRYO1xuXG4gICAgaWYgKHMuc2Nyb2xsYmFyKSB7XG4gICAgICAkc2Nyb2xsYmFyVHJhY2sgPSBzLnNjcm9sbGJhcjtcbiAgICAgICRzY3JvbGxiYXIgPSAkc2Nyb2xsYmFyVHJhY2suZmluZCgnLm1ic2Mtc2MtYmFyJyk7XG4gICAgICBzY3JvbGxiYXIgPSAkc2Nyb2xsYmFyWzBdO1xuICAgICAgc2Nyb2xsYmFyVHJhY2sgPSAkc2Nyb2xsYmFyVHJhY2tbMF07XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5yZWZyZXNoKCk7XG4gICAgbGlzdGVuKGVsLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgbGlzdGVuKGVsLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZWwsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICBsaXN0ZW4oZWwsICd0b3VjaGNhbmNlbCcsIG9uRW5kKTtcbiAgICBsaXN0ZW4oZWwsICdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChzLm1vdXNld2hlZWwpIHtcbiAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ3doZWVsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGRvY3VtZW50LCAnbW91c2V3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICAkc2Nyb2xsYmFyVHJhY2sub24oJ21vdXNlZG93bicsIG9uU2Nyb2xsQmFyU3RhcnQpLm9uKCdjbGljaycsIG9uU2Nyb2xsQmFyQ2xpY2spO1xuICAgIH0gLy9lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldikge1xuICAgIC8vICAgIGlmIChzY3JvbGxlZCkge1xuICAgIC8vICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyAgICB9XG4gICAgLy99LCB0cnVlKTtcblxuICB9O1xuICAvKipcbiAgICogRGVzdHJveVxuICAgKi9cblxuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChzY3JvbGxUaW1lcik7XG4gICAgdW5saXN0ZW4oZWwsICdtb3VzZWRvd24nLCBvblN0YXJ0KTtcbiAgICB1bmxpc3RlbihlbCwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgdW5saXN0ZW4oZWwsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICB1bmxpc3RlbihlbCwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgIHVubGlzdGVuKGVsLCAnY2xpY2snLCBvbkNsaWNrLCB0cnVlKTtcbiAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3doZWVsJywgb25TY3JvbGwsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIHVubGlzdGVuKGRvY3VtZW50LCAnbW91c2V3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChzY3JvbGxiYXIpIHtcbiAgICAgICRzY3JvbGxiYXJUcmFjay5vZmYoJ21vdXNlZG93bicsIG9uU2Nyb2xsQmFyU3RhcnQpLm9mZignY2xpY2snLCBvblNjcm9sbEJhckNsaWNrKTtcbiAgICB9XG4gIH07IC8vIENvbnN0cnVjdG9yXG5cblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTtcblNjcm9sbFZpZXdCYXNlLnByb3RvdHlwZSA9IHtcbiAgX2RlZmF1bHRzOiB7XG4gICAgc3BlZWRVbml0OiAwLjAwMjIsXG4gICAgLy90aW1lVW5pdDogMC44LFxuICAgIHRpbWVVbml0OiAzLFxuICAgIGluaXRpYWxQb3M6IDAsXG4gICAgYXhpczogJ1knLFxuICAgIHRocmVzaG9sZFg6IDEwLFxuICAgIHRocmVzaG9sZFk6IDUsXG4gICAgLy9lYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAuMTkwLCAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gICAgc3RvcFByb3A6IHRydWUsXG4gICAgbW9tZW50dW06IHRydWUsXG4gICAgbW91c2V3aGVlbDogdHJ1ZSxcbiAgICBlbGFzdGljOiB0cnVlXG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIHByZXNldHMgPSB7fSxcbiAgICBjc3MgPSBpc0Jyb3dzZXIgPyB3aW5kb3cuQ1NTIDogbnVsbCxcbiAgICBoYXMzZCA9IGNzcyAmJiBjc3Muc3VwcG9ydHMgJiYgY3NzLnN1cHBvcnRzKFwiKHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2QpXCIpO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZShzdHIpIHtcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvXCIvZywgJ19fXycpO1xufVxudmFyIFNjcm9sbGVyID0gZnVuY3Rpb24gU2Nyb2xsZXIoZWwsIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkbWFya3VwLFxuICAgICAgYmF0Y2hTaXplM2QsXG4gICAgICBiYXRjaFNpemUgPSA0MCxcbiAgICAgIGFuaW1UaW1lID0gMTAwMCxcbiAgICAgIHNjcm9sbDNkQW5nbGUsXG4gICAgICBzY3JvbGwzZCxcbiAgICAgIHNlbGVjdGVkQ2xhc3MsXG4gICAgICBzaG93U2Nyb2xsQXJyb3dzLFxuICAgICAgc3RlcHBlcixcbiAgICAgIHRlbXBXaGVlbEFycmF5LFxuICAgICAgaXRlbUhlaWdodCxcbiAgICAgIGl0ZW1IZWlnaHQzZCxcbiAgICAgIGlzUG9pbnRlcixcbiAgICAgIGlzVmFsaWRhdGluZyxcbiAgICAgIHMsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgbGluZXMsXG4gICAgICB3aGVlbHMsXG4gICAgICB3aGVlbHNNYXAsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWwpOyAvLyBFdmVudCBoYW5kbGVyc1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldikge1xuICAgIHZhciBpID0gKyQkMSh0aGlzKS5hdHRyKCdkYXRhLWluZGV4JyksXG4gICAgICAgIGhhbmRsZSxcbiAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGV2LmtleUNvZGUgPT0gMzgpIHtcbiAgICAgIC8vIFVwXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDQwKSB7XG4gICAgICAvLyBEb3duXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgIC8vIFNwYWNlXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgb25JdGVtVGFwKGksICQkMShldi50YXJnZXQpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgc3RlcHBlci5zdGFydChpLCBkaXJlY3Rpb24sIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVVwKCkge1xuICAgIHN0ZXBwZXIuc3RvcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25JdGVtVGFwKGksICRpdGVtKSB7XG4gICAgdmFyIHdoZWVsID0gd2hlZWxzW2ldLFxuICAgICAgICBpZHggPSArJGl0ZW0uYXR0cignZGF0YS1pbmRleCcpLFxuICAgICAgICB2YWwgPSBnZXRWYWx1ZSh3aGVlbCwgaWR4KSxcbiAgICAgICAgc2VsZWN0ZWQgPSB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0sXG4gICAgICAgIG1heFNlbGVjdCA9IGlzTnVtZXJpYyh3aGVlbC5tdWx0aXBsZSkgPyB3aGVlbC5tdWx0aXBsZSA6IEluZmluaXR5O1xuXG4gICAgaWYgKHRyaWdnZXIoJ29uSXRlbVRhcCcsIHtcbiAgICAgIHRhcmdldDogJGl0ZW1bMF0sXG4gICAgICBpbmRleDogaSxcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBzZWxlY3RlZDogJGl0ZW0uaGFzQ2xhc3MoJ21ic2Mtc2MtaXRtLXNlbCcpXG4gICAgfSkgIT09IGZhbHNlICYmICF0aGF0Ll9wcmV2SXRlbVRhcCkge1xuICAgICAgLy8gU2VsZWN0IGl0ZW0gb24gdGFwXG4gICAgICBpZiAod2hlZWwubXVsdGlwbGUgJiYgIXdoZWVsLl9kaXNhYmxlZFt2YWxdKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZFt2YWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaXRlbS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgZGVsZXRlIHNlbGVjdGVkW3ZhbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1heFNlbGVjdCA9PSAxKSB7XG4gICAgICAgICAgICB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0gPSBzZWxlY3RlZCA9IHt9O1xuXG4gICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG0tc2VsJykucmVtb3ZlQ2xhc3Moc2VsZWN0ZWRDbGFzcykucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkKS5sZW5ndGggPCBtYXhTZWxlY3QpIHtcbiAgICAgICAgICAgICRpdGVtLmFkZENsYXNzKHNlbGVjdGVkQ2xhc3MpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgc2VsZWN0ZWRbdmFsXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0V2hlZWxWYWx1ZSh3aGVlbCwgaSwgaWR4LCBhbmltVGltZSwgd2hlZWwuX2luZGV4IDwgaWR4ID8gMSA6IDIsIHRydWUsIHdoZWVsLm11bHRpcGxlKTtcblxuICAgICAgaWYgKHRoYXQubGl2ZSAmJiAoIXdoZWVsLm11bHRpcGxlIHx8IHdoZWVsLm11bHRpcGxlID09PSAxICYmIHMudGFwU2VsZWN0KSAmJiAocy5zZXRPblRhcCA9PT0gdHJ1ZSB8fCBzLnNldE9uVGFwW2ldKSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdCgpO1xuICAgICAgICB9LCBzLnRhcFNlbGVjdCA/IDAgOiAyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQuX3ByZXZJdGVtVGFwID0gZmFsc2U7XG4gIH0gLy8gUHJpdmF0ZSBmdW5jdGlvbnNcblxuXG4gIGZ1bmN0aW9uIHNob3VsZFNldChpLCBub3Njcm9sbCkge1xuICAgIHZhciB3aGVlbCA9IHdoZWVsc1tpXTtcbiAgICByZXR1cm4gd2hlZWwgJiYgKCF3aGVlbC5tdWx0aXBsZSB8fCB3aGVlbC5tdWx0aXBsZSAhPT0gMSAmJiBub3Njcm9sbCAmJiAocy5zZXRPblRhcCA9PT0gdHJ1ZSB8fCBzLnNldE9uVGFwW2ldKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW4od2hlZWwpIHtcbiAgICByZXR1cm4gLSh3aGVlbC5tYXggLSB3aGVlbC5fb2Zmc2V0IC0gKHdoZWVsLm11bHRpcGxlICYmICFzY3JvbGwzZCA/IE1hdGguZmxvb3Iocy5yb3dzIC8gMikgOiAwKSkgKiBpdGVtSGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF4KHdoZWVsKSB7XG4gICAgcmV0dXJuIC0od2hlZWwubWluIC0gd2hlZWwuX29mZnNldCArICh3aGVlbC5tdWx0aXBsZSAmJiAhc2Nyb2xsM2QgPyBNYXRoLmZsb29yKHMucm93cyAvIDIpIDogMCkpICogaXRlbUhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4KHdoZWVsLCB2YWwpIHtcbiAgICByZXR1cm4gKHdoZWVsLl9hcnJheSA/IHdoZWVsLl9tYXBbdmFsXSA6ICt3aGVlbC5nZXRJbmRleCh2YWwsIHRoYXQpKSB8fCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlbSh3aGVlbCwgaSkge1xuICAgIHZhciBkYXRhID0gd2hlZWwuZGF0YTtcblxuICAgIGlmIChpID49IHdoZWVsLm1pbiAmJiBpIDw9IHdoZWVsLm1heCkge1xuICAgICAgcmV0dXJuIHdoZWVsLl9hcnJheSA/IHdoZWVsLmNpcmN1bGFyID8gJCQxKGRhdGEpLmdldChpICUgd2hlZWwuX2xlbmd0aCkgOiBkYXRhW2ldIDogJCQxLmlzRnVuY3Rpb24oZGF0YSkgPyBkYXRhKGksIHRoYXQpIDogJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlbVZhbHVlKGl0ZW0pIHtcbiAgICByZXR1cm4gJCQxLmlzUGxhaW5PYmplY3QoaXRlbSkgPyBpdGVtLnZhbHVlICE9PSB1bmRlZmluZWQgPyBpdGVtLnZhbHVlIDogaXRlbS5kaXNwbGF5IDogaXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZW1UZXh0KGl0ZW0pIHtcbiAgICB2YXIgdGV4dCA9ICQkMS5pc1BsYWluT2JqZWN0KGl0ZW0pID8gaXRlbS5kaXNwbGF5IDogaXRlbTtcbiAgICByZXR1cm4gdGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiB0ZXh0ICsgdGhhdC5fZ2V0VGV4dChtb2Jpc2Nyb2xsLCAwLjIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUod2hlZWwsIGkpIHtcbiAgICByZXR1cm4gZ2V0SXRlbVZhbHVlKGdldEl0ZW0od2hlZWwsIGkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAoaW5kZXgsIGRpcmVjdGlvbiwgZXYpIHtcbiAgICB2YXIgd2hlZWwgPSB3aGVlbHNbaW5kZXhdO1xuICAgIHNldFdoZWVsVmFsdWUod2hlZWwsIGluZGV4LCB3aGVlbC5faW5kZXggKyBkaXJlY3Rpb24sIHMuZGVsYXkgKyAxMDAsIGRpcmVjdGlvbiA9PSAxID8gMSA6IDIsIGZhbHNlLCBmYWxzZSwgZXYudHlwZSA9PSAna2V5ZG93bicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWFkT25seShpKSB7XG4gICAgcmV0dXJuICQkMS5pc0FycmF5KHMucmVhZG9ubHkpID8gcy5yZWFkb25seVtpXSA6IHMucmVhZG9ubHk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0V2hlZWwod3csIGwsIGtlZXApIHtcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSB3aGVlbCwgaW4gY2FzZSBpZiBzYW1lIG9wdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgbXVsdGlwbGUgc2Nyb2xsZXIgaW5zdGFuY2VzXG4gICAgdmFyIHcgPSBleHRlbmQkMSh3aGVlbHNbbF0gfHwge30sIHd3KTtcbiAgICB2YXIgaW5kZXggPSB3Ll9pbmRleCAtIHcuX2JhdGNoO1xuICAgIHcuZGF0YSA9IHcuZGF0YSB8fCBbXTtcbiAgICB3LmtleSA9IHcua2V5ICE9PSB1bmRlZmluZWQgPyB3LmtleSA6IGw7XG4gICAgdy5sYWJlbCA9IHcubGFiZWwgIT09IHVuZGVmaW5lZCA/IHcubGFiZWwgOiBsO1xuICAgIHcuX21hcCA9IHt9O1xuICAgIHcuX2FycmF5ID0gJCQxLmlzQXJyYXkody5kYXRhKTsgLy8gTWFwIGtleXMgdG8gaW5kZXhcblxuICAgIGlmICh3Ll9hcnJheSkge1xuICAgICAgdy5fbGVuZ3RoID0gdy5kYXRhLmxlbmd0aDtcbiAgICAgICQkMS5lYWNoKHcuZGF0YSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgdy5fbWFwW2dldEl0ZW1WYWx1ZSh2KV0gPSBpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdy5jaXJjdWxhciA9IHMuY2lyY3VsYXIgPT09IHVuZGVmaW5lZCA/IHcuY2lyY3VsYXIgPT09IHVuZGVmaW5lZCA/IHcuX2FycmF5ICYmIHcuX2xlbmd0aCA+IHMucm93cyA6IHcuY2lyY3VsYXIgOiAkJDEuaXNBcnJheShzLmNpcmN1bGFyKSA/IHMuY2lyY3VsYXJbbF0gOiBzLmNpcmN1bGFyO1xuICAgIHcubWluID0gdy5fYXJyYXkgPyB3LmNpcmN1bGFyID8gLUluZmluaXR5IDogMCA6IHcubWluID09PSB1bmRlZmluZWQgPyAtSW5maW5pdHkgOiB3Lm1pbjtcbiAgICB3Lm1heCA9IHcuX2FycmF5ID8gdy5jaXJjdWxhciA/IEluZmluaXR5IDogdy5fbGVuZ3RoIC0gMSA6IHcubWF4ID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHcubWF4O1xuICAgIHcuX25yID0gbDtcbiAgICB3Ll9pbmRleCA9IGdldEluZGV4KHcsIHRlbXBXaGVlbEFycmF5W2xdKTtcbiAgICB3Ll9kaXNhYmxlZCA9IHt9O1xuICAgIHcuX2JhdGNoID0gMDtcbiAgICB3Ll9jdXJyZW50ID0gdy5faW5kZXg7XG4gICAgdy5fZmlyc3QgPSB3Ll9pbmRleCAtIGJhdGNoU2l6ZTsgLy9NYXRoLm1heCh3Lm1pbiwgdy5fY3VycmVudCAtIGJhdGNoU2l6ZSk7XG5cbiAgICB3Ll9sYXN0ID0gdy5faW5kZXggKyBiYXRjaFNpemU7IC8vTWF0aC5taW4ody5tYXgsIHcuX2ZpcnN0ICsgMiAqIGJhdGNoU2l6ZSk7XG5cbiAgICB3Ll9vZmZzZXQgPSB3Ll9maXJzdDtcblxuICAgIGlmIChrZWVwKSB7XG4gICAgICB3Ll9vZmZzZXQgLT0gdy5fbWFyZ2luIC8gaXRlbUhlaWdodCArICh3Ll9pbmRleCAtIGluZGV4KTtcbiAgICAgIHcuX21hcmdpbiArPSAody5faW5kZXggLSBpbmRleCkgKiBpdGVtSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3Ll9tYXJnaW4gPSAwOyAvL3cuX2ZpcnN0ICogaXRlbUhlaWdodDtcbiAgICB9XG5cbiAgICB3Ll9yZWZyZXNoID0gZnVuY3Rpb24gKG5vU2Nyb2xsKSB7XG4gICAgICBleHRlbmQkMSh3Ll9zY3JvbGxlci5zZXR0aW5ncywge1xuICAgICAgICBtaW5TY3JvbGw6IGdldE1pbih3KSxcbiAgICAgICAgbWF4U2Nyb2xsOiBnZXRNYXgodylcbiAgICAgIH0pO1xuXG4gICAgICB3Ll9zY3JvbGxlci5yZWZyZXNoKG5vU2Nyb2xsKTtcbiAgICB9O1xuXG4gICAgd2hlZWxzTWFwW3cua2V5XSA9IHc7XG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUl0ZW1zKHdoZWVsLCBpbmRleCwgc3RhcnQsIGVuZCwgaXMzZCkge1xuICAgIHZhciBpLFxuICAgICAgICBjc3MsXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBsYmwsXG4gICAgICAgIGludmFsaWQsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICBodG1sID0gJycsXG4gICAgICAgIGNoZWNrZWQgPSB0aGF0Ll90ZW1wU2VsZWN0ZWRbaW5kZXhdLFxuICAgICAgICBkaXNhYmxlZCA9IHdoZWVsLl9kaXNhYmxlZCB8fCB7fTtcblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBpdGVtID0gZ2V0SXRlbSh3aGVlbCwgaSk7XG4gICAgICB0ZXh0ID0gZ2V0SXRlbVRleHQoaXRlbSk7XG4gICAgICB2YWx1ZSA9IGdldEl0ZW1WYWx1ZShpdGVtKTtcbiAgICAgIGNzcyA9IGl0ZW0gJiYgaXRlbS5jc3NDbGFzcyAhPT0gdW5kZWZpbmVkID8gaXRlbS5jc3NDbGFzcyA6ICcnO1xuICAgICAgbGJsID0gaXRlbSAmJiBpdGVtLmxhYmVsICE9PSB1bmRlZmluZWQgPyBpdGVtLmxhYmVsIDogJyc7XG4gICAgICBpbnZhbGlkID0gaXRlbSAmJiBpdGVtLmludmFsaWQ7XG4gICAgICBzZWxlY3RlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT0gdGVtcFdoZWVsQXJyYXlbaW5kZXhdICYmICF3aGVlbC5tdWx0aXBsZTsgLy8gVE9ETzogZG9uJ3QgZ2VuZXJhdGUgaXRlbXMgd2l0aCBubyB2YWx1ZSAodXNlIG1hcmdpbiBvciBwbGFjZWhvbGRlciBpbnN0ZWFkKVxuXG4gICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJvcHRpb25cIiB0YWJpbmRleD1cIi0xXCIgYXJpYS1zZWxlY3RlZD1cIicgKyAoY2hlY2tlZFt2YWx1ZV0gPyB0cnVlIDogZmFsc2UpICsgJ1wiIGNsYXNzPVwibWJzYy1zYy1pdG0gJyArIChpczNkID8gJ21ic2Mtc2MtaXRtLTNkICcgOiAnJykgKyBjc3MgKyAnICcgKyAoc2VsZWN0ZWQgPyAnbWJzYy1zYy1pdG0tc2VsICcgOiAnJykgKyAoY2hlY2tlZFt2YWx1ZV0gPyBzZWxlY3RlZENsYXNzIDogJycpICsgKHZhbHVlID09PSB1bmRlZmluZWQgPyAnIG1ic2Mtc2MtaXRtLXBoJyA6ICcgbWJzYy1idG4tZScpICsgKGludmFsaWQgPyAnIG1ic2Mtc2MtaXRtLWludi1oIG1ic2MtZGlzYWJsZWQnIDogJycpICsgKGRpc2FibGVkW3ZhbHVlXSA/ICcgbWJzYy1zYy1pdG0taW52IG1ic2MtZGlzYWJsZWQnIDogJycpICsgJ1wiIGRhdGEtaW5kZXg9XCInICsgaSArICdcIiBkYXRhLXZhbD1cIicgKyBzYW5pdGl6ZSh2YWx1ZSkgKyAnXCInICsgKGxibCA/ICcgYXJpYS1sYWJlbD1cIicgKyBsYmwgKyAnXCInIDogJycpICsgKHNlbGVjdGVkID8gJyBhcmlhLXNlbGVjdGVkPVwidHJ1ZVwiJyA6ICcnKSArICcgc3R5bGU9XCJoZWlnaHQ6JyArIGl0ZW1IZWlnaHQgKyAncHg7bGluZS1oZWlnaHQ6JyArIGl0ZW1IZWlnaHQgKyAncHg7JyArIChpczNkID8gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybTpyb3RhdGVYKCcgKyAod2hlZWwuX29mZnNldCAtIGkpICogc2Nyb2xsM2RBbmdsZSAlIDM2MCArICdkZWcpIHRyYW5zbGF0ZVooJyArIGl0ZW1IZWlnaHQgKiBzLnJvd3MgLyAyICsgJ3B4KTsnIDogJycpICsgJ1wiPicgKyAobGluZXMgPiAxID8gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWl0bS1tbFwiIHN0eWxlPVwibGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoaXRlbUhlaWdodCAvIGxpbmVzKSArICdweDtmb250LXNpemU6JyArIE1hdGgucm91bmQoaXRlbUhlaWdodCAvIGxpbmVzICogMC44KSArICdweDtcIj4nIDogJycpICsgdGV4dCArIChsaW5lcyA+IDEgPyAnPC9kaXY+JyA6ICcnKSArICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5maW5pdGUod2hlZWwsIGksIHBvcykge1xuICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoLXBvcyAvIGl0ZW1IZWlnaHQpICsgd2hlZWwuX29mZnNldCxcbiAgICAgICAgZGlmZiA9IGluZGV4IC0gd2hlZWwuX2N1cnJlbnQsXG4gICAgICAgIGZpcnN0ID0gd2hlZWwuX2ZpcnN0LFxuICAgICAgICBsYXN0ID0gd2hlZWwuX2xhc3QsXG4gICAgICAgIGZpcnN0M2QgPSBmaXJzdCArIGJhdGNoU2l6ZSAtIGJhdGNoU2l6ZTNkICsgMSxcbiAgICAgICAgbGFzdDNkID0gbGFzdCAtIGJhdGNoU2l6ZSArIGJhdGNoU2l6ZTNkO1xuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHdoZWVsLl9maXJzdCArPSBkaWZmO1xuICAgICAgd2hlZWwuX2xhc3QgKz0gZGlmZjtcbiAgICAgIHdoZWVsLl9jdXJyZW50ID0gaW5kZXg7IC8vIEdlbmVyYXRlIGl0ZW1zXG4gICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgd2hlZWwuXyRzY3JvbGxlci5hcHBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgTWF0aC5tYXgobGFzdCArIDEsIGZpcnN0ICsgZGlmZiksIGxhc3QgKyBkaWZmKSk7XG5cbiAgICAgICAgJCQxKCcubWJzYy1zYy1pdG0nLCB3aGVlbC5fJHNjcm9sbGVyKS5zbGljZSgwLCBNYXRoLm1pbihkaWZmLCBsYXN0IC0gZmlyc3QgKyAxKSkucmVtb3ZlKCk7IC8vIDNEXG5cbiAgICAgICAgaWYgKHNjcm9sbDNkKSB7XG4gICAgICAgICAgd2hlZWwuXyQzZC5hcHBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgTWF0aC5tYXgobGFzdDNkICsgMSwgZmlyc3QzZCArIGRpZmYpLCBsYXN0M2QgKyBkaWZmLCB0cnVlKSk7XG5cbiAgICAgICAgICAkJDEoJy5tYnNjLXNjLWl0bScsIHdoZWVsLl8kM2QpLnNsaWNlKDAsIE1hdGgubWluKGRpZmYsIGxhc3QzZCAtIGZpcnN0M2QgKyAxKSkuYXR0cignY2xhc3MnLCAnbWJzYy1zYy1pdG0tZGVsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgd2hlZWwuXyRzY3JvbGxlci5wcmVwZW5kKGdlbmVyYXRlSXRlbXMod2hlZWwsIGksIGZpcnN0ICsgZGlmZiwgTWF0aC5taW4oZmlyc3QgLSAxLCBsYXN0ICsgZGlmZikpKTtcblxuICAgICAgICAkJDEoJy5tYnNjLXNjLWl0bScsIHdoZWVsLl8kc2Nyb2xsZXIpLnNsaWNlKE1hdGgubWF4KGRpZmYsIGZpcnN0IC0gbGFzdCAtIDEpKS5yZW1vdmUoKTsgLy8gM0RcblxuICAgICAgICBpZiAoc2Nyb2xsM2QpIHtcbiAgICAgICAgICB3aGVlbC5fJDNkLnByZXBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgZmlyc3QzZCArIGRpZmYsIE1hdGgubWluKGZpcnN0M2QgLSAxLCBsYXN0M2QgKyBkaWZmKSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgJCQxKCcubWJzYy1zYy1pdG0nLCB3aGVlbC5fJDNkKS5zbGljZShNYXRoLm1heChkaWZmLCBmaXJzdDNkIC0gbGFzdDNkIC0gMSkpLmF0dHIoJ2NsYXNzJywgJ21ic2Mtc2MtaXRtLWRlbCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoZWVsLl9tYXJnaW4gKz0gZGlmZiAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgIHdoZWVsLl8kc2Nyb2xsZXIuY3NzKCdtYXJnaW4tdG9wJywgd2hlZWwuX21hcmdpbiArICdweCcpOyAvL30sIDEwKTtcblxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbGlkKGluZGV4LCB2LCBkaXIsIGRpcykge1xuICAgIHZhciBjb3VudGVyLFxuICAgICAgICB3aGVlbCA9IHdoZWVsc1tpbmRleF0sXG4gICAgICAgIGRpc2FibGVkID0gZGlzIHx8IHdoZWVsLl9kaXNhYmxlZCxcbiAgICAgICAgaWR4ID0gZ2V0SW5kZXgod2hlZWwsIHYpLFxuICAgICAgICB2YWwgPSBnZXRWYWx1ZSh3aGVlbCwgaWR4KSxcbiAgICAgICAgdjEgPSB2YWwsXG4gICAgICAgIHYyID0gdmFsLFxuICAgICAgICBkaXN0MSA9IDAsXG4gICAgICAgIGRpc3QyID0gMDsgLy8gVE9ETzogd2hhdCBpZiBhbGwgaXRlbXMgYXJlIGludmFsaWRcblxuICAgIGlmIChkaXNhYmxlZFt2YWxdID09PSB0cnVlKSB7XG4gICAgICBjb3VudGVyID0gMDtcblxuICAgICAgd2hpbGUgKGlkeCAtIGRpc3QxID49IHdoZWVsLm1pbiAmJiBkaXNhYmxlZFt2MV0gJiYgY291bnRlciA8IDEwMCkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGRpc3QxKys7XG4gICAgICAgIHYxID0gZ2V0VmFsdWUod2hlZWwsIGlkeCAtIGRpc3QxKTtcbiAgICAgIH1cblxuICAgICAgY291bnRlciA9IDA7XG5cbiAgICAgIHdoaWxlIChpZHggKyBkaXN0MiA8IHdoZWVsLm1heCAmJiBkaXNhYmxlZFt2Ml0gJiYgY291bnRlciA8IDEwMCkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGRpc3QyKys7XG4gICAgICAgIHYyID0gZ2V0VmFsdWUod2hlZWwsIGlkeCArIGRpc3QyKTtcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBkaXJlY3Rpb24gKCsvLSBvciBtb3VzZSB3aGVlbCksIHRoZSBkaXN0YW5jZSBkb2VzIG5vdCBjb3VudFxuXG5cbiAgICAgIGlmICgoZGlzdDIgPCBkaXN0MSAmJiBkaXN0MiAmJiBkaXIgIT09IDIgfHwgIWRpc3QxIHx8IGlkeCAtIGRpc3QxIDwgMCB8fCBkaXIgPT0gMSkgJiYgIWRpc2FibGVkW3YyXSkge1xuICAgICAgICB2YWwgPSB2MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHYxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb1Bvcyh0aW1lLCBpbmRleCwgZGlyLCBtYW51YWwsIHRhcCwgbm9zY3JvbGwsIHNob3VsZEZvY3VzKSB7XG4gICAgdmFyIGRpZmYsXG4gICAgICAgIGlkeCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICByZXQsXG4gICAgICAgIGlzVmlzaWJsZSA9IHRoYXQuX2lzVmlzaWJsZTtcbiAgICBpc1ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIHJldCA9IHMudmFsaWRhdGUuY2FsbChlbCwge1xuICAgICAgdmFsdWVzOiB0ZW1wV2hlZWxBcnJheS5zbGljZSgwKSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgfSwgdGhhdCkgfHwge307XG4gICAgaXNWYWxpZGF0aW5nID0gZmFsc2U7XG5cbiAgICBpZiAocmV0LnZhbGlkKSB7XG4gICAgICB0aGF0Ll90ZW1wV2hlZWxBcnJheSA9IHRlbXBXaGVlbEFycmF5ID0gcmV0LnZhbGlkLnNsaWNlKDApO1xuICAgIH1cblxuICAgIGlmICghbm9zY3JvbGwpIHtcbiAgICAgICQkMS5lYWNoKHdoZWVscywgZnVuY3Rpb24gKGksIHdoZWVsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICAvLyBFbmFibGUgYWxsIGl0ZW1zXG4gICAgICAgICAgd2hlZWwuXyRtYXJrdXAuZmluZCgnLm1ic2Mtc2MtaXRtLWludicpLnJlbW92ZUNsYXNzKCdtYnNjLXNjLWl0bS1pbnYgbWJzYy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuX2Rpc2FibGVkID0ge307IC8vIERpc2FibGUgaW52YWxpZCBpdGVtc1xuXG4gICAgICAgIGlmIChyZXQuZGlzYWJsZWQgJiYgcmV0LmRpc2FibGVkW2ldKSB7XG4gICAgICAgICAgJCQxLmVhY2gocmV0LmRpc2FibGVkW2ldLCBmdW5jdGlvbiAoaiwgdikge1xuICAgICAgICAgICAgd2hlZWwuX2Rpc2FibGVkW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS12YWw9XCInICsgc2FuaXRpemUodikgKyAnXCJdJykuYWRkQ2xhc3MoJ21ic2Mtc2MtaXRtLWludiBtYnNjLWRpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gR2V0IGNsb3Nlc3QgdmFsaWQgdmFsdWVcblxuXG4gICAgICAgIHRlbXBXaGVlbEFycmF5W2ldID0gd2hlZWwubXVsdGlwbGUgPyB0ZW1wV2hlZWxBcnJheVtpXSA6IGdldFZhbGlkKGksIHRlbXBXaGVlbEFycmF5W2ldLCBkaXIpO1xuXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoIXdoZWVsLm11bHRpcGxlIHx8IGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdoZWVsLl8kbWFya3VwLmZpbmQoJy5tYnNjLXNjLWl0bS1zZWwnKS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgfSAvLyBHZXQgaW5kZXggb2YgdmFsaWQgdmFsdWVcblxuXG4gICAgICAgICAgaWR4ID0gZ2V0SW5kZXgod2hlZWwsIHRlbXBXaGVlbEFycmF5W2ldKTtcbiAgICAgICAgICBkaWZmID0gaWR4IC0gd2hlZWwuX2luZGV4ICsgd2hlZWwuX2JhdGNoO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMiAqIGJhdGNoU2l6ZSArIDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRpZmYgKyAoMiAqIGJhdGNoU2l6ZSArIDEpICogKGRpZmYgPiAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHdoZWVsLl9vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgd2hlZWwuX21hcmdpbiAtPSBvZmZzZXQgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICB3aGVlbC5fcmVmcmVzaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoZWVsLl9pbmRleCA9IGlkeCArIHdoZWVsLl9iYXRjaDtcblxuICAgICAgICAgIGlmICh3aGVlbC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgLy8gQWRkIHNlbGVjdGVkIHN0eWxpbmcgdG8gc2VsZWN0ZWQgZWxlbWVudHMgaW4gY2FzZSBvZiBtdWx0aXNlbGVjdFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdiBpbiB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS12YWw9XCInICsgc2FuaXRpemUodikgKyAnXCJdJykuYWRkQ2xhc3Moc2VsZWN0ZWRDbGFzcykuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFyayBlbGVtZW50IGFzIGFyaWEgc2VsZWN0ZWRcbiAgICAgICAgICAgIHdoZWVsLl8kbWFya3VwLmZpbmQoJy5tYnNjLXNjLWl0bVtkYXRhLXZhbD1cIicgKyBzYW5pdGl6ZSh0ZW1wV2hlZWxBcnJheVtpXSkgKyAnXCJdJykuYWRkQ2xhc3MoJ21ic2Mtc2MtaXRtLXNlbCcpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3aGVlbC5fJGFjdGl2ZSkge1xuICAgICAgICAgICAgd2hlZWwuXyRhY3RpdmUuYXR0cigndGFiaW5kZXgnLCAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hlZWwuXyRhY3RpdmUgPSB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS1pbmRleD1cIicgKyB3aGVlbC5faW5kZXggKyAnXCJdJykuZXEoc2Nyb2xsM2QgJiYgd2hlZWwubXVsdGlwbGUgPyAxIDogMCkuYXR0cigndGFiaW5kZXgnLCAwKTtcblxuICAgICAgICAgIGlmIChzaG91bGRGb2N1cyAmJiBpbmRleCA9PT0gaSAmJiB3aGVlbC5fJGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLl8kYWN0aXZlWzBdLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIHdoZWVsLl8kc2Nyb2xsZXIucGFyZW50KCkuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgIH0gLy8gU2Nyb2xsIHRvIHZhbGlkIHZhbHVlXG5cblxuICAgICAgICAgIHdoZWVsLl9zY3JvbGxlci5zY3JvbGwoLShpZHggLSB3aGVlbC5fb2Zmc2V0ICsgd2hlZWwuX2JhdGNoKSAqIGl0ZW1IZWlnaHQsIGluZGV4ID09PSBpIHx8IGluZGV4ID09PSB1bmRlZmluZWQgPyB0aW1lIDogYW5pbVRpbWUsIHRhcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyaWdnZXIoJ29uVmFsaWRhdGVkJywge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgdGltZTogdGltZVxuICAgIH0pOyAvLyBHZXQgZm9ybWF0dGVkIHZhbHVlXG5cbiAgICB0aGF0Ll90ZW1wVmFsdWUgPSBzLmZvcm1hdFZhbHVlLmNhbGwoZWwsIHRlbXBXaGVlbEFycmF5LCB0aGF0KTtcblxuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIHRoYXQuX3VwZGF0ZUhlYWRlcigpO1xuICAgIH0gLy8gSWYgaW4gbGl2ZSBtb2RlLCBzZXQgYW5kIGZpbGwgdmFsdWUgb24gZXZlcnkgbW92ZVxuXG5cbiAgICBpZiAodGhhdC5saXZlICYmIHNob3VsZFNldChpbmRleCwgbm9zY3JvbGwpKSB7XG4gICAgICB0aGF0Ll9oYXNWYWx1ZSA9IG1hbnVhbCB8fCB0aGF0Ll9oYXNWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG1hbnVhbCwgbWFudWFsLCAwLCB0cnVlKTtcblxuICAgICAgaWYgKG1hbnVhbCkge1xuICAgICAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYW51YWwpIHtcbiAgICAgIHRyaWdnZXIoJ29uQ2hhbmdlJywge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHZhbHVlVGV4dDogdGhhdC5fdGVtcFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaGVlbFZhbHVlKHdoZWVsLCBpLCBpZHgsIHRpbWUsIGRpciwgdGFwLCBub3Njcm9sbCwgc2hvdWxkRm9jdXMpIHtcbiAgICAvLyBHZXQgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKHdoZWVsLCBpZHgpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBXaGVlbEFycmF5W2ldID0gdmFsdWU7IC8vIEluIGNhc2Ugb2YgY2lyY3VsYXIgd2hlZWxzIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IGJhdGNoXG5cbiAgICAgIHdoZWVsLl9iYXRjaCA9IHdoZWVsLl9hcnJheSA/IE1hdGguZmxvb3IoaWR4IC8gd2hlZWwuX2xlbmd0aCkgKiB3aGVlbC5fbGVuZ3RoIDogMDtcbiAgICAgIHdoZWVsLl9pbmRleCA9IGlkeDtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JvbGxUb1Bvcyh0aW1lLCBpLCBkaXIsIHRydWUsIHRhcCwgbm9zY3JvbGwsIHNob3VsZEZvY3VzKTtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZShmaWxsLCBjaGFuZ2UsIHRpbWUsIG5vc2Nyb2xsLCB0ZW1wKSB7XG4gICAgaWYgKCFub3Njcm9sbCkge1xuICAgICAgc2Nyb2xsVG9Qb3ModGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3RlbXBWYWx1ZSA9IHMuZm9ybWF0VmFsdWUuY2FsbChlbCwgdGhhdC5fdGVtcFdoZWVsQXJyYXksIHRoYXQpO1xuICAgIH1cblxuICAgIGlmICghdGVtcCkge1xuICAgICAgdGhhdC5fd2hlZWxBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBXaGVlbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgc2VsZWN0IHdoZWVsIHRha2UgdGhlIGZpcnN0IHNlbGVjdGVkIHZhbHVlLFxuICAgICAgICB0aGF0Ll93aGVlbEFycmF5W2ldID0gd2hlZWxzW2ldICYmIHdoZWVsc1tpXS5tdWx0aXBsZSA/IE9iamVjdC5rZXlzKHRoYXQuX3RlbXBTZWxlY3RlZFtpXSB8fCB7fSlbMF0gOiB0ZW1wV2hlZWxBcnJheVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5fdmFsdWUgPSB0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6IG51bGw7XG4gICAgICB0aGF0Ll9zZWxlY3RlZCA9IGV4dGVuZCQxKHRydWUsIHt9LCB0aGF0Ll90ZW1wU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBpZiAodGhhdC5faXNJbnB1dCkge1xuICAgICAgICAkZWxtLnZhbCh0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcignb25GaWxsJywge1xuICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX2hhc1ZhbHVlID8gdGhhdC5fdGVtcFZhbHVlIDogJycsXG4gICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICB0aGF0Ll9wcmV2ZW50Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgJGVsbS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBGcmFtZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7IC8vIFB1YmxpYyBmdW5jdGlvbnNcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGVyLlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWwgLSBOZXcgdmFsdWUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpbGw9ZmFsc2VdIC0gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjaGFuZ2U9ZmFsc2VdIC0gVHJpZ2dlciBjaGFuZ2Ugb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RlbXA9ZmFsc2VdIC0gSWYgdHJ1ZSwgdGhlbiBvbmx5IHNldCB0aGUgdGVtcG9yYXJ5IHZhbHVlIChvbmx5IHNjcm9sbCB0aGVyZSBidXQgbm90IHNldCB0aGUgdmFsdWUpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9MF0gLSBBbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuXG4gIHRoYXQuc2V0VmFsID0gdGhhdC5fc2V0VmFsID0gZnVuY3Rpb24gKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wLCB0aW1lKSB7XG4gICAgdGhhdC5faGFzVmFsdWUgPSB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQ7XG4gICAgdGhhdC5fdGVtcFdoZWVsQXJyYXkgPSB0ZW1wV2hlZWxBcnJheSA9ICQkMS5pc0FycmF5KHZhbCkgPyB2YWwuc2xpY2UoMCkgOiBzLnBhcnNlVmFsdWUuY2FsbChlbCwgdmFsLCB0aGF0KSB8fCBbXTtcbiAgICBzZXRWYWx1ZShmaWxsLCBjaGFuZ2UgPT09IHVuZGVmaW5lZCA/IGZpbGwgOiBjaGFuZ2UsIHRpbWUsIGZhbHNlLCB0ZW1wKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKi9cblxuXG4gIHRoYXQuZ2V0VmFsID0gdGhhdC5fZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICB2YXIgdmFsID0gdGhhdC5faGFzVmFsdWUgfHwgdGVtcCA/IHRoYXRbdGVtcCA/ICdfdGVtcFZhbHVlJyA6ICdfdmFsdWUnXSA6IG51bGw7XG4gICAgcmV0dXJuIGlzTnVtZXJpYyh2YWwpID8gK3ZhbCA6IHZhbDtcbiAgfTtcbiAgLypcbiAgICogU2V0cyB0aGUgd2hlZWwgdmFsdWVzIChwYXNzZWQgYXMgYW4gYXJyYXkpLlxuICAgKi9cblxuXG4gIHRoYXQuc2V0QXJyYXlWYWwgPSB0aGF0LnNldFZhbDtcbiAgLypcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0ZWQgd2hlZWwgdmFsdWVzIGFzIGFuIGFycmF5LlxuICAgKi9cblxuICB0aGF0LmdldEFycmF5VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICByZXR1cm4gdGVtcCA/IHRoYXQuX3RlbXBXaGVlbEFycmF5IDogdGhhdC5fd2hlZWxBcnJheTtcbiAgfTtcblxuICB0aGF0LmNoYW5nZVdoZWVsID0gZnVuY3Rpb24gKHdobHMsIHRpbWUsIG1hbnVhbCkge1xuICAgIHZhciBpLCB3LCB3dztcbiAgICAkJDEuZWFjaCh3aGxzLCBmdW5jdGlvbiAoa2V5LCB3aGVlbCkge1xuICAgICAgd3cgPSB3aGVlbHNNYXBba2V5XTsgLy8gQ2hlY2sgaWYgd2hlZWwgZXhpc3RzXG5cbiAgICAgIGlmICh3dykge1xuICAgICAgICBpID0gd3cuX25yO1xuICAgICAgICB3ID0gaW5pdFdoZWVsKHdoZWVsLCBpLCB0cnVlKTtcblxuICAgICAgICBpZiAodGhhdC5faXNWaXNpYmxlKSB7XG4gICAgICAgICAgaWYgKHNjcm9sbDNkKSB7XG4gICAgICAgICAgICB3Ll8kM2QuaHRtbChnZW5lcmF0ZUl0ZW1zKHcsIGksIHcuX2ZpcnN0ICsgYmF0Y2hTaXplIC0gYmF0Y2hTaXplM2QgKyAxLCB3Ll9sYXN0IC0gYmF0Y2hTaXplICsgYmF0Y2hTaXplM2QsIHRydWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Ll8kc2Nyb2xsZXIuaHRtbChnZW5lcmF0ZUl0ZW1zKHcsIGksIHcuX2ZpcnN0LCB3Ll9sYXN0KSkuY3NzKCdtYXJnaW4tdG9wJywgdy5fbWFyZ2luICsgJ3B4Jyk7XG5cbiAgICAgICAgICB3Ll9yZWZyZXNoKGlzVmFsaWRhdGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGF0Ll9pc1Zpc2libGUgJiYgIXRoYXQuX2lzTGlxdWlkICYmICFpc1ZhbGlkYXRpbmcpIHtcbiAgICAgIHRoYXQucG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWRhdGluZykge1xuICAgICAgc2Nyb2xsVG9Qb3ModGltZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG1hbnVhbCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCB2YWxpZCB2YWx1ZS5cbiAgICovXG5cblxuICB0aGF0LmdldFZhbGlkVmFsdWUgPSBnZXRWYWxpZDsgLy8gUHJvdGVjdGVkIG92ZXJyaWRlcyBcblxuICB0aGF0Ll9nZW5lcmF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxibCxcbiAgICAgICAgbWF4UG9wdXBXaWR0aCA9IDAsXG4gICAgICAgIGh0bWwgPSAnJyxcbiAgICAgICAgc3R5bGUgPSBzY3JvbGwzZCA/IGNzc1ByZWZpeCArICd0cmFuc2Zvcm06IHRyYW5zbGF0ZVooJyArIChpdGVtSGVpZ2h0ICogcy5yb3dzIC8gMiArIDMpICsgJ3B4KTsnIDogJycsXG4gICAgICAgIGhpZ2hsaWdodCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1zYy13aGwtbFwiIHN0eWxlPVwiJyArIHN0eWxlICsgJ2hlaWdodDonICsgaXRlbUhlaWdodCArICdweDttYXJnaW4tdG9wOi0nICsgKGl0ZW1IZWlnaHQgLyAyICsgKHMuc2VsZWN0ZWRMaW5lQm9yZGVyIHx8IDApKSArICdweDtcIj48L2Rpdj4nLFxuICAgICAgICBsID0gMDtcbiAgICAkJDEuZWFjaChzLndoZWVscywgZnVuY3Rpb24gKGksIHdnKSB7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy13LXAgbWJzYy1zYy13aGwtZ3ItYycgKyAoc2Nyb2xsM2QgPyAnIG1ic2Mtc2Mtd2hsLWdyLTNkLWMnIDogJycpICsgKHMuc2hvd0xhYmVsID8gJyBtYnNjLXNjLWxibC12JyA6ICcnKSArICdcIj4nICsgaGlnaGxpZ2h0ICsgJzxkaXYgY2xhc3M9XCJtYnNjLXNjLXdobC1ncicgKyAoc2Nyb2xsM2QgPyAnIG1ic2Mtc2Mtd2hsLWdyLTNkJyA6ICcnKSArIChzaG93U2Nyb2xsQXJyb3dzID8gJyBtYnNjLXNjLWNwJyA6ICcnKSArIChzLndpZHRoIHx8IHMubWF4V2lkdGggPyAnXCInIDogJ1wiIHN0eWxlPVwibWF4LXdpZHRoOicgKyBzLm1heFBvcHVwV2lkdGggKyAncHg7XCInKSArICc+JztcbiAgICAgICQkMS5lYWNoKHdnLCBmdW5jdGlvbiAoaiwgd3cpIHtcbiAgICAgICAgLy8gV2hlZWxzXG4gICAgICAgIHRoYXQuX3RlbXBTZWxlY3RlZFtsXSA9IGV4dGVuZCQxKHt9LCB0aGF0Ll9zZWxlY3RlZFtsXSk7IC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGRvbmUgb24gaW5pdGlhbGl6YXRpb24sIG5vdCBvbiBzaG93XG5cbiAgICAgICAgdmFyIHcgPSBpbml0V2hlZWwod3csIGwpO1xuICAgICAgICB2YXIgdG9wTWFyZ2luID0gIWlzUG9pbnRlciB8fCBzLnJvd3MgJSAyID8gaXRlbUhlaWdodDNkIC8gMiA6IDA7XG4gICAgICAgIHdoZWVsc1tsXSA9IHc7XG4gICAgICAgIG1heFBvcHVwV2lkdGggKz0gcy5tYXhXaWR0aCA/IHMubWF4V2lkdGhbbF0gfHwgcy5tYXhXaWR0aCA6IHMud2lkdGggPyBzLndpZHRoW2xdIHx8IHMud2lkdGggOiAwO1xuICAgICAgICBsYmwgPSB3LmxhYmVsICE9PSB1bmRlZmluZWQgPyB3LmxhYmVsIDogajtcbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLXcgJyArICh3LmNzc0NsYXNzIHx8ICcnKSArICh3Lm11bHRpcGxlID8gJyBtYnNjLXNjLXdobC1tdWx0aScgOiAnJykgKyAnXCIgc3R5bGU9XCInICsgKHMud2lkdGggPyAnd2lkdGg6JyArIChzLndpZHRoW2xdIHx8IHMud2lkdGgpICsgJ3B4OycgOiAocy5taW5XaWR0aCA/ICdtaW4td2lkdGg6JyArIChzLm1pbldpZHRoW2xdIHx8IHMubWluV2lkdGgpICsgJ3B4OycgOiAnJykgKyAocy5tYXhXaWR0aCA/ICdtYXgtd2lkdGg6JyArIChzLm1heFdpZHRoW2xdIHx8IHMubWF4V2lkdGgpICsgJ3B4OycgOiAnJykpICsgJ1wiPicgKyAoaXNQb2ludGVyID8gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWJhci1jXCI+PGRpdiBjbGFzcz1cIm1ic2Mtc2MtYmFyXCI+PC9kaXY+PC9kaXY+JyA6ICcnKSArIC8vIFNjcm9sbGJhclxuICAgICAgICAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLW9cIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj48L2Rpdj4nICsgaGlnaGxpZ2h0ICsgJzxkaXYgYXJpYS1saXZlPVwib2ZmXCIgYXJpYS1sYWJlbD1cIicgKyBsYmwgKyAnXCInICsgKHcubXVsdGlwbGUgPyAnIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVwidHJ1ZVwiJyA6ICcnKSArICcgcm9sZT1cImxpc3Rib3hcIiBkYXRhLWluZGV4PVwiJyArIGwgKyAnXCIgY2xhc3M9XCJtYnNjLXNjLXdobFwiJyArICcgc3R5bGU9XCInICsgJ2hlaWdodDonICsgcy5yb3dzICogaXRlbUhlaWdodCAqIChzY3JvbGwzZCA/IDEuMSA6IDEpICsgJ3B4O1wiPicgKyAoc2hvd1Njcm9sbEFycm93cyA/ICc8ZGl2IGRhdGEtaW5kZXg9XCInICsgbCArICdcIiBkYXRhLXN0ZXA9XCIxXCIgY2xhc3M9XCJtYnNjLXNjLWJ0biBtYnNjLXNjLWJ0bi1wbHVzICcgKyAocy5idG5QbHVzQ2xhc3MgfHwgJycpICsgJ1wiPjwvZGl2PicgKyAvLyArIGJ1dHRvblxuICAgICAgICAnPGRpdiBkYXRhLWluZGV4PVwiJyArIGwgKyAnXCIgZGF0YS1zdGVwPVwiLTFcIiBjbGFzcz1cIm1ic2Mtc2MtYnRuIG1ic2Mtc2MtYnRuLW1pbnVzICcgKyAocy5idG5NaW51c0NsYXNzIHx8ICcnKSArICdcIj48L2Rpdj4nIDogJycpICsgLy8gLSBidXR0b25cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWxibFwiPicgKyBsYmwgKyAnPC9kaXY+JyArIC8vIFdoZWVsIGxhYmVsXG4gICAgICAgICc8ZGl2IGNsYXNzPVwibWJzYy1zYy13aGwtY1wiJyArICcgc3R5bGU9XCJoZWlnaHQ6JyArIGl0ZW1IZWlnaHQzZCArICdweDttYXJnaW4tdG9wOi0nICsgKHRvcE1hcmdpbiArIDEpICsgJ3B4OycgKyBzdHlsZSArICdcIj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLXNjLXdobC1zY1wiIHN0eWxlPVwidG9wOicgKyAoaXRlbUhlaWdodDNkIC0gaXRlbUhlaWdodCkgLyAyICsgJ3B4O1wiPic7IC8vIENyZWF0ZSB3aGVlbCB2YWx1ZXNcblxuICAgICAgICBodG1sICs9IGdlbmVyYXRlSXRlbXModywgbCwgdy5fZmlyc3QsIHcuX2xhc3QpICsgJzwvZGl2PjwvZGl2Pic7XG5cbiAgICAgICAgaWYgKHNjcm9sbDNkKSB7XG4gICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLTNkXCIgc3R5bGU9XCJoZWlnaHQ6JyArIGl0ZW1IZWlnaHQgKyAncHg7bWFyZ2luLXRvcDotJyArIGl0ZW1IZWlnaHQgLyAyICsgJ3B4O1wiPic7XG4gICAgICAgICAgaHRtbCArPSBnZW5lcmF0ZUl0ZW1zKHcsIGwsIHcuX2ZpcnN0ICsgYmF0Y2hTaXplIC0gYmF0Y2hTaXplM2QgKyAxLCB3Ll9sYXN0IC0gYmF0Y2hTaXplICsgYmF0Y2hTaXplM2QsIHRydWUpO1xuICAgICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgICBsKys7XG4gICAgICB9KTtcbiAgICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2Pic7XG4gICAgfSk7XG5cbiAgICBpZiAobWF4UG9wdXBXaWR0aCkge1xuICAgICAgcy5tYXhQb3B1cFdpZHRoID0gbWF4UG9wdXBXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcblxuICB0aGF0Ll9hdHRhY2hFdmVudHMgPSBmdW5jdGlvbiAoJG1hcmt1cCkge1xuICAgIHN0ZXBwZXIgPSBjcmVhdGVTdGVwcGVyKCQkMSgnLm1ic2Mtc2MtYnRuJywgJG1hcmt1cCksIHN0ZXAsIHMuZGVsYXksIGlzUmVhZE9ubHksIHRydWUpO1xuICAgICQkMSgnLm1ic2Mtc2Mtd2hsJywgJG1hcmt1cCkub24oJ2tleWRvd24nLCBvbktleURvd24pLm9uKCdrZXl1cCcsIG9uS2V5VXApO1xuICB9O1xuXG4gIHRoYXQuX2RldGFjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RlcHBlcikge1xuICAgICAgc3RlcHBlci5zdG9wKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aGVlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdoZWVsc1tpXS5fc2Nyb2xsZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IGZ1bmN0aW9uICgkbSkge1xuICAgICRtYXJrdXAgPSAkbTtcbiAgICAkJDEoJy5tYnNjLXNjLXdobC13JywgJG1hcmt1cCkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAkd2ggPSAkJDEodGhpcyksXG4gICAgICAgICAgd2hlZWwgPSB3aGVlbHNbaV07XG4gICAgICB3aGVlbC5fJG1hcmt1cCA9ICR3aDtcbiAgICAgIHdoZWVsLl8kc2Nyb2xsZXIgPSAkJDEoJy5tYnNjLXNjLXdobC1zYycsIHRoaXMpO1xuICAgICAgd2hlZWwuXyQzZCA9ICQkMSgnLm1ic2Mtc2Mtd2hsLTNkJywgdGhpcyk7XG4gICAgICB3aGVlbC5fc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsVmlld0Jhc2UodGhpcywge1xuICAgICAgICBtb3VzZXdoZWVsOiBzLm1vdXNld2hlZWwsXG4gICAgICAgIG1vdmVFbGVtZW50OiB3aGVlbC5fJHNjcm9sbGVyLFxuICAgICAgICBzY3JvbGxiYXI6ICQkMSgnLm1ic2Mtc2MtYmFyLWMnLCB0aGlzKSxcbiAgICAgICAgaW5pdGlhbFBvczogKHdoZWVsLl9maXJzdCAtIHdoZWVsLl9pbmRleCkgKiBpdGVtSGVpZ2h0LFxuICAgICAgICBjb250U2l6ZTogcy5yb3dzICogaXRlbUhlaWdodCxcbiAgICAgICAgc25hcDogaXRlbUhlaWdodCxcbiAgICAgICAgbWluU2Nyb2xsOiBnZXRNaW4od2hlZWwpLFxuICAgICAgICBtYXhTY3JvbGw6IGdldE1heCh3aGVlbCksXG4gICAgICAgIG1heFNuYXBTY3JvbGw6IGJhdGNoU2l6ZSxcbiAgICAgICAgcHJldkRlZjogdHJ1ZSxcbiAgICAgICAgc3RvcFByb3A6IHRydWUsXG4gICAgICAgIHRpbWVVbml0OiAzLFxuICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC4xOTAsIDEuMDAwLCAwLjIyMCwgMS4wMDApJyxcbiAgICAgICAgc3luYzogZnVuY3Rpb24gc3luYyhwb3MsIHRpbWUsIGVhc2luZykge1xuICAgICAgICAgIHZhciB0aW1pbmcgPSB0aW1lID8gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSAnICsgTWF0aC5yb3VuZCh0aW1lKSArICdtcyAnICsgZWFzaW5nIDogJyc7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsM2QpIHtcbiAgICAgICAgICAgIHdoZWVsLl8kM2RbMF0uc3R5bGVbanNQcmVmaXggKyAnVHJhbnNpdGlvbiddID0gdGltaW5nO1xuICAgICAgICAgICAgd2hlZWwuXyQzZFswXS5zdHlsZVtqc1ByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICdyb3RhdGVYKCcgKyAtcG9zIC8gaXRlbUhlaWdodCAqIHNjcm9sbDNkQW5nbGUgKyAnZGVnKSc7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGV2LCBpbnN0KSB7XG4gICAgICAgICAgaW5zdC5zZXR0aW5ncy5yZWFkb25seSA9IGlzUmVhZE9ubHkoaSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uR2VzdHVyZVN0YXJ0OiBmdW5jdGlvbiBvbkdlc3R1cmVTdGFydCgpIHtcbiAgICAgICAgICAkd2guYWRkQ2xhc3MoJ21ic2Mtc2Mtd2hsLWEgbWJzYy1zYy13aGwtYW5pbScpO1xuICAgICAgICAgIHRyaWdnZXIoJ29uV2hlZWxHZXN0dXJlU3RhcnQnLCB7XG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkdlc3R1cmVFbmQ6IGZ1bmN0aW9uIG9uR2VzdHVyZUVuZChldikge1xuICAgICAgICAgIHZhciBkaXIgPSBldi5kaXJlY3Rpb24gPT0gOTAgPyAxIDogMixcbiAgICAgICAgICAgICAgdGltZSA9IGV2LmR1cmF0aW9uLFxuICAgICAgICAgICAgICBwb3MgPSBldi5kZXN0aW5hdGlvblk7XG4gICAgICAgICAgaWR4ID0gTWF0aC5yb3VuZCgtcG9zIC8gaXRlbUhlaWdodCkgKyB3aGVlbC5fb2Zmc2V0O1xuICAgICAgICAgIHNldFdoZWVsVmFsdWUod2hlZWwsIGksIGlkeCwgdGltZSwgZGlyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogZnVuY3Rpb24gb25BbmltYXRpb25TdGFydCgpIHtcbiAgICAgICAgICAkd2guYWRkQ2xhc3MoJ21ic2Mtc2Mtd2hsLWFuaW0nKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BbmltYXRpb25FbmQ6IGZ1bmN0aW9uIG9uQW5pbWF0aW9uRW5kKCkge1xuICAgICAgICAgICR3aC5yZW1vdmVDbGFzcygnbWJzYy1zYy13aGwtYSBtYnNjLXNjLXdobC1hbmltJyk7XG4gICAgICAgICAgdHJpZ2dlcignb25XaGVlbEFuaW1hdGlvbkVuZCcsIHtcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB3aGVlbC5fJDNkLmZpbmQoJy5tYnNjLXNjLWl0bS1kZWwnKS5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICAgICAgICBpbmZpbml0ZSh3aGVlbCwgaSwgZXYucG9zWSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQnRuVGFwOiBmdW5jdGlvbiBvbkJ0blRhcChldikge1xuICAgICAgICAgIG9uSXRlbVRhcChpLCAkJDEoZXYudGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNjcm9sbFRvUG9zKCk7XG4gIH07XG5cbiAgdGhhdC5fZmlsbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICBzZXRWYWx1ZSh0cnVlLCB0cnVlLCAwLCB0cnVlKTtcbiAgfTtcblxuICB0aGF0Ll9jbGVhclZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICQkMSgnLm1ic2Mtc2Mtd2hsLW11bHRpIC5tYnNjLXNjLWl0bS1zZWwnLCAkbWFya3VwKS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gIH07XG5cbiAgdGhhdC5fcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gJGVsbS52YWwoKSB8fCAnJyxcbiAgICAgICAgbCA9IDA7XG5cbiAgICBpZiAodiAhPT0gJycpIHtcbiAgICAgIHRoYXQuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGF0Ll90ZW1wV2hlZWxBcnJheSA9IHRlbXBXaGVlbEFycmF5ID0gdGhhdC5faGFzVmFsdWUgJiYgdGhhdC5fd2hlZWxBcnJheSA/IHRoYXQuX3doZWVsQXJyYXkuc2xpY2UoMCkgOiBzLnBhcnNlVmFsdWUuY2FsbChlbCwgdiwgdGhhdCkgfHwgW107XG4gICAgdGhhdC5fdGVtcFNlbGVjdGVkID0gZXh0ZW5kJDEodHJ1ZSwge30sIHRoYXQuX3NlbGVjdGVkKTtcbiAgICAkJDEuZWFjaChzLndoZWVscywgZnVuY3Rpb24gKGksIHdnKSB7XG4gICAgICAkJDEuZWFjaCh3ZywgZnVuY3Rpb24gKGosIHcpIHtcbiAgICAgICAgLy8gV2hlZWxzXG4gICAgICAgIHdoZWVsc1tsXSA9IGluaXRXaGVlbCh3LCBsKTtcbiAgICAgICAgbCsrO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc2V0VmFsdWUoZmFsc2UsIGZhbHNlLCAwLCB0cnVlKTtcbiAgICB0cmlnZ2VyKCdvblJlYWQnKTtcbiAgfTtcblxuICB0aGF0Ll9fcHJvY2Vzc1NldHRpbmdzID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICB0cmlnZ2VyID0gdGhhdC50cmlnZ2VyO1xuICAgIGxpbmVzID0gcy5tdWx0aWxpbmU7XG4gICAgc2VsZWN0ZWRDbGFzcyA9ICdtYnNjLXNjLWl0bS1zZWwgbWJzYy1pYyBtYnNjLWljLScgKyBzLmNoZWNrSWNvbjtcbiAgICBpc1BvaW50ZXIgPSAhcy50b3VjaFVpO1xuXG4gICAgaWYgKGlzUG9pbnRlcikge1xuICAgICAgLy8gU2V0dGluZ3MgdGhhdCBtaWdodCBiZSBuZWVkZWQgYnkgdGhlIHNjcm9sbGVyIHByZXNldCBhcyB3ZWxsXG4gICAgICBzLnRhcFNlbGVjdCA9IHRydWU7XG4gICAgICBzLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgICBzLnJvd3MgPSByZXNwLnJvd3MgfHwgc2V0dGluZ3Mucm93cyB8fCA3O1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9faW5pdCA9IGZ1bmN0aW9uIChuZXdTZXR0aW5ncykge1xuICAgIGlmIChuZXdTZXR0aW5ncykge1xuICAgICAgLy8gUmVzZXQgd2hlZWwgYXJyYXkgaW4gY2FzZSBvZiBzZXR0aW5nIGNoYW5nZSxcbiAgICAgIC8vIHNpbmNlIGl0IG1pZ2h0IGFmZmVjdCB0aGUgbnVtYmVyIG9mIHdoZWVsc1xuICAgICAgdGhhdC5fd2hlZWxBcnJheSA9IG51bGw7XG4gICAgfVxuXG4gICAgd2hlZWxzID0gW107XG4gICAgd2hlZWxzTWFwID0ge307XG4gICAgc2hvd1Njcm9sbEFycm93cyA9IHMuc2hvd1Njcm9sbEFycm93cztcbiAgICBzY3JvbGwzZCA9IHMuc2Nyb2xsM2QgJiYgaGFzM2QgJiYgIXNob3dTY3JvbGxBcnJvd3MgJiYgIWlzUG9pbnRlciAmJiAocy50aGVtZSA9PSAnaW9zJyB8fCBzLmJhc2VUaGVtZSA9PSAnaW9zJyk7XG4gICAgaXRlbUhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGl0ZW1IZWlnaHQzZCA9IHNjcm9sbDNkID8gTWF0aC5yb3VuZCgoaXRlbUhlaWdodCAtIChpdGVtSGVpZ2h0ICogcy5yb3dzIC8gMiArIDMpICogMC4wMykgLyAyKSAqIDIgOiBpdGVtSGVpZ2h0O1xuICAgIGJhdGNoU2l6ZTNkID0gTWF0aC5yb3VuZChzLnJvd3MgKiAxLjgpO1xuICAgIHNjcm9sbDNkQW5nbGUgPSAzNjAgLyAoYmF0Y2hTaXplM2QgKiAyKTsgLy8gRW5zdXJlIGEgbWluaW11bSBudW1iZXIgb2YgMyBpdGVtcyBpZiBjbGlja3BpY2sgYnV0dG9ucyBwcmVzZW50XG5cbiAgICBpZiAoc2hvd1Njcm9sbEFycm93cykge1xuICAgICAgcy5yb3dzID0gTWF0aC5tYXgoMywgcy5yb3dzKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fZ2V0SXRlbVZhbHVlID0gZ2V0SXRlbVZhbHVlOyAvLyBQcm9wZXJ0aWVzXG5cbiAgdGhhdC5fdGVtcFNlbGVjdGVkID0ge307XG4gIHRoYXQuX3NlbGVjdGVkID0ge307IC8vIENvbnN0cnVjdG9yXG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07IC8vIEV4dGVuZCBkZWZhdWx0c1xuXG5TY3JvbGxlci5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9yZXNwb25zaXZlOiB0cnVlLFxuICBfY2xhc3M6ICdzY3JvbGxlcicsXG4gIF9wcmVzZXRzOiBwcmVzZXRzLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBGcmFtZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgLy8gT3B0aW9uc1xuICAgIG1pbldpZHRoOiA4MCxcbiAgICBoZWlnaHQ6IDQwLFxuICAgIHJvd3M6IDMsXG4gICAgbXVsdGlsaW5lOiAxLFxuICAgIGRlbGF5OiAyMDAsXG4gICAgcmVhZG9ubHk6IGZhbHNlLFxuICAgIHNob3dMYWJlbDogdHJ1ZSxcbiAgICBzZXRPblRhcDogZmFsc2UsXG4gICAgd2hlZWxzOiBbXSxcbiAgICBwcmVzZXQ6ICcnLFxuICAgIHNwZWVkVW5pdDogMC4wMDEyLFxuICAgIHRpbWVVbml0OiAwLjA4LFxuICAgIGNoZWNrSWNvbjogJ2NoZWNrbWFyaycsXG4gICAgY29tcENsYXNzOiAnbWJzYy1zYycsXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKCkge30sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGQpIHtcbiAgICAgIHJldHVybiBkLmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUsIGluc3QpIHtcbiAgICAgIHZhciB2YWwgPSBbXSxcbiAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICBkYXRhO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSAodmFsdWUgKyAnJykuc3BsaXQoJyAnKTtcbiAgICAgIH1cblxuICAgICAgJCQxLmVhY2goaW5zdC5zZXR0aW5ncy53aGVlbHMsIGZ1bmN0aW9uIChqLCB3Zykge1xuICAgICAgICAkJDEuZWFjaCh3ZywgZnVuY3Rpb24gKGssIHcpIHtcbiAgICAgICAgICBkYXRhID0gdy5kYXRhOyAvLyBEZWZhdWx0IHRvIGZpcnN0IHdoZWVsIHZhbHVlIGlmIG5vdCBmb3VuZFxuXG4gICAgICAgICAgZm91bmQgPSBpbnN0Ll9nZXRJdGVtVmFsdWUoZGF0YVswXSk7XG4gICAgICAgICAgJCQxLmVhY2goZGF0YSwgZnVuY3Rpb24gKGwsIGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIERvbid0IGRvIHN0cmljdCBjb21wYXJpc29uXG4gICAgICAgICAgICBpZiAodmFsW2ldID09IGluc3QuX2dldEl0ZW1WYWx1ZShpdGVtKSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IGluc3QuX2dldEl0ZW1WYWx1ZShpdGVtKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldC5wdXNoKGZvdW5kKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSlcbn07XG5jbGFzc2VzLlNjcm9sbGVyID0gU2Nyb2xsZXI7XG5cbnZhciBkZWZhdWx0cyQxID0ge1xuICBzZXBhcmF0b3I6ICcgJyxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGRhdGVGb3JtYXQ6ICdtbS9kZC95eScsXG4gIGRhdGVEaXNwbGF5OiAnTU1kZHl5JyxcbiAgdGltZUZvcm1hdDogJ2g6aWkgQScsXG4gIGRheVRleHQ6ICdEYXknLFxuICBtb250aFRleHQ6ICdNb250aCcsXG4gIHllYXJUZXh0OiAnWWVhcicsXG4gIGhvdXJUZXh0OiAnSG91cnMnLFxuICBtaW51dGVUZXh0OiAnTWludXRlcycsXG4gIGFtcG1UZXh0OiAnJm5ic3A7JyxcbiAgc2VjVGV4dDogJ1NlY29uZHMnLFxuICBub3dUZXh0OiAnTm93JyxcbiAgdG9kYXlUZXh0OiAnVG9kYXknXG59OyAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG52YXIgRGF0ZVRpbWUgPSBmdW5jdGlvbiBEYXRlVGltZShpbnN0KSB7XG4gIGZ1bmN0aW9uIGNvbnZlcnRSYW5nZXMoYXJyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHYsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIHJldCA9IFtdO1xuXG4gICAgaWYgKGFycikge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ID0gYXJyW2ldOyAvLyBDaGVjayBpZiBpdCdzIGEgcmFuZ2UsIGJ1dCBza2lwIHRpbWUtb25seSByYW5nZXNcblxuICAgICAgICBpZiAodi5zdGFydCAmJiB2LmVuZCAmJiAhSVNPXzg2MDFfVElNRS50ZXN0KHYuc3RhcnQpKSB7XG4gICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShtYWtlRGF0ZSh2LnN0YXJ0LCBmb3JtYXQsIHMpKTtcbiAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShtYWtlRGF0ZSh2LmVuZCwgZm9ybWF0LCBzKSk7XG5cbiAgICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgICByZXQucHVzaChhZGp1c3RlZERhdGUoc3RhcnQuZ2V0RnVsbFllYXIoKSwgc3RhcnQuZ2V0TW9udGgoKSwgc3RhcnQuZ2V0RGF0ZSgpKSk7XG4gICAgICAgICAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwKHYsIHN0LCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGguZmxvb3IodiAvIHN0KSAqIHN0ICsgbWluKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1heChzdGVwLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gc3RlcCkgKiBzdGVwICsgbWluO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0WWVhcihkKSB7XG4gICAgcmV0dXJuIHMuZ2V0WWVhcihkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1vbnRoKGQpIHtcbiAgICByZXR1cm4gcy5nZXRNb250aChkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERheShkKSB7XG4gICAgcmV0dXJuIHMuZ2V0RGF5KGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG91cnMoZCkge1xuICAgIHZhciBob3VyID0gZC5nZXRIb3VycygpO1xuICAgIGhvdXIgPSBoYXNBbVBtICYmIGhvdXIgPj0gMTIgPyBob3VyIC0gMTIgOiBob3VyO1xuICAgIHJldHVybiBzdGVwKGhvdXIsIHN0ZXBIb3VyLCBtaW5Ib3VyLCBtYXhIb3VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbnV0ZXMoZCkge1xuICAgIHJldHVybiBzdGVwKGQuZ2V0TWludXRlcygpLCBzdGVwTWludXRlLCBtaW5NaW51dGUsIG1heE1pbnV0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTZWNvbmRzKGQpIHtcbiAgICByZXR1cm4gc3RlcChkLmdldFNlY29uZHMoKSwgc3RlcFNlY29uZCwgbWluU2Vjb25kLCBtYXhTZWNvbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRzKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFtUG0oZCkge1xuICAgIHJldHVybiBkLmdldEhvdXJzKCkgPiAxMSA/IDEgOiAwO1xuICB9IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBTVEFSVCAtLS1cblxuXG4gIGZ1bmN0aW9uIGdldEZ1bGxEYXRlKGQpIHtcbiAgICByZXR1cm4gZC5nZXRGdWxsWWVhcigpICsgJy0nICsgcGFkKGQuZ2V0TW9udGgoKSArIDEpICsgJy0nICsgcGFkKGQuZ2V0RGF0ZSgpKTtcbiAgfSAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG5cbiAgZnVuY3Rpb24gZ2V0RnVsbFRpbWUoZCkge1xuICAgIHJldHVybiBzdGVwKE1hdGgucm91bmQoKGQuZ2V0VGltZSgpIC0gbmV3IERhdGUoZCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpIC8gMTAwMCksIHRpbWVTdGVwIHx8IDEsIDAsIDg2NDAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFycmF5UGFydChkYXRhLCBwYXJ0LCBkLCBkZWYpIHtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKHdoZWVsT3JkZXJbcGFydF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0ID0gK2RhdGFbd2hlZWxPcmRlcltwYXJ0XV07XG5cbiAgICAgIGlmICghaXNOYU4ocmV0KSkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkKSB7XG4gICAgICByZXR1cm4gZ2V0RGF0ZVBhcnRbcGFydF0oZCk7XG4gICAgfVxuXG4gICAgaWYgKGlubmVyVmFsdWVzW3BhcnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBpbm5lclZhbHVlc1twYXJ0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0RGF0ZVBhcnRbcGFydF0oZGVmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGUoZGF0YSkge1xuICAgIHZhciBkLFxuICAgICAgICBkZWYgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcblxuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAod2hlZWxPcmRlci5kZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkID0gZGF0YVt3aGVlbE9yZGVyLmRkXS5zcGxpdCgnLScpO1xuICAgICAgZCA9IG5ldyBEYXRlKGRbMF0sIGRbMV0gLSAxLCBkWzJdKTtcbiAgICB9XG5cbiAgICBpZiAod2hlZWxPcmRlci50dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkID0gZCB8fCBkZWY7XG4gICAgICBkID0gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyBkYXRhW3doZWVsT3JkZXIudHRdICUgODY0MDAgKiAxMDAwKTtcbiAgICB9XG5cbiAgICB2YXIgeWVhciA9IGdldEFycmF5UGFydChkYXRhLCAneScsIGQsIGRlZiksXG4gICAgICAgIG1vbnRoID0gZ2V0QXJyYXlQYXJ0KGRhdGEsICdtJywgZCwgZGVmKSxcbiAgICAgICAgZGF5ID0gTWF0aC5taW4oZ2V0QXJyYXlQYXJ0KGRhdGEsICdkJywgZCwgZGVmKSwgcy5nZXRNYXhEYXlPZk1vbnRoKHllYXIsIG1vbnRoKSksXG4gICAgICAgIGhvdXIgPSBnZXRBcnJheVBhcnQoZGF0YSwgJ2gnLCBkLCBkZWYpO1xuICAgIHJldHVybiBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSwgaGFzQW1QbSAmJiBnZXRBcnJheVBhcnQoZGF0YSwgJ2EnLCBkLCBkZWYpID8gaG91ciArIDEyIDogaG91ciwgZ2V0QXJyYXlQYXJ0KGRhdGEsICdpJywgZCwgZGVmKSwgZ2V0QXJyYXlQYXJ0KGRhdGEsICdzJywgZCwgZGVmKSwgZ2V0QXJyYXlQYXJ0KGRhdGEsICd1JywgZCwgZGVmKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBcnJheShkLCBmaWxsSW5uZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcGFydCxcbiAgICAgICAgcGFydHMgPSBbJ3knLCAnbScsICdkJywgJ2EnLCAnaCcsICdpJywgJ3MnLCAndScsICdkZCcsICd0dCddLFxuICAgICAgICByZXQgPSBbXTtcblxuICAgIGlmIChkID09PSBudWxsIHx8IGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgIGlmICh3aGVlbE9yZGVyW3BhcnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0W3doZWVsT3JkZXJbcGFydF1dID0gZ2V0RGF0ZVBhcnRbcGFydF0oZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsSW5uZXIpIHtcbiAgICAgICAgaW5uZXJWYWx1ZXNbcGFydF0gPSBnZXREYXRlUGFydFtwYXJ0XShkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBTVEFSVCAtLS1cblxuXG4gIGZ1bmN0aW9uIGdldERhdGVJbmRleChkLCBoYXNEYXkpIHtcbiAgICByZXR1cm4gaGFzRGF5ID8gLy8gTnVtYmVyIG9mIGRheXMgc2luY2UgMTk3MC0wMS0wMVxuICAgIE1hdGguZmxvb3IobmV3IERhdGUoZCkgLyA4LjY0ZTcpIDogLy8gTnVtYmVyIG9mIG1vbnRoIHNpbmNlIDE5NzAtMDEtMDFcbiAgICBkLmdldE1vbnRoKCkgKyAxMiAqIChkLmdldEZ1bGxZZWFyKCkgLSAxOTcwKTtcbiAgfVxuICAvKlxuICBmdW5jdGlvbiBnZXRZZWFyVmFsdWUoaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICBkaXNwbGF5OiAoL3l5L2kudGVzdChkYXRlRGlzcGxheSkgPyBpIDogKGkgKyAnJykuc3Vic3RyKDIsIDIpKSArIChzLnllYXJTdWZmaXggfHwgJycpXG4gICAgICB9O1xuICB9XG4gICBmdW5jdGlvbiBnZXRZZWFySW5kZXgodikge1xuICAgICAgcmV0dXJuIHY7XG4gIH1cbiAgIGZ1bmN0aW9uIGdldERhdGVXaGVlbCh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIGhhc0RheSA9IC9kL2kudGVzdCh0ZW1wbGF0ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBjc3NDbGFzczogJ21ic2MtZHQtd2hsLWRhdGUnLFxuICAgICAgICAgIG1pbjogbWluRGF0ZSA/IGdldERhdGVJbmRleChnZXRGdWxsRGF0ZShtaW5EYXRlKSwgaGFzRGF5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtYXg6IG1heERhdGUgPyBnZXREYXRlSW5kZXgoZ2V0RnVsbERhdGUobWF4RGF0ZSksIGhhc0RheSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGF0YTogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgdmFyIHRvZGF5ID0gbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKSksXG4gICAgICAgICAgICAgICAgICBkID0gaGFzRGF5ID8gbmV3IERhdGUoaSAqIDguNjRlNykgOiBuZXcgRGF0ZSgxOTcwLCBpLCAxKTtcbiAgICAgICAgICAgICAgIGlmIChoYXNEYXkpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZShkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgaW52YWxpZDogaGFzRGF5ICYmICFpc1ZhbGlkKGQsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGdldEZ1bGxEYXRlKGQpLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogdG9kYXkuZ2V0VGltZSgpID09IGQuZ2V0VGltZSgpID8gcy50b2RheVRleHQgOiBmb3JtYXREYXRlKHRlbXBsYXRlLCBkLCBzKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXREYXRlSW5kZXgodiwgaGFzRGF5KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICB9XG4gICBmdW5jdGlvbiBnZXRUaW1lV2hlZWwodGVtcGxhdGUpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgdGltZSxcbiAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICBpZiAoL3MvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgIHN0ZXAgPSBzdGVwU2Vjb25kO1xuICAgICAgfSBlbHNlIGlmICgvaS9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICAgICAgc3RlcCA9IHN0ZXBNaW51dGUgKiA2MDtcbiAgICAgIH0gZWxzZSBpZiAoL2gvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgIHN0ZXAgPSBzdGVwSG91ciAqIDM2MDA7XG4gICAgICB9XG4gICAgICAgdGltZVN0ZXAgPSBzdGVwcy50dCA9IHN0ZXA7XG4gICAgICAgZm9yIChpID0gMDsgaSA8IDg2NDAwOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICB0aW1lID0gbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKSArIGkgKiAxMDAwKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgICBkaXNwbGF5OiBmb3JtYXREYXRlKHRlbXBsYXRlLCB0aW1lLCBzKVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtdGltZScsXG4gICAgICAgICAgZGF0YTogdmFsdWVzXG4gICAgICB9O1xuICB9XG4gICBmdW5jdGlvbiBnZXRXaGVlbHMoKSB7XG4gICAgICB2YXIgZGF0ZVBhcnRzLFxuICAgICAgICAgIHRpbWVQYXJ0cyxcbiAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIG1vbnRoU3RyLFxuICAgICAgICAgIG5yID0gMCxcbiAgICAgICAgICB3aGVlbHMgPSBbXSxcbiAgICAgICAgICBkYXRlR3JvdXAgPSBbXSxcbiAgICAgICAgICB0aW1lR3JvdXAgPSBbXTtcbiAgICAgICBpZiAoL2RhdGUvaS50ZXN0KHByZXNldCkpIHtcbiAgICAgICAgICBkYXRlUGFydHMgPSBkYXRlV2hlZWxzLnNwbGl0KC9cXHwvLnRlc3QoZGF0ZVdoZWVscykgPyAnfCcgOiAnJyk7XG4gICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSBkYXRlUGFydHNbaV07XG4gICAgICAgICAgICAgIHR5cGVzID0gMDtcbiAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgY29udGFpbnMgZGlmZmVyZW50IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgIGlmICgveS9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNvUGFydHMueSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBpZiAoL20vaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlzb1BhcnRzLnkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGlzb1BhcnRzLm0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGVzKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYgKC9kL2kudGVzdCh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc29QYXJ0cy55ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBpc29QYXJ0cy5tID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBpc29QYXJ0cy5kID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlcysrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGlmICh0eXBlcyA+IDEgJiYgd2hlZWxPcmRlci5kZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hlZWxPcmRlci5kZCA9IG5yO1xuICAgICAgICAgICAgICAgICAgICAgIG5yKys7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZUdyb3VwLnB1c2goZ2V0RGF0ZVdoZWVsKHRlbXBsYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGltZUdyb3VwID0gZGF0ZUdyb3VwOyAvLyBUT0RPID8/P1xuICAgICAgICAgICAgICAgICAgICAgIG9uZURhdGVXaGVlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC95L2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGVlbE9yZGVyLnkgPSBucjtcbiAgICAgICAgICAgICAgICAgICAgICBucisrO1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBZZWFyIHdoZWVsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogJ21ic2MtZHQtd2hsLXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcy55ZWFyVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBtaW5EYXRlID8gcy5nZXRZZWFyKG1pbkRhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG1heERhdGUgPyBzLmdldFllYXIobWF4RGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGdldFllYXJWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXg6IGdldFllYXJJbmRleFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvbS9pLnRlc3QodGVtcGxhdGUpICYmIHdoZWVsT3JkZXIubSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gTW9udGggd2hlZWxcbiAgICAgICAgICAgICAgICAgICAgICB3aGVlbE9yZGVyLm0gPSBucjtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBucisrO1xuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aFN0ciA9IGRhdGVEaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW2R5fF0vZ2ksICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL21tLywgcGFkKGogKyAxKSArIChzLm1vbnRoU3VmZml4IHx8ICcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9tLywgaiArIDEgKyAocy5tb250aFN1ZmZpeCB8fCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAvTU0vLnRlc3QobW9udGhTdHIpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aFN0ci5yZXBsYWNlKC9NTS8sICc8c3BhbiBjbGFzcz1cIm1ic2MtZHQtbW9udGhcIj4nICsgcy5tb250aE5hbWVzW2pdICsgJzwvc3Bhbj4nKSA6IG1vbnRoU3RyLnJlcGxhY2UoL00vLCAnPHNwYW4gY2xhc3M9XCJtYnNjLWR0LW1vbnRoXCI+JyArIHMubW9udGhOYW1lc1Nob3J0W2pdICsgJzwvc3Bhbj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGVHcm91cC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1tJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHMubW9udGhUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL2QvaS50ZXN0KHRlbXBsYXRlKSAmJiB3aGVlbE9yZGVyLmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIERheSB3aGVlbFxuICAgICAgICAgICAgICAgICAgICAgIHdoZWVsT3JkZXIuZCA9IG5yO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIG5yKys7XG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCAzMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogKC9kZC9pLnRlc3QoZGF0ZURpc3BsYXkpID8gcGFkKGopIDogaikgKyAocy5kYXlTdWZmaXggfHwgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogJ21ic2MtZHQtd2hsLWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcy5kYXlUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAgd2hlZWxzLnB1c2goZGF0ZUdyb3VwKTtcbiAgICAgIH1cbiAgICAgICBpZiAoL3RpbWUvaS50ZXN0KHByZXNldCkpIHtcbiAgICAgICAgICB0aW1lUGFydHMgPSB0aW1lV2hlZWxzLnNwbGl0KC9cXHwvLnRlc3QodGltZVdoZWVscykgPyAnfCcgOiAnJyk7XG4gICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aW1lUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aW1lUGFydHNbaV07XG4gICAgICAgICAgICAgIHR5cGVzID0gMDtcbiAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgY29udGFpbnMgZGlmZmVyZW50IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgIGlmICgvaC9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNvUGFydHMuaCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBpZiAoL2kvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlzb1BhcnRzLmkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGVzKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYgKC9zL2kudGVzdCh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpc29QYXJ0cy5zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlcysrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGlmICgvYS9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaWYgKHR5cGVzID4gMSAmJiB3aGVlbE9yZGVyLnR0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHdoZWVsT3JkZXIudHQgPSBucjtcbiAgICAgICAgICAgICAgICAgIG5yKys7XG4gICAgICAgICAgICAgICAgICB0aW1lR3JvdXAucHVzaChnZXRUaW1lV2hlZWwodGVtcGxhdGUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvaC9pLnRlc3QodGVtcGxhdGUpICYmIHdoZWVsT3JkZXIuaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIb3VycyB3aGVlbFxuICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICB3aGVlbE9yZGVyLmggPSBucjtcbiAgICAgICAgICAgICAgICAgIGlzb1BhcnRzLmggPSAxO1xuICAgICAgICAgICAgICAgICAgbnIrKztcbiAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBtaW5Ib3VyOyBqIDwgKGhhc0FtUG0gPyAxMiA6IDI0KTsgaiArPSBzdGVwSG91cikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGhhc0FtUG0gJiYgaiA9PT0gMCA/IDEyIDogL2hoL2kudGVzdCh0aW1lRGlzcGxheSkgPyBwYWQoaikgOiBqXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgdGltZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtaCcsXG4gICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHMuaG91clRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvaS9pLnRlc3QodGVtcGxhdGUpICYmIHdoZWVsT3JkZXIuaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBNaW51dGVzIHdoZWVsXG4gICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHdoZWVsT3JkZXIuaSA9IG5yO1xuICAgICAgICAgICAgICAgICAgaXNvUGFydHMuaSA9IDE7XG4gICAgICAgICAgICAgICAgICBucisrO1xuICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IG1pbk1pbnV0ZTsgaiA8IDYwOyBqICs9IHN0ZXBNaW51dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAvaWkvaS50ZXN0KHRpbWVEaXNwbGF5KSA/IHBhZChqKSA6IGpcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB0aW1lR3JvdXAucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1pJyxcbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcy5taW51dGVUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoL3MvaS50ZXN0KHRlbXBsYXRlKSAmJiB3aGVlbE9yZGVyLnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kcyB3aGVlbFxuICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICB3aGVlbE9yZGVyLnMgPSBucjtcbiAgICAgICAgICAgICAgICAgIGlzb1BhcnRzLnMgPSAxO1xuICAgICAgICAgICAgICAgICAgbnIrKztcbiAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBtaW5TZWNvbmQ7IGogPCA2MDsgaiArPSBzdGVwU2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogL3NzL2kudGVzdCh0aW1lRGlzcGxheSkgPyBwYWQoaikgOiBqXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgdGltZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtcycsXG4gICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHMuc2VjVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9hL2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci5hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHdoZWVsT3JkZXIuYSA9IG5yO1xuICAgICAgICAgICAgICAgICAgbnIrKztcbiAgICAgICAgICAgICAgICAgICB0aW1lR3JvdXAucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1hJyxcbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcy5hbXBtVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAvQS8udGVzdCh0ZW1wbGF0ZSkgPyBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogcy5hbVRleHQudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHMucG1UZXh0LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICB9XSA6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBzLmFtVGV4dFxuICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHMucG1UZXh0XG4gICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICBpZiAodGltZUdyb3VwICE9IGRhdGVHcm91cCkge1xuICAgICAgICAgICAgICB3aGVlbHMucHVzaCh0aW1lR3JvdXApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgICByZXR1cm4gd2hlZWxzO1xuICB9XG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRIdG1sNU9wdGlvbnMoJGVsbSkge1xuICAgIHZhciBmb3JtYXQsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4LFxuICAgICAgICByZXQgPSB7fTsgLy8gRm9yY2UgZm9ybWF0IGZvciBodG1sNSBkYXRlIGlucHV0cyAoZXhwZXJpbWVudGFsKVxuXG4gICAgaWYgKCRlbG0uaXMoJ2lucHV0JykpIHtcbiAgICAgIHN3aXRjaCAoJGVsbS5hdHRyKCd0eXBlJykpIHtcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgZm9ybWF0ID0gJ3l5LW1tLWRkJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgZm9ybWF0ID0gJ3l5LW1tLWRkVEhIOmlpOnNzWic7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgICAgICAgIGZvcm1hdCA9ICd5eS1tbS1kZFRISDppaTpzcyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIGZvcm1hdCA9ICd5eS1tbSc7XG4gICAgICAgICAgcmV0LmRhdGVPcmRlciA9ICdtbXl5JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICBmb3JtYXQgPSAnSEg6aWk6c3MnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXQuZm9ybWF0ID0gZm9ybWF0OyAvLyBDaGVjayBmb3IgbWluL21heCBhdHRyaWJ1dGVzXG5cbiAgICAgIG1pbiA9ICRlbG0uYXR0cignbWluJyk7XG4gICAgICBtYXggPSAkZWxtLmF0dHIoJ21heCcpO1xuXG4gICAgICBpZiAobWluICYmIG1pbiAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXQubWluID0gcGFyc2VEYXRlKGZvcm1hdCwgbWluKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAmJiBtYXggIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0Lm1heCA9IHBhcnNlRGF0ZShmb3JtYXQsIG1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsb3Nlc3RWYWxpZERhdGUoZCwgZGlyKSB7XG4gICAgdmFyIG5leHQsXG4gICAgICAgIHByZXYsXG4gICAgICAgIG5leHRWYWxpZCA9IGZhbHNlLFxuICAgICAgICBwcmV2VmFsaWQgPSBmYWxzZSxcbiAgICAgICAgdXAgPSAwLFxuICAgICAgICBkb3duID0gMCxcbiAgICAgICAgLy8gTm9ybWFsaXplIG1pbiBhbmQgbWF4IGRhdGVzIGZvciBjb21wYXJpbmcgbGF0ZXIgKHNldCBkZWZhdWx0IHZhbHVlcyB3aGVyZSB0aGVyZSBhcmUgbm8gdmFsdWVzIGZyb20gd2hlZWxzKVxuICAgIG1pbmQgPSBtaW5EYXRlID8gZ2V0RGF0ZShnZXRBcnJheShtaW5EYXRlKSkgOiAtSW5maW5pdHksXG4gICAgICAgIG1heGQgPSBtYXhEYXRlID8gZ2V0RGF0ZShnZXRBcnJheShtYXhEYXRlKSkgOiBJbmZpbml0eTtcblxuICAgIGlmIChpc1ZhbGlkKGQpKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBpZiAoZCA8IG1pbmQpIHtcbiAgICAgIGQgPSBtaW5kO1xuICAgIH1cblxuICAgIGlmIChkID4gbWF4ZCkge1xuICAgICAgZCA9IG1heGQ7XG4gICAgfVxuXG4gICAgbmV4dCA9IGQ7XG4gICAgcHJldiA9IGQ7XG5cbiAgICBpZiAoZGlyICE9PSAyKSB7XG4gICAgICBuZXh0VmFsaWQgPSBpc1ZhbGlkKG5leHQsIHRydWUpO1xuXG4gICAgICB3aGlsZSAoIW5leHRWYWxpZCAmJiBuZXh0IDwgbWF4ZCAmJiB1cCA8IDEwMCkge1xuICAgICAgICBuZXh0ID0gbmV3IERhdGUobmV4dC5nZXRUaW1lKCkgKyAxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgICAgICAgbmV4dFZhbGlkID0gaXNWYWxpZChuZXh0LCB0cnVlKTtcbiAgICAgICAgdXArKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyICE9PSAxKSB7XG4gICAgICBwcmV2VmFsaWQgPSBpc1ZhbGlkKHByZXYsIHRydWUpO1xuXG4gICAgICB3aGlsZSAoIXByZXZWYWxpZCAmJiBwcmV2ID4gbWluZCAmJiBkb3duIDwgMTAwKSB7XG4gICAgICAgIHByZXYgPSBuZXcgRGF0ZShwcmV2LmdldFRpbWUoKSAtIDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgICBwcmV2VmFsaWQgPSBpc1ZhbGlkKHByZXYsIHRydWUpO1xuICAgICAgICBkb3duKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpciA9PT0gMSAmJiBuZXh0VmFsaWQpIHtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIGlmIChkaXIgPT09IDIgJiYgcHJldlZhbGlkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICBpZiAoaXNTYW1lTW9udGgoZCwgbmV4dCkpIHtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cblxuICAgIGlmIChpc1NhbWVNb250aChkLCBwcmV2KSkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvd24gPD0gdXAgJiYgcHJldlZhbGlkID8gcHJldiA6IG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVNb250aChkMSwgZDIpIHtcbiAgICByZXR1cm4gcy5nZXRZZWFyKGQxKSA9PT0gcy5nZXRZZWFyKGQyKSAmJiBzLmdldE1vbnRoKGQxKSA9PT0gcy5nZXRNb250aChkMik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkKGQsIHNraXApIHtcbiAgICBpZiAoIXNraXAgJiYgZCA8IG1pbkRhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXNraXAgJiYgZCA+IG1heERhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNJbk9iaihkLCB2YWxpZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0luT2JqKGQsIGludmFsaWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0luT2JqKGQsIG9iaikge1xuICAgIHZhciBjdXJyLCBqLCB2LCB2YWw7XG5cbiAgICBpZiAob2JqKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGN1cnIgPSBvYmpbal07XG4gICAgICAgIHZhbCA9IGN1cnIuZCB8fCBjdXJyO1xuICAgICAgICB2ID0gdmFsICsgJyc7XG5cbiAgICAgICAgaWYgKCFjdXJyLnN0YXJ0KSB7XG4gICAgICAgICAgaWYgKERBWV9PRl9XRUVLLnRlc3QodikpIHtcbiAgICAgICAgICAgIC8vIERheSBvZiB3ZWVrXG4gICAgICAgICAgICB2ID0gK3YucmVwbGFjZSgndycsICcnKTtcblxuICAgICAgICAgICAgaWYgKHYgPT0gZC5nZXREYXkoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKERBWV9PRl9NT05USC50ZXN0KHYpKSB7XG4gICAgICAgICAgICAvLyBEYXkgb2YgbW9udGg6ICcyJyBvciAnMTIvMjQnXG4gICAgICAgICAgICB2ID0gdi5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICBpZiAodlsxXSkge1xuICAgICAgICAgICAgICBpZiAodlswXSAtIDEgPT0gZC5nZXRNb250aCgpICYmIHZbMV0gPT0gZC5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2WzBdID09IGQuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFeGFjdCBkYXRlXG4gICAgICAgICAgICBjdXJyID0gbWFrZURhdGUodmFsLCBmb3JtYXQsIHMpO1xuXG4gICAgICAgICAgICBpZiAoZC5nZXRGdWxsWWVhcigpID09IGN1cnIuZ2V0RnVsbFllYXIoKSAmJiBkLmdldE1vbnRoKCkgPT0gY3Vyci5nZXRNb250aCgpICYmIGQuZ2V0RGF0ZSgpID09IGN1cnIuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRGF0ZXMob2JqLCB5LCBtLCBmaXJzdCwgbWF4ZGF5cywgaW52YWxpZHMsIHZhbCkge1xuICAgIHZhciBkLCBkZCwgaiwgaywgdjtcblxuICAgIGlmIChvYmopIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBvYmoubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZCA9IG9ialtqXTtcbiAgICAgICAgZGQgPSBkLmQgfHwgZDtcbiAgICAgICAgdiA9IGRkICsgJyc7XG5cbiAgICAgICAgaWYgKCFkLnN0YXJ0KSB7XG4gICAgICAgICAgaWYgKERBWV9PRl9XRUVLLnRlc3QodikpIHtcbiAgICAgICAgICAgIC8vIERheSBvZiB3ZWVrXG4gICAgICAgICAgICB2ID0gK3YucmVwbGFjZSgndycsICcnKTtcblxuICAgICAgICAgICAgZm9yIChrID0gdiAtIGZpcnN0OyBrIDwgbWF4ZGF5czsgayArPSA3KSB7XG4gICAgICAgICAgICAgIGlmIChrID49IDApIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkc1trICsgMV0gPSB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKERBWV9PRl9NT05USC50ZXN0KHYpKSB7XG4gICAgICAgICAgICAvLyBEYXkgb2YgbW9udGg6ICcyJyBvciAnMTIvMjQnXG4gICAgICAgICAgICB2ID0gdi5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICBpZiAodlsxXSkge1xuICAgICAgICAgICAgICBpZiAodlswXSAtIDEgPT0gbSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRzW3ZbMV1dID0gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnZhbGlkc1t2WzBdXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXhhY3QgZGF0ZVxuICAgICAgICAgICAgZCA9IG1ha2VEYXRlKGRkLCBmb3JtYXQsIHMpO1xuXG4gICAgICAgICAgICBpZiAocy5nZXRZZWFyKGQpID09IHkgJiYgcy5nZXRNb250aChkKSA9PSBtKSB7XG4gICAgICAgICAgICAgIGludmFsaWRzW3MuZ2V0RGF5KGQpXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVRpbWVzKHZvYmosIGluZGV4LCB2LCB5LCBtLCBkLCBpbnZhbGlkcywgdmFsaWQpIHtcbiAgICB2YXIgYWRkLFxuICAgICAgICBhbGwsXG4gICAgICAgIGRkLFxuICAgICAgICBob3VyczEsXG4gICAgICAgIGhvdXJzMixcbiAgICAgICAgaG91cnMzLFxuICAgICAgICBpLFxuICAgICAgICBpMSxcbiAgICAgICAgaTIsXG4gICAgICAgIGosXG4gICAgICAgIG9iaixcbiAgICAgICAgcGFydHMxLFxuICAgICAgICBwYXJ0czIsXG4gICAgICAgIHByb3AxLFxuICAgICAgICBwcm9wMixcbiAgICAgICAgcmVtb3ZlLFxuICAgICAgICBzcyxcbiAgICAgICAgc3RyLFxuICAgICAgICB2MSxcbiAgICAgICAgdjIsXG4gICAgICAgIHNwZWMgPSB7fSxcbiAgICAgICAgZGF5ID0gcy5nZXREYXRlKHksIG0sIGQpLFxuICAgICAgICB3ID0gWydhJywgJ2gnLCAnaScsICdzJ107XG5cbiAgICBpZiAodm9iaikge1xuICAgICAgLy8gQ2hlY2sgaWYgcnVsZXMgYXBwbHkgdG8gdGhlIHNlbGVjdGVkIGRhdGVcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2b2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iaiA9IHZvYmpbaV07XG5cbiAgICAgICAgaWYgKG9iai5zdGFydCkge1xuICAgICAgICAgIG9iai5hcHBseSA9IGZhbHNlO1xuICAgICAgICAgIGRkID0gb2JqLmQ7XG4gICAgICAgICAgc3MgPSBkZCArICcnO1xuICAgICAgICAgIHN0ciA9IHNzLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICBpZiAoZGQgJiYgKGRkLmdldFRpbWUgJiYgeSA9PSBzLmdldFllYXIoZGQpICYmIG0gPT0gcy5nZXRNb250aChkZCkgJiYgZCA9PSBzLmdldERheShkZCkgfHwgLy8gRXhhY3QgZGF0ZVxuICAgICAgICAgICFEQVlfT0ZfV0VFSy50ZXN0KHNzKSAmJiAoc3RyWzFdICYmIGQgPT0gc3RyWzFdICYmIG0gPT0gc3RyWzBdIC0gMSB8fCAhc3RyWzFdICYmIGQgPT0gc3RyWzBdKSB8fCAvLyBEYXkgb2YgbW9udGhcbiAgICAgICAgICBEQVlfT0ZfV0VFSy50ZXN0KHNzKSAmJiBkYXkuZ2V0RGF5KCkgPT0gK3NzLnJlcGxhY2UoJ3cnLCAnJykgLy8gRGF5IG9mIHdlZWtcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICBvYmouYXBwbHkgPSB0cnVlO1xuICAgICAgICAgICAgc3BlY1tkYXldID0gdHJ1ZTsgLy8gUHJldmVudCBhcHBseWluZyBnZW5lcmljIHJ1bGUgb24gZGF5LCBpZiBzcGVjaWZpYyBleGlzdHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXBwbHkgcnVsZXNcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdm9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYmogPSB2b2JqW2ldO1xuICAgICAgICBhZGQgPSAwO1xuICAgICAgICByZW1vdmUgPSAwO1xuICAgICAgICBpMSA9IG1pbnNbdl07XG4gICAgICAgIGkyID0gbWF4c1t2XTtcbiAgICAgICAgcHJvcDEgPSB0cnVlO1xuICAgICAgICBwcm9wMiA9IHRydWU7XG4gICAgICAgIGFsbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvYmouc3RhcnQgJiYgKG9iai5hcHBseSB8fCAhb2JqLmQgJiYgIXNwZWNbZGF5XSkpIHtcbiAgICAgICAgICAvLyBEZWZpbmUgdGltZSBwYXJ0c1xuICAgICAgICAgIHBhcnRzMSA9IG9iai5zdGFydC5zcGxpdCgnOicpO1xuICAgICAgICAgIHBhcnRzMiA9IG9iai5lbmQuc3BsaXQoJzonKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0czFbal0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJ0czFbal0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFydHMyW2pdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFydHMyW2pdID0gNTk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzMVtqXSA9ICtwYXJ0czFbal07XG4gICAgICAgICAgICBwYXJ0czJbal0gPSArcGFydHMyW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2ID09ICd0dCcpIHtcbiAgICAgICAgICAgIC8vIFdoZWVsIGNvbnRhaW5pbmcgZnVsbCB0aW1lXG4gICAgICAgICAgICBpMSA9IHN0ZXAoTWF0aC5yb3VuZCgobmV3IERhdGUoZGF5KS5zZXRIb3VycyhwYXJ0czFbMF0sIHBhcnRzMVsxXSwgcGFydHMxWzJdKSAtIG5ldyBEYXRlKGRheSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpIC8gMTAwMCksIHRpbWVTdGVwLCAwLCA4NjQwMCk7XG4gICAgICAgICAgICBpMiA9IHN0ZXAoTWF0aC5yb3VuZCgobmV3IERhdGUoZGF5KS5zZXRIb3VycyhwYXJ0czJbMF0sIHBhcnRzMlsxXSwgcGFydHMyWzJdKSAtIG5ldyBEYXRlKGRheSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpIC8gMTAwMCksIHRpbWVTdGVwLCAwLCA4NjQwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzMS51bnNoaWZ0KHBhcnRzMVswXSA+IDExID8gMSA6IDApO1xuICAgICAgICAgICAgcGFydHMyLnVuc2hpZnQocGFydHMyWzBdID4gMTEgPyAxIDogMCk7XG5cbiAgICAgICAgICAgIGlmIChoYXNBbVBtKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0czFbMV0gPj0gMTIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0czFbMV0gPSBwYXJ0czFbMV0gLSAxMjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwYXJ0czJbMV0gPj0gMTIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0czJbMV0gPSBwYXJ0czJbMV0gLSAxMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBMb29rIGJlaGluZFxuXG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbmRleDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmICh2YWxpZFZhbHVlc1tqXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdjEgPSBzdGVwKHBhcnRzMVtqXSwgc3RlcHNbd1tqXV0sIG1pbnNbd1tqXV0sIG1heHNbd1tqXV0pO1xuICAgICAgICAgICAgICAgIHYyID0gc3RlcChwYXJ0czJbal0sIHN0ZXBzW3dbal1dLCBtaW5zW3dbal1dLCBtYXhzW3dbal1dKTtcbiAgICAgICAgICAgICAgICBob3VyczEgPSAwO1xuICAgICAgICAgICAgICAgIGhvdXJzMiA9IDA7XG4gICAgICAgICAgICAgICAgaG91cnMzID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNBbVBtICYmIGogPT0gMSkge1xuICAgICAgICAgICAgICAgICAgaG91cnMxID0gcGFydHMxWzBdID8gMTIgOiAwO1xuICAgICAgICAgICAgICAgICAgaG91cnMyID0gcGFydHMyWzBdID8gMTIgOiAwO1xuICAgICAgICAgICAgICAgICAgaG91cnMzID0gdmFsaWRWYWx1ZXNbMF0gPyAxMiA6IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wMSkge1xuICAgICAgICAgICAgICAgICAgdjEgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcHJvcDIpIHtcbiAgICAgICAgICAgICAgICAgIHYyID0gbWF4c1t3W2pdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKHByb3AxIHx8IHByb3AyKSAmJiB2MSArIGhvdXJzMSA8IHZhbGlkVmFsdWVzW2pdICsgaG91cnMzICYmIHZhbGlkVmFsdWVzW2pdICsgaG91cnMzIDwgdjIgKyBob3VyczIpIHtcbiAgICAgICAgICAgICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWVzW2pdICE9IHYxKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWxpZFZhbHVlc1tqXSAhPSB2Mikge1xuICAgICAgICAgICAgICAgICAgcHJvcDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gTG9vayBhaGVhZFxuXG5cbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gaW5kZXggKyAxOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzMVtqXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGFkZCA9IHN0ZXBzW3ZdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0czJbal0gPCBtYXhzW3dbal1dKSB7XG4gICAgICAgICAgICAgICAgICByZW1vdmUgPSBzdGVwc1t2XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhbGwpIHtcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgICAgICAgICB2MSA9IHN0ZXAocGFydHMxW2luZGV4XSwgc3RlcHNbdl0sIG1pbnNbdl0sIG1heHNbdl0pICsgYWRkO1xuICAgICAgICAgICAgICB2MiA9IHN0ZXAocGFydHMyW2luZGV4XSwgc3RlcHNbdl0sIG1pbnNbdl0sIG1heHNbdl0pIC0gcmVtb3ZlO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9wMSkge1xuICAgICAgICAgICAgICAgIGkxID0gdjE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocHJvcDIpIHtcbiAgICAgICAgICAgICAgICBpMiA9IHYyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBEaXNhYmxlIHZhbHVlc1xuXG5cbiAgICAgICAgICBpZiAocHJvcDEgfHwgcHJvcDIgfHwgYWxsKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpMTsgaiA8PSBpMjsgaiArPSBzdGVwc1t2XSkge1xuICAgICAgICAgICAgICBpbnZhbGlkc1tqXSA9ICF2YWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgdmFyIHRpbWVTdGVwLFxuICAgICAgb25lRGF0ZVdoZWVsLFxuICAgICAgd2hlZWxzLFxuICAgICAgd2hlZWxPcmRlciA9IHt9LFxuICAgICAgaW5uZXJWYWx1ZXMgPSB7fSxcbiAgICAgIGlzb1BhcnRzID0ge30sXG4gICAgICB2YWxpZFZhbHVlcyA9IFtdLFxuICAgICAgaHRtbDVkZWYgPSBnZXRIdG1sNU9wdGlvbnMoJCQxKHRoaXMpKSxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBjYWxlbmRhclN5c3RlbSA9IGNhbGVuZGFyc1tvcmlnLmNhbGVuZGFyU3lzdGVtXSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkYXRlVGltZURlZmF1bHRzLCBjYWxlbmRhclN5c3RlbSwgZGVmYXVsdHMkMSwgaHRtbDVkZWYsIG9yaWcpLFxuICAgICAgcHJlc2V0ID0gcy5wcmVzZXQsXG4gICAgICBkaXNwbGF5Rm9ybWF0ID0gcHJlc2V0ID09ICdkYXRldGltZScgPyBzLmRhdGVGb3JtYXQgKyBzLnNlcGFyYXRvciArIHMudGltZUZvcm1hdCA6IHByZXNldCA9PSAndGltZScgPyBzLnRpbWVGb3JtYXQgOiBzLmRhdGVGb3JtYXQsXG4gICAgICBmb3JtYXQgPSBodG1sNWRlZi5mb3JtYXQgfHwgZGlzcGxheUZvcm1hdCxcbiAgICAgIGRhdGVXaGVlbHMgPSBzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0LFxuICAgICAgdGltZVdoZWVscyA9IHMudGltZVdoZWVscyB8fCBzLnRpbWVGb3JtYXQsXG4gICAgICAvL2RhdGVXaGVlbHMgPSAnfEQgTSBkfCcsIC8vIFRPRE8gc2V0dGluZ3NcbiAgLy90aW1lV2hlZWxzID0gJ3xofGlpfEF8JyxcbiAgZGF0ZURpc3BsYXkgPSBzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRGlzcGxheSxcbiAgICAgIHRpbWVEaXNwbGF5ID0gdGltZVdoZWVscyxcbiAgICAgIGJhc2VUaGVtZSA9IHMuYmFzZVRoZW1lIHx8IHMudGhlbWUsXG4gICAgICBpbnZhbGlkID0gY29udmVydFJhbmdlcyhzLmludmFsaWQpLFxuICAgICAgdmFsaWQgPSBjb252ZXJ0UmFuZ2VzKHMudmFsaWQpLFxuICAgICAgbWluRGF0ZSA9IG1ha2VEYXRlKHMubWluLCBmb3JtYXQsIHMpLFxuICAgICAgbWF4RGF0ZSA9IG1ha2VEYXRlKHMubWF4LCBmb3JtYXQsIHMpLFxuICAgICAgaGFzVGltZSA9IC90aW1lL2kudGVzdChwcmVzZXQpLFxuICAgICAgaGFzQW1QbSA9IC9oLy50ZXN0KHRpbWVEaXNwbGF5KSxcbiAgICAgIGdlbkRheU5hbWVzID0gL0QvLnRlc3QoZGF0ZURpc3BsYXkpLFxuICAgICAgc3RlcFBhcnRzID0gcy5zdGVwcyB8fCB7fSxcbiAgICAgIHN0ZXBIb3VyID0gc3RlcFBhcnRzLmhvdXIgfHwgcy5zdGVwSG91ciB8fCAxLFxuICAgICAgc3RlcE1pbnV0ZSA9IHN0ZXBQYXJ0cy5taW51dGUgfHwgcy5zdGVwTWludXRlIHx8IDEsXG4gICAgICBzdGVwU2Vjb25kID0gc3RlcFBhcnRzLnNlY29uZCB8fCBzLnN0ZXBTZWNvbmQgfHwgMSxcbiAgICAgIHplcm9CYXNlZCA9IHN0ZXBQYXJ0cy56ZXJvQmFzZWQsXG4gICAgICBtaW5Ib3VyID0gemVyb0Jhc2VkIHx8ICFtaW5EYXRlID8gMCA6IG1pbkRhdGUuZ2V0SG91cnMoKSAlIHN0ZXBIb3VyLFxuICAgICAgbWluTWludXRlID0gemVyb0Jhc2VkIHx8ICFtaW5EYXRlID8gMCA6IG1pbkRhdGUuZ2V0TWludXRlcygpICUgc3RlcE1pbnV0ZSxcbiAgICAgIG1pblNlY29uZCA9IHplcm9CYXNlZCB8fCAhbWluRGF0ZSA/IDAgOiBtaW5EYXRlLmdldFNlY29uZHMoKSAlIHN0ZXBTZWNvbmQsXG4gICAgICBtYXhIb3VyID0gZ2V0TWF4KHN0ZXBIb3VyLCBtaW5Ib3VyLCBoYXNBbVBtID8gMTEgOiAyMyksXG4gICAgICBtYXhNaW51dGUgPSBnZXRNYXgoc3RlcE1pbnV0ZSwgbWluTWludXRlLCA1OSksXG4gICAgICBtYXhTZWNvbmQgPSBnZXRNYXgoc3RlcE1pbnV0ZSwgbWluTWludXRlLCA1OSksXG4gICAgICBtaW5zID0ge1xuICAgIHk6IG1pbkRhdGUgPyBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgOiAtSW5maW5pdHksXG4gICAgbTogMCxcbiAgICBkOiAxLFxuICAgIGg6IG1pbkhvdXIsXG4gICAgaTogbWluTWludXRlLFxuICAgIHM6IG1pblNlY29uZCxcbiAgICBhOiAwLFxuICAgIHR0OiAwXG4gIH0sXG4gICAgICBtYXhzID0ge1xuICAgIHk6IG1heERhdGUgPyBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgOiBJbmZpbml0eSxcbiAgICBtOiAxMSxcbiAgICBkOiAzMSxcbiAgICBoOiBtYXhIb3VyLFxuICAgIGk6IG1heE1pbnV0ZSxcbiAgICBzOiBtYXhTZWNvbmQsXG4gICAgYTogMSxcbiAgICB0dDogODY0MDBcbiAgfSxcbiAgICAgIHN0ZXBzID0ge1xuICAgIHk6IDEsXG4gICAgbTogMSxcbiAgICBkOiAxLFxuICAgIGg6IHN0ZXBIb3VyLFxuICAgIGk6IHN0ZXBNaW51dGUsXG4gICAgczogc3RlcFNlY29uZCxcbiAgICBhOiAxLFxuICAgIHR0OiAxXG4gIH0sXG4gICAgICB3aWR0aHMgPSB7XG4gICAgYm9vdHN0cmFwOiA0NixcbiAgICBpb3M6IDUwLFxuICAgIG1hdGVyaWFsOiA0NixcbiAgICBtb2Jpc2Nyb2xsOiA0NixcbiAgICB3aW5kb3dzOiA1MFxuICB9LFxuICAgICAgZ2V0RGF0ZVBhcnQgPSB7XG4gICAgeTogZ2V0WWVhcixcbiAgICBtOiBnZXRNb250aCxcbiAgICBkOiBnZXREYXksXG4gICAgaDogZ2V0SG91cnMsXG4gICAgaTogZ2V0TWludXRlcyxcbiAgICBzOiBnZXRTZWNvbmRzLFxuICAgIHU6IGdldE1pbGxpc2Vjb25kcyxcbiAgICBhOiBnZXRBbVBtLFxuICAgIGRkOiBnZXRGdWxsRGF0ZSxcbiAgICB0dDogZ2V0RnVsbFRpbWVcbiAgfTsgLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIEVORCAtLS1cbiAgLy8gRXh0ZW5kZWQgbWV0aG9kc1xuICAvLyAtLS1cblxuICBpbnN0LmdldFZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyByZXR1cm5EYXRlKGdldERhdGUoaW5zdC5nZXRBcnJheVZhbCh0ZW1wKSksIHMsIGZvcm1hdCkgOiBudWxsO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0ZWQgZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdGVtcD1mYWxzZV0gSWYgdHJ1ZSwgcmV0dXJuIHRoZSBjdXJyZW50bHkgc2hvd24gZGF0ZSBvbiB0aGUgcGlja2VyLCBvdGhlcndpc2UgdGhlIGxhc3Qgc2VsZWN0ZWQgb25lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cblxuXG4gIGluc3QuZ2V0RGF0ZSA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBnZXREYXRlKGluc3QuZ2V0QXJyYXlWYWwodGVtcCkpIDogbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGVkIGRhdGVcbiAgICpcbiAgICogQHBhcmFtIHtEYXRlfSBkIERhdGUgdG8gc2VsZWN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaWxsPWZhbHNlXSBBbHNvIHNldCB0aGUgdmFsdWUgb2YgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9MF0gQW5pbWF0aW9uIHRpbWUgdG8gc2Nyb2xsIHRvIHRoZSBzZWxlY3RlZCBkYXRlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0ZW1wPWZhbHNlXSBTZXQgdGVtcG9yYXJ5IHZhbHVlIG9ubHkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NoYW5nZT1maWxsXSBUcmlnZ2VyIGNoYW5nZSBvbiBpbnB1dCBlbGVtZW50LlxuICAgKi9cblxuXG4gIGluc3Quc2V0RGF0ZSA9IGZ1bmN0aW9uIChkLCBmaWxsLCB0aW1lLCB0ZW1wLCBjaGFuZ2UpIHtcbiAgICBpbnN0LnNldEFycmF5VmFsKGdldEFycmF5KGQsIHRydWUpLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpO1xuICB9OyAvLyAtLS1cbiAgLy8gSW5pdGlhbGl6YXRpb25zXG4gIC8vIC0tLVxuXG4gIC8qXG4gIHdoZWVscyA9IGdldFdoZWVscygpO1xuICAgcy5pc29QYXJ0cyA9IGlzb1BhcnRzO1xuICAqL1xuICAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgU1RBUlQgLS0tXG5cblxuICB3aGVlbE9yZGVyID0gaW5zdC5yZW1vdGUuZGF0ZXRpbWUud2hlZWxPcmRlcjtcbiAgb25lRGF0ZVdoZWVsID0gaW5zdC5yZW1vdGUuZGF0ZXRpbWUub25lRGF0ZVdoZWVsO1xuICB0aW1lU3RlcCA9IGluc3QucmVtb3RlLmRhdGV0aW1lLnRpbWVTdGVwO1xuICB3aGVlbHMgPSBpbnN0LnJlbW90ZS5kYXRldGltZS53aGVlbHM7XG4gIHMuaXNvUGFydHMgPSBpc29QYXJ0cyA9IGluc3QucmVtb3RlLmRhdGV0aW1lLmlzb1BhcnRzO1xuICBzLmRhdGVEaXNwbGF5ID0gZGF0ZURpc3BsYXk7XG4gIGluc3QucmVtb3RlLmRhdGV0aW1lLmlzVmFsaWQgPSBpc1ZhbGlkO1xuICBpbnN0LnJlbW90ZS5kYXRldGltZS5nZXRGdWxsRGF0ZSA9IGdldEZ1bGxEYXRlO1xuICBpbnN0LnJlbW90ZS5kYXRldGltZS5nZXREYXRlSW5kZXggPSBnZXREYXRlSW5kZXg7XG4gIGluc3QucmVtb3RlLmRhdGV0aW1lLmRhdGV0aW1lID0ge1xuICAgIGZvcm1hdERhdGU6IGZvcm1hdERhdGVcbiAgfTsgLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIEVORCAtLS1cblxuICBpbnN0Ll9mb3JtYXQgPSBkaXNwbGF5Rm9ybWF0O1xuICBpbnN0Ll9vcmRlciA9IHdoZWVsT3JkZXI7XG5cbiAgaW5zdC5oYW5kbGVycy5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC5zZXREYXRlKG5ldyBEYXRlKCksIGluc3QubGl2ZSwgMTAwMCwgdHJ1ZSwgdHJ1ZSk7XG4gIH07XG5cbiAgaW5zdC5idXR0b25zLm5vdyA9IHtcbiAgICB0ZXh0OiBzLm5vd1RleHQsXG4gICAgaWNvbjogcy5ub3dJY29uLFxuICAgIGhhbmRsZXI6ICdub3cnXG4gIH07IC8vIC0tLVxuXG4gIHJldHVybiB7XG4gICAgbWluV2lkdGg6IG9uZURhdGVXaGVlbCAmJiBoYXNUaW1lID8gd2lkdGhzW2Jhc2VUaGVtZV0gOiB1bmRlZmluZWQsXG4gICAgY29tcENsYXNzOiAnbWJzYy1kdCBtYnNjLXNjJyxcbiAgICB3aGVlbHM6IHdoZWVscyxcbiAgICBoZWFkZXJUZXh0OiBzLmhlYWRlclRleHQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShkaXNwbGF5Rm9ybWF0LCBnZXREYXRlKGluc3QuZ2V0QXJyYXlWYWwodHJ1ZSkpLCBzKTtcbiAgICB9IDogZmFsc2UsXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGQpIHtcbiAgICAgIHJldHVybiBmb3JtYXREYXRlKGZvcm1hdCwgZ2V0RGF0ZShkKSwgcyk7XG4gICAgfSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbCkge1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgaW5uZXJWYWx1ZXMgPSB7fTtcbiAgICAgICAgaW5zdC5faGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEFycmF5KG1ha2VEYXRlKHZhbCB8fCBzLmRlZmF1bHRWYWx1ZSB8fCBuZXcgRGF0ZSgpLCBmb3JtYXQsIHMsIGlzb1BhcnRzKSwgISF2YWwpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgZGF5U3RyLFxuICAgICAgICAgIHdlZWtEYXksXG4gICAgICAgICAgdmFsdWVzID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgaW5kZXggPSBkYXRhLmluZGV4LFxuICAgICAgICAgIGRpciA9IGRhdGEuZGlyZWN0aW9uLFxuICAgICAgICAgIGRheVdoZWVsID0gcy53aGVlbHNbMF1bd2hlZWxPcmRlci5kXSxcbiAgICAgICAgICB2YWxpZGF0ZWQgPSBnZXRDbG9zZXN0VmFsaWREYXRlKGdldERhdGUodmFsdWVzKSwgZGlyKSxcbiAgICAgICAgICB0ZW1wID0gZ2V0QXJyYXkodmFsaWRhdGVkKSxcbiAgICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICAgIHdoZWVscyA9IHt9LFxuICAgICAgICAgIHkgPSBnZXREYXRlUGFydC55KHZhbGlkYXRlZCksXG4gICAgICAgICAgLy9nZXQodGVtcCwgJ3knKSxcbiAgICAgIG0gPSBnZXREYXRlUGFydC5tKHZhbGlkYXRlZCksXG4gICAgICAgICAgLy9nZXQodGVtcCwgJ20nKSxcbiAgICAgIG1heGRheXMgPSBzLmdldE1heERheU9mTW9udGgoeSwgbSksXG4gICAgICAgICAgbWlucHJvcCA9IHRydWUsXG4gICAgICAgICAgbWF4cHJvcCA9IHRydWU7XG4gICAgICAkJDEuZWFjaChbJ2RkJywgJ3knLCAnbScsICdkJywgJ3R0JywgJ2EnLCAnaCcsICdpJywgJ3MnXSwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgdmFyIG1pbiA9IG1pbnNbaV0sXG4gICAgICAgICAgICBtYXggPSBtYXhzW2ldLFxuICAgICAgICAgICAgdmFsID0gZ2V0RGF0ZVBhcnRbaV0odmFsaWRhdGVkKTtcbiAgICAgICAgZGlzYWJsZWRbd2hlZWxPcmRlcltpXV0gPSBbXTtcblxuICAgICAgICBpZiAobWlucHJvcCAmJiBtaW5EYXRlKSB7XG4gICAgICAgICAgbWluID0gZ2V0RGF0ZVBhcnRbaV0obWluRGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4cHJvcCAmJiBtYXhEYXRlKSB7XG4gICAgICAgICAgbWF4ID0gZ2V0RGF0ZVBhcnRbaV0obWF4RGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICAgICAgdmFsID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICAgIHZhbCA9IG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpICE9PSAnZGQnICYmIGkgIT09ICd0dCcpIHtcbiAgICAgICAgICBpZiAobWlucHJvcCkge1xuICAgICAgICAgICAgbWlucHJvcCA9IHZhbCA9PSBtaW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heHByb3ApIHtcbiAgICAgICAgICAgIG1heHByb3AgPSB2YWwgPT0gbWF4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbE9yZGVyW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoaSAhPSAneScgJiYgaSAhPSAnZGQnKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBtaW5zW2ldOyBqIDw9IG1heHNbaV07IGogKz0gc3RlcHNbaV0pIHtcbiAgICAgICAgICAgICAgaWYgKGogPCBtaW4gfHwgaiA+IG1heCkge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkW3doZWVsT3JkZXJbaV1dLnB1c2goaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIERpc2FibGUgc29tZSBkYXlzXG5cblxuICAgICAgICAgIGlmIChpID09ICdkJykge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcy5nZXREYXRlKHksIG0sIDEpLmdldERheSgpLFxuICAgICAgICAgICAgICAgIGludmFsaWRzID0ge307IC8vIFNldCBpbnZhbGlkIGluZGV4ZXNcblxuICAgICAgICAgICAgdmFsaWRhdGVEYXRlcyhpbnZhbGlkLCB5LCBtLCBmaXJzdCwgbWF4ZGF5cywgaW52YWxpZHMsIDEpOyAvLyBEZWxldGUgaW5kZXhlcyB3aGljaCBhcmUgdmFsaWRcblxuICAgICAgICAgICAgdmFsaWRhdGVEYXRlcyh2YWxpZCwgeSwgbSwgZmlyc3QsIG1heGRheXMsIGludmFsaWRzLCAwKTtcbiAgICAgICAgICAgICQkMS5lYWNoKGludmFsaWRzLCBmdW5jdGlvbiAoaiwgdikge1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkW3doZWVsT3JkZXJbaV1dLnB1c2goaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEludmFsaWQgdGltZXNcblxuICAgICAgaWYgKGhhc1RpbWUpIHtcbiAgICAgICAgJCQxLmVhY2goWydhJywgJ2gnLCAnaScsICdzJywgJ3R0J10sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGdldERhdGVQYXJ0W3ZdKHZhbGlkYXRlZCksXG4gICAgICAgICAgICAgIGQgPSBnZXREYXRlUGFydC5kKHZhbGlkYXRlZCksXG4gICAgICAgICAgICAgIGludmFsaWRzID0ge307XG5cbiAgICAgICAgICBpZiAod2hlZWxPcmRlclt2XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVRpbWVzKGludmFsaWQsIGksIHYsIHksIG0sIGQsIGludmFsaWRzLCAwKTtcbiAgICAgICAgICAgIHZhbGlkYXRlVGltZXModmFsaWQsIGksIHYsIHksIG0sIGQsIGludmFsaWRzLCAxKTtcbiAgICAgICAgICAgICQkMS5lYWNoKGludmFsaWRzLCBmdW5jdGlvbiAoaiwgeCkge1xuICAgICAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkW3doZWVsT3JkZXJbdl1dLnB1c2goaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyAvLyBHZXQgdmFsaWQgdmFsdWVcblxuICAgICAgICAgICAgdmFsaWRWYWx1ZXNbaV0gPSBpbnN0LmdldFZhbGlkVmFsdWUod2hlZWxPcmRlclt2XSwgdmFsLCBkaXIsIGludmFsaWRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBSZWdlbmVyYXRlIGRheSB3aGVlbCBpZiBudW1iZXIgb2YgZGF5cyBpbiBtb250aCBjaGFuZ2VzXG4gICAgICAvLyBvciBpZiBkYXkgbmFtZXMgbmVlZHMgdG8gYmUgcmVnZW5lcmF0ZWRcblxuXG4gICAgICBpZiAoZGF5V2hlZWwgJiYgKGRheVdoZWVsLmRhdGEubGVuZ3RoICE9PSBtYXhkYXlzIHx8IGdlbkRheU5hbWVzICYmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSB3aGVlbE9yZGVyLnkgfHwgaW5kZXggPT09IHdoZWVsT3JkZXIubSkpKSB7XG4gICAgICAgIHdoZWVsc1t3aGVlbE9yZGVyLmRdID0gZGF5V2hlZWw7XG4gICAgICAgIGRheVdoZWVsLmRhdGEgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG1heGRheXM7IGkrKykge1xuICAgICAgICAgIHdlZWtEYXkgPSBzLmdldERhdGUoeSwgbSwgaSkuZ2V0RGF5KCk7XG4gICAgICAgICAgZGF5U3RyID0gZGF0ZURpc3BsYXkucmVwbGFjZSgvW215fF0vZ2ksICcnKS5yZXBsYWNlKC9kZC8sIChpIDwgMTAgPyAnMCcgKyBpIDogaSkgKyAocy5kYXlTdWZmaXggfHwgJycpKS5yZXBsYWNlKC9kLywgaSArIChzLmRheVN1ZmZpeCB8fCAnJykpO1xuICAgICAgICAgIGRheVdoZWVsLmRhdGEucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgIGRpc3BsYXk6IC9ERC8udGVzdChkYXlTdHIpID8gZGF5U3RyLnJlcGxhY2UoL0RELywgJzxzcGFuIGNsYXNzPVwibWJzYy1kdC1kYXlcIj4nICsgcy5kYXlOYW1lc1t3ZWVrRGF5XSArICc8L3NwYW4+JykgOiBkYXlTdHIucmVwbGFjZSgvRC8sICc8c3BhbiBjbGFzcz1cIm1ic2MtZHQtZGF5XCI+JyArIHMuZGF5TmFtZXNTaG9ydFt3ZWVrRGF5XSArICc8L3NwYW4+JylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBOZWVkIHRvIHVwZGF0ZSBkYXkgdmFsdWUsIGlmIG91dCBvZiBtb250aFxuXG5cbiAgICAgICAgaW5zdC5fdGVtcFdoZWVsQXJyYXlbd2hlZWxPcmRlci5kXSA9IHRlbXBbd2hlZWxPcmRlci5kXTtcbiAgICAgICAgaW5zdC5jaGFuZ2VXaGVlbCh3aGVlbHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgIHZhbGlkOiB0ZW1wXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBpZCQxID0gMDtcblxuZnVuY3Rpb24ganNvbnAkMSh1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgIHVuaXF1ZSA9ICdtYnNjanNvbnAnICsgKytpZCQxO1xuXG4gIHdpbmRvd1t1bmlxdWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIGRlbGV0ZSB3aW5kb3dbdW5pcXVlXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGRhdGEpO1xuICB9O1xuXG4gIHNjcmlwdC5zcmMgPSB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArICdjYWxsYmFjaz0nICsgdW5pcXVlO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG5cbmZ1bmN0aW9uIGFqYXhHZXQodXJsLCBjYWxsYmFjaykge1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cbiAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDQwMCkge1xuICAgICAgLy8gU3VjY2VzcyFcbiAgICAgIGNhbGxiYWNrKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZSkpO1xuICAgIH0gLy9lbHNlIHtcbiAgICAvLyBXZSByZWFjaGVkIG91ciB0YXJnZXQgc2VydmVyLCBidXQgaXQgcmV0dXJuZWQgYW4gZXJyb3JcbiAgICAvL31cblxuICB9O1xuXG4gIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHsvLyBUaGVyZSB3YXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHNvbWUgc29ydFxuICB9O1xuXG4gIHJlcXVlc3Quc2VuZCgpO1xufVxuXG5mdW5jdGlvbiBnZXRKc29uKHVybCwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gJ2pzb25wJykge1xuICAgIGpzb25wJDEodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgYWpheEdldCh1cmwsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG51dGlsLmdldEpzb24gPSBnZXRKc29uO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxudmFyIGRlZmF1bHRzJDIgPSB7XG4gIGNvbnRyb2xzOiBbJ2NhbGVuZGFyJ10sXG4gIGZpcnN0RGF5OiAwLFxuICB3ZWVrRGF5czogJ3Nob3J0JyxcbiAgbWF4TW9udGhXaWR0aDogMTcwLFxuICBicmVha1BvaW50TWQ6IDc2OCxcbiAgbW9udGhzOiAxLFxuICBwYWdlQnVmZmVyOiAxLFxuICB3ZWVrczogNixcbiAgaGlnaGxpZ2h0OiB0cnVlLFxuICBvdXRlck1vbnRoQ2hhbmdlOiB0cnVlLFxuICBxdWlja05hdjogdHJ1ZSxcbiAgeWVhckNoYW5nZTogdHJ1ZSxcbiAgdGFiczogJ2F1dG8nLFxuICAvLyBDU1MgY2xhc3Nlc1xuICB0b2RheUNsYXNzOiAnbWJzYy1jYWwtdG9kYXknLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctbGVmdDYnLFxuICBidG5DYWxOZXh0Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctcmlnaHQ2JyxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGRhdGVUZXh0OiAnRGF0ZScsXG4gIHRpbWVUZXh0OiAnVGltZScsXG4gIHRvZGF5VGV4dDogJ1RvZGF5JyxcbiAgZnJvbVRleHQ6ICdTdGFydCcsXG4gIHRvVGV4dDogJ0VuZCcsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBtb3JlJyxcbiAgcHJldk1vbnRoVGV4dDogJ1ByZXZpb3VzIE1vbnRoJyxcbiAgbmV4dE1vbnRoVGV4dDogJ05leHQgTW9udGgnLFxuICBwcmV2WWVhclRleHQ6ICdQcmV2aW91cyBZZWFyJyxcbiAgbmV4dFllYXJUZXh0OiAnTmV4dCBZZWFyJ1xufTsgLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIEVORCAtLS1cblxudmFyIENhbGVuZGFyQmFzZSA9IGZ1bmN0aW9uIENhbGVuZGFyQmFzZShpbnN0KSB7XG4gIHZhciAkY2FsZW5kYXIsXG4gICAgICAkbWFya3VwLFxuICAgICAgJG1vbnRoSGRyLFxuICAgICAgJG1vbnRoUGlja2VyLFxuICAgICAgJHRhYlBhbmVDb250LFxuICAgICAgJHRhYlBhbmVzLFxuICAgICAgJHllYXJIZHIsXG4gICAgICAkeWVhclBpY2tlcixcbiAgICAgIGFjdGl2ZURhdGUsXG4gICAgICBiYXNlLFxuICAgICAgY2FsUm93cyxcbiAgICAgIGNhbFNpemUsXG4gICAgICBjYWxXaWR0aCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb250cm9scyxcbiAgICAgIGNvbnRyb2xzQXJyYXksXG4gICAgICBjc3NEaXNhYmxlZCxcbiAgICAgIGNzc1NlbGVjdGVkLFxuICAgICAgY3NzU2VsZWN0ZWRUYWIsXG4gICAgICBjdXJyRmlyc3REYXksXG4gICAgICBkYXlMYWJlbHMsXG4gICAgICBkYXlQcm9wcyxcbiAgICAgIGRheVNjcm9sbCxcbiAgICAgIGRpc3BsYXlGb3JtYXQsXG4gICAgICBmaXJzdFdlZWtEYXksXG4gICAgICBoYXNDYWwsXG4gICAgICBoYXNMYWJlbHMsXG4gICAgICBoYXNNYXJrcyxcbiAgICAgIGhhc1RhYnMsXG4gICAgICAvLyBoYXNUZXh0LFxuICBoYXNRdWlja05hdixcbiAgICAgIGhvdmVyVGltZXIsXG4gICAgICBpbnZhbGlkT2JqLFxuICAgICAgaXNDZWxsSG92ZXIsXG4gICAgICBpc0RheUNsaWNrLFxuICAgICAgaXNMaXF1aWQsXG4gICAgICBpc01vbnRoVmlldyxcbiAgICAgIGlzUGFnZU1vdmUsXG4gICAgICBpc1JUTCxcbiAgICAgIGlzVmVydGljYWwsXG4gICAgICBsYWJlbHNPYmosXG4gICAgICBtYXJrZWRPYmosXG4gICAgICBjb2xvcnNPYmosXG4gICAgICBtYXhEYXRlLFxuICAgICAgbWF4Rmlyc3RZZWFyLFxuICAgICAgbWF4TGFiZWxzLFxuICAgICAgbWF4TW9udGgsXG4gICAgICBtYXhZZWFyLFxuICAgICAgbWluRGF0ZSxcbiAgICAgIG1pbkZpcnN0WWVhcixcbiAgICAgIG1pbk1vbnRoLFxuICAgICAgbWluWWVhcixcbiAgICAgIG1vbnRoSW5kZXgsXG4gICAgICBtb250aE5hbWVzLFxuICAgICAgbW9udGhTY3JvbGwsXG4gICAgICBuZWVkc1NsaWRlLFxuICAgICAgbmVlZHNSZWZyZXNoLFxuICAgICAgcGFnZUJ1ZmZlcixcbiAgICAgIHBhZ2VOcixcbiAgICAgIHBhZ2VPZmZzZXQsXG4gICAgICBwYWdlVG90YWwsXG4gICAgICBydGwsXG4gICAgICBzLFxuICAgICAgc2VsZWN0ZWREYXRlLFxuICAgICAgc2hvd091dGVyRGF5cyxcbiAgICAgIHRyaWdnZXIsXG4gICAgICB2YWxpZE9iaixcbiAgICAgIHZpc2libGVUYWIsXG4gICAgICB3YXNUb3VjaGVkLFxuICAgICAgd2Vla0NvdW50ZXIsXG4gICAgICB3ZWVrRGF5cyxcbiAgICAgIHllYXJDaGFuZ2UsXG4gICAgICB5ZWFySW5kZXgsXG4gICAgICB5ZWFyU2Nyb2xsLFxuICAgICAgeWVhclN1ZmZpeCxcbiAgICAgIGxhYmVsSWR4ID0gMSxcbiAgICAgIGVsbSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gc2hvd0NvbnQoJGNvbnQpIHtcbiAgICBpZiAoJGNvbnQuaGFzQ2xhc3MoJ21ic2MtY2FsLWgnKSkge1xuICAgICAgJGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2MtY2FsLWgnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlQ29udCgkY29udCkge1xuICAgIGlmICghJGNvbnQuaGFzQ2xhc3MoJ21ic2MtY2FsLWgnKSkge1xuICAgICAgJGNvbnQuYWRkQ2xhc3MoJ21ic2MtY2FsLWgnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVDb250KCRjb250KSB7XG4gICAgaWYgKCRjb250Lmhhc0NsYXNzKCdtYnNjLWNhbC1oJykpIHtcbiAgICAgIHNob3dDb250KCRjb250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUNvbnQoJGNvbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZVByb2Nlc3NTZXR0aW5ncygpIHtcbiAgICB2YXIgY3RybHMsIGxheW91dCwgb3JpZztcbiAgICBjb250cm9scyA9IHt9O1xuICAgIGNvbnRyb2xzQXJyYXkgPSBbXTtcbiAgICBkYXlMYWJlbHMgPSB7fTtcbiAgICB0cmlnZ2VyID0gaW5zdC50cmlnZ2VyO1xuICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyk7XG4gICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJDIsIG9yaWcpO1xuICAgIGN0cmxzID0gcy5jb250cm9scy5qb2luKCcsJyk7XG4gICAgZmlyc3RXZWVrRGF5ID0gcy5maXJzdERheTtcbiAgICBpc1JUTCA9IHMucnRsO1xuICAgIHBhZ2VCdWZmZXIgPSBzLnBhZ2VCdWZmZXI7XG4gICAgd2Vla0NvdW50ZXIgPSBzLndlZWtDb3VudGVyO1xuICAgIGNhbFJvd3MgPSBzLndlZWtzO1xuICAgIGlzTW9udGhWaWV3ID0gY2FsUm93cyA9PSA2O1xuICAgIGlzVmVydGljYWwgPSBzLmNhbGVuZGFyU2Nyb2xsID09ICd2ZXJ0aWNhbCc7XG4gICAgY29udGV4dCA9IGluc3QuX2dldFJlc3BDb250KCk7XG4gICAgd2Vla0RheXMgPSBzLndlZWtEYXlzID09ICdmdWxsJyA/ICcnIDogcy53ZWVrRGF5cyA9PSAnbWluJyA/ICdNaW4nIDogJ1Nob3J0JztcbiAgICBsYXlvdXQgPSBzLmxheW91dCB8fCAocy5kaXNwbGF5ID09ICdpbmxpbmUnIHx8IC90b3B8Ym90dG9tLy50ZXN0KHMuZGlzcGxheSkgJiYgcy50b3VjaFVpID8gJ2xpcXVpZCcgOiAnJyk7XG4gICAgaXNMaXF1aWQgPSBsYXlvdXQgPT0gJ2xpcXVpZCc7IC8vICYmIHMuZGlzcGxheSAhPT0gJ2J1YmJsZSc7XG5cbiAgICBjYWxXaWR0aCA9IGlzTGlxdWlkID8gbnVsbCA6IHMuY2FsZW5kYXJXaWR0aDtcbiAgICBydGwgPSBpc1JUTCAmJiAhaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgICBjc3NEaXNhYmxlZCA9ICdtYnNjLWRpc2FibGVkICcgKyAocy5kaXNhYmxlZENsYXNzIHx8ICcnKTtcbiAgICBjc3NTZWxlY3RlZFRhYiA9ICdtYnNjLXNlbGVjdGVkICcgKyAocy5zZWxlY3RlZFRhYkNsYXNzIHx8ICcnKTtcbiAgICBjc3NTZWxlY3RlZCA9ICdtYnNjLXNlbGVjdGVkICcgKyAocy5zZWxlY3RlZENsYXNzIHx8ICcnKTtcbiAgICBtYXhMYWJlbHMgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKCgocy5jYWxlbmRhckhlaWdodCB8fCAwKSAvIGNhbFJvd3MgLSA0NSkgLyAxOCkpO1xuXG4gICAgaWYgKGN0cmxzLm1hdGNoKC9jYWxlbmRhci8pKSB7XG4gICAgICBjb250cm9scy5jYWxlbmRhciA9IDE7XG4gICAgICBoYXNDYWwgPSB0cnVlO1xuICAgIH0gLy8gQWxsb3cgZGF0ZSBzY3JvbGxlciBvbmx5IGlmIGNhbGVuZGFyIG5vdCBwcmVzZW50XG5cblxuICAgIGlmIChjdHJscy5tYXRjaCgvZGF0ZS8pICYmICFoYXNDYWwpIHtcbiAgICAgIGNvbnRyb2xzLmRhdGUgPSAxO1xuICAgIH1cblxuICAgIGlmIChjdHJscy5tYXRjaCgvdGltZS8pKSB7XG4gICAgICBjb250cm9scy50aW1lID0gMTtcbiAgICB9XG5cbiAgICBzLmNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmIChjb250cm9sc1t2XSkge1xuICAgICAgICBjb250cm9sc0FycmF5LnB1c2godik7XG4gICAgICB9XG4gICAgfSk7IC8vIERpc2FibGUgcXVpY2sgbmF2IGZvciB3ZWVrIHZpZXdcblxuICAgIGhhc1F1aWNrTmF2ID0gcy5xdWlja05hdiAmJiBoYXNDYWwgJiYgaXNNb250aFZpZXc7IC8vIERpc2FibGUgeWVhciBjaGFuZ2UgZm9yIHdlZWsgdmlld1xuXG4gICAgeWVhckNoYW5nZSA9IHMueWVhckNoYW5nZSAmJiBpc01vbnRoVmlldzsgLy8gRnVsbHNjcmVlbiBtb2RlXG5cbiAgICBpZiAoaXNMaXF1aWQgJiYgaGFzQ2FsICYmIHMuZGlzcGxheSA9PSAnY2VudGVyJykge1xuICAgICAgaW5zdC5faXNGdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzLmxheW91dCA9IGxheW91dDsgLy8gUGFzcyBiYWNrIHRvIGNvcmUgaWYgc2V0IHRvIGxpcXVpZFxuXG4gICAgcy5wcmVzZXQgPSAoY29udHJvbHMuZGF0ZSB8fCBoYXNDYWwgPyAnZGF0ZScgOiAnJykgKyAoY29udHJvbHMudGltZSA/ICd0aW1lJyA6ICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RQcm9jZXNzU2V0dGluZ3MoKSB7XG4gICAgbW9udGhOYW1lcyA9IHllYXJDaGFuZ2UgPyBzLm1vbnRoTmFtZXNTaG9ydCA6IHMubW9udGhOYW1lcztcbiAgICB5ZWFyU3VmZml4ID0gcy55ZWFyU3VmZml4IHx8ICcnO1xuICAgIG1vbnRoSW5kZXggPSAocy5kYXRlV2hlZWxzIHx8IHMuZGF0ZUZvcm1hdCkuc2VhcmNoKC9tL2kpO1xuICAgIHllYXJJbmRleCA9IChzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0KS5zZWFyY2goL3kvaSk7XG4gICAgZGlzcGxheUZvcm1hdCA9IGluc3QuX2Zvcm1hdDtcblxuICAgIGlmIChzLm1pbikge1xuICAgICAgbWluRGF0ZSA9IGdldERhdGVPbmx5KG1ha2VEYXRlKHMubWluLCBkaXNwbGF5Rm9ybWF0LCBzKSk7XG4gICAgICBtaW5ZZWFyID0gcy5nZXRZZWFyKG1pbkRhdGUpO1xuICAgICAgbWluTW9udGggPSBzLmdldE1vbnRoKG1pbkRhdGUpO1xuICAgICAgbWluRmlyc3RZZWFyID0gcy5nZXREYXRlKE1hdGguZmxvb3IobWluWWVhciAvIDEyKSAqIDEyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAocy5tYXgpIHtcbiAgICAgIG1heERhdGUgPSBnZXREYXRlT25seShtYWtlRGF0ZShzLm1heCwgZGlzcGxheUZvcm1hdCwgcykpO1xuICAgICAgbWF4WWVhciA9IHMuZ2V0WWVhcihtYXhEYXRlKTtcbiAgICAgIG1heE1vbnRoID0gcy5nZXRNb250aChtYXhEYXRlKTtcbiAgICAgIG1heEZpcnN0WWVhciA9IHMuZ2V0RGF0ZShNYXRoLmZsb29yKG1heFllYXIgLyAxMikgKiAxMiwgMCwgMSk7XG4gICAgfVxuXG4gICAgaW5zdC5fbWluRGF0ZSA9IG1pbkRhdGU7XG4gICAgaW5zdC5fbWF4RGF0ZSA9IG1heERhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUb0xpc3Qob2JqLCBkLCBldikge1xuICAgIG9ialtkXSA9IG9ialtkXSB8fCBbXTtcbiAgICBvYmpbZF0ucHVzaChldik7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlT2JqKGxpc3QsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZCxcbiAgICAgICAgdixcbiAgICAgICAgeWVhcixcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRheSxcbiAgICAgICAgbWF4RGF5cyxcbiAgICAgICAgZW5kVGltZSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBnZXREYXRlID0gcy5nZXREYXRlLFxuICAgICAgICBnZXRZZWFyID0gcy5nZXRZZWFyLFxuICAgICAgICBnZXRNb250aCA9IHMuZ2V0TW9udGgsXG4gICAgICAgIGdldERheSA9IHMuZ2V0RGF5LFxuICAgICAgICBnZXRNYXhEYXlPZk1vbnRoID0gcy5nZXRNYXhEYXlPZk1vbnRoLFxuICAgICAgICBzdGFydFllYXIgPSBnZXRZZWFyKHN0YXJ0KSxcbiAgICAgICAgc3RhcnRNb250aCA9IGdldE1vbnRoKHN0YXJ0KSxcbiAgICAgICAgb2JqID0ge307XG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgJCQxLmVhY2gobGlzdCwgZnVuY3Rpb24gKGksIGV2KSB7XG4gICAgICAgIGQgPSBldi5kIHx8IGV2LnN0YXJ0IHx8IGV2O1xuICAgICAgICB2ID0gZCArICcnO1xuXG4gICAgICAgIGlmIChldi5zdGFydCAmJiBldi5lbmQpIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSBnZXREYXRlT25seShtYWtlRGF0ZShldi5zdGFydCwgZGlzcGxheUZvcm1hdCwgcykpO1xuICAgICAgICAgIGVuZFRpbWUgPSBnZXREYXRlT25seShtYWtlRGF0ZShldi5lbmQsIGRpc3BsYXlGb3JtYXQsIHMpKTtcblxuICAgICAgICAgIHdoaWxlIChzdGFydFRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgICAgYWRkVG9MaXN0KG9iaiwgc3RhcnRUaW1lLCBldik7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBnZXREYXRlKGdldFllYXIoc3RhcnRUaW1lKSwgZ2V0TW9udGgoc3RhcnRUaW1lKSwgZ2V0RGF5KHN0YXJ0VGltZSkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoREFZX09GX1dFRUsudGVzdCh2KSkge1xuICAgICAgICAgIC8vIERheSBvZiB3ZWVrXG4gICAgICAgICAgc3RhcnRUaW1lID0gZ2V0Rmlyc3REYXkoc3RhcnQsIGZhbHNlLCArdi5yZXBsYWNlKCd3JywgJycpKTtcblxuICAgICAgICAgIHdoaWxlIChzdGFydFRpbWUgPD0gZW5kKSB7XG4gICAgICAgICAgICBhZGRUb0xpc3Qob2JqLCBzdGFydFRpbWUsIGV2KTtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGdldERhdGUoZ2V0WWVhcihzdGFydFRpbWUpLCBnZXRNb250aChzdGFydFRpbWUpLCBnZXREYXkoc3RhcnRUaW1lKSArIDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChEQVlfT0ZfTU9OVEgudGVzdCh2KSkge1xuICAgICAgICAgIC8vIERheSBvZiBtb250aDogJzInIG9yICcxMi8yNCdcbiAgICAgICAgICB2ID0gdi5zcGxpdCgnLycpO1xuICAgICAgICAgIHZhciBoYXNNb250aCA9ICEhdlsxXSxcbiAgICAgICAgICAgICAgeWVhckluYyA9IGhhc01vbnRoID8gMSA6IDAsXG4gICAgICAgICAgICAgIG1vbnRoSW5jID0gaGFzTW9udGggPyAwIDogMSxcbiAgICAgICAgICAgICAgdk1vbnRoID0gaGFzTW9udGggPyB2WzBdIC0gMSA6IHN0YXJ0TW9udGgsXG4gICAgICAgICAgICAgIHZEYXkgPSBoYXNNb250aCA/ICt2WzFdIDogK3ZbMF07XG4gICAgICAgICAgbWF4RGF5cyA9IGdldE1heERheU9mTW9udGgoc3RhcnRZZWFyLCB2TW9udGgpO1xuICAgICAgICAgIHN0YXJ0VGltZSA9IGdldERhdGUoc3RhcnRZZWFyLCB2TW9udGgsIE1hdGgubWluKHZEYXksIG1heERheXMpKTtcblxuICAgICAgICAgIHdoaWxlIChzdGFydFRpbWUgPD0gZW5kKSB7XG4gICAgICAgICAgICB5ZWFyID0gZ2V0WWVhcihzdGFydFRpbWUpO1xuICAgICAgICAgICAgbW9udGggPSBnZXRNb250aChzdGFydFRpbWUpO1xuICAgICAgICAgICAgZGF5ID0gZ2V0RGF5KHN0YXJ0VGltZSk7XG5cbiAgICAgICAgICAgIGlmIChkYXkgPT09IHZEYXkpIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0KG9iaiwgc3RhcnRUaW1lLCBldik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heERheXMgPSBnZXRNYXhEYXlPZk1vbnRoKHllYXIgKyB5ZWFySW5jLCBtb250aCArIG1vbnRoSW5jKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGdldERhdGUoeWVhciArIHllYXJJbmMsIG1vbnRoICsgbW9udGhJbmMsIE1hdGgubWluKHZEYXksIG1heERheXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRXhhY3QgZGF0ZVxuICAgICAgICAgIGFkZFRvTGlzdChvYmosIGdldERhdGVPbmx5KG1ha2VEYXRlKGQsIGRpc3BsYXlGb3JtYXQsIHMpKSwgZXYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZERhdGUoZCkge1xuICAgIGlmIChkIDwgbWluRGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkID4gbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkT2JqW2RdID09PSB1bmRlZmluZWQgfHwgdmFsaWRPYmpbZF0gIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERheVByb3BzKGQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWFyayxcbiAgICAgICAgbWFya2VkTWFya3VwLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgbWFya2VkID0gbWFya2VkT2JqW2RdID8gbWFya2VkT2JqW2RdIDogZmFsc2UsXG4gICAgICAgIGNvbG9ycyA9IGNvbG9yc09ialtkXSA/IGNvbG9yc09ialtkXSA6IGZhbHNlLFxuICAgICAgICBiYWNrZ3JvdW5kID0gY29sb3JzICYmIGNvbG9yc1swXS5iYWNrZ3JvdW5kID8gY29sb3JzWzBdLmJhY2tncm91bmQgOiBtYXJrZWQgJiYgbWFya2VkWzBdLmJhY2tncm91bmQsXG4gICAgICAgIGNzc0NsYXNzID0gJyc7XG5cbiAgICBpZiAoY29sb3JzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzc0NsYXNzICs9IChjb2xvcnNbaV0uY3NzQ2xhc3MgfHwgJycpICsgJyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZWQpIHtcbiAgICAgIC8vIE1hcmtzXG4gICAgICBtYXJrZWRNYXJrdXAgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtzXCI+JztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1hcmtlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrID0gbWFya2VkW2ldO1xuICAgICAgICBjc3NDbGFzcyArPSAobWFyay5jc3NDbGFzcyB8fCAnJykgKyAnICc7XG4gICAgICAgIG1hcmtlZE1hcmt1cCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtcIicgKyAobWFyay5jb2xvciA/ICcgc3R5bGU9XCJiYWNrZ3JvdW5kOicgKyBtYXJrLmNvbG9yICsgJztcIicgOiAnJykgKyAnPjwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlZE1hcmt1cCArPSAnPC9kaXY+JztcbiAgICB9XG5cbiAgICBwcm9wcyA9IHtcbiAgICAgIG1hcmtlZDogbWFya2VkLFxuICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZCxcbiAgICAgIGNzc0NsYXNzOiBjc3NDbGFzcyxcbiAgICAgIC8vIGFyaWFMYWJlbDogaGFzVGV4dCA/IHR4dCA6ICcnLFxuICAgICAgbWFya3VwOiBkYXlMYWJlbHNbZF0gPyBkYXlMYWJlbHNbZF0uam9pbignJykgOiBoYXNNYXJrcyA/IG1hcmtlZE1hcmt1cCA6ICcnXG4gICAgfTtcbiAgICByZXR1cm4gZXh0ZW5kJDEocHJvcHMsIGluc3QuX2dldERheVByb3BzKGQsIHByb3BzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPZmZzZXRTdHlsZShvZmZzZXQpIHtcbiAgICByZXR1cm4gJyBzdHlsZT1cIicgKyAoaXNWZXJ0aWNhbCA/ICd0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoJyArIG9mZnNldCAqIDEwMCArICclKScgOiAnbGVmdDonICsgb2Zmc2V0ICogMTAwICogcnRsICsgJyUnKSArICdcIic7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjTW9udGhOcigpIHtcbiAgICAvLyBDYWxjdWxhdGUgcGFnZU5yXG4gICAgcGFnZU5yID0gcy5tb250aHMgPT0gJ2F1dG8nID8gLy8gRXhhY3QgbW9udGggbnVtYmVyIGZyb20gc2V0dGluZ1xuICAgIE1hdGgubWF4KDEsIC8vIE1pbiAxIG1vbnRoXG4gICAgTWF0aC5taW4oMywgLy8gTWF4IDMgbW9udGhzXG4gICAgTWF0aC5mbG9vcigoY2FsV2lkdGggfHwgZ2V0V2lkdGgoY29udGV4dCkpIC8gMjgwKSkpIDogK3MubW9udGhzO1xuICAgIHBhZ2VUb3RhbCA9IHBhZ2VOciArIDIgKiBwYWdlQnVmZmVyO1xuICAgIHBhZ2VPZmZzZXQgPSAwOyAvL01hdGgucm91bmQocGFnZU5yIC8gMikgLSAxO1xuICAgIC8vIERvbid0IGFsbG93IHZlcnRpY2FsIHNjcm9sbCB3aXRoIG11bHRpcGxlIG1vbnRoc1xuXG4gICAgaXNWZXJ0aWNhbCA9IGlzVmVydGljYWwgJiYgcGFnZU5yIDwgMjsgLy8gRG9uJ3Qgc2hvdyBvdXRlciBkYXlzIGJ5IGRlZmF1bHQgZm9yIG11bHRpcGxlIG1vbnRocyBvciB2ZXJ0aWNhbCBzY3JvbGxcblxuICAgIHNob3dPdXRlckRheXMgPSBzLnNob3dPdXRlckRheXMgPT09IHVuZGVmaW5lZCA/IHBhZ2VOciA8IDIgJiYgIWlzVmVydGljYWwgfHwgIWlzTW9udGhWaWV3IDogcy5zaG93T3V0ZXJEYXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RyYWluKGQpIHtcbiAgICBpZiAoZ2V0UGFnZURheShkLCBwYWdlTnIgLSAxKSA+IG1heERhdGUpIHtcbiAgICAgIGQgPSBnZXRQYWdlRGF5KG1heERhdGUsIDEgLSBwYWdlTnIpO1xuICAgIH1cblxuICAgIGlmIChkIDwgbWluRGF0ZSkge1xuICAgICAgZCA9IG1pbkRhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYWJlbE1hcmt1cChldmVudCwgaSwgc2hvd1RleHQpIHtcbiAgICB2YXIgbm9CZyA9IGV2ZW50LmJhY2tncm91bmQgPT09ICdub25lJztcbiAgICB2YXIgY29sb3IgPSBub0JnID8gJ25vbmUnIDogZXZlbnQuY29sb3I7XG4gICAgdmFyIHR4dENvbG9yID0gbm9CZyA/IGV2ZW50LmNvbG9yIDogZ2V0VGV4dENvbG9yKGNvbG9yKTtcbiAgICB2YXIgdHh0ID0gZXZlbnQudGV4dDtcbiAgICByZXR1cm4gJzxkaXYgZGF0YS1pZD1cIicgKyBldmVudC5faWQgKyAnXCIgZGF0YS1pbmRleD1cIicgKyBpICsgJ1wiIGNsYXNzPVwibWJzYy1jYWwtdHh0JyArIChub0JnID8gJyBtYnNjLWNhbC10eHQtb25seScgOiAnJykgKyAnXCIgdGl0bGU9XCInICsgJCQxKCc8ZGl2PicgKyB0eHQgKyAnPC9kaXY+JykudGV4dCgpICsgJ1wiJyArIChjb2xvciA/ICcgc3R5bGU9XCJiYWNrZ3JvdW5kOicgKyBjb2xvciArIChzaG93VGV4dCAmJiB0eHRDb2xvciA/ICc7Y29sb3I6JyArIHR4dENvbG9yIDogJycpICsgJztcIicgOiAnJykgKyAnPicgKyAoc2hvd1RleHQgPyB0eHQgOiAnJykgKyAnPC9kaXY+JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVFdmVudHMoYSwgYikge1xuICAgIHZhciBzdGFydDEgPSBhLnN0YXJ0ID8gbWFrZURhdGUoYS5zdGFydCkgOiBudWxsLFxuICAgICAgICBzdGFydDIgPSBiLnN0YXJ0ID8gbWFrZURhdGUoYi5zdGFydCkgOiBudWxsLFxuICAgICAgICBlbmQxID0gYS5lbmQgPyBtYWtlRGF0ZShhLmVuZCkgOiBudWxsLFxuICAgICAgICBlbmQyID0gYi5lbmQgPyBtYWtlRGF0ZShiLmVuZCkgOiBudWxsLFxuICAgICAgICBpc1JlcGVhdGluZzEgPSBEQVlfT0ZfV0VFSy50ZXN0KGEuZCkgfHwgREFZX09GX01PTlRILnRlc3QoYS5kKSxcbiAgICAgICAgaXNSZXBlYXRpbmcyID0gREFZX09GX1dFRUsudGVzdChiLmQpIHx8IERBWV9PRl9NT05USC50ZXN0KGIuZCksXG4gICAgICAgIGR0MSA9IGEuZCA/IGlzUmVwZWF0aW5nMSA/IGEuZCA6IG1ha2VEYXRlKGEuZCkgOiBzdGFydDEsXG4gICAgICAgIGR0MiA9IGIuZCA/IGlzUmVwZWF0aW5nMiA/IGIuZCA6IG1ha2VEYXRlKGIuZCkgOiBzdGFydDIsXG4gICAgICAgIHdlaWdodDEgPSAhZHQxLmdldFRpbWUgPyAwIDogYS5hbGxEYXkgPyAxIDogZHQxLmdldFRpbWUoKSxcbiAgICAgICAgd2VpZ2h0MiA9ICFkdDIuZ2V0VGltZSA/IDAgOiBiLmFsbERheSA/IDEgOiBkdDIuZ2V0VGltZSgpO1xuXG4gICAgaWYgKHdlaWdodDEgPT0gd2VpZ2h0Mikge1xuICAgICAgcmV0dXJuIGEudGV4dCA+IGIudGV4dCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2VpZ2h0MSAtIHdlaWdodDI7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cykge1xuICAgIHJldHVybiBldmVudHMuc2xpY2UoMCkuc29ydChzLmV2ZW50T3JkZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25HZW5Nb250aChkKSB7XG4gICAgdmFyIHN0YXJ0ID0gZ2V0Rmlyc3REYXkoZ2V0UGFnZURheShkLCAtcGFnZU9mZnNldCAtIHBhZ2VCdWZmZXIpLCBmYWxzZSk7XG4gICAgdmFyIGVuZCA9IGdldEZpcnN0RGF5KGdldFBhZ2VEYXkoZCwgLXBhZ2VPZmZzZXQgKyBwYWdlTnIgKyBwYWdlQnVmZmVyIC0gMSksIGZhbHNlKTtcbiAgICBlbmQgPSBzLmdldERhdGUocy5nZXRZZWFyKGVuZCksIHMuZ2V0TW9udGgoZW5kKSwgcy5nZXREYXkoZW5kKSArIGNhbFJvd3MgKiA3KTtcblxuICAgIGluc3QuX29uR2VuTW9udGgoc3RhcnQsIGVuZCk7XG5cbiAgICBpbnZhbGlkT2JqID0gcHJlcGFyZU9iaihzLmludmFsaWQsIHN0YXJ0LCBlbmQpO1xuICAgIHZhbGlkT2JqID0gcHJlcGFyZU9iaihzLnZhbGlkLCBzdGFydCwgZW5kKTtcbiAgICBtYXJrZWRPYmogPSBwcmVwYXJlT2JqKHMubGFiZWxzIHx8IHMuZXZlbnRzIHx8IHMubWFya2VkLCBzdGFydCwgZW5kKTtcbiAgICBjb2xvcnNPYmogPSBwcmVwYXJlT2JqKHMuY29sb3JzLCBzdGFydCwgZW5kKTtcbiAgICBsYWJlbHNPYmogPSBpbnN0Ll9sYWJlbHMgfHwgbWFya2VkT2JqIHx8IGNvbG9yc09iajtcbiAgICBoYXNMYWJlbHMgPSBzLmxhYmVscyB8fCBpbnN0Ll9sYWJlbHM7IC8vIE11bHRpcGxlIGxhYmVsc1xuXG4gICAgaWYgKGhhc0xhYmVscykge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGF5TGFiZWxzID0ge307XG4gICAgICAgIHZhciBldmVudFJvd3MgPSB7fTtcbiAgICAgICAgdmFyIGRheSA9IHN0YXJ0O1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIGlmIChkYXkuZ2V0RGF5KCkgPT0gZmlyc3RXZWVrRGF5KSB7XG4gICAgICAgICAgICBldmVudFJvd3MgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4Um93cyA9IG1heExhYmVscztcbiAgICAgICAgICB2YXIgZXZlbnRzID0gc29ydEV2ZW50cyhsYWJlbHNPYmpbZGF5XSB8fCBbXSk7XG4gICAgICAgICAgdmFyIGV2ZW50c05yID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgICAgdmFyIHByZXZFdmVudCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gdm9pZCAwO1xuICAgICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICAgIHZhciBkaXNwbGF5ZWQgPSAwO1xuICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG5cbiAgICAgICAgICB3aGlsZSAocm93IDwgbWF4Um93cykge1xuICAgICAgICAgICAgcHJldkV2ZW50ID0gbnVsbDsgLy8gQ2hlY2sgIGlmIHRoZXJlIGFyZSBhbnkgZXZlbnRzIGFscmVhZHkgaW4gdGhpcyByb3dcblxuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2LCBqKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFJvd3Nbcm93XSA9PSBldikge1xuICAgICAgICAgICAgICAgIHByZXZFdmVudCA9IGV2O1xuICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IGo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocm93ID09IG1heFJvd3MgLSAxICYmIChkaXNwbGF5ZWQgPCBldmVudHNOciAtIDEgfHwgZXZlbnRzTnIgJiYgaSA9PSBldmVudHNOciAmJiAhcHJldkV2ZW50KSkge1xuICAgICAgICAgICAgICB2YXIgbnIgPSBldmVudHNOciAtIGRpc3BsYXllZDtcbiAgICAgICAgICAgICAgdmFyIHR4dCA9IChuciA+IDEgPyBzLm1vcmVFdmVudHNQbHVyYWxUZXh0IHx8IHMubW9yZUV2ZW50c1RleHQgOiBzLm1vcmVFdmVudHNUZXh0KS5yZXBsYWNlKC97Y291bnR9LywgbnIpO1xuXG4gICAgICAgICAgICAgIGlmIChucikge1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKCc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtdHh0LW1vcmVcIj4nICsgdHh0ICsgJzwvZGl2PicpO1xuICAgICAgICAgICAgICB9IC8vIFJlbW92ZSBldmVudCBmcm9tIHByZXZpb3VzIGRheXMgYW5kIHJlcGxhY2UgaXQgd2l0aCBtb3JlIGxhYmVsXG5cblxuICAgICAgICAgICAgICBpZiAocHJldkV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnRSb3dzW3Jvd10gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcHJldkV2ZW50Ll9kYXlzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgIGRheUxhYmVsc1tkXVtyb3ddID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC10eHQtbW9yZVwiPicgKyBzLm1vcmVFdmVudHNUZXh0LnJlcGxhY2UoL3tjb3VudH0vLCAxKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlzcGxheWVkKys7XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2RXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZJbmRleCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzU2FtZURheShkYXksIG1ha2VEYXRlKHByZXZFdmVudC5lbmQpKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Um93c1tyb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKGdldExhYmVsTWFya3VwKHByZXZFdmVudCwgcHJldkluZGV4KSk7XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICBkaXNwbGF5ZWQrKztcblxuICAgICAgICAgICAgICBwcmV2RXZlbnQuX2RheXMucHVzaChkYXkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgZXZlbnRzTnIpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gZXZlbnQuc3RhcnQgJiYgbWFrZURhdGUoZXZlbnQuc3RhcnQpO1xuICAgICAgICAgICAgICB2YXIgZW5kVGltZSA9IGV2ZW50LmVuZCAmJiBtYWtlRGF0ZShldmVudC5lbmQpO1xuICAgICAgICAgICAgICB2YXIgd2Vla0RheSA9IGRheS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGZpcnN0V2Vla0RheSAtIHdlZWtEYXkgPiAwID8gNyA6IDA7XG4gICAgICAgICAgICAgIHZhciBtdWx0aURheSA9IGVuZFRpbWUgJiYgIWlzU2FtZURheShzdGFydFRpbWUsIGVuZFRpbWUpO1xuXG4gICAgICAgICAgICAgIGlmICghc3RhcnRUaW1lIHx8IC8vIGFsbCBkYXkgZXZlbnRcbiAgICAgICAgICAgICAgaXNTYW1lRGF5KGRheSwgc3RhcnRUaW1lKSB8fCAvLyBldmVudCBzdGFydCBkYXlcbiAgICAgICAgICAgICAgd2Vla0RheSA9PSBmaXJzdFdlZWtEYXkgLy8gZmlyc3QgZGF5IG9mIHdlZWsgKGlmIGV2ZW50IGNvbnRpbnVlcyBmcm9tIHByZXYgd2VlaykpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Ll9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pZCA9IGxhYmVsSWR4Kys7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aURheSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFJvd3Nbcm93XSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBldmVudC5fZGF5cyA9IFtkYXldO1xuICAgICAgICAgICAgICAgICAgd2lkdGggPSBtdWx0aURheSA/IE1hdGgubWluKGdldERheURpZmYoZGF5LCBnZXREYXRlT25seShlbmRUaW1lKSkgKyAxLCA3ICsgZmlyc3RXZWVrRGF5IC0gd2Vla0RheSAtIG9mZnNldCkgKiAxMDAgOiAxMDA7XG4gICAgICAgICAgICAgICAgICBsYWJlbHMucHVzaChtdWx0aURheSA/ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtdHh0LXdcIiBzdHlsZT1cIndpZHRoOicgKyB3aWR0aCArICclXCI+JyArIGdldExhYmVsTWFya3VwKGV2ZW50LCBpLCB0cnVlKSArICc8L2Rpdj4nICsgZ2V0TGFiZWxNYXJrdXAoZXZlbnQsIGkpIDogZ2V0TGFiZWxNYXJrdXAoZXZlbnQsIGksIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgICAgICAgZGlzcGxheWVkKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhYmVscy5wdXNoKCc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtdHh0LXBoXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheUxhYmVsc1tkYXldID0gbGFiZWxzO1xuICAgICAgICAgIGRheSA9IHMuZ2V0RGF0ZShzLmdldFllYXIoZGF5KSwgcy5nZXRNb250aChkYXkpLCBzLmdldERheShkYXkpICsgMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgd2hpbGUgKGRheSA8IGVuZCkge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CZWZvcmVNb250aENoYW5nZShkKSB7XG4gICAgdmFyIHkgPSBzLmdldFllYXIoZCksXG4gICAgICAgIG0gPSBzLmdldE1vbnRoKGQpO1xuICAgIGN1cnJGaXJzdERheSA9IGQ7XG4gICAgYWN0aXZlRGF0ZSA9IGQ7XG4gICAgc2V0VGl0bGUoZCk7XG4gICAgdHJpZ2dlcignb25Nb250aENoYW5nZScsIHtcbiAgICAgIHllYXI6IHksXG4gICAgICBtb250aDogbVxuICAgIH0pO1xuICAgIHRyaWdnZXIoJ29uTW9udGhMb2FkaW5nJywge1xuICAgICAgeWVhcjogeSxcbiAgICAgIG1vbnRoOiBtXG4gICAgfSk7XG4gICAgdHJpZ2dlcignb25QYWdlQ2hhbmdlJywge1xuICAgICAgZmlyc3REYXk6IGRcbiAgICB9KTtcbiAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkaW5nJywge1xuICAgICAgZmlyc3REYXk6IGRcbiAgICB9KTtcbiAgICBvbkdlbk1vbnRoKGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25BZnRlck1vbnRoQ2hhbmdlKGQpIHtcbiAgICB2YXIgeSA9IHMuZ2V0WWVhcihkKSxcbiAgICAgICAgbSA9IHMuZ2V0TW9udGgoZCk7XG5cbiAgICBpZiAobmVlZHNSZWZyZXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUGFnZUxvYWRlZChkLCB5LCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuQWxsTW9udGhzKGQsIG5lZWRzUmVmcmVzaCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZm9jdXNEYXRlKGFjdGl2ZURhdGUsIGRheVNjcm9sbC5mb2N1cyk7XG4gICAgZGF5U2Nyb2xsLmZvY3VzID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblBhZ2VMb2FkZWQoZCwgeSwgbSkge1xuICAgIHZhciAkc2Nyb2xsZXIgPSBkYXlTY3JvbGwuJHNjcm9sbGVyO1xuICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlJywgJHNjcm9sbGVyKS5yZW1vdmVDbGFzcygnbWJzYy1jYWwtc2xpZGUtYScpO1xuICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlJywgJHNjcm9sbGVyKS5zbGljZShwYWdlQnVmZmVyLCBwYWdlQnVmZmVyICsgcGFnZU5yKS5hZGRDbGFzcygnbWJzYy1jYWwtc2xpZGUtYScpO1xuICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlLWEgLm1ic2MtY2FsLWRheScsICRzY3JvbGxlcikub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNlbGwgPSAkJDEodGhpcyk7XG5cbiAgICAgIGlmICghd2FzVG91Y2hlZCAmJiAhaXNQYWdlTW92ZSkge1xuICAgICAgICBob3ZlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNDZWxsSG92ZXIgPSB0cnVlO1xuICAgICAgICAgIHRyaWdnZXIoJ29uQ2VsbEhvdmVySW4nLCBnZXREYXlJbmZvKCRjZWxsKSk7XG4gICAgICAgIH0sIDE1MCk7XG4gICAgICB9XG4gICAgfSkub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lcik7XG5cbiAgICAgIGlmICghd2FzVG91Y2hlZCAmJiBpc0NlbGxIb3Zlcikge1xuICAgICAgICBpc0NlbGxIb3ZlciA9IGZhbHNlO1xuICAgICAgICB0cmlnZ2VyKCdvbkNlbGxIb3Zlck91dCcsIGdldERheUluZm8oJCQxKHRoaXMpKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzTGFiZWxzKSB7XG4gICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZS1hIC5tYnNjLWNhbC10eHQnLCAkc2Nyb2xsZXIpLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSAkJDEodGhpcykuYXR0cignZGF0YS1pZCcpO1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC10eHRbZGF0YS1pZD1cIicgKyBpZCArICdcIl0nLCAkc2Nyb2xsZXIpLmFkZENsYXNzKCdtYnNjLWhvdmVyJyk7XG4gICAgICB9KS5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCQxKCcubWJzYy1jYWwtdHh0Lm1ic2MtaG92ZXInLCAkc2Nyb2xsZXIpLnJlbW92ZUNsYXNzKCdtYnNjLWhvdmVyJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyKCdvbk1vbnRoTG9hZGVkJywge1xuICAgICAgeWVhcjogeSxcbiAgICAgIG1vbnRoOiBtXG4gICAgfSk7XG4gICAgdHJpZ2dlcignb25QYWdlTG9hZGVkJywge1xuICAgICAgZmlyc3REYXk6IGRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblRhYk1hcmt1cCgpIHtcbiAgICB2YXIgaHRtbCwgdGFiVGV4dDtcbiAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC10YWJzLWNcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtdGFic1wiIHJvbGU9XCJ0YWJsaXN0XCI+JztcbiAgICBjb250cm9sc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHRhYlRleHQgPSBzWyh2ID09ICdjYWxlbmRhcicgPyAnZGF0ZScgOiB2KSArICdUZXh0J107XG4gICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJ0YWJcIiBhcmlhLWNvbnRyb2xzPVwiJyArIChlbG0uaWQgKyAnLW1ic2MtcG5sLScgKyBpKSArICdcIiBjbGFzcz1cIm1ic2MtY2FsLXRhYiBtYnNjLWZyLWJ0bi1lICcgKyAoaSA/ICcnIDogY3NzU2VsZWN0ZWRUYWIpICsgJ1wiIGRhdGEtY29udHJvbD1cIicgKyB2ICsgJ1wiJyArIChzLnRhYkxpbmsgPyAnPjxhIGhyZWY9XCIjXCI+JyArIHRhYlRleHQgKyAnPC9hPicgOiAnIHRhYmluZGV4PVwiMFwiPicgKyB0YWJUZXh0KSArICc8L2Rpdj4nO1xuICAgIH0pO1xuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5DYWxNYXJrdXAoKSB7XG4gICAgdmFyIGh0bWwsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG1vbnRoQnRucyxcbiAgICAgICAgbW9udGhzTWFya3VwLFxuICAgICAgICB5ZWFyQnRucyA9ICcnLFxuICAgICAgICBidG5QcmV2Q2xhc3MgPSBpc1JUTCA/IHMuYnRuQ2FsTmV4dENsYXNzIDogcy5idG5DYWxQcmV2Q2xhc3MsXG4gICAgICAgIGJ0bk5leHRDbGFzcyA9IGlzUlRMID8gcy5idG5DYWxQcmV2Q2xhc3MgOiBzLmJ0bkNhbE5leHRDbGFzczsgLy8gR2VuZXJhdGUgbW9udGggYnV0dG9uc1xuXG4gICAgbW9udGhCdG5zID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1idG4td1wiPjxkaXYgZGF0YS1zdGVwPVwiLTFcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgYXJpYS1sYWJlbD1cIicgKyBzLnByZXZNb250aFRleHQgKyAnXCIgY2xhc3M9XCInICsgYnRuUHJldkNsYXNzICsgJyBtYnNjLWNhbC1wcmV2IG1ic2MtY2FsLXByZXYtbSBtYnNjLWNhbC1idG4gbWJzYy1mci1idG4gbWJzYy1mci1idG4tZVwiPjwvZGl2Pic7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgKGNhbFJvd3MgPyBwYWdlTnIgOiAxKTsgaSsrKSB7XG4gICAgICBtb250aEJ0bnMgKz0gJzxkaXYgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwibWJzYy1jYWwtbW9udGhcIj48L2Rpdj4nO1xuICAgIH1cblxuICAgIG1vbnRoQnRucyArPSAnPGRpdiBkYXRhLXN0ZXA9XCIxXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGFyaWEtbGFiZWw9XCInICsgcy5uZXh0TW9udGhUZXh0ICsgJ1wiIGNsYXNzPVwiJyArIGJ0bk5leHRDbGFzcyArICcgbWJzYy1jYWwtbmV4dCBtYnNjLWNhbC1uZXh0LW0gbWJzYy1jYWwtYnRuIG1ic2MtZnItYnRuIG1ic2MtZnItYnRuLWVcIj48L2Rpdj48L2Rpdj4nOyAvLyBHZW5lcmF0ZSB5ZWFyIGJ1dHRvbnNcblxuICAgIGlmICh5ZWFyQ2hhbmdlKSB7XG4gICAgICB5ZWFyQnRucyA9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtYnRuLXdcIj48ZGl2IGRhdGEtc3RlcD1cIi0xMlwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJyArIHMucHJldlllYXJUZXh0ICsgJ1wiIGNsYXNzPVwiJyArIGJ0blByZXZDbGFzcyArICcgbWJzYy1jYWwtcHJldiBtYnNjLWNhbC1wcmV2LXkgbWJzYy1jYWwtYnRuIG1ic2MtZnItYnRuIG1ic2MtZnItYnRuLWVcIj48L2Rpdj4nICsgJzxkaXYgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwibWJzYy1jYWwteWVhclwiPjwvZGl2PicgKyAnPGRpdiBkYXRhLXN0ZXA9XCIxMlwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJyArIHMubmV4dFllYXJUZXh0ICsgJ1wiIGNsYXNzPVwiJyArIGJ0bk5leHRDbGFzcyArICcgbWJzYy1jYWwtbmV4dCBtYnNjLWNhbC1uZXh0LXkgbWJzYy1jYWwtYnRuIG1ic2MtZnItYnRuIG1ic2MtZnItYnRuLWVcIj48L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIGlmIChjYWxSb3dzKSB7XG4gICAgICBtb250aHNNYXJrdXAgPSBnZW5BbGxNb250aHMoY3VyckZpcnN0RGF5KTtcbiAgICB9XG5cbiAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJtYnNjLXctcCBtYnNjLWNhbC1jXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsICcgKyAoaXNNb250aFZpZXcgPyAnJyA6ICcgbWJzYy1jYWwtd2Vlay12aWV3JykgKyAocGFnZU5yID4gMSA/ICcgbWJzYy1jYWwtbXVsdGkgJyA6ICcnKSArICh3ZWVrQ291bnRlciA/ICcgbWJzYy1jYWwtd2Vla3MgJyA6ICcnKSArIChpc1ZlcnRpY2FsID8gJyBtYnNjLWNhbC12ZXJ0aWNhbCcgOiAnJykgKyAoaGFzTWFya3MgPyAnIG1ic2MtY2FsLWhhcy1tYXJrcycgOiAnJykgKyAoaGFzTGFiZWxzID8gJyBtYnNjLWNhbC1oYXMtbGFiZWxzJyA6ICcnKSArICggLy8gKGhhc1RleHQgPyAnIG1ic2MtY2FsLWhhcy10eHQnIDogJycpICtcbiAgICBzaG93T3V0ZXJEYXlzID8gJycgOiAnIG1ic2MtY2FsLWhpZGUtZGlmZiAnKSArIChzLmNhbGVuZGFyQ2xhc3MgfHwgJycpICsgJ1wiJyArICghaXNMaXF1aWQgPyAnIHN0eWxlPVwid2lkdGg6JyArIChjYWxXaWR0aCB8fCAyODAgKiBwYWdlTnIpICsgJ3B4O1wiJyA6ICcnKSArICc+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtaGRyXCI+JyArICh5ZWFySW5kZXggPCBtb250aEluZGV4IHx8IHBhZ2VOciA+IDEgPyB5ZWFyQnRucyArIG1vbnRoQnRucyA6IG1vbnRoQnRucyArIHllYXJCdG5zKSArICc8L2Rpdj4nO1xuXG4gICAgaWYgKGNhbFJvd3MpIHtcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1ib2R5XCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLWRheS1waWNrZXJcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtZGF5cy1jXCI+JztcblxuICAgICAgZm9yIChqID0gMDsgaiA8IHBhZ2VOcjsgaisrKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIHdlZWsgZGF5c1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZGF5c1wiPic7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgIGsgPSAoaSArIGZpcnN0V2Vla0RheSkgJSA3O1xuICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC13ZWVrLWRheScgKyBrICsgJ1wiIGFyaWEtbGFiZWw9XCInICsgcy5kYXlOYW1lc1trXSArICdcIj4nICsgc1snZGF5TmFtZXMnICsgd2Vla0RheXNdW2tdICsgJzwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1zY3JvbGwtYyBtYnNjLWNhbC1kYXktc2Nyb2xsLWMgJyArIChzLmNhbGVuZGFyQ2xhc3MgfHwgJycpICsgJ1wiJyArIChzLmNhbGVuZGFySGVpZ2h0ID8gJyBzdHlsZT1cImhlaWdodDonICsgcy5jYWxlbmRhckhlaWdodCArICdweFwiJyA6ICcnKSArICc+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2Nyb2xsXCIgc3R5bGU9XCJ3aWR0aDonICsgMTAwIC8gcGFnZU5yICsgJyUnICsgJ1wiPicgKyBtb250aHNNYXJrdXAgKyAnPC9kaXY+PC9kaXY+JztcbiAgICB9XG5cbiAgICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgaWYgKGhhc1F1aWNrTmF2KSB7XG4gICAgICAvLyBHZW5lcmF0ZSBtb250aCBwaWNrZXJcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1tb250aC1waWNrZXIgbWJzYy1jYWwtcGlja2VyIG1ic2MtY2FsLWhcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2Nyb2xsLWMgJyArIChzLmNhbGVuZGFyQ2xhc3MgfHwgJycpICsgJ1wiPicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNjcm9sbFwiPic7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNsaWRlXCInICsgZ2V0T2Zmc2V0U3R5bGUoaSAtIDEpICsgJz48ZGl2IHJvbGU9XCJncmlkXCIgY2xhc3M9XCJtYnNjLWNhbC10YWJsZVwiPjxkaXYgcm9sZT1cInJvd1wiIGNsYXNzPVwibWJzYy1jYWwtcm93XCI+JztcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTI7IGorKykge1xuICAgICAgICAgIGlmIChqICYmIGogJSAzID09PSAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8L2Rpdj48ZGl2IHJvbGU9XCJyb3dcIiBjbGFzcz1cIm1ic2MtY2FsLXJvd1wiPic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaHRtbCArPSAnPGRpdiByb2xlPVwiZ3JpZGNlbGxcIicgKyAoaSA9PSAxID8gJyB0YWJpbmRleD1cIi0xXCIgYXJpYS1sYWJlbD1cIicgKyBzLm1vbnRoTmFtZXNbal0gKyAnXCIgZGF0YS12YWw9XCInICsgaiArICdcIicgOiAnJykgKyAnIGNsYXNzPVwibWJzYy1jYWwtY2VsbCcgKyAoaSA9PSAxID8gJyBtYnNjLWJ0bi1lJyA6ICcnKSArICdcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtY2VsbC1pIG1ic2MtY2FsLWNlbGwtdHh0XCI+JyArIChpID09IDEgPyBzLm1vbnRoTmFtZXNTaG9ydFtqXSA6ICcmbmJzcDsnKSArICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+PC9kaXY+JztcbiAgICAgIH1cblxuICAgICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+PC9kaXY+JzsgLy8gR2VuZXJhdGUgeWVhciBwaWNrZXJcblxuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXllYXItcGlja2VyIG1ic2MtY2FsLXBpY2tlciBtYnNjLWNhbC1oXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNjcm9sbC1jICcgKyAocy5jYWxlbmRhckNsYXNzIHx8ICcnKSArICdcIj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1zY3JvbGxcIj4nO1xuXG4gICAgICBmb3IgKGkgPSAtMTsgaSA8IDI7IGkrKykge1xuICAgICAgICBodG1sICs9IGdlblllYXJzKGdldFBhZ2VZZWFyKGN1cnJGaXJzdERheSwgaSksIGkpO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj48L2Rpdj4nO1xuICAgIH0gLy8gQ2xvc2luZ1xuXG5cbiAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj48L2Rpdj4nO1xuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuWWVhcnMoZCwgb2ZmKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHllYXIgPSBzLmdldFllYXIoZCksXG4gICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNsaWRlXCInICsgZ2V0T2Zmc2V0U3R5bGUob2ZmKSArICc+PGRpdiByb2xlPVwiZ3JpZFwiIGNsYXNzPVwibWJzYy1jYWwtdGFibGVcIj48ZGl2IHJvbGU9XCJyb3dcIiBjbGFzcz1cIm1ic2MtY2FsLXJvd1wiPic7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgaWYgKGkgJiYgaSAlIDMgPT09IDApIHtcbiAgICAgICAgaHRtbCArPSAnPC9kaXY+PGRpdiByb2xlPVwicm93XCIgY2xhc3M9XCJtYnNjLWNhbC1yb3dcIj4nO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJncmlkY2VsbFwiIHRhYmluZGV4PVwiLTFcIiBhcmlhLWxhYmVsPVwiJyArIHllYXIgKyAnXCIgZGF0YS12YWw9XCInICsgeWVhciArICdcIicgKyAnIGNsYXNzPVwibWJzYy1jYWwtY2VsbCBtYnNjLWJ0bi1lICcgKyAoeWVhciA8IG1pblllYXIgfHwgeWVhciA+IG1heFllYXIgPyAnIG1ic2MtZGlzYWJsZWQgJyA6ICcnKSArICh5ZWFyID09IHMuZ2V0WWVhcihjdXJyRmlyc3REYXkpID8gY3NzU2VsZWN0ZWQgOiAnJykgKyAnXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLWNlbGwtaSBtYnNjLWNhbC1jZWxsLXR4dFwiPicgKyB5ZWFyICsgeWVhclN1ZmZpeCArICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgeWVhcisrO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5Nb250aChmaXJzdERheSwgb2ZmKSB7XG4gICAgdmFyIGJnLFxuICAgICAgICBjdXJyLFxuICAgICAgICBjc3NDbGFzcyxcbiAgICAgICAgeSxcbiAgICAgICAgbSxcbiAgICAgICAgZCxcbiAgICAgICAgZGlzcGxheU1vbnRoLFxuICAgICAgICBkaXNwbGF5RGF0ZSxcbiAgICAgICAgZnVsbERhdGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBpc1ZhbGlkLFxuICAgICAgICBpc1NlbGVjdGVkLFxuICAgICAgICBpc1RvZGF5LFxuICAgICAgICBpc091dGVyRGF5LFxuICAgICAgICBtYXhEYXlzLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBrID0gMSxcbiAgICAgICAgeWVhciA9IHMuZ2V0WWVhcihmaXJzdERheSksXG4gICAgICAgIG1vbnRoID0gcy5nZXRNb250aChmaXJzdERheSksXG4gICAgICAgIGRheSA9IHMuZ2V0RGF5KGZpcnN0RGF5KSxcbiAgICAgICAgc2VsZWN0ZWQgPSBzLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCAmJiAhaW5zdC5faGFzVmFsdWUgPyBudWxsIDogaW5zdC5nZXREYXRlKHRydWUpLFxuICAgICAgICB3ZWVrRGF5ID0gcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkpLmdldERheSgpLFxuICAgICAgICAvLyBHZXQgdGhlIHdlZWtkYXkgb2YgdGhlIG1vbnRoXG4gICAgb2Zmc2V0ID0gZmlyc3RXZWVrRGF5IC0gd2Vla0RheSA+IDAgPyA3IDogMCxcbiAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2xpZGVcIicgKyBnZXRPZmZzZXRTdHlsZShvZmYpICsgJz48ZGl2IHJvbGU9XCJncmlkXCIgY2xhc3M9XCJtYnNjLWNhbC10YWJsZVwiPjxkaXYgcm9sZT1cInJvd1wiIGNsYXNzPVwibWJzYy1jYWwtcm93XCI+JztcblxuICAgIGZvciAoaiA9IDA7IGogPCA3ICogY2FsUm93czsgaisrKSB7XG4gICAgICBpID0gaiArIGZpcnN0V2Vla0RheSAtIG9mZnNldDtcbiAgICAgIGN1cnIgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGkgLSB3ZWVrRGF5ICsgZGF5KTtcbiAgICAgIHkgPSBjdXJyLmdldEZ1bGxZZWFyKCk7XG4gICAgICBtID0gY3Vyci5nZXRNb250aCgpO1xuICAgICAgZCA9IGN1cnIuZ2V0RGF0ZSgpO1xuICAgICAgZGlzcGxheU1vbnRoID0gcy5nZXRNb250aChjdXJyKTtcbiAgICAgIGRpc3BsYXlEYXRlID0gcy5nZXREYXkoY3Vycik7XG4gICAgICBtYXhEYXlzID0gcy5nZXRNYXhEYXlPZk1vbnRoKHksIG0pO1xuICAgICAgZnVsbERhdGUgPSB5ICsgJy0nICsgKG0gKyAxKSArICctJyArIGQ7XG4gICAgICBwcm9wcyA9IGV4dGVuZCQxKHtcbiAgICAgICAgdmFsaWQ6IGlzVmFsaWREYXRlKGN1cnIpLFxuICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQgJiYgaXNTYW1lRGF5KHNlbGVjdGVkLCBjdXJyKVxuICAgICAgfSwgZ2V0RGF5UHJvcHMoY3VycikpO1xuICAgICAgYmcgPSBwcm9wcy5iYWNrZ3JvdW5kID09PSAnbm9uZScgPyBmYWxzZSA6IHByb3BzLmJhY2tncm91bmQ7XG4gICAgICBpc1ZhbGlkID0gcHJvcHMudmFsaWQ7XG4gICAgICBpc1NlbGVjdGVkID0gcHJvcHMuc2VsZWN0ZWQ7XG4gICAgICBjc3NDbGFzcyA9IHByb3BzLmNzc0NsYXNzOyAvLyBDb21wYXJlIGRhdGVzIGF0IG5vb24sIGluIHNvbWUgdGltZXpvbmVzIDA6MDAgZG9lc24ndCBleGlzdHMgb24gZGF5bGlnaHQgc2F2aW5nIGRheVxuXG4gICAgICBpc1RvZGF5ID0gbmV3IERhdGUoY3Vycikuc2V0SG91cnMoMTIsIDAsIDAsIDApID09PSBuZXcgRGF0ZSgpLnNldEhvdXJzKDEyLCAwLCAwLCAwKTtcbiAgICAgIGlzT3V0ZXJEYXkgPSBkaXNwbGF5TW9udGggIT09IG1vbnRoOyAvLyBEYXkgaXMgZnJvbSBhbm90aGVyIG1vbnRoXG5cbiAgICAgIGRheVByb3BzW2Z1bGxEYXRlXSA9IHByb3BzO1xuXG4gICAgICBpZiAoaiAmJiBqICUgNyA9PT0gMCkge1xuICAgICAgICBodG1sICs9ICc8L2Rpdj48ZGl2IHJvbGU9XCJyb3dcIiBjbGFzcz1cIm1ic2MtY2FsLXJvd1wiPic7XG4gICAgICB9XG5cbiAgICAgIGlmICh3ZWVrQ291bnRlciAmJiBqICUgNyA9PT0gMCkge1xuICAgICAgICAvLyBJZiBkaXNwbGF5aW5nIGRheXMgZnJvbSBuZXh0IG1vbnRoLCByZXNldCBtb250aCBjb3VudGVyXG4gICAgICAgIGlmICh3ZWVrQ291bnRlciA9PSAnbW9udGgnICYmIGlzT3V0ZXJEYXkgJiYgayA+IDEpIHtcbiAgICAgICAgICBrID0gZCA9PSAxID8gMSA6IDI7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla0NvdW50ZXIgPT0gJ3llYXInKSB7XG4gICAgICAgICAgayA9IHMuZ2V0V2Vla051bWJlcihzLmdldERhdGUoeSwgbSwgZCArICg3IC0gZmlyc3RXZWVrRGF5ICsgMSkgJSA3KSk7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJncmlkY2VsbFwiIGNsYXNzPVwibWJzYy1jYWwtY2VsbCBtYnNjLWNhbC13ZWVrLW5yXCI+JyArIGsgKyAnPC9kaXY+JztcbiAgICAgICAgaysrO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJncmlkY2VsbFwiJyArIC8vIEFyaWEgYXR0cmlidXRlc1xuICAgICAgJyBhcmlhLWxhYmVsPVwiJyArIChpc1RvZGF5ID8gcy50b2RheVRleHQgKyAnLCAnIDogJycpICsgcy5kYXlOYW1lc1tjdXJyLmdldERheSgpXSArICcsICcgKyBzLm1vbnRoTmFtZXNbZGlzcGxheU1vbnRoXSArICcgJyArIGRpc3BsYXlEYXRlICsgJyAnICsgKHByb3BzLmFyaWFMYWJlbCA/ICcsICcgKyBwcm9wcy5hcmlhTGFiZWwgOiAnJykgKyAnXCInICsgKGlzT3V0ZXJEYXkgJiYgIXNob3dPdXRlckRheXMgPyAnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiJyA6ICcgZGF0YS1mdWxsPVwiJyArIGZ1bGxEYXRlICsgJ1wiJykgKyAoaXNPdXRlckRheSB8fCAhaXNWYWxpZCA/ICcgYXJpYS1kaXNhYmxlZD1cInRydWVcIicgOiAnJykgKyAoaXNTZWxlY3RlZCA/ICcgYXJpYS1zZWxlY3RlZD1cInRydWVcIicgOiAnJykgKyAoaXNWYWxpZCA/ICcgdGFiaW5kZXg9XCItMVwiJyA6ICcnKSArIC8vIENsYXNzZXNcbiAgICAgICcgY2xhc3M9XCJtYnNjLWNhbC1jZWxsIG1ic2MtY2FsLWRheSBtYnNjLWNhbC1kYXknICsgaSAlIDcgKyAnICcgKyAocy5kYXlDbGFzcyB8fCAnJykgKyAnICcgKyAoaXNTZWxlY3RlZCA/IGNzc1NlbGVjdGVkIDogJycpICsgKGlzVG9kYXkgPyAnICcgKyBzLnRvZGF5Q2xhc3MgOiAnJykgKyAoY3NzQ2xhc3MgPyAnICcgKyBjc3NDbGFzcyA6ICcnKSArIChkaXNwbGF5RGF0ZSA9PSAxID8gJyBtYnNjLWNhbC1kYXktZmlyc3QnIDogJycpICsgKGRpc3BsYXlEYXRlID09IG1heERheXMgPyAnIG1ic2MtY2FsLWRheS1sYXN0JyA6ICcnKSArIChpc091dGVyRGF5ID8gJyBtYnNjLWNhbC1kYXktZGlmZicgOiAnJykgKyAoaXNWYWxpZCA/ICcgbWJzYy1idG4tZScgOiAnIG1ic2MtZGlzYWJsZWQnKSArIChwcm9wcy5tYXJrZWQgPyAnIG1ic2MtY2FsLWRheS1tYXJrZWQnIDogJycpICsgKGJnID8gJyBtYnNjLWNhbC1kYXktY29sb3JlZCcgOiAnJykgKyAnXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLWNlbGwtaSBtYnNjLWNhbC1kYXktaVwiPjxkaXYgY2xhc3M9XCJtYnNjLWNhbC1kYXktZGF0ZSBtYnNjLWNhbC1jZWxsLXR4dFwiJyArIChiZyA/ICcgc3R5bGU9XCJiYWNrZ3JvdW5kOicgKyBiZyArICc7Y29sb3I6JyArIGdldFRleHRDb2xvcihiZykgKyAnXCInIDogJycpICsgJz4nICsgZGlzcGxheURhdGUgKyAnPC9kaXY+JyArIGluc3QuX2dldFRleHQobW9iaXNjcm9sbCwgMC4wNikgKyAoIC8vIEV4dHJhIG1hcmt1cCAoZXh0cmEgZGl2IGlzIG5lZWRlZCBpbiBSVEwgbW9kZSBmb3IgQ2hyb21lLCBvdGhlcndpc2UgbGFiZWxzIGFuZCBtYXJrcyBhcHBlYXIgYXQgdGhlIHRvcCBvZiB0aGUgY2VsbClcbiAgICAgIHByb3BzLm1hcmt1cCA/ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZGF5LW1hcmt1cFwiPicgKyBwcm9wcy5tYXJrdXAgKyAnPC9kaXY+JyA6ICcnKSArICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5BbGxNb250aHMoZmlyc3REYXksIHJlbmRlciwgaW5zZXJ0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIHkgPSBzLmdldFllYXIoZmlyc3REYXkpLFxuICAgICAgICBtID0gcy5nZXRNb250aChmaXJzdERheSksXG4gICAgICAgIHBvcyA9IGRheVNjcm9sbCA/IGRheVNjcm9sbC5wb3MgOiAwLFxuICAgICAgICBodG1sID0gJyc7XG4gICAgZGF5UHJvcHMgPSB7fTtcblxuICAgIGlmIChjYWxSb3dzKSB7XG4gICAgICBpZiAoIXJlbmRlcikge1xuICAgICAgICB0cmlnZ2VyKCdvbk1vbnRoTG9hZGluZycsIHtcbiAgICAgICAgICB5ZWFyOiB5LFxuICAgICAgICAgIG1vbnRoOiBtXG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkaW5nJywge1xuICAgICAgICAgIGZpcnN0RGF5OiBmaXJzdERheVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb25HZW5Nb250aChmaXJzdERheSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWdlVG90YWw7IGkrKykge1xuICAgICAgICBodG1sICs9IGdlbk1vbnRoKGdldFBhZ2VEYXkoZmlyc3REYXksIGkgLSBwYWdlT2Zmc2V0IC0gcGFnZUJ1ZmZlciksIHBvcyAqIHJ0bCArIGkgLSBwYWdlQnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IC8vYWN0aXZhdGVNb250aCgpOyAvLyBUT0RPOiA/Pz9cblxuXG4gICAgbmVlZHNSZWZyZXNoID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGluc2VydCAmJiBkYXlTY3JvbGwpIHtcbiAgICAgIGRheVNjcm9sbC4kYWN0aXZlID0gbnVsbDtcbiAgICAgIGRheVNjcm9sbC4kc2Nyb2xsZXIuaHRtbChodG1sKTtcbiAgICAgIG9uUGFnZUxvYWRlZChmaXJzdERheSwgeSwgbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBmb2N1c0RhdGUoZCwgZm9jdXMpIHtcbiAgICBpZiAoZGF5U2Nyb2xsKSB7XG4gICAgICB2YXIgJGFjdGl2ZSA9IGRheVNjcm9sbC4kYWN0aXZlO1xuXG4gICAgICBpZiAoJGFjdGl2ZSAmJiAkYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAkYWN0aXZlWzBdLmJsdXIoKTtcblxuICAgICAgICBpZiAoJGFjdGl2ZS5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgJGFjdGl2ZS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRhY3RpdmUuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXlTY3JvbGwuJGFjdGl2ZSA9ICQkMSgnLm1ic2MtY2FsLXNsaWRlLWEgLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgZ2V0RGF0ZVN0cihkKSArICdcIl0nLCBkYXlTY3JvbGwuJHNjcm9sbGVyKS5hdHRyKCd0YWJpbmRleCcsICcwJyk7XG5cbiAgICAgIGlmIChmb2N1cyAmJiBkYXlTY3JvbGwuJGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgZGF5U2Nyb2xsLiRhY3RpdmVbMF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHREYXRlKGQpIHtcbiAgICB2YXIgJGN0eCA9IGRheVNjcm9sbCAmJiBkYXlTY3JvbGwuJHNjcm9sbGVyO1xuXG4gICAgaWYgKHMuaGlnaGxpZ2h0ICYmIGRheVNjcm9sbCkge1xuICAgICAgJCQxKCcubWJzYy1zZWxlY3RlZCcsICRjdHgpLnJlbW92ZUNsYXNzKGNzc1NlbGVjdGVkKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG5cbiAgICAgIGlmIChzLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCB8fCBpbnN0Ll9oYXNWYWx1ZSkge1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC1kYXlbZGF0YS1mdWxsPVwiJyArIGdldERhdGVTdHIoZCkgKyAnXCJdJywgJGN0eCkuYWRkQ2xhc3MoY3NzU2VsZWN0ZWQpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodFNlbGVjdGVkKHYsICRjdHgpIHtcbiAgICAkJDEoJy5tYnNjLXNlbGVjdGVkJywgJGN0eCkucmVtb3ZlQ2xhc3MoY3NzU2VsZWN0ZWQpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAkJDEoJy5tYnNjLWNhbC1jZWxsW2RhdGEtdmFsPVwiJyArIHYgKyAnXCJdJywgJGN0eCkuYWRkQ2xhc3MoY3NzU2VsZWN0ZWQpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGF0ZShkLCBuYXYsIGFuaW0sIGZvY3VzKSB7XG4gICAgdmFyIGRpZmYsIG5ld0ZpcnN0RGF5O1xuXG4gICAgaWYgKCF2aXNpYmxlVGFiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGQgPCBtaW5EYXRlKSB7XG4gICAgICBkID0gbWluRGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZCA+IG1heERhdGUpIHtcbiAgICAgIGQgPSBtYXhEYXRlO1xuICAgIH1cblxuICAgIGlmICh2aXNpYmxlVGFiID09PSAnY2FsZW5kYXInIHx8ICFoYXNUYWJzIHx8IG5hdikge1xuICAgICAgaW5zdC5faXNTZXREYXRlID0gIW5hdjtcblxuICAgICAgaWYgKGhhc0NhbCAmJiBjYWxSb3dzKSB7XG4gICAgICAgIG5ld0ZpcnN0RGF5ID0gZ2V0Rmlyc3REYXkoY29uc3RyYWluKGQpLCBpc01vbnRoVmlldyk7XG5cbiAgICAgICAgaWYgKG5lZWRzU2xpZGUgJiYgKGQgPCBnZXRQYWdlRGF5KGN1cnJGaXJzdERheSwgLXBhZ2VPZmZzZXQpIHx8IGQgPj0gZ2V0UGFnZURheShjdXJyRmlyc3REYXksIHBhZ2VOciAtIHBhZ2VPZmZzZXQpKSkge1xuICAgICAgICAgIGRpZmYgPSBpc01vbnRoVmlldyA/IHMuZ2V0TW9udGgobmV3Rmlyc3REYXkpIC0gcy5nZXRNb250aChjdXJyRmlyc3REYXkpICsgKHMuZ2V0WWVhcihuZXdGaXJzdERheSkgLSBzLmdldFllYXIoY3VyckZpcnN0RGF5KSkgKiAxMiA6IE1hdGguZmxvb3IoZ2V0RGF5RGlmZihjdXJyRmlyc3REYXksIG5ld0ZpcnN0RGF5KSAvICg3ICogY2FsUm93cykpO1xuXG4gICAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHF1ZXVlIHRvIG5hdmlnYXRlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBkYXlTY3JvbGwucXVldWUgPSBbXTtcbiAgICAgICAgICAgIGRheVNjcm9sbC5mb2N1cyA9IGZvY3VzICYmIGFuaW07XG4gICAgICAgICAgICBjaGFuZ2VQYWdlUXVldWUoZGF5U2Nyb2xsLCBkaWZmLCBhbmltKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZmYgfHwgIWFuaW0pIHtcbiAgICAgICAgICBmb2N1c0RhdGUoZCwgZm9jdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYXYpIHtcbiAgICAgICAgICBoaWdobGlnaHREYXRlKGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc01vbnRoVmlldyAmJiAhZGlmZikge1xuICAgICAgICAgIHNldFRpdGxlKGN1cnJGaXJzdERheSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhY3RpdmVEYXRlID0gZDtcbiAgICAgICAgbmVlZHNTbGlkZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc3QuX29uU2V0RGF0ZShkLCBkaWZmKTtcblxuICAgICAgaW5zdC5faXNTZXREYXRlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGl0bGUoZCwgc2tpcEJ1dHRvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgeWVhcixcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRkLFxuICAgICAgICB5ID0gcy5nZXRZZWFyKGQpLFxuICAgICAgICBtID0gcy5nZXRNb250aChkKSxcbiAgICAgICAgeXkgPSB5ICsgeWVhclN1ZmZpeDtcblxuICAgIGlmIChoYXNRdWlja05hdikge1xuICAgICAgLy8gSGlnaGxpZ2h0IG1vbnRoXG4gICAgICBoaWdobGlnaHRTZWxlY3RlZChtLCBtb250aFNjcm9sbC4kc2Nyb2xsZXIpOyAvLyBIaWdobGlnaHQgeWVhclxuXG4gICAgICBoaWdobGlnaHRTZWxlY3RlZCh5LCB5ZWFyU2Nyb2xsLiRzY3JvbGxlcik7IC8vIFNjcm9sbCB0byBzZWxlY3RlZCB5ZWFyXG5cbiAgICAgIGNoYW5nZVBhZ2VRdWV1ZSh5ZWFyU2Nyb2xsLCBNYXRoLmZsb29yKHkgLyAxMikgLSBNYXRoLmZsb29yKHMuZ2V0WWVhcih5ZWFyU2Nyb2xsLmZpcnN0KSAvIDEyKSwgdHJ1ZSk7IC8vIERpc2FibGUgb3V0IG9mIHJhbmdlIG1vbnRoc1xuXG4gICAgICAkJDEoJy5tYnNjLWNhbC1jZWxsJywgbW9udGhTY3JvbGwuJHNjcm9sbGVyKS5yZW1vdmVDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuXG4gICAgICBpZiAoeSA9PT0gbWluWWVhcikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluTW9udGg7IGkrKykge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWNlbGxbZGF0YS12YWw9XCInICsgaSArICdcIl0nLCBtb250aFNjcm9sbC4kc2Nyb2xsZXIpLmFkZENsYXNzKCdtYnNjLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHkgPT09IG1heFllYXIpIHtcbiAgICAgICAgZm9yIChpID0gbWF4TW9udGggKyAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1jZWxsW2RhdGEtdmFsPVwiJyArIGkgKyAnXCJdJywgbW9udGhTY3JvbGwuJHNjcm9sbGVyKS5hZGRDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFza2lwQnV0dG9ucykge1xuICAgICAgLy8gRGlzYWJsZS9lbmFibGUgcHJldi9uZXh0IGJ1dHRvbnNcbiAgICAgIGNoZWNrQnRuKCQkMSgnLm1ic2MtY2FsLXByZXYtbScsICRtYXJrdXApLCBnZXRQYWdlRGF5KGQsIC1wYWdlT2Zmc2V0KSA8PSBtaW5EYXRlKTtcbiAgICAgIGNoZWNrQnRuKCQkMSgnLm1ic2MtY2FsLW5leHQtbScsICRtYXJrdXApLCBnZXRQYWdlRGF5KGQsIHBhZ2VOciAtIHBhZ2VPZmZzZXQpID4gbWF4RGF0ZSk7XG4gICAgICBjaGVja0J0bigkJDEoJy5tYnNjLWNhbC1wcmV2LXknLCAkbWFya3VwKSwgcy5nZXREYXRlKHkgLSAxLCBtICsgMSwgMSkgPD0gbWluRGF0ZSk7XG4gICAgICBjaGVja0J0bigkJDEoJy5tYnNjLWNhbC1uZXh0LXknLCAkbWFya3VwKSwgcy5nZXREYXRlKHkgKyAxLCBtLCAxKSA+IG1heERhdGUpO1xuICAgIH0gLy8gVXBkYXRlIHllYXIgaW4gaGVhZGVyXG5cblxuICAgICR5ZWFySGRyLmF0dHIoJ2FyaWEtbGFiZWwnLCB5KS5odG1sKHl5KTsgLy8gVXBkYXRlIG1vbnRoIGluIGhlYWRlclxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhZ2VOcjsgaSsrKSB7XG4gICAgICBkZCA9IGdldFBhZ2VEYXkoZCwgaSAtIHBhZ2VPZmZzZXQpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWREYXRlID49IGRkICYmIHNlbGVjdGVkRGF0ZSA8IGdldFBhZ2VEYXkoZGQsIDEpKSB7XG4gICAgICAgIGRkID0gc2VsZWN0ZWREYXRlO1xuICAgICAgfVxuXG4gICAgICB5ZWFyID0gcy5nZXRZZWFyKGRkKTtcbiAgICAgIG1vbnRoID0gcy5nZXRNb250aChkZCk7XG4gICAgICB5eSA9IHllYXIgKyB5ZWFyU3VmZml4O1xuICAgICAgJG1vbnRoSGRyLmVxKGkpLmF0dHIoJ2FyaWEtbGFiZWwnLCBzLm1vbnRoTmFtZXNbbW9udGhdICsgKHllYXJDaGFuZ2UgPyAnJyA6ICcgJyArIHkpKS5odG1sKCgheWVhckNoYW5nZSAmJiB5ZWFySW5kZXggPCBtb250aEluZGV4ID8geXkgKyAnICcgOiAnJykgKyBtb250aE5hbWVzW21vbnRoXSArICgheWVhckNoYW5nZSAmJiB5ZWFySW5kZXggPiBtb250aEluZGV4ID8gJyAnICsgeXkgOiAnJykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQnRuKCRidG4sIGRpc2FibGUpIHtcbiAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgJGJ0bi5hZGRDbGFzcyhjc3NEaXNhYmxlZCkuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRidG4ucmVtb3ZlQ2xhc3MoY3NzRGlzYWJsZWQpLnJlbW92ZUF0dHIoJ2FyaWEtZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXlJbmZvKCRkYXkpIHtcbiAgICB2YXIgZGF5ID0gJGRheVswXSxcbiAgICAgICAgZnVsbCA9ICRkYXkuYXR0cignZGF0YS1mdWxsJyksXG4gICAgICAgIHBhcnRzID0gZnVsbCA/IGZ1bGwuc3BsaXQoJy0nKSA6IFtdLFxuICAgICAgICBkID0gYWRqdXN0ZWREYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkZGF5Lmhhc0NsYXNzKCdtYnNjLXNlbGVjdGVkJyk7XG4gICAgcmV0dXJuIGV4dGVuZCQxKGRheVByb3BzID8gZGF5UHJvcHNbZnVsbF0gOiB7fSwge1xuICAgICAgZGF0ZTogZCxcbiAgICAgIHRhcmdldDogZGF5LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3REYXkoJGRheSwgZXYpIHtcbiAgICB2YXIgY3VyciA9IGluc3QuZ2V0RGF0ZSh0cnVlKSxcbiAgICAgICAgcHJvcHMgPSBnZXREYXlJbmZvKCRkYXkpLFxuICAgICAgICBkYXkgPSAkZGF5WzBdLFxuICAgICAgICBkID0gcHJvcHMuZGF0ZSxcbiAgICAgICAgZHRpbWUgPSBhZGp1c3RlZERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpLCBjdXJyLmdldEhvdXJzKCksIGN1cnIuZ2V0TWludXRlcygpLCBjdXJyLmdldFNlY29uZHMoKSksXG4gICAgICAgICR0YXJnZXQgPSAkJDEoZXYudGFyZ2V0KSxcbiAgICAgICAgdGFyZ2V0ID0gJHRhcmdldFswXTtcblxuICAgIGlmICghZGF5UHJvcHMgfHwgIXNob3dPdXRlckRheXMgJiYgJGRheS5oYXNDbGFzcygnbWJzYy1jYWwtZGF5LWRpZmYnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3BzLmRhdGUgPSBkdGltZTsgLy8gQ2hlY2sgaWYgYSBsYWJlbCB3YXMgdGFwcGVkXG5cbiAgICBpZiAoaGFzTGFiZWxzICYmIGRheS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICB3aGlsZSAodGFyZ2V0ICE9IGRheSkge1xuICAgICAgICBpZiAoJHRhcmdldC5oYXNDbGFzcygnbWJzYy1jYWwtdHh0JykgfHwgJHRhcmdldC5oYXNDbGFzcygnbWJzYy1jYWwtdHh0LW1vcmUnKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9ICR0YXJnZXQuYXR0cignZGF0YS1pbmRleCcpO1xuICAgICAgICAgIHZhciBsYWJlbHMgPSBsYWJlbHNPYmpbZF07XG5cbiAgICAgICAgICBpZiAodHJpZ2dlcignb25MYWJlbFRhcCcsIHtcbiAgICAgICAgICAgIGRhdGU6IGR0aW1lLFxuICAgICAgICAgICAgZG9tRXZlbnQ6IGV2LFxuICAgICAgICAgICAgdGFyZ2V0OiAkdGFyZ2V0WzBdLFxuICAgICAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxzW2luZGV4XVxuICAgICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRhcmdldCA9ICR0YXJnZXQucGFyZW50KCk7XG4gICAgICAgIHRhcmdldCA9ICR0YXJnZXRbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXIoJ29uRGF5Q2hhbmdlJywgcHJvcHMpICE9PSBmYWxzZSAmJiAhcy5yZWFkb25seSAmJiAhJGRheS5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICBpbnN0Ll9zZWxlY3REYXkoJGRheSwgZCwgZHRpbWUsIHByb3BzLnNlbGVjdGVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RNb250aCgkbW9udGgpIHtcbiAgICBoaWRlQ29udCgkbW9udGhQaWNrZXIpO1xuICAgIHNldERhdGUocy5nZXREYXRlKHMuZ2V0WWVhcihkYXlTY3JvbGwuZmlyc3QpLCAkbW9udGguYXR0cignZGF0YS12YWwnKSwgMSksIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0WWVhcigkeWVhcikge1xuICAgIGhpZGVDb250KCR5ZWFyUGlja2VyKTtcbiAgICBzZXREYXRlKHMuZ2V0RGF0ZSgkeWVhci5hdHRyKCdkYXRhLXZhbCcpLCBzLmdldE1vbnRoKGRheVNjcm9sbC5maXJzdCksIDEpLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0RGF5KGQsIGlzTW9udGgsIHcpIHtcbiAgICB2YXIgeSA9IHMuZ2V0WWVhcihkKSxcbiAgICAgICAgbSA9IHMuZ2V0TW9udGgoZCksXG4gICAgICAgIHdlZWtEYXkgPSBkLmdldERheSgpLFxuICAgICAgICBvZmZzZXQgPSBmaXJzdFdlZWtEYXkgLSB3ZWVrRGF5ID4gMCA/IDcgOiAwO1xuICAgIHJldHVybiBpc01vbnRoID8gcy5nZXREYXRlKHksIG0sIDEpIDogcy5nZXREYXRlKHksIG0sICh3ID09PSB1bmRlZmluZWQgPyBmaXJzdFdlZWtEYXkgOiB3KSAtIG9mZnNldCAtIHdlZWtEYXkgKyBzLmdldERheShkKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYWdlRGF5KGQsIGRpZmYpIHtcbiAgICB2YXIgeWVhciA9IHMuZ2V0WWVhcihkKSxcbiAgICAgICAgbW9udGggPSBzLmdldE1vbnRoKGQpLFxuICAgICAgICBkYXkgPSBzLmdldERheShkKTtcbiAgICByZXR1cm4gaXNNb250aFZpZXcgPyBzLmdldERhdGUoeWVhciwgbW9udGggKyBkaWZmLCAxKSA6IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCwgZGF5ICsgZGlmZiAqIGNhbFJvd3MgKiA3KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhZ2VZZWFyKGQsIGRpZmYpIHtcbiAgICB2YXIgeWVhciA9IE1hdGguZmxvb3Iocy5nZXRZZWFyKGQpIC8gMTIpICogMTI7XG4gICAgcmV0dXJuIHMuZ2V0RGF0ZSh5ZWFyICsgZGlmZiAqIDEyLCAwLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVBhZ2VRdWV1ZShwcm9wcywgZGlmZiwgYW5pbSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWRpZmYgfHwgIWluc3QuX2lzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb3BzLnF1ZXVlLnB1c2goYXJndW1lbnRzKTtcblxuICAgIGlmIChwcm9wcy5xdWV1ZS5sZW5ndGggPT0gMSkge1xuICAgICAgY2hhbmdlUGFnZShwcm9wcywgZGlmZiwgYW5pbSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVBhZ2UocHJvcHMsIGRpZmYsIGFuaW0sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGluYyxcbiAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICAkc2Nyb2xsZXIgPSBwcm9wcy4kc2Nyb2xsZXIsXG4gICAgICAgIHBhZ2VCdWZmZXIgPSBwcm9wcy5idWZmZXIsXG4gICAgICAgIHBhZ2VPZmZzZXQgPSBwcm9wcy5vZmZzZXQsXG4gICAgICAgIHBhZ2VOciA9IHByb3BzLnBhZ2VzLFxuICAgICAgICBwYWdlVG90YWwgPSBwcm9wcy50b3RhbCxcbiAgICAgICAgZmlyc3REYXkgPSBwcm9wcy5maXJzdCxcbiAgICAgICAgZ2VuUGFnZSA9IHByb3BzLmdlblBhZ2UsXG4gICAgICAgIGdldEZpcnN0ID0gcHJvcHMuZ2V0Rmlyc3QsXG4gICAgICAgIG1vdmUgPSBkaWZmID4gMCA/IE1hdGgubWluKGRpZmYsIHBhZ2VCdWZmZXIpIDogTWF0aC5tYXgoZGlmZiwgLXBhZ2VCdWZmZXIpLFxuICAgICAgICBwb3MgPSBwcm9wcy5wb3MgKiBydGwgKyBtb3ZlIC0gZGlmZiArIHBhZ2VPZmZzZXQsXG4gICAgICAgIGxvYWQgPSBNYXRoLmFicyhkaWZmKSA+IHBhZ2VCdWZmZXI7IC8vIENhbGwgYW55IHBlbmRpbmcgY2FsbGJhY2tcblxuICAgIGlmIChwcm9wcy5jYWxsYmFjaykge1xuICAgICAgcHJvcHMubG9hZCgpO1xuICAgICAgcHJvcHMuY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvcHMuZmlyc3QgPSBnZXRGaXJzdChmaXJzdERheSwgZGlmZik7XG4gICAgcHJvcHMucG9zICs9IG1vdmUgKiBydGw7XG4gICAgcHJvcHMuY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgcHJvcHMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWdlTnI7IGkrKykge1xuICAgICAgICAgIGluYyA9IGRpZmYgKyBpIC0gcGFnZU9mZnNldDsgLy8gPz8/XG5cbiAgICAgICAgICBodG1sICs9IGdlblBhZ2UoZ2V0Rmlyc3QoZmlyc3REYXksIGluYyksIHBvcyArIGluYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UoLXBhZ2VOcikucmVtb3ZlKCk7XG4gICAgICAgICAgJHNjcm9sbGVyLmFwcGVuZChodG1sKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlJywgJHNjcm9sbGVyKS5zbGljZSgwLCBwYWdlTnIpLnJlbW92ZSgpO1xuICAgICAgICAgICRzY3JvbGxlci5wcmVwZW5kKGh0bWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHByb3BzLmNhbGxiYWNrID0gZnVuY3Rpb24gKGZvcmNlU3RvcCkge1xuICAgICAgdmFyIG5yID0gTWF0aC5hYnMobW92ZSksXG4gICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICBpZiAoIWluc3QuX2lzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBucjsgaSsrKSB7XG4gICAgICAgIGluYyA9IGRpZmYgKyBpIC0gcGFnZU9mZnNldCAtIHBhZ2VCdWZmZXIgKyAoZGlmZiA+IDAgPyBwYWdlVG90YWwgLSBuciA6IDApOyAvLyA/Pz9cblxuICAgICAgICBodG1sICs9IGdlblBhZ2UoZ2V0Rmlyc3QoZmlyc3REYXksIGluYyksIHBvcyArIGluYyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAkc2Nyb2xsZXIuYXBwZW5kKGh0bWwpO1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UoMCwgbW92ZSkucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICRzY3JvbGxlci5wcmVwZW5kKGh0bWwpO1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UobW92ZSkucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2FkKSB7XG4gICAgICAgIGh0bWwgPSAnJztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykge1xuICAgICAgICAgIGluYyA9IGRpZmYgKyBpIC0gcGFnZU9mZnNldCAtIHBhZ2VCdWZmZXIgKyAoZGlmZiA+IDAgPyAwIDogcGFnZVRvdGFsIC0gbnIpOyAvLyA/Pz9cblxuICAgICAgICAgIGh0bWwgKz0gZ2VuUGFnZShnZXRGaXJzdChmaXJzdERheSwgaW5jKSwgcG9zICsgaW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlJywgJHNjcm9sbGVyKS5zbGljZSgwLCBtb3ZlKS5yZW1vdmUoKTtcbiAgICAgICAgICAkc2Nyb2xsZXIucHJlcGVuZChodG1sKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlJywgJHNjcm9sbGVyKS5zbGljZShtb3ZlKS5yZW1vdmUoKTtcbiAgICAgICAgICAkc2Nyb2xsZXIuYXBwZW5kKGh0bWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hTY3JvbGxlcihwcm9wcyk7XG5cbiAgICAgIGlmIChjYWxsYmFjayAmJiAhZm9yY2VTdG9wKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIHByb3BzLmxvYWQgPSBudWxsO1xuICAgICAgcHJvcHMucXVldWUuc2hpZnQoKTtcbiAgICAgIGxvYWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHByb3BzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VQYWdlLmFwcGx5KHRoaXMsIHByb3BzLnF1ZXVlWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzLmNoYW5naW5nID0gZmFsc2U7XG4gICAgICAgIHByb3BzLm9uQWZ0ZXJDaGFuZ2UocHJvcHMuZmlyc3QpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9wcy5vbkJlZm9yZUNoYW5nZShwcm9wcy5maXJzdCk7XG5cbiAgICBpZiAocHJvcHMubG9hZCkge1xuICAgICAgcHJvcHMubG9hZCgpO1xuICAgICAgcHJvcHMuc2Nyb2xsZXIuc2Nyb2xsKC1wcm9wcy5wb3MgKiBwcm9wcy5zaXplLCBhbmltID8gMjAwIDogMCwgZmFsc2UsIHByb3BzLmNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTY3JvbGxlcihjb250LCBtaW4sIG1heCwgYnVmZmVyLCBvZmZzZXQsIHBhZ2VzLCB0b3RhbCwgZmlyc3QsIG9uVGFwLCBvbkJlZm9yZUNoYW5nZSwgb25BZnRlckNoYW5nZSwgZ2VuUGFnZSwgZ2V0Rmlyc3QpIHtcbiAgICB2YXIgYXhpcyA9IGlzVmVydGljYWwgPyAnWScgOiAnWCcsXG4gICAgICAgIHByb3BzID0ge1xuICAgICAgJHNjcm9sbGVyOiAkJDEoJy5tYnNjLWNhbC1zY3JvbGwnLCBjb250KSxcbiAgICAgIHF1ZXVlOiBbXSxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBwYWdlczogcGFnZXMsXG4gICAgICBmaXJzdDogZmlyc3QsXG4gICAgICB0b3RhbDogdG90YWwsXG4gICAgICBwb3M6IDAsXG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgZ2VuUGFnZTogZ2VuUGFnZSxcbiAgICAgIGdldEZpcnN0OiBnZXRGaXJzdCxcbiAgICAgIG9uQmVmb3JlQ2hhbmdlOiBvbkJlZm9yZUNoYW5nZSxcbiAgICAgIG9uQWZ0ZXJDaGFuZ2U6IG9uQWZ0ZXJDaGFuZ2VcbiAgICB9O1xuICAgIHByb3BzLnNjcm9sbGVyID0gbmV3IFNjcm9sbFZpZXdCYXNlKGNvbnQsIHtcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBlYXNpbmc6ICcnLFxuICAgICAgY29udFNpemU6IDAsXG4gICAgICBtYXhTbmFwU2Nyb2xsOiBidWZmZXIsXG4gICAgICBtb3VzZXdoZWVsOiBzLm1vdXNld2hlZWwgPT09IHVuZGVmaW5lZCA/IGlzVmVydGljYWwgOiBzLm1vdXNld2hlZWwsXG4gICAgICB0aW1lOiAyMDAsXG4gICAgICBsb2NrOiB0cnVlLFxuICAgICAgcnRsOiBpc1JUTCxcbiAgICAgIHN0b3BQcm9wOiBmYWxzZSxcbiAgICAgIG1pblNjcm9sbDogMCxcbiAgICAgIG1heFNjcm9sbDogMCxcbiAgICAgIG9uQnRuVGFwOiBmdW5jdGlvbiBvbkJ0blRhcChldikge1xuICAgICAgICBpZiAoZXYuZG9tRXZlbnQudHlwZSA9PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgcHJldmVudENsaWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvblRhcCgkJDEoZXYudGFyZ2V0KSwgZXYuZG9tRXZlbnQpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVyKTtcbiAgICAgIH0sXG4gICAgICBvbkdlc3R1cmVTdGFydDogZnVuY3Rpb24gb25HZXN0dXJlU3RhcnQoKSB7XG4gICAgICAgIGlzUGFnZU1vdmUgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIG9uQW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uIG9uQW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgICAgIHByb3BzLmNoYW5naW5nID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvbkFuaW1hdGlvbkVuZDogZnVuY3Rpb24gb25BbmltYXRpb25FbmQoZXYpIHtcbiAgICAgICAgaXNQYWdlTW92ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChnZW5QYWdlKSB7XG4gICAgICAgICAgY2hhbmdlUGFnZVF1ZXVlKHByb3BzLCBNYXRoLnJvdW5kKCgtcHJvcHMucG9zICogcHJvcHMuc2l6ZSAtIGV2Wydwb3MnICsgYXhpc10pIC8gcHJvcHMuc2l6ZSkgKiBydGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbnN0Ll9zY3JvbGxlcnMucHVzaChwcm9wcy5zY3JvbGxlcik7XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsZXIocHJvcHMsIGNoZWNrKSB7XG4gICAgdmFyIHNpemUsXG4gICAgICAgIHBsdXMgPSAwLFxuICAgICAgICBtaW51cyA9IDAsXG4gICAgICAgIGZpcnN0RGF5ID0gcHJvcHMuZmlyc3Q7XG5cbiAgICBpZiAocHJvcHMuY2hhbmdpbmcgJiYgY2hlY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZ2V0Rmlyc3QpIHtcbiAgICAgIHBsdXMgPSBwcm9wcy5idWZmZXI7XG4gICAgICBtaW51cyA9IHByb3BzLmJ1ZmZlcjsgLy93aGlsZSAobWludXMgJiYgcy5nZXREYXRlKHksIG0gKyBtaW51cyArIG1vbnRoTnIgLSBtb3ZlTW9udGggLSAxLCAxKSA+IG1heERhdGUpIHsgPz8/XG5cbiAgICAgIHdoaWxlIChtaW51cyAmJiBwcm9wcy5nZXRGaXJzdChmaXJzdERheSwgbWludXMgKyBwcm9wcy5wYWdlcyAtIHByb3BzLm9mZnNldCAtIDEpID4gcHJvcHMubWF4KSB7XG4gICAgICAgIG1pbnVzLS07XG4gICAgICB9IC8vd2hpbGUgKHBsdXMgJiYgcy5nZXREYXRlKHksIG0gLSBwbHVzIC0gbW92ZU1vbnRoLCAxKSA8IG1pbkRhdGUpIHsgPz8/XG5cblxuICAgICAgd2hpbGUgKHBsdXMgJiYgcHJvcHMuZ2V0Rmlyc3QoZmlyc3REYXksIDEgLSBwbHVzIC0gcHJvcHMub2Zmc2V0KSA8PSBwcm9wcy5taW4pIHtcbiAgICAgICAgcGx1cy0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNpemUgPSBNYXRoLnJvdW5kKGNhbFNpemUgLyBwcm9wcy5wYWdlcyk7IC8vIFBhZ2Ugc2l6ZSBtaWdodCBiZSBhIGZyYWN0aW9uYWwgdmFsdWUgaW4gY2FzZSBvZiBtdWx0aXBsZSBtb250aHNcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSByb3VuZGVkIHZhbHVlXG5cbiAgICBpZiAoaXNMaXF1aWQgJiYgc2l6ZSAmJiBwcm9wcy5zaXplICE9IHNpemUpIHtcbiAgICAgIHByb3BzLiRzY3JvbGxlcltpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnXShzaXplKTtcbiAgICB9XG5cbiAgICBleHRlbmQkMShwcm9wcy5zY3JvbGxlci5zZXR0aW5ncywge1xuICAgICAgc25hcDogc2l6ZSxcbiAgICAgIG1pblNjcm9sbDogKC1wcm9wcy5wb3MgKiBydGwgLSBtaW51cykgKiBzaXplLFxuICAgICAgbWF4U2Nyb2xsOiAoLXByb3BzLnBvcyAqIHJ0bCArIHBsdXMpICogc2l6ZVxuICAgIH0pO1xuICAgIHByb3BzLnNpemUgPSBzaXplO1xuICAgIHByb3BzLnNjcm9sbGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2gocmVuZGVyKSB7XG4gICAgaW5zdC5fb25SZWZyZXNoKHJlbmRlcik7XG5cbiAgICBpZiAoaW5zdC5faXNWaXNpYmxlICYmIGhhc0NhbCAmJiBjYWxSb3dzKSB7XG4gICAgICBpZiAoZGF5U2Nyb2xsICYmIGRheVNjcm9sbC5jaGFuZ2luZykge1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSByZW5kZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5BbGxNb250aHMoY3VyckZpcnN0RGF5LCByZW5kZXIsIHRydWUpO1xuICAgICAgICBmb2N1c0RhdGUoYWN0aXZlRGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2KSB7XG4gICAgd2FzVG91Y2hlZCA9IGV2LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICBpZiAoaGFzQ2FsICYmIGNhbFJvd3MpIHtcbiAgICAgIHZhciAkc2Nyb2xsZXJzID0gJCQxKCcubWJzYy1jYWwtc2Nyb2xsLWMnLCAkbWFya3VwKTsgLy8gRGF5IHNlbGVjdG9yXG5cbiAgICAgIGRheVNjcm9sbCA9IGNyZWF0ZVNjcm9sbGVyKCRzY3JvbGxlcnNbMF0sIG1pbkRhdGUsIG1heERhdGUsIHBhZ2VCdWZmZXIsIHBhZ2VPZmZzZXQsIHBhZ2VOciwgcGFnZVRvdGFsLCBjdXJyRmlyc3REYXksIHNlbGVjdERheSwgb25CZWZvcmVNb250aENoYW5nZSwgb25BZnRlck1vbnRoQ2hhbmdlLCBnZW5Nb250aCwgZ2V0UGFnZURheSk7XG5cbiAgICAgIGlmIChoYXNRdWlja05hdikge1xuICAgICAgICAvLyBNb250aCBzZWxlY3RvclxuICAgICAgICBtb250aFNjcm9sbCA9IGNyZWF0ZVNjcm9sbGVyKCRzY3JvbGxlcnNbMV0sIG51bGwsIG51bGwsIDEsIDAsIDEsIDMsIGN1cnJGaXJzdERheSwgc2VsZWN0TW9udGgpOyAvLyBZZWFyIHNlbGVjdG9yXG5cbiAgICAgICAgeWVhclNjcm9sbCA9IGNyZWF0ZVNjcm9sbGVyKCRzY3JvbGxlcnNbMl0sIG1pbkZpcnN0WWVhciwgbWF4Rmlyc3RZZWFyLCAxLCAwLCAxLCAzLCBjdXJyRmlyc3REYXksIHNlbGVjdFllYXIsIG5vb3AsIG5vb3AsIGdlblllYXJzLCBnZXRQYWdlWWVhcik7IC8vIFNob3cgLyBoaWRlIG1vbnRoIHBpY2tlclxuXG4gICAgICAgIGluc3QudGFwKCRtb250aEhkciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRvZ2dsZUNvbnQoJG1vbnRoUGlja2VyKTtcbiAgICAgICAgICBoaWRlQ29udCgkeWVhclBpY2tlcik7XG4gICAgICAgIH0pOyAvLyBTaG93IC8gaGlkZSB5ZWFyIHBpY2tlclxuXG4gICAgICAgIGluc3QudGFwKCR5ZWFySGRyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdG9nZ2xlQ29udCgkeWVhclBpY2tlcik7XG4gICAgICAgICAgaGlkZUNvbnQoJG1vbnRoUGlja2VyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEluaXQgbmF2aWdhdGlvbiBhcnJvd3NcblxuXG4gICAgICBjcmVhdGVTdGVwcGVyKCQkMSgnLm1ic2MtY2FsLWJ0bicsICRtYXJrdXApLCBmdW5jdGlvbiAoaSwgZGlmZiwgZXYsIG5leHQpIHtcbiAgICAgICAgY2hhbmdlUGFnZVF1ZXVlKGRheVNjcm9sbCwgZGlmZiwgdHJ1ZSwgbmV4dCk7XG4gICAgICB9KTsgLy8gVHJpZ2dlcnMgb25Nb250aExvYWRlZCBvbiBpbml0aWFsIHJlbmRlclxuXG4gICAgICBvbkFmdGVyTW9udGhDaGFuZ2UoY3VyckZpcnN0RGF5KTsgLy8gRm9jdXMgb24gdGhlIHNlbGVjdGVkIGRhdGUgb24gc2hvd1xuXG4gICAgICBpZiAoKHMuZGVmYXVsdFZhbHVlICE9PSBudWxsIHx8IGluc3QuX2hhc1ZhbHVlKSAmJiAhaW5zdC5fbXVsdGlwbGUpIHtcbiAgICAgICAgaW5zdC5fYWN0aXZlRWxtID0gZGF5U2Nyb2xsLiRhY3RpdmVbMF07XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbigkY2FsZW5kYXJbMF0sICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKCRjYWxlbmRhclswXSwgJ21vdXNlZG93bicsIG9uVG91Y2hTdGFydCk7XG4gICAgICAkY2FsZW5kYXIgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciB5ZWFyID0gcy5nZXRZZWFyKGFjdGl2ZURhdGUpLFxuICAgICAgICAgICAgbW9udGggPSBzLmdldE1vbnRoKGFjdGl2ZURhdGUpLFxuICAgICAgICAgICAgZGF5ID0gcy5nZXREYXkoYWN0aXZlRGF0ZSksXG4gICAgICAgICAgICBuZXdEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAoZXYua2V5Q29kZSkge1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAvL1NQQUNFXG4gICAgICAgICAgICBzZWxlY3REYXkoZGF5U2Nyb2xsLiRhY3RpdmUsIGV2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIC8vTEVGVF9BUlJPVzpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSAtIDEgKiBydGwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgLy9SSUdIVF9BUlJPVzpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSArIDEgKiBydGwpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgLy9VUF9BUlJPVzpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSAtIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgLy9ET1dOX0FSUk9XOlxuICAgICAgICAgICAgbmV3RGF0ZSA9IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCwgZGF5ICsgNyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAvL0hPTUU6XG4gICAgICAgICAgICBuZXdEYXRlID0gcy5nZXREYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgIC8vRU5EOlxuICAgICAgICAgICAgbmV3RGF0ZSA9IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCArIDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgLy9QQUdFX1VQOlxuICAgICAgICAgICAgbmV3RGF0ZSA9IGV2LmFsdEtleSA/IHMuZ2V0RGF0ZSh5ZWFyIC0gMSwgbW9udGgsIGRheSkgOiBpc01vbnRoVmlldyA/IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkgOiBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSAtIGNhbFJvd3MgKiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIC8vUEFHRV9ET1dOOlxuICAgICAgICAgICAgbmV3RGF0ZSA9IGV2LmFsdEtleSA/IHMuZ2V0RGF0ZSh5ZWFyICsgMSwgbW9udGgsIGRheSkgOiBpc01vbnRoVmlldyA/IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCArIDEsIGRheSkgOiBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSArIGNhbFJvd3MgKiA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0RhdGUpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNldERhdGUobmV3RGF0ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRhYnNcblxuXG4gICAgaW5zdC50YXAoJCQxKCcubWJzYy1jYWwtdGFiJywgJG1hcmt1cCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGluc3QuY2hhbmdlVGFiKCQkMSh0aGlzKS5hdHRyKCdkYXRhLWNvbnRyb2wnKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcmVQcm9jZXNzU2V0dGluZ3MoKTtcbiAgYmFzZSA9IERhdGVUaW1lLmNhbGwodGhpcywgaW5zdCk7XG4gIHBvc3RQcm9jZXNzU2V0dGluZ3MoKTsgLy8gUHVibGljIGZ1bmN0aW9uc1xuICAvLyAtLS1cblxuICBpbnN0LnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVmcmVzaChmYWxzZSk7XG4gIH07XG5cbiAgaW5zdC5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVmcmVzaCh0cnVlKTtcbiAgfTtcblxuICBpbnN0Lm5hdmlnYXRlID0gZnVuY3Rpb24gKGQsIGFuaW0pIHtcbiAgICBzZXREYXRlKG1ha2VEYXRlKGQsIGRpc3BsYXlGb3JtYXQsIHMpLCB0cnVlLCBhbmltKTtcbiAgfTtcblxuICBpbnN0LmNoYW5nZVRhYiA9IGZ1bmN0aW9uICh0YWIpIHtcbiAgICBpZiAoIWluc3QuX2lzVmlzaWJsZSB8fCAhY29udHJvbHNbdGFiXSB8fCB2aXNpYmxlVGFiID09IHRhYikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZpc2libGVUYWIgPSB0YWI7XG4gICAgJCQxKCcubWJzYy1jYWwtdGFiJywgJG1hcmt1cCkucmVtb3ZlQ2xhc3MoY3NzU2VsZWN0ZWRUYWIpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAkJDEoJy5tYnNjLWNhbC10YWJbZGF0YS1jb250cm9sPVwiJyArIHRhYiArICdcIl0nLCAkbWFya3VwKS5hZGRDbGFzcyhjc3NTZWxlY3RlZFRhYikuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG5cbiAgICBpZiAoaGFzVGFicykge1xuICAgICAgJHRhYlBhbmVzLmFkZENsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgICBjb250cm9sc1t2aXNpYmxlVGFiXS5yZW1vdmVDbGFzcygnbWJzYy1jYWwtaCcpO1xuICAgIH1cblxuICAgIGlmICh2aXNpYmxlVGFiID09ICdjYWxlbmRhcicpIHtcbiAgICAgIC8vIFNldCB0aGUgZGF0ZSBvZiB0aGUgY2FsZW5kYXIgaWYgZGF0ZSBjaGFuZ2VkIGZyb20gdGhlIHNjcm9sbGVyXG4gICAgICBzZXREYXRlKGluc3QuZ2V0RGF0ZSh0cnVlKSwgZmFsc2UsIHRydWUpO1xuICAgIH0gLy8gSGlkZVxuXG5cbiAgICBpbnN0Ll9zaG93RGF5UGlja2VyKCk7XG5cbiAgICBpbnN0LnRyaWdnZXIoJ29uVGFiQ2hhbmdlJywge1xuICAgICAgdGFiOiB2aXNpYmxlVGFiXG4gICAgfSk7XG4gIH07IC8vIC0tLVxuICAvLyBQcm90ZWN0ZWQgZnVuY3Rpb25zXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5fY2hlY2tTaXplID0gdHJ1ZTtcbiAgaW5zdC5fb25HZW5Nb250aCA9IG5vb3A7XG4gIGluc3QuX29uU2V0RGF0ZSA9IG5vb3A7XG4gIGluc3QuX29uUmVmcmVzaCA9IG5vb3A7XG4gIGluc3QuX2dldERheVByb3BzID0gbm9vcDtcbiAgaW5zdC5fcHJlcGFyZU9iaiA9IHByZXBhcmVPYmo7XG5cbiAgaW5zdC5fc2hvd0RheVBpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzUXVpY2tOYXYpIHtcbiAgICAgIGhpZGVDb250KCR5ZWFyUGlja2VyKTtcbiAgICAgIGhpZGVDb250KCRtb250aFBpY2tlcik7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuX3NlbGVjdERheSA9IGluc3QuX19zZWxlY3REYXkgPSBmdW5jdGlvbiAoJGRheSwgZCwgZHRpbWUpIHtcbiAgICB2YXIgZmlsbCA9IGluc3QubGl2ZTsgLy8gUHJldmVudHMgbW9udGggc2xpZGUgaW4gc2V0RGF0ZVxuXG4gICAgbmVlZHNTbGlkZSA9IHMub3V0ZXJNb250aENoYW5nZTtcbiAgICBpc0RheUNsaWNrID0gdHJ1ZTsgLy8gU2V0IGRhdGUgb24gc2Nyb2xsZXJcblxuICAgIGluc3Quc2V0RGF0ZShkdGltZSwgZmlsbCwgMTAwMCwgIWZpbGwsIHRydWUpO1xuXG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRyaWdnZXIoJ29uU2V0Jywge1xuICAgICAgICB2YWx1ZVRleHQ6IGluc3QuX3ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaW5zdC5fY2hlY2tCdG4gPSBjaGVja0J0bjsgLy8gLS0tXG5cbiAgcmV0dXJuIGV4dGVuZCQxKGJhc2UsIHtcbiAgICBsYWJlbHM6IG51bGwsXG4gICAgLy8gT3ZlcnJpZGVzIGxhYmVscyBjb21pbmcgZnJvbSBsYW5ndWFnZSBmaWxlc1xuICAgIGNvbXBDbGFzczogJ21ic2MtY2FsZW5kYXIgbWJzYy1kdCBtYnNjLXNjJyxcbiAgICBldmVudE9yZGVyOiBjb21wYXJlRXZlbnRzLFxuICAgIG9uTWFya3VwUmVhZHk6IGZ1bmN0aW9uIG9uTWFya3VwUmVhZHkoZXYpIHtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgICRtYXJrdXAgPSAkJDEoZXYudGFyZ2V0KTtcbiAgICAgICR0YWJQYW5lQ29udCA9ICQkMSgnLm1ic2MtZnItYycsICRtYXJrdXApO1xuICAgICAgYWN0aXZlRGF0ZSA9IGluc3QuZ2V0RGF0ZSh0cnVlKTtcbiAgICAgIGNhbFNpemUgPSAwO1xuXG4gICAgICBpZiAoaGFzQ2FsKSB7XG4gICAgICAgIGhhc01hcmtzID0gISEocy5tYXJrZWQgfHwgcy5kYXRhKSAmJiAhcy5sYWJlbHMgJiYgIXMubXVsdGlMYWJlbCAmJiAhcy5zaG93RXZlbnRDb3VudDsgLy8gaGFzVGV4dCA9IHMuc2hvd0V2ZW50Q291bnQgfHwgISEocy5ldmVudHMgfHwgcy5sYWJlbHMpO1xuXG4gICAgICAgIG5lZWRzU2xpZGUgPSB0cnVlO1xuICAgICAgICB2aXNpYmxlVGFiID0gJ2NhbGVuZGFyJztcbiAgICAgICAgY2FsY01vbnRoTnIoKTtcbiAgICAgICAgY3VyckZpcnN0RGF5ID0gZ2V0Rmlyc3REYXkoY29uc3RyYWluKGFjdGl2ZURhdGUpLCBpc01vbnRoVmlldyk7XG4gICAgICAgICR0YWJQYW5lQ29udC5hcHBlbmQoZ2VuQ2FsTWFya3VwKCkpO1xuICAgICAgICAkbW9udGhIZHIgPSAkJDEoJy5tYnNjLWNhbC1tb250aCcsICRtYXJrdXApO1xuICAgICAgICAkeWVhckhkciA9ICQkMSgnLm1ic2MtY2FsLXllYXInLCAkbWFya3VwKTtcbiAgICAgICAgJGNhbGVuZGFyID0gJCQxKCcubWJzYy1jYWwtZGF5LXNjcm9sbC1jJywgJG1hcmt1cCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNRdWlja05hdikge1xuICAgICAgICAkeWVhclBpY2tlciA9ICQkMSgnLm1ic2MtY2FsLXllYXItcGlja2VyJywgJG1hcmt1cCk7XG4gICAgICAgICRtb250aFBpY2tlciA9ICQkMSgnLm1ic2MtY2FsLW1vbnRoLXBpY2tlcicsICRtYXJrdXApO1xuICAgICAgfVxuXG4gICAgICAkdGFiUGFuZXMgPSAkJDEoJy5tYnNjLXctcCcsICRtYXJrdXApOyAvLyBJbnNlcnQgdGFiIG1hcmt1cFxuXG4gICAgICBpZiAoY29udHJvbHNBcnJheS5sZW5ndGggPiAxKSB7XG4gICAgICAgICR0YWJQYW5lQ29udC5iZWZvcmUoZ2VuVGFiTWFya3VwKCkpO1xuICAgICAgfSAvLyBGaW5kIG1hcmt1cCBmb3IgY29udHJvbHNcblxuXG4gICAgICBbJ2RhdGUnLCAndGltZScsICdjYWxlbmRhciddLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xzW3ZdKSB7XG4gICAgICAgICAgY29udHJvbHNbdl0gPSAkdGFiUGFuZXMuZXEoaik7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT0gJ2RhdGUnICYmICFjb250cm9scy5kYXRlICYmIGhhc0NhbCkge1xuICAgICAgICAgICR0YWJQYW5lcy5lcShqKS5yZW1vdmUoKTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBJbnNlcnQgY29udHJvbHMgaW4gY29ycmVjdCBvcmRlclxuXG4gICAgICBjb250cm9sc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgJHRhYlBhbmVDb250LmFwcGVuZChjb250cm9sc1t2XSk7XG4gICAgICB9KTsgLy8gVE9ETzogdGhpcyBpcyBhbiB1Z2x5IHNvbHV0aW9uXG5cbiAgICAgIGlmICghaGFzQ2FsICYmIGNvbnRyb2xzLmRhdGUpIHtcbiAgICAgICAgY29udHJvbHMuZGF0ZS5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGluc3QuX3Njcm9sbGVycyA9IFtdO1xuICAgICAgYXR0YWNoRXZlbnRzKCk7XG4gICAgfSxcbiAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgIGlmIChoYXNDYWwgJiYgY2FsUm93cykge1xuICAgICAgICBzZXRUaXRsZShjdXJyRmlyc3REYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25IaWRlOiBmdW5jdGlvbiBvbkhpZGUoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lcik7XG5cbiAgICAgIGluc3QuX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHYuZGVzdHJveSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRheVByb3BzID0gbnVsbDtcbiAgICAgIGRheVNjcm9sbCA9IG51bGw7XG4gICAgICBtb250aFNjcm9sbCA9IG51bGw7XG4gICAgICB5ZWFyU2Nyb2xsID0gbnVsbDtcbiAgICAgIHZpc2libGVUYWIgPSBudWxsO1xuICAgIH0sXG4gICAgb25WYWxpZGF0ZWQ6IGZ1bmN0aW9uIG9uVmFsaWRhdGVkKGV2KSB7XG4gICAgICB2YXIgY3RybCxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGkgPSBldi5pbmRleCxcbiAgICAgICAgICBvcmRlciA9IGluc3QuX29yZGVyO1xuICAgICAgZCA9IGluc3QuZ2V0RGF0ZSh0cnVlKTtcbiAgICAgIHNlbGVjdGVkRGF0ZSA9IGQ7IC8vIEZpbmQgb3V0IG9uIHdoaWNoIGNvbnRyb2wgd2FzIHRoZSBzZWxlY3Rpb24gbWFkZVxuXG4gICAgICBpZiAoaXNEYXlDbGljaykge1xuICAgICAgICBjdHJsID0gJ2NhbGVuZGFyJztcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0cmwgPSBvcmRlci5kZCA9PSBpIHx8IG9yZGVyLmQgPT0gaSB8fCBvcmRlci5tID09IGkgfHwgb3JkZXIueSA9PSBpID8gJ2RhdGUnIDogJ3RpbWUnO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyKCdvblNldERhdGUnLCB7XG4gICAgICAgIGRhdGU6IGQsXG4gICAgICAgIGNvbnRyb2w6IGN0cmxcbiAgICAgIH0pOyAvLyBTZXQgZGF0ZSBvbiBjYWxlbmRhclxuXG4gICAgICBpZiAoY3RybCAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHNldERhdGUoZCwgZmFsc2UsICEhZXYudGltZSwgaXNEYXlDbGljayAmJiAhaW5zdC5fbXVsdGlwbGUpO1xuICAgICAgfVxuXG4gICAgICBpc0RheUNsaWNrID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblBvc2l0aW9uOiBmdW5jdGlvbiBvblBvc2l0aW9uKGV2KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICB5LFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZG9SZWZyZXNoLFxuICAgICAgICAgIG1vZGFsSGVpZ2h0LFxuICAgICAgICAgIG5ld0NhbFNpemUsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgICAgIG9sZEhlaWdodCA9IGV2Lm9sZEhlaWdodCxcbiAgICAgICAgICB3aW5kb3dIZWlnaHQgPSBldi53aW5kb3dIZWlnaHQ7XG4gICAgICBoYXNUYWJzID0gKGV2Lmhhc1RhYnMgfHwgcy50YWJzID09PSB0cnVlIHx8IHMudGFicyAhPT0gZmFsc2UgJiYgaXNMaXF1aWQpICYmIGNvbnRyb2xzQXJyYXkubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKGlzTGlxdWlkKSB7XG4gICAgICAgIGlmIChldi53aW5kb3dXaWR0aCA+PSBzLmJyZWFrUG9pbnRNZCkge1xuICAgICAgICAgICQkMShldi50YXJnZXQpLmFkZENsYXNzKCdtYnNjLWZyLW1kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKGV2LnRhcmdldCkucmVtb3ZlQ2xhc3MoJ21ic2MtZnItbWQnKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBTaG93L2hpZGUgdGFic1xuXG5cbiAgICAgIGlmIChoYXNUYWJzKSB7XG4gICAgICAgICRtYXJrdXAuYWRkQ2xhc3MoJ21ic2MtY2FsLXRhYmJlZCcpO1xuICAgICAgICB2aXNpYmxlVGFiID0gJCQxKCcubWJzYy1jYWwtdGFiLm1ic2Mtc2VsZWN0ZWQnLCAkbWFya3VwKS5hdHRyKCdkYXRhLWNvbnRyb2wnKTtcbiAgICAgICAgJHRhYlBhbmVzLmFkZENsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgICAgIGNvbnRyb2xzW3Zpc2libGVUYWJdLnJlbW92ZUNsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2aXNpYmxlVGFiID0gJ2NhbGVuZGFyJztcbiAgICAgICAgJG1hcmt1cC5yZW1vdmVDbGFzcygnbWJzYy1jYWwtdGFiYmVkJyk7XG4gICAgICAgICR0YWJQYW5lcy5yZW1vdmVDbGFzcygnbWJzYy1jYWwtaCcpO1xuICAgICAgfSAvLyBGdWxsIHNjcmVlbiBtb2RlXG5cblxuICAgICAgaWYgKGluc3QuX2lzRnVsbFNjcmVlbikge1xuICAgICAgICAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgJGNhbGVuZGFyLmhlaWdodCgnJyk7XG4gICAgICAgIG1vZGFsSGVpZ2h0ID0gZXYucG9wdXAub2Zmc2V0SGVpZ2h0OyAvLyBHZXQgYXZhaWxhYmxlIGhlaWdodFxuXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IHdpbmRvd0hlaWdodCAtIG1vZGFsSGVpZ2h0ICsgJGNhbGVuZGFyWzBdLm9mZnNldEhlaWdodDsgLy8gT25seSBzZXQgZml4ZWQgaGVpZ2h0IGlmIGNhbGVuZGFyIGhlaWdodCBpcyBiaWdnZXIgdGhhbiB2aWV3cG9ydCBoZWlnaHRcblxuICAgICAgICBpZiAod2luZG93SGVpZ2h0ID49IG1vZGFsSGVpZ2h0KSB7XG4gICAgICAgICAgJGNhbGVuZGFyLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNMYWJlbHMgJiYgY2FsUm93cyAmJiB3aW5kb3dIZWlnaHQgIT0gb2xkSGVpZ2h0KSB7XG4gICAgICAgIC8vIENoZWNrIGhvdyBtYW55IGxhYmVscyBjYW4gd2UgZGlzcGxheSBvbiBhIGRheVxuICAgICAgICB2YXIgY2FsSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0IHx8ICRjYWxlbmRhclswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBwaCA9ICRjYWxlbmRhci5maW5kKCcubWJzYy1jYWwtdHh0LC5tYnNjLWNhbC10eHQtcGgnKVswXTtcbiAgICAgICAgdmFyIG51bWJlckhlaWdodCA9IHBoLm9mZnNldFRvcDtcbiAgICAgICAgdmFyIHR4dEhlaWdodCA9IHBoLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIG5ld01heExhYmVscyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKGNhbEhlaWdodCAvIGNhbFJvd3MgLSBudW1iZXJIZWlnaHQpIC8gKHR4dEhlaWdodCArIDIpKSk7IC8vIFJlZHJhdyB0aGUgY2FsZW5kYXIsIGlmIG1heCBsYWJlbHMgY2hhbmdlZFxuXG4gICAgICAgIGlmIChtYXhMYWJlbHMgIT0gbmV3TWF4TGFiZWxzKSB7XG4gICAgICAgICAgbWF4TGFiZWxzID0gbmV3TWF4TGFiZWxzO1xuICAgICAgICAgIGluc3QucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVmcmVzaCBzY3JvbGx2aWV3c1xuXG5cbiAgICAgIGlmIChoYXNDYWwgJiYgY2FsUm93cykge1xuICAgICAgICAvLyBOZWVkIHRvIGNhbGN1bGF0ZSBzaXplXG4gICAgICAgIGlmIChpc0xpcXVpZCB8fCBpc1ZlcnRpY2FsIHx8IGhhc1RhYnMpIHtcbiAgICAgICAgICBuZXdDYWxTaXplID0gJGNhbGVuZGFyWzBdW2lzVmVydGljYWwgPyAnb2Zmc2V0SGVpZ2h0JyA6ICdvZmZzZXRXaWR0aCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NhbFNpemUgPSBjYWxXaWR0aCB8fCBwYWdlTnIgKiAyODA7XG4gICAgICAgIH1cblxuICAgICAgICBkb1JlZnJlc2ggPSBuZXdDYWxTaXplICE9IGNhbFNpemU7XG4gICAgICAgIGNhbFNpemUgPSBuZXdDYWxTaXplOyAvLyBVc2UgbG9uZyBvciBzaG9ydCBtb250aCBuYW1lc1xuXG4gICAgICAgIGlmIChpc0xpcXVpZCAmJiBkb1JlZnJlc2gpIHtcbiAgICAgICAgICBpZiAoeWVhckNoYW5nZSkge1xuICAgICAgICAgICAgbW9udGhOYW1lcyA9IHMubWF4TW9udGhXaWR0aCA+ICRtb250aEhkclswXS5vZmZzZXRXaWR0aCA/IHMubW9udGhOYW1lc1Nob3J0IDogcy5tb250aE5hbWVzO1xuICAgICAgICAgICAgeSA9IHMuZ2V0WWVhcihjdXJyRmlyc3REYXkpO1xuICAgICAgICAgICAgbSA9IHMuZ2V0TW9udGgoY3VyckZpcnN0RGF5KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhZ2VOcjsgaSsrKSB7XG4gICAgICAgICAgICAgICRtb250aEhkci5lcShpKS50ZXh0KG1vbnRoTmFtZXNbcy5nZXRNb250aChzLmdldERhdGUoeSwgbSAtIHBhZ2VPZmZzZXQgKyBpLCAxKSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9SZWZyZXNoKSB7XG4gICAgICAgICAgcmVmcmVzaFNjcm9sbGVyKGRheVNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1F1aWNrTmF2ICYmIGRvUmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2Nyb2xsZXIobW9udGhTY3JvbGwsIHRydWUpO1xuICAgICAgICByZWZyZXNoU2Nyb2xsZXIoeWVhclNjcm9sbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBDYWxlbmRhciA9IFNjcm9sbGVyO1xudmFyIGRlZmF1bHRzJDMgPSB7fTtcblxucHJlc2V0cy5jYWxlbmRhciA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIGZ1bmN0aW9uIGdldERhdGVPbmx5KGQpIHtcbiAgICByZXR1cm4gYWRqdXN0ZWREYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIGksXG4gICAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICBzZWxlY3RlZFZhbHVlcyA9IHt9O1xuXG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGQgPSBtYWtlRGF0ZSh2YWx1ZXNbaV0sIGRpc3BsYXlGb3JtYXQsIHMsIHMuaXNvUGFydHMpO1xuICAgICAgICBmaXJzdCA9IGZpcnN0IHx8IGQ7XG4gICAgICAgIHNlbGVjdGVkVmFsdWVzW2dldERhdGVPbmx5KGQpXSA9IGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgIGluc3QucmVkcmF3KCk7XG4gIH0gLy8gLS0tXG5cblxuICB2YXIgYmFzZSxcbiAgICAgIGN0eCxcbiAgICAgIGRpc3BsYXlGb3JtYXQsXG4gICAgICBmaXJzdFNlbGVjdERheSxcbiAgICAgIG9yaWdWYWx1ZXMsXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJDMsIG9yaWcpLFxuICAgICAgY3NzU2VsZWN0ZWQgPSAnbWJzYy1zZWxlY3RlZCAnICsgKHMuc2VsZWN0ZWRDbGFzcyB8fCAnJyksXG4gICAgICBkZWZhdWx0VmFsdWUgPSBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIG11bHRpID0gcy5zZWxlY3QgPT0gJ211bHRpcGxlJyB8fCBzLnNlbGVjdCA+IDEgfHwgcy5zZWxlY3RUeXBlID09ICd3ZWVrJyxcbiAgICAgIG1heFNlbGVjdCA9IGlzTnVtZXJpYyhzLnNlbGVjdCkgPyBzLnNlbGVjdCA6IEluZmluaXR5LFxuICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSB7fTtcbiAgYmFzZSA9IENhbGVuZGFyQmFzZS5jYWxsKHRoaXMsIGluc3QpO1xuICBmaXJzdFNlbGVjdERheSA9IHMuZmlyc3RTZWxlY3REYXkgPT09IHVuZGVmaW5lZCA/IHMuZmlyc3REYXkgOiBzLmZpcnN0U2VsZWN0RGF5O1xuICBkaXNwbGF5Rm9ybWF0ID0gaW5zdC5fZm9ybWF0O1xuXG4gIGlmIChtdWx0aSkge1xuICAgIHNldFZhbHVlcyhkZWZhdWx0VmFsdWUpO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0Ll9tdWx0aXBsZSA9IG11bHRpO1xuXG4gIGluc3QuX2dldERheVByb3BzID0gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWQ6IG11bHRpID8gc2VsZWN0ZWRWYWx1ZXNbZF0gIT09IHVuZGVmaW5lZCA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG5cbiAgaW5zdC5fc2VsZWN0RGF5ID0gZnVuY3Rpb24gKCRkYXksIGQsIGR0aW1lLCBzZWxlY3RlZCkge1xuICAgIHZhciBpc1NpbmdsZVNlbGVjdCA9IHMuc2VsZWN0ID09ICdzaW5nbGUnIHx8IHMuc2VsZWN0ID09IDEgfHwgcy5zZWxlY3QgPT09IHVuZGVmaW5lZDsgLy8gU2luZ2xlIHNlbGVjdCB3aXRoIGluc3RhbnQgY2xvc2VcblxuICAgIGlmIChzLnNldE9uRGF5VGFwICYmIGlzU2luZ2xlU2VsZWN0ICYmIHMuZGlzcGxheSAhPSAnaW5saW5lJykge1xuICAgICAgaW5zdC5zZXREYXRlKGR0aW1lKTtcbiAgICAgIGluc3Quc2VsZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG11bHRpKSB7XG4gICAgICAvLyBNdWx0aXBsZSBkYXkgc2VsZWN0aW9uXG4gICAgICBpZiAocy5zZWxlY3RUeXBlID09ICd3ZWVrJykge1xuICAgICAgICAvLyBTZWxlY3Qgd2hvbGUgd2Vla1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHNlbCxcbiAgICAgICAgICAgIGRpZmYgPSBkLmdldERheSgpIC0gZmlyc3RTZWxlY3REYXk7XG4gICAgICAgIGRpZmYgPSBkaWZmIDwgMCA/IDcgKyBkaWZmIDogZGlmZjtcblxuICAgICAgICBpZiAoaXNTaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAvLyBPbmx5IG9uZSB3ZWVrIGNhbiBiZSBzZWxlY3RlZFxuICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgc2VsID0gYWRqdXN0ZWREYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSAtIGRpZmYgKyBpKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkVmFsdWVzW3NlbF07XG4gICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkVmFsdWVzKS5sZW5ndGggLyA3IDwgbWF4U2VsZWN0KSB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlc1tzZWxdID0gc2VsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VsZWN0IGRheSBvbmx5XG4gICAgICAgIHZhciBkYXlzID0gJCQxKCcubWJzYy1jYWwtZGF5W2RhdGEtZnVsbD1cIicgKyAkZGF5LmF0dHIoJ2RhdGEtZnVsbCcpICsgJ1wiXScsIGN0eCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgZGF5cy5yZW1vdmVDbGFzcyhjc3NTZWxlY3RlZCkucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFZhbHVlc1tkXTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkVmFsdWVzKS5sZW5ndGggPCBtYXhTZWxlY3QpIHtcbiAgICAgICAgICBkYXlzLmFkZENsYXNzKGNzc1NlbGVjdGVkKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlc1tkXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFN0YW5kYXJkIHNlbGVjdGlvblxuXG5cbiAgICBpbnN0Ll9fc2VsZWN0RGF5KCRkYXksIGQsIGR0aW1lKTtcbiAgfTtcblxuICBpbnN0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSkge1xuICAgIGlmIChtdWx0aSkge1xuICAgICAgdmFsID0gc2V0VmFsdWVzKHZhbCk7XG4gICAgfVxuXG4gICAgaW5zdC5fc2V0VmFsKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wLCB0aW1lKTtcblxuICAgIGlmIChtdWx0aSkge1xuICAgICAgcmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGZvciAoaSBpbiBzZWxlY3RlZFZhbHVlcykge1xuICAgICAgICByZXQucHVzaChyZXR1cm5EYXRlKHNlbGVjdGVkVmFsdWVzW2ldLCBzLCBkaXNwbGF5Rm9ybWF0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybkRhdGUoaW5zdC5nZXREYXRlKHRlbXApLCBzLCBkaXNwbGF5Rm9ybWF0KTtcbiAgfTsgLy8gLS0tXG5cblxuICByZXR1cm4gZXh0ZW5kJDEoe30sIGJhc2UsIHtcbiAgICBoaWdobGlnaHQ6ICFtdWx0aSxcbiAgICBvdXRlck1vbnRoQ2hhbmdlOiAhbXVsdGksXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICBpZiAobXVsdGkgJiYgdiAmJiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdiA9IHNldFZhbHVlcyh2LnNwbGl0KCcsJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGkgJiYgZGVmYXVsdFZhbHVlICYmIGRlZmF1bHRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWVbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnBhcnNlVmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIGZvciAoaSBpbiBzZWxlY3RlZFZhbHVlcykge1xuICAgICAgICAgIHJldC5wdXNoKGZvcm1hdERhdGUoZGlzcGxheUZvcm1hdCwgc2VsZWN0ZWRWYWx1ZXNbaV0sIHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQuam9pbignLCAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UuZm9ybWF0VmFsdWUuY2FsbCh0aGlzLCBkLCBpbnN0KTtcbiAgICB9LFxuICAgIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJlZm9yZVNob3c6IGZ1bmN0aW9uIG9uQmVmb3JlU2hvdygpIHtcbiAgICAgIGlmIChzLnNldE9uRGF5VGFwID09PSB1bmRlZmluZWQgJiYgKCFzLmJ1dHRvbnMgfHwgIXMuYnV0dG9ucy5sZW5ndGgpICYmIHMuY29udHJvbHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcy5zZXRPbkRheVRhcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLnNldE9uRGF5VGFwICYmIHMuZGlzcGxheSAhPSAnaW5saW5lJykge1xuICAgICAgICBzLm91dGVyTW9udGhDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMuY291bnRlciAmJiBtdWx0aSkge1xuICAgICAgICBzLmhlYWRlclRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICAgIHcgPSBzLnNlbGVjdFR5cGUgPT0gJ3dlZWsnID8gNyA6IDE7XG4gICAgICAgICAgJCQxLmVhY2goc2VsZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxlbmd0aCA9IE1hdGgucm91bmQobGVuZ3RoIC8gdyk7XG4gICAgICAgICAgcmV0dXJuIChsZW5ndGggPiAxID8gcy5zZWxlY3RlZFBsdXJhbFRleHQgfHwgcy5zZWxlY3RlZFRleHQgOiBzLnNlbGVjdGVkVGV4dCkucmVwbGFjZSgve2NvdW50fS8sIGxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgICBiYXNlLm9uTWFya3VwUmVhZHkuY2FsbCh0aGlzLCBldik7XG4gICAgICBjdHggPSAkJDEoZXYudGFyZ2V0KTtcblxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgICQkMSgnLm1ic2MtZnItaGRyJywgY3R4KS5hdHRyKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XG4gICAgICAgIG9yaWdWYWx1ZXMgPSBleHRlbmQkMSh7fSwgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgaWYgKCFpbnN0LmxpdmUgJiYgbXVsdGkpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBleHRlbmQkMSh7fSwgb3JpZ1ZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBNYnNjRGF0ZXRpbWVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0RhdGV0aW1lQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWVCYXNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1ic2NEYXRldGltZUJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtZHQtYicgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRGF0ZXRpbWVCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRGF0ZXRpbWVCYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnZGVmYXVsdFZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpbnZhbGlkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncmV0dXJuRm9ybWF0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGVwcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsaWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NhbGVuZGFyU3lzdGVtJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdhbXBtVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnYW1UZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkYXRlRm9ybWF0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkYXRlV2hlZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkYXlOYW1lcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGF5TmFtZXNTaG9ydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGF5VGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaG91clRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pbnV0ZVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vbnRoTmFtZXMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vbnRoTmFtZXNTaG9ydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbW9udGhTdWZmaXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vbnRoVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbm93VGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncG1UZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzZWNUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0aW1lRm9ybWF0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0aW1lV2hlZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd5ZWFyU3VmZml4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd5ZWFyVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NEYXRldGltZUJhc2U7XG59KE1ic2NTY3JvbGxlckJhc2UpKTtcbnZhciBNYnNjRGF0ZXRpbWVCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWVCYXNlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjRGF0ZXRpbWVCYXNlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjRGF0ZXRpbWVCYXNlXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NEYXRldGltZUJhc2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lQmFzZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBNYnNjQ2FsQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDYWxCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NDYWxCYXNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub25UYWJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTGFiZWxUYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTW9udGhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTW9udGhMb2FkaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbk1vbnRoTG9hZGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblBhZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uUGFnZUxvYWRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25QYWdlTG9hZGluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQ2FsQmFzZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5LmNvbG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkubWFya2VkID0gW107XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NDYWxCYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1ttYnNjLWNhbC1iJyB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDYWxCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ2FsQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2NhbGVuZGFySGVpZ2h0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjYWxlbmRhcldpZHRoJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjYWxlbmRhclNjcm9sbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnY29sb3JzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjb3VudGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWZhdWx0VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2V2ZW50cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXZlbnRPcmRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXJrZWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vbnRocyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbW91c2V3aGVlbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3V0ZXJNb250aENoYW5nZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2hvd091dGVyRGF5cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndGFicyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnd2Vla0NvdW50ZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3dlZWtEYXlzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd3ZWVrcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAneWVhckNoYW5nZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGF0ZVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RheU5hbWVzTWluJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdmaXJzdERheSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndGltZVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vcmVFdmVudHNQbHVyYWxUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtb3JlRXZlbnRzVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25UYWJDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25MYWJlbFRhcCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbk1vbnRoQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uTW9udGhMb2FkaW5nJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uTW9udGhMb2FkZWQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25QYWdlQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uUGFnZUxvYWRlZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblBhZ2VMb2FkaW5nJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjQ2FsQmFzZTtcbn0oTWJzY0RhdGV0aW1lQmFzZSkpO1xudmFyIE1ic2NDYWxCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjQ2FsQmFzZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY0NhbEJhc2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY0RhdGV0aW1lQmFzZU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NDYWxCYXNlXSxcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDYWxCYXNlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NDYWxCYXNlTW9kdWxlO1xufSgpKTtcblxudmFyIE1ic2NDYWxlbmRhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDYWxlbmRhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjQ2FsZW5kYXIoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgX3RoaXMub25TZXREYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkNlbGxIb3ZlckluID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkNlbGxIb3Zlck91dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25EYXlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMuaXNNdWx0aSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ2FsZW5kYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NDYWxlbmRhci5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFkZWVwRXF1YWxzQXJyYXkodiwgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICgoIWlubmVyVmFsdWUgJiYgdikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlubmVyVmFsdWUgJiYgIXYpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpbm5lclZhbHVlICYmIHYgJiYgaW5uZXJWYWx1ZS50b1N0cmluZygpICE9PSB2LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAnY2FsZW5kYXInIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IENhbGVuZGFyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5pdGlhbFZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTXVsdGkgPSB0aGlzLm9wdGlvbnMgJiYgKCh0aGlzLm9wdGlvbnMuc2VsZWN0ICYmIHRoaXMub3B0aW9ucy5zZWxlY3QgIT09ICdzaW5nbGUnKSB8fCAodGhpcy5vcHRpb25zLnNlbGVjdFR5cGUgPT0gJ3dlZWsnKSk7XG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5Lm1hcmtlZCA9IFtdO1xuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5pbnZhbGlkID0gW107XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NDYWxlbmRhci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1jYWxlbmRhcl0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FsZW5kYXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ2FsZW5kYXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjb250cm9scyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZmlyc3RTZWxlY3REYXknOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NlbGVjdFR5cGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NlbGVjdCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2V0T25EYXlUYXAnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uU2V0RGF0ZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNlbGxIb3ZlckluJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQ2VsbEhvdmVyT3V0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uRGF5Q2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1jYWxlbmRhcicsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1jYWxlbmRhckNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0NhbGVuZGFyO1xufShNYnNjQ2FsQmFzZSkpO1xudmFyIE1ic2NDYWxlbmRhckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDYWxlbmRhckNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjQ2FsZW5kYXJDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NDYWxlbmRhckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhbGVuZGFyJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FsZW5kYXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NDYWxlbmRhckNvbXBvbmVudDtcbn0oTWJzY0NhbGVuZGFyKSk7XG52YXIgTWJzY0NhbGVuZGFyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjQ2FsZW5kYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NDYWxlbmRhck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjQ2FsQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0NhbGVuZGFyLCBNYnNjQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY0NhbGVuZGFyLCBNYnNjQ2FsZW5kYXJDb21wb25lbnRdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FsZW5kYXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0NhbGVuZGFyTW9kdWxlO1xufSgpKTtcblxudmFyIEJ1dHRvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Zvcm1Db250cm9sKSB7XG4gIF9pbmhlcml0c0xvb3NlKEJ1dHRvbiwgX0Zvcm1Db250cm9sKTtcblxuICBmdW5jdGlvbiBCdXR0b24oZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Zvcm1Db250cm9sLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICB2YXIgJGVsbSA9IF90aGlzLl8kZWxtO1xuICAgIHZhciBoYXNJY29uID0gJGVsbS5hdHRyKCdkYXRhLWljb24nKTtcbiAgICAkZWxtLmFkZENsYXNzKCdtYnNjLWJ0biBtYnNjLW5vLXRvdWNoJykuZmluZCgnLm1ic2MtYnRuLWljJykucmVtb3ZlKCk7XG5cbiAgICBpZiAoaGFzSWNvbikge1xuICAgICAgJGVsbS5wcmVwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtYnRuLWljIG1ic2MtaWMgbWJzYy1pYy0nICsgaGFzSWNvbiArICdcIj48L3NwYW4+Jyk7XG5cbiAgICAgIGlmICgkZWxtLnRleHQoKSA9PT0gXCJcIikge1xuICAgICAgICAkZWxtLmFkZENsYXNzKCdtYnNjLWJ0bi1pY29uLW9ubHknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5fJHJpcHBsZUVsbSA9ICRlbG07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJ1dHRvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldENsYXNzRWxtID0gZnVuY3Rpb24gZ2V0Q2xhc3NFbG0oKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRlbG07XG4gIH07XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oRm9ybUNvbnRyb2wpOyAvLyBJbml0IG1ic2MtYnV0dG9uIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtYnV0dG9uXScsIEJ1dHRvbik7XG5cbnZhciBDaGVja0JveCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Zvcm1Db250cm9sKSB7XG4gIF9pbmhlcml0c0xvb3NlKENoZWNrQm94LCBfRm9ybUNvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIENoZWNrQm94KGVsbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Gb3JtQ29udHJvbC5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5fJHBhcmVudC5wcmVwZW5kKF90aGlzLl8kZWxtKS5hZGRDbGFzcygnbWJzYy1jaGVja2JveCBtYnNjLWNvbnRyb2wtdycpLmZpbmQoJy5tYnNjLWNoZWNrYm94LWJveCcpLnJlbW92ZSgpO1xuXG4gICAgX3RoaXMuXyRlbG0uYWZ0ZXIoJzxzcGFuIGNsYXNzPVwibWJzYy1jaGVja2JveC1ib3hcIj48L3NwYW4+Jyk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQ2hlY2tCb3g7XG59KEZvcm1Db250cm9sKTsgLy8gSW5pdCBtYnNjLWNoZWNrYm94IGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtY2hlY2tib3hdJywgQ2hlY2tCb3gpO1xuXG52YXIgUmFkaW8gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Gb3JtQ29udHJvbCkge1xuICBfaW5oZXJpdHNMb29zZShSYWRpbywgX0Zvcm1Db250cm9sKTtcblxuICBmdW5jdGlvbiBSYWRpbyhlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRm9ybUNvbnRyb2wuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuXyRwYXJlbnQuYWRkQ2xhc3MoJ21ic2MtcmFkaW8gbWJzYy1jb250cm9sLXcnKS5maW5kKCcubWJzYy1yYWRpby1ib3gnKS5yZW1vdmUoKTtcblxuICAgIF90aGlzLl8kZWxtLmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2MtcmFkaW8tYm94XCI+PHNwYW4+PC9zcGFuPjwvc3Bhbj4nKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBSYWRpbztcbn0oRm9ybUNvbnRyb2wpOyAvLyBJbml0IG1ic2MtcmFkaW8gZWxlbWVudHMgb24gcGFnZSBsb2FkXG5cbmF1dG9Jbml0KCdbbWJzYy1yYWRpb10nLCBSYWRpbyk7XG5cbnZhciBTZWxlY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShTZWxlY3QsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gU2VsZWN0KGVsbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgdmFyICRlbG0gPSBfdGhpcy5fJGVsbTtcbiAgICB2YXIgJHBhcmVudCA9IF90aGlzLl8kcGFyZW50O1xuICAgIHZhciAkZXhpc3RpbmcgPSAkcGFyZW50LmZpbmQoJy5tYnNjLXNlbGVjdC1pbnB1dCcpO1xuICAgIHZhciAkaW5wdXQgPSAkZXhpc3RpbmcubGVuZ3RoID8gJGV4aXN0aW5nIDogJCQxKCc8aW5wdXQgdGFiaW5kZXg9XCItMVwiIGNsYXNzPVwibWJzYy1zZWxlY3QtaW5wdXQgbWJzYy1jb250cm9sXCIgcmVhZG9ubHk+Jyk7XG4gICAgX3RoaXMuXyRpbnB1dCA9ICRpbnB1dDtcbiAgICBfdGhpcy5fZGVsbSA9ICRpbnB1dFswXTtcbiAgICBfdGhpcy5fc2V0VGV4dCA9IF90aGlzLl9zZXRUZXh0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2Mtc2VsZWN0JyArIChfdGhpcy5fJGZyYW1lID8gJyBtYnNjLXNlbGVjdC1pbmxpbmUnIDogJycpKTtcbiAgICAkZWxtLmFmdGVyKCRpbnB1dCk7XG4gICAgJGlucHV0LmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VsZWN0LWljIG1ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNVwiPjwvc3Bhbj4nKTsgLy8gVXBkYXRlIGR1bW15IGlucHV0IHRleHQgb24gY2hhbmdlXG5cbiAgICAkZWxtLm9uKCdjaGFuZ2UnLCBfdGhpcy5fc2V0VGV4dCk7XG5cbiAgICBfdGhpcy5fc2V0VGV4dCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNlbGVjdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF9JbnB1dC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fJHBhcmVudC5maW5kKCcubWJzYy1zZWxlY3QtaWMnKS5yZW1vdmUoKTtcblxuICAgIHRoaXMuXyRlbG0ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9zZXRUZXh0KTtcbiAgfTtcblxuICBfcHJvdG8uX3NldFRleHQgPSBmdW5jdGlvbiBfc2V0VGV4dCgpIHtcbiAgICB2YXIgZWxtID0gdGhpcy5fZWxtO1xuICAgIHZhciAkZWxtID0gJCQxKGVsbSk7IC8vIENoZWNrIGlmIHNlbGVjdCBhbmQgbW9iaXNjcm9sbCBzZWxlY3Qgd2FzIG5vdCBpbml0aWFsaXplZFxuXG4gICAgaWYgKCRlbG0uaXMoJ3NlbGVjdCcpICYmICEkZWxtLmhhc0NsYXNzKCdtYnNjLWNvbXAnKSkge1xuICAgICAgdGhpcy5fJGlucHV0LnZhbChlbG0uc2VsZWN0ZWRJbmRleCAhPSAtMSA/IGVsbS5vcHRpb25zW2VsbS5zZWxlY3RlZEluZGV4XS50ZXh0IDogJycpO1xuICAgIH0gLy8gQ2hlY2sgZmxvYXRpbmcgbGFiZWxcblxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdDtcbn0oSW5wdXQpOyAvLyBJbml0IG1ic2Mtc2VsZWN0IGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtZHJvcGRvd25dJywgU2VsZWN0KTtcblxudmFyIGV2ZW50cyQyID0gWydjaGFuZ2UnLCAna2V5ZG93bicsICdpbnB1dCcsICdzY3JvbGwnXTtcbnZhciBzaXplRGVib3VuY2U7XG5cbmZ1bmN0aW9uIHNpemVUZXh0QXJlYXMoKSB7XG4gIGNsZWFyVGltZW91dChzaXplRGVib3VuY2UpO1xuICBzaXplRGVib3VuY2UgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAkJDEoJ3RleHRhcmVhLm1ic2MtY29udHJvbCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgc2l6ZVRleHRBcmVhKHRoaXMpO1xuICAgIH0pO1xuICB9LCAxMDApO1xufVxuXG5mdW5jdGlvbiBzaXplVGV4dEFyZWEoY29udHJvbCkge1xuICB2YXIgaGVpZ2h0LFxuICAgICAgbGluZU5yLFxuICAgICAgbGluZSxcbiAgICAgIHJvd05yID0gJCQxKGNvbnRyb2wpLmF0dHIoJ3Jvd3MnKSB8fCA2O1xuXG4gIGlmIChjb250cm9sLm9mZnNldEhlaWdodCkge1xuICAgIGNvbnRyb2wuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgbGluZSA9IGNvbnRyb2wuc2Nyb2xsSGVpZ2h0IC0gY29udHJvbC5vZmZzZXRIZWlnaHQ7XG4gICAgaGVpZ2h0ID0gY29udHJvbC5vZmZzZXRIZWlnaHQgKyAobGluZSA+IDAgPyBsaW5lIDogMCk7XG4gICAgbGluZU5yID0gTWF0aC5yb3VuZChoZWlnaHQgLyAyNCk7XG5cbiAgICBpZiAobGluZU5yID4gcm93TnIpIHtcbiAgICAgIC8vY29udHJvbC5zY3JvbGxUb3AgPSBoZWlnaHQ7XG4gICAgICBoZWlnaHQgPSAyNCAqIHJvd05yICsgKGhlaWdodCAtIGxpbmVOciAqIDI0KTtcbiAgICAgICQkMShjb250cm9sKS5hZGRDbGFzcygnbWJzYy10ZXh0YXJlYS1zY3JvbGwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCQxKGNvbnRyb2wpLnJlbW92ZUNsYXNzKCdtYnNjLXRleHRhcmVhLXNjcm9sbCcpO1xuICAgIH1cblxuICAgIGlmIChoZWlnaHQpIHtcbiAgICAgIGNvbnRyb2wuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVGV4dEFyZWEoZWxtKSB7XG4gIHZhciAkZWxtID0gJCQxKGVsbSk7XG5cbiAgaWYgKCEkZWxtLmhhc0NsYXNzKCdtYnNjLXRleHRhcmVhLXNjcm9sbCcpKSB7XG4gICAgdmFyIGxpbmUgPSBlbG0uc2Nyb2xsSGVpZ2h0IC0gZWxtLm9mZnNldEhlaWdodCxcbiAgICAgICAgaGVpZ2h0ID0gZWxtLm9mZnNldEhlaWdodCArIGxpbmUsXG4gICAgICAgIGxpbmVOciA9IE1hdGgucm91bmQoaGVpZ2h0IC8gMjQpLFxuICAgICAgICByb3dOciA9ICRlbG0uYXR0cigncm93cycpIHx8IDY7XG5cbiAgICBpZiAobGluZU5yIDw9IHJvd05yKSB7XG4gICAgICBlbG0uc2Nyb2xsVG9wID0gMDtcbiAgICAgIGVsbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfVxufVxuXG5pZiAoaXNCcm93c2VyKSB7XG4gIC8vIFNldCBoZWlnaHQgb2YgdGV4dGFyZWFzIG9uIHZpZXdwb3J0IHNpemUgY2hhbmdlc1xuICAkJDEod2luZG93KS5vbigncmVzaXplIG9yaWVudGF0aW9uY2hhbmdlJywgc2l6ZVRleHRBcmVhcyk7XG59XG5cbnZhciBUZXh0QXJlYSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRleHRBcmVhLCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFRleHRBcmVhKGVsbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9JbnB1dC5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5fJHBhcmVudC5hZGRDbGFzcygnbWJzYy10ZXh0YXJlYScpO1xuXG4gICAgZXZlbnRzJDIuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIF90aGlzLl8kZWxtLm9uKGV2LCBfdGhpcy5faGFuZGxlKTtcbiAgICB9KTtcbiAgICBzaXplVGV4dEFyZWEoZWxtKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGV4dEFyZWEucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9JbnB1dC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgZXZlbnRzJDIuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIF90aGlzMi5fJGVsbS5vZmYoZXYsIF90aGlzMi5faGFuZGxlKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgX0lucHV0LnByb3RvdHlwZS5yZWZyZXNoLmNhbGwodGhpcyk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVib3VuY2UpO1xuICAgIHNpemVUZXh0QXJlYSh0aGlzLl9lbG0pO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlID0gZnVuY3Rpb24gX2hhbmRsZShldikge1xuICAgIF9JbnB1dC5wcm90b3R5cGUuX2hhbmRsZS5jYWxsKHRoaXMsIGV2KTtcblxuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgY2FzZSAnY2hhbmdlJzpcbiAgICAgICAgc2l6ZVRleHRBcmVhKHRoaXMuX2VsbSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdGhpcy5fb25JbnB1dChldik7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIHNjcm9sbFRleHRBcmVhKHRoaXMuX2VsbSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fb25JbnB1dCA9IGZ1bmN0aW9uIF9vbklucHV0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlKTtcbiAgICB0aGlzLl9kZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2l6ZVRleHRBcmVhKF90aGlzMy5fZWxtKTtcbiAgICB9LCAxMDApO1xuICB9O1xuXG4gIHJldHVybiBUZXh0QXJlYTtcbn0oSW5wdXQpO1xuXG5hdXRvSW5pdCgnW21ic2MtdGV4dGFyZWFdJywgVGV4dEFyZWEpO1xuXG52YXIgU2VnbWVudGVkSXRlbSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Zvcm1Db250cm9sKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNlZ21lbnRlZEl0ZW0sIF9Gb3JtQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gU2VnbWVudGVkSXRlbShlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRm9ybUNvbnRyb2wuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgIHZhciAkc2VnbWVudENvbnQ7XG4gICAgdmFyICRzZWdtZW50O1xuICAgIHZhciAkZWxtID0gX3RoaXMuXyRlbG07XG4gICAgdmFyICRwYXJlbnQgPSBfdGhpcy5fJHBhcmVudDtcblxuICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnbWJzYy1zZWdtZW50ZWQtaXRlbS1yZWFkeScpKSB7XG4gICAgICAkc2VnbWVudENvbnQgPSAkJDEoJzxkaXYgY2xhc3M9XCJtYnNjLXNlZ21lbnRlZCBtYnNjLXNlZ21lbnRlZC1ncm91cCBtYnNjLW5vLXRvdWNoXCI+PC9kaXY+Jyk7XG4gICAgICAkcGFyZW50LmFmdGVyKCRzZWdtZW50Q29udCk7XG4gICAgICAkcGFyZW50LnBhcmVudCgpLmZpbmQoJ2lucHV0W25hbWU9XCInICsgJGVsbS5hdHRyKCduYW1lJykgKyAnXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkaW5wdXQgPSAkJDEodGhpcyk7XG4gICAgICAgICRzZWdtZW50ID0gJGlucHV0LnBhcmVudCgpLmFkZENsYXNzKCdtYnNjLXNlZ21lbnRlZC1pdGVtIG1ic2Mtc2VnbWVudGVkLWl0ZW0tcmVhZHknKTtcbiAgICAgICAgJCQxKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnRcIj4nICsgKCRpbnB1dC5hdHRyKCdkYXRhLWljb24nKSA/ICc8c3BhbiBjbGFzcz1cIm1ic2MtaWMgbWJzYy1pYy0nICsgJGlucHV0LmF0dHIoJ2RhdGEtaWNvbicpICsgJ1wiPjwvc3Bhbj4nIDogJycpICsgJzwvc3Bhbj4nKS5hcHBlbmQoJHNlZ21lbnQuY29udGVudHMoKSkuYXBwZW5kVG8oJHNlZ21lbnQpO1xuICAgICAgICAkc2VnbWVudC5wcmVwZW5kKCRpbnB1dCk7XG4gICAgICAgICRzZWdtZW50Q29udC5hcHBlbmQoJHNlZ21lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3RoaXMuXyRyaXBwbGVFbG0gPSAkZWxtLm5leHQoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2VnbWVudGVkSXRlbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldENsYXNzRWxtID0gZnVuY3Rpb24gZ2V0Q2xhc3NFbG0oKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRlbG0uY2xvc2VzdCgnLm1ic2Mtc2VnbWVudGVkJyk7XG4gIH07XG5cbiAgcmV0dXJuIFNlZ21lbnRlZEl0ZW07XG59KEZvcm1Db250cm9sKTsgLy8gSW5pdCBtYnNjLXNlZ21lbnRlZCBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLXNlZ21lbnRlZF0nLCBTZWdtZW50ZWRJdGVtKTtcblxudmFyIFN0ZXBwZXIgPSBmdW5jdGlvbiBTdGVwcGVyKGNvbnRyb2wsIHNldHRpbmdzKSB7XG4gIHZhciAkYnRuUGx1cyxcbiAgICAgICRidG5NaW51cyxcbiAgICAgICRjb250cm9scyxcbiAgICAgIGNzc0NsYXNzID0gJycsXG4gICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBpbnB1dFN0eWxlLFxuICAgICAgcmlwcGxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzdGVwLFxuICAgICAgc3RlcHBlcixcbiAgICAgIHMsXG4gICAgICB0aGVtZSxcbiAgICAgIHZhbCxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgJGNvbnRyb2wgPSAkJDEoY29udHJvbCksXG4gICAgICByZWFkeSxcbiAgICAgICRwYXJlbnQsXG4gICAgICBvbGQgPSB2YWw7XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgdmFyIHY7XG5cbiAgICBpZiAoIWNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KCQkMSh0aGlzKS52YWwoKSk7XG4gICAgICBzZXRWYWx1ZShpc05hTih2KSA/IHZhbCA6IHYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIGNvbnRyb2wuZGlzYWJsZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwVmFsdWUoaW5kZXgsIGRpcikge1xuICAgIHNldFZhbHVlKHZhbCArIGRpciAqIHN0ZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWUodiwgZmlsbCwgY2hhbmdlKSB7XG4gICAgb2xkID0gdmFsO1xuXG4gICAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmlsbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGFuZ2UgPSBmaWxsO1xuICAgIH1cblxuICAgIHZhbCA9IHJvdW5kKHYpO1xuICAgICRjb250cm9scy5yZW1vdmVDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuXG4gICAgaWYgKGZpbGwpIHtcbiAgICAgICRjb250cm9sLnZhbCh2YWwpO1xuICAgIH1cblxuICAgIGlmICh2YWwgPT0gbWluKSB7XG4gICAgICAkYnRuTWludXMuYWRkQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodmFsID09IG1heCkge1xuICAgICAgJGJ0blBsdXMuYWRkQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodmFsICE9PSBvbGQgJiYgY2hhbmdlKSB7XG4gICAgICAkY29udHJvbC50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyKGF0dHIsIGRlZiwgc3RyKSB7XG4gICAgdmFyIHYgPSAkY29udHJvbC5hdHRyKGF0dHIpO1xuICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gJycgPyBkZWYgOiBzdHIgPyB2IDogK3Y7XG4gIH1cblxuICBmdW5jdGlvbiByb3VuZCh2KSB7XG4gICAgcmV0dXJuICtNYXRoLm1pbihtYXgsIE1hdGgubWF4KE1hdGgucm91bmQodiAvIHN0ZXApICogc3RlcCwgbWluKSkudG9GaXhlZChzY2FsZSk7XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBCYXNlLmNhbGwodGhpcywgY29udHJvbCwgc2V0dGluZ3MsIHRydWUpO1xuICAvKiBUUklBTEZVTkMgKi9cblxuICB0aGF0LmdldFZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHBhcnNlRmxvYXQoJGNvbnRyb2wudmFsKCkpO1xuICAgIHYgPSBpc05hTih2KSA/IHZhbCA6IHY7XG4gICAgcmV0dXJuIHJvdW5kKHYpO1xuICB9O1xuXG4gIHRoYXQuc2V0VmFsID0gZnVuY3Rpb24gKHYsIGZpbGwsIGNoYW5nZSkge1xuICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgIHNldFZhbHVlKGlzTmFOKHYpID8gdmFsIDogdiwgZmlsbCwgY2hhbmdlKTtcbiAgfTtcblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlYWR5ID0gJGNvbnRyb2wucGFyZW50KCkuaGFzQ2xhc3MoJ21ic2Mtc3RlcHBlcicpO1xuICAgICRwYXJlbnQgPSByZWFkeSA/ICRjb250cm9sLmNsb3Nlc3QoJy5tYnNjLXN0ZXBwZXItY29udCcpIDogJGNvbnRyb2wucGFyZW50KCk7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgbWluID0gc2V0dGluZ3MubWluID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdtaW4nLCBzLm1pbikgOiBzZXR0aW5ncy5taW47XG4gICAgbWF4ID0gc2V0dGluZ3MubWF4ID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdtYXgnLCBzLm1heCkgOiBzZXR0aW5ncy5tYXg7XG4gICAgc3RlcCA9IHNldHRpbmdzLnN0ZXAgPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ3N0ZXAnLCBzLnN0ZXApIDogc2V0dGluZ3Muc3RlcDtcbiAgICBzY2FsZSA9IE1hdGguYWJzKHN0ZXApIDwgMSA/IChzdGVwICsgJycpLnNwbGl0KCcuJylbMV0ubGVuZ3RoIDogMDtcbiAgICBpbnB1dFN0eWxlID0gc2V0dGluZ3MuaW5wdXRTdHlsZSA9PT0gdW5kZWZpbmVkID8gZ2V0QXR0cignZGF0YS1pbnB1dC1zdHlsZScsIHMuaW5wdXRTdHlsZSwgdHJ1ZSkgOiBzZXR0aW5ncy5pbnB1dFN0eWxlO1xuICAgIGRpc3BsYXlWYWx1ZSA9ICRjb250cm9sLmF0dHIoJ2RhdGEtdmFsJykgfHwgcy52YWw7XG4gICAgdmFsID0gcm91bmQoK2NvbnRyb2wudmFsdWUgfHwgMCk7XG4gICAgdGhlbWUgPSBtb2Jpc2Nyb2xsLnRoZW1lcy5mb3JtW3MudGhlbWVdO1xuICAgIHJpcHBsZSA9IHRoZW1lICYmIHRoZW1lLmFkZFJpcHBsZSA/IHRoZW1lIDogbnVsbDtcblxuICAgIGlmICghcmVhZHkpIHtcbiAgICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2Mtc3RlcHBlci1jb250IG1ic2Mtbm8tdG91Y2ggbWJzYy1jb250cm9sLXcnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdib3gnID8gJ21ic2MtaW5wdXQtYm94JyA6ICcnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdvdXRsaW5lJyA/ICdtYnNjLWlucHV0LW91dGxpbmUnIDogJycpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXNlZ21lbnRlZCBtYnNjLXN0ZXBwZXInICsgJ1wiPjwvc3Bhbj4nKS5maW5kKCcubWJzYy1zdGVwcGVyJykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWl0ZW0gbWJzYy1zdGVwcGVyLWNvbnRyb2wgbWJzYy1zdGVwcGVyLW1pbnVzICcgKyAodmFsID09IG1pbiA/ICdtYnNjLWRpc2FibGVkJyA6ICcnKSArICdcIiBkYXRhLXN0ZXA9XCItMVwiIHRhYmluZGV4PVwiMFwiPjxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtY29udGVudFwiPjxzcGFuIGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLW1pbnVzXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+JykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWl0ZW0gbWJzYy1zdGVwcGVyLWNvbnRyb2wgbWJzYy1zdGVwcGVyLXBsdXMgJyArICh2YWwgPT0gbWF4ID8gJ21ic2MtZGlzYWJsZWQnIDogJycpICsgJ1wiICBkYXRhLXN0ZXA9XCIxXCIgdGFiaW5kZXg9XCIwXCI+PHNwYW4gY2xhc3M9XCJtYnNjLXNlZ21lbnRlZC1jb250ZW50XCI+IDxzcGFuIGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLXBsdXNcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj4nKS5wcmVwZW5kKCRjb250cm9sKTtcbiAgICB9XG5cbiAgICBpZiAoY3NzQ2xhc3MpIHtcbiAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpLmZpbmQoJy5tYnNjLXNlZ21lbnRlZCcpLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB9XG5cbiAgICBjc3NDbGFzcyA9ICdtYnNjLScgKyBzLnRoZW1lICsgKHRoZW1lLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgdGhlbWUuYmFzZVRoZW1lIDogJycpICsgKHMucnRsID8gJyBtYnNjLXJ0bCcgOiAnIG1ic2MtbHRyJyk7XG4gICAgJHBhcmVudC5hZGRDbGFzcyhjc3NDbGFzcykuZmluZCgnLm1ic2Mtc2VnbWVudGVkJykuYWRkQ2xhc3MoY3NzQ2xhc3MpO1xuICAgICRidG5NaW51cyA9ICQkMSgnLm1ic2Mtc3RlcHBlci1taW51cycsICRwYXJlbnQpO1xuICAgICRidG5QbHVzID0gJCQxKCcubWJzYy1zdGVwcGVyLXBsdXMnLCAkcGFyZW50KTtcbiAgICAkY29udHJvbHMgPSAkJDEoJy5tYnNjLXN0ZXBwZXItY29udHJvbCcsICRwYXJlbnQpO1xuXG4gICAgaWYgKCFyZWFkeSkge1xuICAgICAgaWYgKGRpc3BsYXlWYWx1ZSA9PSAnbGVmdCcpIHtcbiAgICAgICAgJHBhcmVudC5hZGRDbGFzcygnbWJzYy1zdGVwcGVyLXZhbC1sZWZ0Jyk7XG4gICAgICAgICRjb250cm9sLmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWl0ZW1cIj48c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnRcIj48L3NwYW4+PC9zcGFuPicpO1xuICAgICAgfSBlbHNlIGlmIChkaXNwbGF5VmFsdWUgPT0gJ3JpZ2h0Jykge1xuICAgICAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLXN0ZXBwZXItdmFsLXJpZ2h0Jyk7XG4gICAgICAgICRidG5QbHVzLmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWl0ZW1cIj48c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnRcIj48L3NwYW4+PC9zcGFuPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGJ0bk1pbnVzLmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWl0ZW1cIj48c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnQgbWJzYy1zdGVwcGVyLXZhbFwiPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdGVwcGVyKSB7XG4gICAgICAkY29udHJvbC5vbignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgc3RlcHBlciA9IGNyZWF0ZVN0ZXBwZXIoJGNvbnRyb2xzLCBzdGVwVmFsdWUsIDE1MCwgY2hlY2tEaXNhYmxlZCwgZmFsc2UsIHJpcHBsZSk7XG4gICAgfVxuXG4gICAgJGNvbnRyb2wudmFsKHZhbCkuYXR0cignZGF0YS1yb2xlJywgJ3N0ZXBwZXInKS5hdHRyKCdtaW4nLCBtaW4pLmF0dHIoJ21heCcsIG1heCkuYXR0cignc3RlcCcsIHN0ZXApLmFkZENsYXNzKCdtYnNjLWNvbnRyb2wnKTtcbiAgICBjb250cm9sLm1ic2NJbnN0ID0gdGhhdDtcbiAgfTtcblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICRjb250cm9sLnJlbW92ZUNsYXNzKCdtYnNjLWNvbnRyb2wnKS5vZmYoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBzdGVwcGVyLmRlc3Ryb3koKTtcbiAgICBkZWxldGUgY29udHJvbC5tYnNjSW5zdDtcbiAgfTtcblxuICB0aGF0LmluaXQoKTtcbn07XG5TdGVwcGVyLnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnc3RlcHBlcicsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9kZWZhdWx0czoge1xuICAgIG1pbjogMCxcbiAgICBtYXg6IDEwMCxcbiAgICBzdGVwOiAxXG4gIH1cbn07XG5jbGFzc2VzLlN0ZXBwZXIgPSBTdGVwcGVyOyAvLyBJbml0IG1ic2Mtc3RlcHBlciBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLXN0ZXBwZXJdJywgU3RlcHBlcik7XG5cbnZhciBQcm9ncmVzc0Jhc2UgPSBmdW5jdGlvbiBQcm9ncmVzc0Jhc2UoZWxtLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJGVsbSxcbiAgICAgICRwYXJlbnQsXG4gICAgICBjc3NDbGFzcyxcbiAgICAgIHMsXG4gICAgICB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgQmFzZS5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MsIHRydWUpO1xuICB0aGF0Ll9faW5pdCA9IG5vb3A7XG4gIHRoYXQuX19kZXN0cm95ID0gbm9vcDtcblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3YXNJbml0O1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgICRlbG0gPSAkJDEoZWxtKTsgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWRcblxuICAgIHdhc0luaXQgPSAhISRwYXJlbnQ7XG4gICAgJHBhcmVudCA9ICRlbG0ucGFyZW50KCk7XG4gICAgJHBhcmVudCA9ICRwYXJlbnQuaGFzQ2xhc3MoJ21ic2MtaW5wdXQtd3JhcCcpID8gJHBhcmVudC5wYXJlbnQoKSA6ICRwYXJlbnQ7XG4gICAgdGhhdC5fJHBhcmVudCA9ICRwYXJlbnQ7XG5cbiAgICBpZiAoY3NzQ2xhc3MpIHtcbiAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgIH1cblxuICAgIGNzc0NsYXNzID0gdGhhdC5fY3NzICsgJyBtYnNjLXByb2dyZXNzLXcgbWJzYy1jb250cm9sLXcgJyArIGdldENzc0NsYXNzKHMpO1xuICAgICRwYXJlbnQuYWRkQ2xhc3MoY3NzQ2xhc3MpO1xuICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtY29udHJvbCcpO1xuXG4gICAgdGhhdC5fX2luaXQoKTtcblxuICAgIGlmICghd2FzSW5pdCkge1xuICAgICAgdGhhdC5fYXR0YWNoQ2hhbmdlKCk7XG4gICAgfSAvLyBTaG93IGluaXRpYWwgdmFsdWVcblxuXG4gICAgdGhhdC5yZWZyZXNoKCk7XG4gICAgZWxtLm1ic2NJbnN0ID0gdGhhdDtcbiAgfTtcblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX19kZXN0cm95KCk7XG5cbiAgICAkcGFyZW50LnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbnRyb2wnKTtcbiAgICBkZWxldGUgZWxtLm1ic2NJbnN0O1xuICB9O1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59O1xuXG52YXIgU2xpZGVyQmFzZSA9IGZ1bmN0aW9uIFNsaWRlckJhc2UoZWxtLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJGVsbSxcbiAgICAgICRoYW5kbGUsXG4gICAgICAkaGFuZGxlQ29udCxcbiAgICAgICRoYW5kbGVzLFxuICAgICAgJGxpc3RlbmVycyxcbiAgICAgICRwYXJlbnQsXG4gICAgICAkdHJhY2ssXG4gICAgICBhY3Rpb24sXG4gICAgICBiYXNlLFxuICAgICAgY2hhbmdlZCxcbiAgICAgIGRpZmZYLFxuICAgICAgZGlmZlksXG4gICAgICBkaWZmLFxuICAgICAgZW5kWCxcbiAgICAgIGVuZFksXG4gICAgICBoYW5kbGVJbmRleCxcbiAgICAgIGlzSG92ZXIsXG4gICAgICBpc1ByZXNzZWQsXG4gICAgICBpc1J0bCxcbiAgICAgIGxpdmUsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBtb3ZlZCxcbiAgICAgIG11bHRpcGxlLFxuICAgICAgb2xkVmFsdWUsXG4gICAgICBzdGVwLFxuICAgICAgcyxcbiAgICAgIHNjYWxlLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3RlcERlY2ltYWwsXG4gICAgICB0aW1lcixcbiAgICAgIHRvdGFsV2lkdGgsXG4gICAgICB2YWx1ZSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgbGFzdFVwZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgZnVuY3Rpb24gb25TdGFydChldikge1xuICAgIGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGVzdFRvdWNoKGV2LCB0aGlzKSAmJiAoIWFjdGlvbiB8fCBpc0hvdmVyKSAmJiAhZWxtLmRpc2FibGVkICYmICFlbG0ucmVhZE9ubHlcbiAgICAvKiBUUklBTENPTkQgKi9cbiAgICApIHtcbiAgICAgICAgaWYgKHMuc3RvcFByb3ApIHtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGlvbiA9IHRydWU7XG4gICAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgICBlbmRYID0gc3RhcnRYO1xuICAgICAgICAkdHJhY2sucmVtb3ZlQ2xhc3MoJ21ic2MtcHJvZ3Jlc3MtYW5pbScpO1xuICAgICAgICAkaGFuZGxlID0gbXVsdGlwbGUgPyAkJDEoJy5tYnNjLXNsaWRlci1oYW5kbGUnLCB0aGlzKSA6ICRoYW5kbGVzO1xuXG4gICAgICAgIGlmICgkaGFuZGxlQ29udCkge1xuICAgICAgICAgICRoYW5kbGVDb250LnJlbW92ZUNsYXNzKCdtYnNjLWhhbmRsZS1jdXJyJyk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFuZGxlQ29udCA9ICRoYW5kbGUucGFyZW50KCkuYWRkQ2xhc3MoJ21ic2MtYWN0aXZlIG1ic2MtaGFuZGxlLWN1cnInKTtcbiAgICAgICAgJGVsbS5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgICAgaGFuZGxlSW5kZXggPSArJGhhbmRsZS5hdHRyKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgIHRvdGFsV2lkdGggPSAkdHJhY2tbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIGRpZmYgPSAkdHJhY2tbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblxuICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICBpc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNlbW92ZScsIG9uTW92ZSkub24oJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZW50ZXInKSB7XG4gICAgICAgICAgaXNIb3ZlciA9IHRydWU7XG4gICAgICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgZW5kWCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgZW5kWSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgZGlmZlggPSBlbmRYIC0gc3RhcnRYO1xuICAgICAgZGlmZlkgPSBlbmRZIC0gc3RhcnRZO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlmZlgpID4gNSkge1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBpc1ByZXNzZWQgfHwgaXNIb3Zlcikge1xuICAgICAgICBpZiAoTWF0aC5hYnMobGFzdFVwZGF0ZSAtIG5ldyBEYXRlKCkpID4gNTApIHtcbiAgICAgICAgICBsYXN0VXBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICB1cGRhdGVTbGlkZXIoZW5kWCwgcy5yb3VuZCwgbGl2ZSAmJiAoIWlzSG92ZXIgfHwgaXNQcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZZKSA+IDcgJiYgZXYudHlwZSA9PSAndG91Y2htb3ZlJykge1xuICAgICAgICBjbGVhblVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoZXYpIHtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgICR0cmFjay5hZGRDbGFzcygnbWJzYy1wcm9ncmVzcy1hbmltJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hvdmVyICYmICFpc1ByZXNzZWQpIHtcbiAgICAgICAgdXBkYXRlVmFsdWUodmFsdWVbaGFuZGxlSW5kZXhdLCBoYW5kbGVJbmRleCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVNsaWRlcihlbmRYLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3ZlZCAmJiAhY2hhbmdlZCkge1xuICAgICAgICBpZiAoZXYudHlwZSA9PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBnaG9zdCBjbGlja1xuICAgICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fb25UYXAodmFsdWVbaGFuZGxlSW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNldXAnKSB7XG4gICAgICAgIGlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgaXNIb3ZlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzSG92ZXIpIHtcbiAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGNsZWFuVXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICB2YXIgdiA9IHRoYXQuX3JlYWRWYWx1ZSgkJDEodGhpcykpLFxuICAgICAgICBpID0gKyQkMSh0aGlzKS5hdHRyKCdkYXRhLWluZGV4Jyk7XG5cbiAgICBpZiAodiAhPT0gdmFsdWVbaV0pIHtcbiAgICAgIHZhbHVlW2ldID0gdjtcbiAgICAgIG9sZFZhbHVlW2ldID0gdjtcbiAgICAgIHVwZGF0ZVZhbHVlKHYsIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAvLyBQcmV2ZW50IHByb3BhZ2F0aW5nIGNsaWNrIHRvIGxhYmVsXG4gICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkxhYmVsQ2xpY2soZXYpIHtcbiAgICAvLyBQcmV2ZW50IGNoYW5nZSBvbiBsYWJlbCBjbGljayBmb3Igc3dpdGhlc1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleURvd24oZXYpIHtcbiAgICB2YXIgZGlyO1xuXG4gICAgaWYgKCFlbG0uZGlzYWJsZWQpIHtcbiAgICAgIHN3aXRjaCAoZXYua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBkaXIgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICBoYW5kbGVJbmRleCA9ICskJDEodGhpcykuYXR0cignZGF0YS1pbmRleCcpO1xuICAgICAgICAgIHVwZGF0ZVZhbHVlKHZhbHVlW2hhbmRsZUluZGV4XSArIHN0ZXAgKiBkaXIsIGhhbmRsZUluZGV4LCB0cnVlKTtcbiAgICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHZhbHVlW2hhbmRsZUluZGV4XSArIHN0ZXAgKiBkaXIsIGhhbmRsZUluZGV4LCB0cnVlKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgdGltZXIgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICBhY3Rpb24gPSBmYWxzZTtcbiAgICAkaGFuZGxlQ29udC5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpOyAvLyBEZXRhY2ggZG9jdW1lbnQgZXZlbnRzXG5cbiAgICAkJDEoZG9jdW1lbnQpLm9mZignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vZmYoJ21vdXNldXAnLCBvbkVuZCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbGlkZXIocG9zLCByb3VuZCwgZmlsbCkge1xuICAgIHZhciBwZXJjZW50ID0gcm91bmQgPyBNYXRoLm1pbihNYXRoW3RoYXQuX3JvdW5kaW5nIHx8ICdyb3VuZCddKE1hdGgubWF4KChwb3MgLSBkaWZmKSAqIDEwMCAvIHRvdGFsV2lkdGgsIDApIC8gc2NhbGUgLyBzdGVwKSAqIHN0ZXAgKiAxMDAgLyAobWF4IC0gbWluICsgYmFzZSksIDEwMCkgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigocG9zIC0gZGlmZikgKiAxMDAgLyB0b3RhbFdpZHRoLCAxMDApKTtcblxuICAgIGlmIChpc1J0bCkge1xuICAgICAgcGVyY2VudCA9IDEwMCAtIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUoTWF0aC5yb3VuZCgobWluIC0gYmFzZSArIHBlcmNlbnQgLyBzY2FsZSkgKiBzdGVwRGVjaW1hbCkgLyBzdGVwRGVjaW1hbCwgaGFuZGxlSW5kZXgsIGZpbGwsIHBlcmNlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWUodiwgaW5kZXgsIGZpbGwsIHBlcmNlbnQsIHJlZnJlc2gsIGNoYW5nZSkge1xuICAgIHZhciAkaGFuZGxlID0gJGhhbmRsZXMuZXEoaW5kZXgpLFxuICAgICAgICAkaGFuZGxlQ29udCA9ICRoYW5kbGUucGFyZW50KCk7XG4gICAgdiA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgodiwgbWluKSk7XG5cbiAgICBpZiAoY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoYW5nZSA9IGZpbGw7XG4gICAgfVxuXG4gICAgaWYgKHRoYXQuX3VwZGF0ZSkge1xuICAgICAgdiA9IHRoYXQuX3VwZGF0ZSh2LCB2YWx1ZSwgaW5kZXgsIHBlcmNlbnQsIG11bHRpcGxlLCByZWZyZXNoLCAkaGFuZGxlQ29udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRoYW5kbGVDb250LmNzcyh7XG4gICAgICAgIGxlZnQ6IGlzUnRsID8gJ2F1dG8nIDogKHBlcmNlbnQgfHwgZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkpICsgJyUnLFxuICAgICAgICByaWdodDogaXNSdGwgPyAocGVyY2VudCB8fCBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSkgKyAnJScgOiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2ID4gbWluKSB7XG4gICAgICAkaGFuZGxlQ29udC5yZW1vdmVDbGFzcygnbWJzYy1zbGlkZXItc3RhcnQnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlW2luZGV4XSA+IG1pbiB8fCByZWZyZXNoKSB7XG4gICAgICAkaGFuZGxlQ29udC5hZGRDbGFzcygnbWJzYy1zbGlkZXItc3RhcnQnKTtcbiAgICB9IC8vIFN0b3JlIG5ldyB2YWx1ZVxuXG5cbiAgICBpZiAoZmlsbCkge1xuICAgICAgdmFsdWVbaW5kZXhdID0gdjtcbiAgICB9IC8vIENoZWNrIGlmIHZhbHVlIGNoYW5nZWRcblxuXG4gICAgaWYgKGZpbGwgJiYgb2xkVmFsdWVbaW5kZXhdICE9IHYpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgb2xkVmFsdWVbaW5kZXhdID0gdjsgLy8gU2V0IG5ldyB2YWx1ZSB0byB0aGUgaW5wdXRcblxuICAgICAgdGhhdC5fZmlsbFZhbHVlKHYsIGluZGV4LCBjaGFuZ2UpO1xuICAgIH1cblxuICAgICRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycsIHYpO1xuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgUHJvZ3Jlc3NCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHRoYXQuX29uVGFwID0gbm9vcDtcbiAgdGhhdC5fX19pbml0ID0gbm9vcDtcbiAgdGhhdC5fX19kZXN0cm95ID0gbm9vcDtcblxuICB0aGF0Ll9hdHRhY2hDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGVsbS5vbihzLmNoYW5nZUV2ZW50LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgdGhhdC5fX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhc0luaXQ7XG5cbiAgICBpZiAoJGhhbmRsZXMpIHtcbiAgICAgIHdhc0luaXQgPSB0cnVlO1xuICAgICAgJGhhbmRsZXMucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhhdC5fX19pbml0KCk7XG5cbiAgICAkcGFyZW50ID0gdGhhdC5fJHBhcmVudDtcbiAgICAkdHJhY2sgPSB0aGF0Ll8kdHJhY2s7XG4gICAgJGVsbSA9ICRwYXJlbnQuZmluZCgnaW5wdXQnKTtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBtaW4gPSB0aGF0Ll9taW47XG4gICAgbWF4ID0gdGhhdC5fbWF4O1xuICAgIGJhc2UgPSB0aGF0Ll9iYXNlIHx8IDA7XG4gICAgc3RlcCA9IHRoYXQuX3N0ZXA7XG4gICAgbGl2ZSA9IHRoYXQuX2xpdmU7XG4gICAgc3RlcERlY2ltYWwgPSBzdGVwICUgMSAhPT0gMCA/IDEwMCAvICgrKHN0ZXAgJSAxKS50b0ZpeGVkKDIpICogMTAwKSA6IDE7XG4gICAgc2NhbGUgPSAxMDAgLyAobWF4IC0gbWluICsgYmFzZSkgfHwgMTAwO1xuICAgIG11bHRpcGxlID0gJGVsbS5sZW5ndGggPiAxO1xuICAgIGlzUnRsID0gcy5ydGw7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBvbGRWYWx1ZSA9IFtdOyAvLyBSZWFkIHZhbHVlc1xuXG4gICAgJGVsbS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZVtpXSA9IHRoYXQuX3JlYWRWYWx1ZSgkJDEodGhpcykpO1xuICAgICAgJCQxKHRoaXMpLmF0dHIoJ2RhdGEtaW5kZXgnLCBpKTtcbiAgICB9KTtcbiAgICAkaGFuZGxlcyA9ICRwYXJlbnQuZmluZCgnLm1ic2Mtc2xpZGVyLWhhbmRsZScpO1xuICAgICRsaXN0ZW5lcnMgPSAkcGFyZW50LmZpbmQobXVsdGlwbGUgPyAnLm1ic2Mtc2xpZGVyLWhhbmRsZS1jb250JyA6ICcubWJzYy1wcm9ncmVzcy1jb250Jyk7IC8vIEF0dGFjaCBldmVudHNcblxuICAgICRoYW5kbGVzLm9uKCdrZXlkb3duJywgb25LZXlEb3duKS5vbigna2V5dXAnLCBvbktleVVwKS5vbignYmx1cicsIG9uS2V5VXApO1xuICAgICRsaXN0ZW5lcnMuZWFjaChmdW5jdGlvbiAoaSwgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbihsaXN0ZW5lciwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGxpc3RlbmVyLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgICBsaXN0ZW4obGlzdGVuZXIsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICAgIGxpc3RlbihsaXN0ZW5lciwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgICAgbGlzdGVuKGxpc3RlbmVyLCAncG9pbnRlcmNhbmNlbCcsIG9uQ2FuY2VsKTtcblxuICAgICAgaWYgKHMuaG92ZXIpIHtcbiAgICAgICAgbGlzdGVuKGxpc3RlbmVyLCAnbW91c2VlbnRlcicsIG9uU3RhcnQpO1xuICAgICAgICBsaXN0ZW4obGlzdGVuZXIsICdtb3VzZWxlYXZlJywgb25FbmQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCF3YXNJbml0KSB7XG4gICAgICAkZWxtLm9uKCdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgJHBhcmVudC5vbignY2xpY2snLCBvbkxhYmVsQ2xpY2spOyAvLyBBdHRhY2ggdG8gZG9jdW1lbnQgdG8gYXZvaWQgbm9uLXBhc3NpdmUgbGlzdGVuZXIgd2FybmluZ3NcblxuICAgICAgbGlzdGVuKGRvY3VtZW50LCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJHBhcmVudC5vZmYoJ2NsaWNrJywgb25MYWJlbENsaWNrKTtcbiAgICAkZWxtLm9mZihzLmNoYW5nZUV2ZW50LCBvbkNoYW5nZSkub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xuICAgICRoYW5kbGVzLm9mZigna2V5ZG93bicsIG9uS2V5RG93bikub2ZmKCdrZXl1cCcsIG9uS2V5VXApLm9mZignYmx1cicsIG9uS2V5VXApO1xuICAgICRsaXN0ZW5lcnMuZWFjaChmdW5jdGlvbiAoaSwgbGlzdGVuZXIpIHtcbiAgICAgIHVubGlzdGVuKGxpc3RlbmVyLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ21vdXNlZG93bicsIG9uU3RhcnQpO1xuICAgICAgdW5saXN0ZW4obGlzdGVuZXIsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKGxpc3RlbmVyLCAndG91Y2hjYW5jZWwnLCBvbkVuZCk7XG4gICAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ21vdXNlZW50ZXInLCBvblN0YXJ0KTtcbiAgICAgIHVubGlzdGVuKGxpc3RlbmVyLCAnbW91c2VsZWF2ZScsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoYXQuX19fZGVzdHJveSgpO1xuICB9O1xuXG4gIHRoYXQucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkZWxtLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIHVwZGF0ZVZhbHVlKHRoYXQuX3JlYWRWYWx1ZSgkJDEodGhpcykpLCBpLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoYXQuZ2V0VmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtdWx0aXBsZSA/IHZhbHVlLnNsaWNlKDApIDogdmFsdWVbMF07XG4gIH07XG5cbiAgdGhhdC5zZXRWYWwgPSB0aGF0Ll9zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UpIHtcbiAgICBpZiAoISQkMS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IFt2YWxdO1xuICAgIH1cblxuICAgICQkMS5lYWNoKHZhbCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgIHZhbHVlW2ldID0gdjtcbiAgICB9KTtcbiAgICAkJDEuZWFjaCh2YWwsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICB1cGRhdGVWYWx1ZSh2LCBpLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgY2hhbmdlKTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTtcblxudmFyIFN3aXRjaCA9IGZ1bmN0aW9uIFN3aXRjaChlbG0sIHNldHRpbmdzKSB7XG4gIHZhciAkZWxtLFxuICAgICAgJHBhcmVudCxcbiAgICAgIHMsXG4gICAgICBmb3JtQ29udHJvbCxcbiAgICAgIHRoYXQgPSB0aGlzO1xuICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICBleHRlbmQkMShzZXR0aW5ncywge1xuICAgIGNoYW5nZUV2ZW50OiAnY2xpY2snLFxuICAgIHJvdW5kOiBmYWxzZVxuICB9KTsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgU2xpZGVyQmFzZS5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQuX3JlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxtLmNoZWNrZWQgPyAxIDogMDtcbiAgfTtcblxuICB0aGF0Ll9maWxsVmFsdWUgPSBmdW5jdGlvbiAodiwgaW5kZXgsIGNoYW5nZSkge1xuICAgICRlbG0ucHJvcCgnY2hlY2tlZCcsICEhdik7XG5cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAkZWxtLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9vblRhcCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdGhhdC5fc2V0VmFsKHYgPyAwIDogMSk7XG4gIH07XG5cbiAgdGhhdC5fX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgICRlbG0gPSAkJDEoZWxtKTtcbiAgICAkcGFyZW50ID0gJGVsbS5wYXJlbnQoKTtcbiAgICAkcGFyZW50LmZpbmQoJy5tYnNjLXN3aXRjaC10cmFjaycpLnJlbW92ZSgpO1xuICAgICRwYXJlbnQucHJlcGVuZCgkZWxtKTtcbiAgICAkZWxtLmF0dHIoJ2RhdGEtcm9sZScsICdzd2l0Y2gnKS5hZnRlcignPHNwYW4gY2xhc3M9XCJtYnNjLXByb2dyZXNzLWNvbnQgbWJzYy1zd2l0Y2gtdHJhY2tcIj4nICsgJzxzcGFuIGNsYXNzPVwibWJzYy1wcm9ncmVzcy10cmFjayBtYnNjLXByb2dyZXNzLWFuaW1cIj4nICsgJzxzcGFuIGNsYXNzPVwibWJzYy1zbGlkZXItaGFuZGxlLWNvbnRcIj4nICsgJzxzcGFuIGNsYXNzPVwibWJzYy1zbGlkZXItaGFuZGxlIG1ic2Mtc3dpdGNoLWhhbmRsZVwiIGRhdGEtaW5kZXg9XCIwXCI+JyArICc8c3BhbiBjbGFzcz1cIm1ic2Mtc3dpdGNoLXR4dC1vZmZcIj4nICsgcy5vZmZUZXh0ICsgJzwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwibWJzYy1zd2l0Y2gtdHh0LW9uXCI+JyArIHMub25UZXh0ICsgJzwvc3Bhbj4nICsgJzwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj4nKTtcblxuICAgIGlmIChmb3JtQ29udHJvbCkge1xuICAgICAgZm9ybUNvbnRyb2wuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGZvcm1Db250cm9sID0gbmV3IEZvcm1Db250cm9sKGVsbSwgcyk7XG4gICAgdGhhdC5fJHRyYWNrID0gJHBhcmVudC5maW5kKCcubWJzYy1wcm9ncmVzcy10cmFjaycpO1xuICAgIHRoYXQuX21pbiA9IDA7XG4gICAgdGhhdC5fbWF4ID0gMTtcbiAgICB0aGF0Ll9zdGVwID0gMTtcbiAgfTtcblxuICB0aGF0Ll9fX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9ybUNvbnRyb2wuZGVzdHJveSgpO1xuICB9O1xuXG4gIHRoYXQuZ2V0VmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbG0uY2hlY2tlZDtcbiAgfTtcblxuICB0aGF0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSkge1xuICAgIHRoYXQuX3NldFZhbCh2YWwgPyAxIDogMCwgZmlsbCwgY2hhbmdlKTtcbiAgfTtcblxuICB0aGF0LmluaXQoKTtcbn07XG5Td2l0Y2gucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdzd2l0Y2gnLFxuICBfY3NzOiAnbWJzYy1zd2l0Y2gnLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfaGFzRGVmOiB0cnVlLFxuICBfZGVmYXVsdHM6IHtcbiAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICBvZmZUZXh0OiAnT2ZmJyxcbiAgICBvblRleHQ6ICdPbidcbiAgfVxufTtcbmNsYXNzZXMuU3dpdGNoID0gU3dpdGNoOyAvLyBJbml0IG1ic2Mtc3dpdGNoIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2Mtc3dpdGNoXScsIFN3aXRjaCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIFByb2dyZXNzID0gZnVuY3Rpb24gUHJvZ3Jlc3MoZWxtLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJGRpc3BsYXksXG4gICAgICAkZWxtLFxuICAgICAgJHBhcmVudCxcbiAgICAgICRwcm9ncmVzcyxcbiAgICAgICR0YXJnZXQsXG4gICAgICAkdHJhY2ssXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBpbnB1dFN0eWxlLFxuICAgICAgbGFiZWxTdHlsZSxcbiAgICAgIHMsXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWVUZXh0LFxuICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgdmFyIHYgPSBnZXRBdHRyKCd2YWx1ZScsIG1pbik7XG5cbiAgICBpZiAodiAhPT0gdmFsdWUpIHtcbiAgICAgIHVwZGF0ZVZhbHVlKHYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0dHIoYXR0ciwgZGVmLCBzdHIpIHtcbiAgICB2YXIgdiA9ICRlbG0uYXR0cihhdHRyKTtcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09ICcnID8gZGVmIDogc3RyID8gdiA6ICt2O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWUodiwgcmVmcmVzaCwgZmlsbCwgY2hhbmdlKSB7XG4gICAgdiA9XG4gICAgLyogVFJJQUxDT05EUkVWICovXG4gICAgTWF0aC5taW4obWF4LCBNYXRoLm1heCh2LCBtaW4pKTtcbiAgICAkcHJvZ3Jlc3MuY3NzKCd3aWR0aCcsICh2IC0gbWluKSAqIDEwMCAvIChtYXggLSBtaW4pICsgJyUnKTtcblxuICAgIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbGwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hhbmdlID0gZmlsbDtcbiAgICB9XG5cbiAgICBpZiAodiAhPT0gdmFsdWUgfHwgcmVmcmVzaCkge1xuICAgICAgLy8gRGlzcGxheSB2YWx1ZVxuICAgICAgdGhhdC5fZGlzcGxheSh2KTtcbiAgICB9XG5cbiAgICBpZiAodiAhPT0gdmFsdWUpIHtcbiAgICAgIC8vIFNldCBuZXcgdmFsdWVcbiAgICAgIHZhbHVlID0gdjsgLy8gUHV0IG5ldyB2YWx1ZSBpbiB0aGUgcHJvZ3Jlc3MgZWxlbWVudFxuXG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICAkZWxtLmF0dHIoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgfSAvLyBUcmlnZ2VyIGNoYW5nZSBvbiB0aGUgZWxlbWVudFxuXG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgJGVsbS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBQcm9ncmVzc0Jhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcblxuICB0aGF0Ll9kaXNwbGF5ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YWx1ZVRleHQgPSB0ZW1wbGF0ZSAmJiBzLnJldHVybkFmZml4ID8gdGVtcGxhdGUucmVwbGFjZSgvXFx7dmFsdWVcXH0vLCB2KS5yZXBsYWNlKC9cXHttYXhcXH0vLCBtYXgpIDogdjtcblxuICAgIGlmICgkdGFyZ2V0KSB7XG4gICAgICAkdGFyZ2V0Lmh0bWwodmFsdWVUZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoJGRpc3BsYXkpIHtcbiAgICAgICRkaXNwbGF5Lmh0bWwodmFsdWVUZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fYXR0YWNoQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICRlbG0ub24oJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgfTtcblxuICB0aGF0Ll9faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlzcGxheVZhbHVlLCBpLCBzdGVwTGFiZWxzLCB3YXNJbml0O1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgICRlbG0gPSAkJDEoZWxtKTsgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWRcblxuICAgIHdhc0luaXQgPSAhISRwYXJlbnQ7XG4gICAgJHBhcmVudCA9IHRoYXQuXyRwYXJlbnQ7IC8vIFJlYWQgc2V0dGluZ3MgZnJvbSBkYXRhIGF0dHJpYnV0ZXMgb3Igc2V0dGluZ3Mgb2JqZWN0XG5cbiAgICBtaW4gPSB0aGF0Ll9taW4gPSBzZXR0aW5ncy5taW4gPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ21pbicsIHMubWluKSA6IHNldHRpbmdzLm1pbjtcbiAgICBtYXggPSB0aGF0Ll9tYXggPSBzZXR0aW5ncy5tYXggPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ21heCcsIHMubWF4KSA6IHNldHRpbmdzLm1heDtcbiAgICBpbnB1dFN0eWxlID0gc2V0dGluZ3MuaW5wdXRTdHlsZSA9PT0gdW5kZWZpbmVkID8gZ2V0QXR0cignZGF0YS1pbnB1dC1zdHlsZScsIHMuaW5wdXRTdHlsZSwgdHJ1ZSkgOiBzZXR0aW5ncy5pbnB1dFN0eWxlO1xuICAgIGxhYmVsU3R5bGUgPSBzZXR0aW5ncy5sYWJlbFN0eWxlID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdkYXRhLWxhYmVsLXN0eWxlJywgcy5sYWJlbFN0eWxlLCB0cnVlKSA6IHNldHRpbmdzLmxhYmVsU3R5bGU7XG4gICAgdmFsdWUgPSBnZXRBdHRyKCd2YWx1ZScsIG1pbik7XG4gICAgZGlzcGxheVZhbHVlID0gJGVsbS5hdHRyKCdkYXRhLXZhbCcpIHx8IHMudmFsO1xuICAgIHN0ZXBMYWJlbHMgPSAkZWxtLmF0dHIoJ2RhdGEtc3RlcC1sYWJlbHMnKTtcbiAgICBzdGVwTGFiZWxzID0gc3RlcExhYmVscyA/IEpTT04ucGFyc2Uoc3RlcExhYmVscykgOiBzLnN0ZXBMYWJlbHM7XG4gICAgdGVtcGxhdGUgPSAkZWxtLmF0dHIoJ2RhdGEtdGVtcGxhdGUnKSB8fCAobWF4ID09IDEwMCAmJiAhcy50ZW1wbGF0ZSA/ICd7dmFsdWV9JScgOiBzLnRlbXBsYXRlKTtcblxuICAgIGlmICghd2FzSW5pdCkge1xuICAgICAgd3JhcExhYmVsKCRwYXJlbnQsIG51bGwsIGlucHV0U3R5bGUsIGxhYmVsU3R5bGUsIGVsbSk7XG4gICAgICBhZGRJY29uKCRlbG0pOyAvLyBHZW5lcmF0ZSB0cmFjayBhbmQgcHJvZ3Jlc3NcblxuICAgICAgJHBhcmVudC5maW5kKCcubWJzYy1pbnB1dC13cmFwJykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3MtY29udFwiPjxzcGFuIGNsYXNzPVwibWJzYy1wcm9ncmVzcy10cmFjayBtYnNjLXByb2dyZXNzLWFuaW1cIj48c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3MtYmFyXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICAkcHJvZ3Jlc3MgPSB0aGF0Ll8kcHJvZ3Jlc3MgPSAkcGFyZW50LmZpbmQoJy5tYnNjLXByb2dyZXNzLWJhcicpO1xuICAgICAgJHRyYWNrID0gdGhhdC5fJHRyYWNrID0gJHBhcmVudC5maW5kKCcubWJzYy1wcm9ncmVzcy10cmFjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlzcGxheVZhbHVlKSB7XG4gICAgICAgICRkaXNwbGF5LnJlbW92ZSgpO1xuICAgICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdtYnNjLXByb2dyZXNzLXZhbHVlLScgKyAoZGlzcGxheVZhbHVlID09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwTGFiZWxzKSB7XG4gICAgICAgICQkMSgnLm1ic2MtcHJvZ3Jlc3Mtc3RlcC1sYWJlbCcsICR0cmFjaykucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSAvLyBTZXQgYXR0cmlidXRlc1xuXG5cbiAgICAkZWxtLmF0dHIoJ21pbicsIG1pbikuYXR0cignbWF4JywgbWF4KTsgLy8gR2VuZXJhdGUgdmFsdWUgY29udGFpbmVyIG9uIGxlZnQgb3IgcmlnaHQgc2lkZVxuXG4gICAgaWYgKGRpc3BsYXlWYWx1ZSkge1xuICAgICAgJGRpc3BsYXkgPSAkJDEoJzxzcGFuIGNsYXNzPVwibWJzYy1wcm9ncmVzcy12YWx1ZVwiPjwvc3Bhbj4nKTtcbiAgICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2MtcHJvZ3Jlc3MtdmFsdWUtJyArIChkaXNwbGF5VmFsdWUgPT0gJ3JpZ2h0JyA/ICdyaWdodCcgOiAnbGVmdCcpKS5maW5kKCcubWJzYy1pbnB1dC13cmFwJykuYXBwZW5kKCRkaXNwbGF5KTtcbiAgICB9IC8vIEdlbmVyYXRlIHN0ZXAgbGFiZWxzXG5cblxuICAgIGlmIChzdGVwTGFiZWxzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RlcExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAkdHJhY2suYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3Mtc3RlcC1sYWJlbFwiIHN0eWxlPVwiJyArIChzLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCcpICsgJzogJyArIChzdGVwTGFiZWxzW2ldIC0gbWluKSAqIDEwMCAvIChtYXggLSBtaW4pICsgJyVcIiA+JyArIHN0ZXBMYWJlbHNbaV0gKyAnPC9zcGFuPicpO1xuICAgICAgfVxuICAgIH1cblxuICAgICR0YXJnZXQgPSAkJDEoJGVsbS5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IHMudGFyZ2V0KTtcbiAgfTtcblxuICB0aGF0Ll9fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdtYnNjLWljLWxlZnQgbWJzYy1pYy1yaWdodCcpLmZpbmQoJy5tYnNjLXByb2dyZXNzLWNvbnQnKS5yZW1vdmUoKTtcbiAgICAkcGFyZW50LmZpbmQoJy5tYnNjLWlucHV0LWljJykucmVtb3ZlKCk7XG4gICAgJGVsbS5vZmYoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgfTtcblxuICB0aGF0LnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlVmFsdWUoZ2V0QXR0cigndmFsdWUnLCBtaW4pLCB0cnVlLCBmYWxzZSk7XG4gIH07XG5cbiAgdGhhdC5nZXRWYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHRoYXQuc2V0VmFsID0gZnVuY3Rpb24gKHYsIGZpbGwsIGNoYW5nZSkge1xuICAgIHVwZGF0ZVZhbHVlKHYsIHRydWUsIGZpbGwsIGNoYW5nZSk7XG4gIH07XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5Qcm9ncmVzcy5wcm90b3R5cGUgPSB7XG4gIF9jbGFzczogJ3Byb2dyZXNzJyxcbiAgX2NzczogJ21ic2MtcHJvZ3Jlc3MnLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfaGFzRGVmOiB0cnVlLFxuICBfZGVmYXVsdHM6IHtcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxMDAsXG4gICAgcmV0dXJuQWZmaXg6IHRydWVcbiAgfVxufTtcbmNsYXNzZXMuUHJvZ3Jlc3MgPSBQcm9ncmVzczsgLy8gSW5pdCBtYnNjLXByb2dyZXNzIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtcHJvZ3Jlc3NdJywgUHJvZ3Jlc3MpO1xuXG52YXIgU2xpZGVyID0gZnVuY3Rpb24gU2xpZGVyKGVsbSwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRlbG0sXG4gICAgICAkcGFyZW50LFxuICAgICAgJHByb2dyZXNzLFxuICAgICAgJHRvb2x0aXBzLFxuICAgICAgJHRyYWNrLFxuICAgICAgaGFzUHJvZ3Jlc3MsXG4gICAgICBoYXNUb29sdGlwLFxuICAgICAgaXNSYW5nZSxcbiAgICAgIGlzUnRsLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgc3RlcCxcbiAgICAgIHMsXG4gICAgICB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgUHJvZ3Jlc3MuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcbiAgdmFyIHByb2dyZXNzSW5pdCA9IHRoYXQuX19pbml0LFxuICAgICAgcHJvZ3Jlc3NEZXN0cm95ID0gdGhhdC5fX2Rlc3Ryb3k7XG4gIFNsaWRlckJhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcbiAgdmFyIHNsaWRlckluaXQgPSB0aGF0Ll9faW5pdCxcbiAgICAgIHNsaWRlckRlc3Ryb3kgPSB0aGF0Ll9fZGVzdHJveTsgLy8gLS0tXG5cbiAgdGhhdC5fX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvZ3Jlc3NJbml0KCk7XG4gICAgc2xpZGVySW5pdCgpO1xuICB9O1xuXG4gIHRoYXQuX19kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2dyZXNzRGVzdHJveSgpO1xuICAgIHNsaWRlckRlc3Ryb3koKTtcbiAgfTtcblxuICB0aGF0Ll91cGRhdGUgPSBmdW5jdGlvbiAodiwgdmFsdWUsIGluZGV4LCBwZXJjZW50LCBtdWx0aXBsZSwgcmVmcmVzaCwgJGhhbmRsZUNvbnQpIHtcbiAgICBpZiAoaXNSYW5nZSkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHYgPSBNYXRoLm1pbih2LCB2YWx1ZVsxXSk7XG4gICAgICAgICRwcm9ncmVzcy5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBnZXRQZXJjZW50KHZhbHVlWzFdLCBtaW4sIG1heCkgLSBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSArICclJyxcbiAgICAgICAgICBsZWZ0OiBpc1J0bCA/ICdhdXRvJyA6IGdldFBlcmNlbnQodiwgbWluLCBtYXgpICsgJyUnLFxuICAgICAgICAgIHJpZ2h0OiBpc1J0bCA/IGdldFBlcmNlbnQodiwgbWluLCBtYXgpICsgJyUnIDogJ2F1dG8nXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IE1hdGgubWF4KHYsIHZhbHVlWzBdKTtcbiAgICAgICAgJHByb2dyZXNzLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IGdldFBlcmNlbnQodiwgbWluLCBtYXgpIC0gZ2V0UGVyY2VudCh2YWx1ZVswXSwgbWluLCBtYXgpICsgJyUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGUgfHwgIWhhc1Byb2dyZXNzKSB7XG4gICAgICAkaGFuZGxlQ29udC5jc3Moe1xuICAgICAgICBsZWZ0OiBpc1J0bCA/ICdhdXRvJyA6IChwZXJjZW50IHx8IGdldFBlcmNlbnQodiwgbWluLCBtYXgpKSArICclJyxcbiAgICAgICAgcmlnaHQ6IGlzUnRsID8gKHBlcmNlbnQgfHwgZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkpICsgJyUnIDogJ2F1dG8nXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHByb2dyZXNzLmNzcygnd2lkdGgnLCAocGVyY2VudCB8fCBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSkgKyAnJScpO1xuICAgIH1cblxuICAgIGlmIChoYXNUb29sdGlwKSB7XG4gICAgICAkdG9vbHRpcHMuZXEoaW5kZXgpLmh0bWwodik7XG4gICAgfSAvLyBEaXNwbGF5IHZhbHVlIGluIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyKHMpXG5cblxuICAgIGlmICghbXVsdGlwbGUgJiYgKHZhbHVlW2luZGV4XSAhPSB2IHx8IHJlZnJlc2gpKSB7XG4gICAgICB0aGF0Ll9kaXNwbGF5KHYpO1xuICAgIH0gLy8gUmV0dXJuIHZhbGlkYXRlZCB2YWx1ZVxuXG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB0aGF0Ll9yZWFkVmFsdWUgPSBmdW5jdGlvbiAoJGVsbSkge1xuICAgIHJldHVybiArJGVsbS52YWwoKTtcbiAgfTtcblxuICB0aGF0Ll9maWxsVmFsdWUgPSBmdW5jdGlvbiAodiwgaW5kZXgsIGNoYW5nZSkge1xuICAgICRlbG0uZXEoaW5kZXgpLnZhbCh2KTtcblxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICRlbG0uZXEoaW5kZXgpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSwgc3RlcE5yO1xuXG4gICAgaWYgKGhhc1Rvb2x0aXApIHtcbiAgICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2Mtc2xpZGVyLWhhcy10b29sdGlwJyk7XG4gICAgfSAvLyBHZW5lcmF0ZSBzdGVwIG1hcmtzXG5cblxuICAgIGlmIChzdGVwICE9IDEpIHtcbiAgICAgIHN0ZXBOciA9IChtYXggLSBtaW4pIC8gc3RlcDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8PSBzdGVwTnI7ICsraSkge1xuICAgICAgICAkdHJhY2suYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2xpZGVyLXN0ZXBcIiBzdHlsZT1cIicgKyAoaXNSdGwgPyAncmlnaHQnIDogJ2xlZnQnKSArICc6JyArIDEwMCAvIHN0ZXBOciAqIGkgKyAnJVwiPjwvc3Bhbj4nKTtcbiAgICAgIH1cbiAgICB9IC8vIEdlbmVyYXRlIHNsaWRlciBoYW5kbGVzXG5cblxuICAgICRlbG0uZWFjaChmdW5jdGlvbiAoaSwgZWxtKSB7XG4gICAgICB2YXIgdmFsdWUgPSArZWxtLnZhbHVlO1xuXG4gICAgICBpZiAoZWxtLnR5cGUgPT0gJ3JhbmdlJykge1xuICAgICAgICAvLyBTZXQgbWluIC8gbWF4IC8gc3RlcCBwcm9wZXJ0aWVzIGZvciBhbGwgaW5wdXRzXG4gICAgICAgICQkMShlbG0pLmF0dHIoJ21pbicsIG1pbikuYXR0cignbWF4JywgbWF4KS5hdHRyKCdzdGVwJywgc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIChoYXNQcm9ncmVzcyA/ICRwcm9ncmVzcyA6ICR0cmFjaykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2xpZGVyLWhhbmRsZS1jb250JyArIChpc1JhbmdlICYmICFpID8gJyBtYnNjLXNsaWRlci1oYW5kbGUtbGVmdCcgOiAnJykgKyAoaXNSYW5nZSAmJiAhaSAmJiB2YWx1ZSA+IChtYXggLSBtaW4pIC8gMiA/ICcgbWJzYy1oYW5kbGUtY3VycicgOiAnJykgKyAnXCI+JyArICc8c3BhbiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cIm1ic2Mtc2xpZGVyLWhhbmRsZVwiIGFyaWEtdmFsdWVtaW49XCInICsgbWluICsgJ1wiIGFyaWEtdmFsdWVtYXg9XCInICsgbWF4ICsgJ1wiIGRhdGEtaW5kZXg9XCInICsgaSArICdcIj48L3NwYW4+JyArIChoYXNUb29sdGlwID8gJzxzcGFuIGNsYXNzPVwibWJzYy1zbGlkZXItdG9vbHRpcFwiPjwvc3Bhbj4nIDogJycpICsgJzwvc3Bhbj4nKTtcbiAgICB9KTtcbiAgICAkdG9vbHRpcHMgPSAkcGFyZW50LmZpbmQoJy5tYnNjLXNsaWRlci10b29sdGlwJyk7XG4gIH07XG5cbiAgdGhhdC5fX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgkcGFyZW50KSB7XG4gICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdtYnNjLXNsaWRlci1oYXMtdG9vbHRpcCcpO1xuXG4gICAgICBpZiAoc3RlcCAhPSAxKSB7XG4gICAgICAgICQkMSgnLm1ic2Mtc2xpZGVyLXN0ZXAnLCAkdHJhY2spLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgICRwYXJlbnQgPSB0aGF0Ll8kcGFyZW50O1xuICAgICR0cmFjayA9IHRoYXQuXyR0cmFjaztcbiAgICAkcHJvZ3Jlc3MgPSB0aGF0Ll8kcHJvZ3Jlc3M7XG4gICAgJGVsbSA9ICRwYXJlbnQuZmluZCgnaW5wdXQnKTtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBtaW4gPSB0aGF0Ll9taW47XG4gICAgbWF4ID0gdGhhdC5fbWF4O1xuICAgIHRoYXQuX3N0ZXAgPSBzdGVwID0gc2V0dGluZ3Muc3RlcCA9PT0gdW5kZWZpbmVkID8gKyRlbG0uYXR0cignc3RlcCcpIHx8IHMuc3RlcCA6IHNldHRpbmdzLnN0ZXA7XG4gICAgdGhhdC5fbGl2ZSA9IGdldEJvb2xBdHRyKCdkYXRhLWxpdmUnLCBzLmxpdmUsICRlbG0pO1xuICAgIGhhc1Rvb2x0aXAgPSBnZXRCb29sQXR0cignZGF0YS10b29sdGlwJywgcy50b29sdGlwLCAkZWxtKTtcbiAgICBoYXNQcm9ncmVzcyA9IGdldEJvb2xBdHRyKCdkYXRhLWhpZ2hsaWdodCcsIHMuaGlnaGxpZ2h0LCAkZWxtKSAmJiAkZWxtLmxlbmd0aCA8IDM7XG4gICAgaXNSYW5nZSA9IGhhc1Byb2dyZXNzICYmICRlbG0ubGVuZ3RoID09IDI7XG4gICAgaXNSdGwgPSBzLnJ0bDtcblxuICAgIHRoYXQuX21hcmt1cFJlYWR5KCk7XG4gIH07XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5TbGlkZXIucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdwcm9ncmVzcycsXG4gIF9jc3M6ICdtYnNjLXByb2dyZXNzIG1ic2Mtc2xpZGVyJyxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgY2hhbmdlRXZlbnQ6ICdjaGFuZ2UnLFxuICAgIHN0b3BQcm9wOiB0cnVlLFxuICAgIG1pbjogMCxcbiAgICBtYXg6IDEwMCxcbiAgICBzdGVwOiAxLFxuICAgIGxpdmU6IHRydWUsXG4gICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgIHJvdW5kOiB0cnVlLFxuICAgIHJldHVybkFmZml4OiB0cnVlXG4gIH1cbn07XG5jbGFzc2VzLlNsaWRlciA9IFNsaWRlcjsgLy8gSW5pdCBtYnNjLXNsaWRlciBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLXNsaWRlcl0nLCBTbGlkZXIpO1xuXG52YXIgUmF0aW5nID0gZnVuY3Rpb24gUmF0aW5nKGVsbSwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRwcm9ncmVzcyxcbiAgICAgICR0cmFjayxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGVtcHR5LFxuICAgICAgZmlsbGVkLFxuICAgICAgcyxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgJGVsbSA9ICQkMShlbG0pOyAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuICBTbGlkZXIuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcblxuICB0aGF0Ll91cGRhdGUgPSBmdW5jdGlvbiAodiwgdmFsdWUsIGluZGV4LCBwZXJjZW50LCBtdWx0aXBsZSwgcmVmcmVzaCkge1xuICAgICRwcm9ncmVzcy5jc3MoJ3dpZHRoJywgZ2V0UGVyY2VudCh2LCAwLCBtYXgpICsgJyUnKTsgLy8gRGlzcGxheSB2YWx1ZSBpbiB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lcihzKVxuXG4gICAgaWYgKCFtdWx0aXBsZSAmJiAodmFsdWVbaW5kZXhdICE9IHYgfHwgcmVmcmVzaCkpIHtcbiAgICAgIHRoYXQuX2Rpc3BsYXkodik7XG4gICAgfSAvLyBSZXR1cm4gdmFsaWRhdGVkIHZhbHVlXG5cblxuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHRoYXQuX21hcmt1cFJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgICBlbXB0eVN0cmluZyA9ICcnLFxuICAgICAgICBmaWxsZWRTdHJpbmcgPSAnJztcbiAgICAkdHJhY2sgPSB0aGF0Ll8kdHJhY2s7XG4gICAgJHByb2dyZXNzID0gdGhhdC5fJHByb2dyZXNzO1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgIG1pbiA9IHRoYXQuX21pbjtcbiAgICBtYXggPSB0aGF0Ll9tYXg7XG4gICAgdGhhdC5fYmFzZSA9IG1pbjtcbiAgICB0aGF0Ll9yb3VuZGluZyA9IHMucnRsID8gJ2Zsb29yJyA6ICdjZWlsJztcbiAgICBlbXB0eSA9ICRlbG0uYXR0cignZGF0YS1lbXB0eScpIHx8IHMuZW1wdHk7XG4gICAgZmlsbGVkID0gJGVsbS5hdHRyKCdkYXRhLWZpbGxlZCcpIHx8IHMuZmlsbGVkO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heDsgKytpKSB7XG4gICAgICBlbXB0eVN0cmluZyArPSAnPHNwYW4gY2xhc3M9XCJtYnNjLWljIG1ic2MtaWMtJyArIGVtcHR5ICsgJ1wiPjwvc3Bhbj4nO1xuICAgICAgZmlsbGVkU3RyaW5nICs9ICc8c3BhbiBjbGFzcz1cIm1ic2MtaWMgbWJzYy1pYy0nICsgZmlsbGVkICsgJ1wiPjwvc3Bhbj4nO1xuICAgIH1cblxuICAgICR0cmFjay5odG1sKGVtcHR5U3RyaW5nKTtcbiAgICAkdHJhY2suYXBwZW5kKCRwcm9ncmVzcyk7XG4gICAgJHByb2dyZXNzLmh0bWwoZmlsbGVkU3RyaW5nKTtcbiAgICAkdHJhY2suYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtcmF0aW5nLWhhbmRsZS1jb250JyArICdcIj4nICsgJzxzcGFuIHRhYmluZGV4PVwiMFwiIGNsYXNzPVwibWJzYy1zbGlkZXItaGFuZGxlXCIgYXJpYS12YWx1ZW1pbj1cIicgKyBtaW4gKyAnXCIgYXJpYS12YWx1ZW1heD1cIicgKyBtYXggKyAnXCIgZGF0YS1pbmRleD1cIjBcIj48L3NwYW4+JyArICc8L3NwYW4+Jyk7XG4gIH07XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5SYXRpbmcucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdwcm9ncmVzcycsXG4gIF9jc3M6ICdtYnNjLXByb2dyZXNzIG1ic2MtcmF0aW5nJyxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgY2hhbmdlRXZlbnQ6ICdjaGFuZ2UnLFxuICAgIHN0b3BQcm9wOiB0cnVlLFxuICAgIG1pbjogMSxcbiAgICBtYXg6IDUsXG4gICAgc3RlcDogMSxcbiAgICBsaXZlOiB0cnVlLFxuICAgIHJvdW5kOiB0cnVlLFxuICAgIGhvdmVyOiB0cnVlLFxuICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICByZXR1cm5BZmZpeDogdHJ1ZSxcbiAgICBlbXB0eTogJ3N0YXInLFxuICAgIGZpbGxlZDogJ3N0YXIzJ1xuICB9XG59O1xuY2xhc3Nlcy5SYXRpbmcgPSBSYXRpbmc7IC8vIEluaXQgbWJzYy1yYXRpbmcgZWxlbWVudHMgb24gcGFnZSBsb2FkXG5cbmF1dG9Jbml0KCdbbWJzYy1yYXRpbmddJywgUmF0aW5nKTtcblxudmFyIG5yID0gMTtcbnZhciBDb2xsYXBzaWJsZUJhc2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xsYXBzaWJsZUJhc2UoZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY29udGVudDtcbiAgICB2YXIgJGhlYWRlcjtcbiAgICB2YXIgJGNvbnRlbnQ7XG4gICAgdmFyICRlbG0gPSAkJDEoZWxtKTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5faXNPcGVuID0gc2V0dGluZ3MuaXNPcGVuIHx8IGZhbHNlO1xuICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUgJyArICh0aGlzLl9pc09wZW4gPyAnbWJzYy1jb2xsYXBzaWJsZS1vcGVuJyA6ICcnKSk7XG5cbiAgICBpZiAoJGVsbS5oYXNDbGFzcygnbWJzYy1jYXJkJykpIHtcbiAgICAgIC8vIGNhcmQgZW5oYW5jZVxuICAgICAgJGhlYWRlciA9ICRlbG0uZmluZCgnLm1ic2MtY2FyZC1oZWFkZXInKS5lcSgwKS5hZGRDbGFzcygnbWJzYy1jb2xsYXBzaWJsZS1oZWFkZXInKTtcbiAgICAgICRjb250ZW50ID0gJGVsbS5maW5kKCcubWJzYy1jYXJkLWNvbnRlbnQnKS5lcSgwKS5hZGRDbGFzcygnbWJzYy1jb2xsYXBzaWJsZS1jb250ZW50Jyk7XG4gICAgfSBlbHNlIGlmICgkZWxtLmhhc0NsYXNzKCdtYnNjLWZvcm0tZ3JvdXAnKSB8fCAkZWxtLmhhc0NsYXNzKCdtYnNjLWZvcm0tZ3JvdXAtaW5zZXQnKSkge1xuICAgICAgLy8gZm9ybSBncm91cCBlbmhhbmNlXG4gICAgICAkaGVhZGVyID0gJGVsbS5maW5kKCcubWJzYy1mb3JtLWdyb3VwLXRpdGxlJykuZXEoMCkuYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtaGVhZGVyJyk7XG4gICAgICAkY29udGVudCA9ICRlbG0uZmluZCgnLm1ic2MtZm9ybS1ncm91cC1jb250ZW50JykuZXEoMCkuYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtY29udGVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBpdCBpcyB1c2VkIGluZGVwZW5kZW50bHlcbiAgICAgICRoZWFkZXIgPSAkZWxtLmZpbmQoJy5tYnNjLWNvbGxhcHNpYmxlLWhlYWRlcicpLmVxKDApO1xuICAgICAgJGNvbnRlbnQgPSAkZWxtLmZpbmQoJy5tYnNjLWNvbGxhcHNpYmxlLWNvbnRlbnQnKS5lcSgwKTtcbiAgICB9XG5cbiAgICBjb250ZW50ID0gJGNvbnRlbnRbMF07XG5cbiAgICBpZiAoY29udGVudCAmJiAhY29udGVudC5pZCkge1xuICAgICAgY29udGVudC5pZCA9ICdtYnNjLWNvbGxhcHNpYmxlLScgKyBucisrO1xuICAgIH1cblxuICAgIGlmICgkaGVhZGVyLmxlbmd0aCAmJiBjb250ZW50KSB7XG4gICAgICB2YXIgJGNvbGxhcHNpYmxlSWNvbiA9ICQkMSgnPHNwYW4gY2xhc3M9XCJtYnNjLWNvbGxhcHNpYmxlLWljb24gbWJzYy1pYyBtYnNjLWljLWFycm93LWRvd241XCI+PC9zcGFuPicpO1xuICAgICAgdGFwKHRoaXMsICRoZWFkZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuY29sbGFwc2UoKTtcbiAgICAgIH0pO1xuICAgICAgJGhlYWRlci5hdHRyKCdyb2xlJywgJ2J1dHRvbicpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLl9pc09wZW4pLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBjb250ZW50LmlkKS5hdHRyKCd0YWJpbmRleCcsICcwJykub24oJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pLm9uKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pLmFwcGVuZCgkY29sbGFwc2libGVJY29uKTtcbiAgICB9XG5cbiAgICBlbG0ubWJzY0luc3QgPSB0aGlzO1xuICAgIHRoaXMuXyRoZWFkZXIgPSAkaGVhZGVyO1xuICAgIHRoaXMuXyRjb250ZW50ID0gJGNvbnRlbnQ7XG4gICAgdGhpcy5fJGVsbSA9ICRlbG07XG4gICAgdGhpcy5fJGFjY29yZGlvblBhcmVudCA9ICRlbG0ucGFyZW50KCdbbWJzYy1hY2NvcmRpb25dLCBtYnNjLWFjY29yZGlvbiwgLm1ic2MtYWNjb3JkaW9uJyk7XG4gICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oaWRlID0gdGhpcy5oaWRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy50b2dnbGUgPSB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25LZXlEb3duID0gdGhpcy5vbktleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbGxhcHNpYmxlQmFzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2Uoc2hvdykge1xuICAgIHZhciAkZWxtID0gdGhpcy5fJGVsbTtcbiAgICB2YXIgJGNvbnRlbnQgPSB0aGlzLl8kY29udGVudDtcblxuICAgIHZhciByZW1vdmVIZWlnaHQgPSBmdW5jdGlvbiByZW1vdmVIZWlnaHQoKSB7XG4gICAgICAkY29udGVudC5vZmYoJ3RyYW5zaXRpb25lbmQnLCByZW1vdmVIZWlnaHQpLmNzcygnaGVpZ2h0JywgJycpO1xuICAgIH07XG5cbiAgICBpZiAoc2hvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaG93ID0gIXRoaXMuX2lzT3BlbjtcbiAgICB9XG5cbiAgICBpZiAoc2hvdyAmJiB0aGlzLl9pc09wZW4gfHwgIXNob3cgJiYgIXRoaXMuX2lzT3BlbiB8fCAhJGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNob3cpIHtcbiAgICAgIGlmIChoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICRjb250ZW50Lm9uKCd0cmFuc2l0aW9uZW5kJywgcmVtb3ZlSGVpZ2h0KS5jc3MoJ2hlaWdodCcsICRjb250ZW50WzBdLnNjcm9sbEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtb3BlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAkY29udGVudC5jc3MoJ2hlaWdodCcsIGdldENvbXB1dGVkU3R5bGUoJGNvbnRlbnRbMF0pLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAkY29udGVudC5jc3MoJ2hlaWdodCcsIDApO1xuICAgICAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbGxhcHNpYmxlLW9wZW4nKTtcbiAgICAgIH0sIDUwKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdyAmJiB0aGlzLl8kYWNjb3JkaW9uUGFyZW50KSB7XG4gICAgICB0aGlzLl8kYWNjb3JkaW9uUGFyZW50LmZpbmQoJy5tYnNjLWNvbGxhcHNpYmxlLW9wZW4nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgIT09ICRlbG1bMF0pIHtcbiAgICAgICAgICB0aGlzLm1ic2NJbnN0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gc2hvdztcblxuICAgIHRoaXMuXyRoZWFkZXIuYXR0cignYXJpYS1leHBhbmRlZCcsIHRoaXMuX2lzT3Blbik7XG4gIH07XG5cbiAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuY29sbGFwc2UodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY29sbGFwc2UoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgdGhpcy5jb2xsYXBzZSgpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl8kZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbGxhcHNpYmxlIG1ic2MtY29sbGFwc2libGUtb3BlbicpO1xuXG4gICAgdGhpcy5fJGNvbnRlbnQucmVtb3ZlQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtY29udGVudCcpO1xuXG4gICAgdGhpcy5fJGhlYWRlci5yZW1vdmVDbGFzcygnbWJzYy1jb2xsYXBzaWJsZS1oZWFkZXInKS5vZmYoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pLm9mZigna2V5ZG93bicsIHRoaXMub25LZXlEb3duKS5maW5kKCcubWJzYy1jb2xsYXBzaWJsZS1pY29uJykucmVtb3ZlKCk7XG5cbiAgICB0YXBPZmYodGhpcy5fJGhlYWRlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9uS2V5RG93biA9IGZ1bmN0aW9uIG9uS2V5RG93bihldikge1xuICAgIGlmIChldi53aGljaCA9PT0gMzIgfHwgZXYua2V5Q29kZSA9PSAxMykge1xuICAgICAgLy9zcGFjZSBvciBlbnRlciBcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmNvbGxhcHNlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2KSB7XG4gICAgLy8gcHJldmVudCBmb2N1cyBvbiBtb3VzZSBkb3duXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICByZXR1cm4gQ29sbGFwc2libGVCYXNlO1xufSgpO1xuY2xhc3Nlcy5Db2xsYXBzaWJsZUJhc2UgPSBDb2xsYXBzaWJsZUJhc2U7XG5cbnZhciBpZCQyID0gMDtcblxuZnVuY3Rpb24gaW5pdENvbnRyb2xzKCRjdHgsIGNvbnRyb2xzLCBzLCBzaGFsbG93KSB7XG4gICQkMSgnaW5wdXQsc2VsZWN0LHRleHRhcmVhLHByb2dyZXNzLGJ1dHRvbicsICRjdHgpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250cm9sID0gdGhpcyxcbiAgICAgICAgJGNvbnRyb2wgPSAkJDEoY29udHJvbCksXG4gICAgICAgIC8vJHBhcmVudCA9ICRjb250cm9sLnBhcmVudCgpLFxuICAgIHR5cGUgPSBnZXRDb250cm9sVHlwZSgkY29udHJvbCk7IC8vIFNraXAgZWxlbWVudHMgd2l0aCBkYXRhLWVuaGFuY2U9XCJmYWxzZVwiXG5cbiAgICBpZiAoJGNvbnRyb2wuYXR0cignZGF0YS1lbmhhbmNlJykgIT0gJ2ZhbHNlJ1xuICAgIC8qIFRSSUFMQ09ORCAqL1xuICAgICkge1xuICAgICAgICBpZiAoJGNvbnRyb2wuaGFzQ2xhc3MoJ21ic2MtY29udHJvbCcpKSB7XG4gICAgICAgICAgaWYgKGNvbnRyb2wubWJzY0luc3QpIHtcbiAgICAgICAgICAgIGNvbnRyb2wubWJzY0luc3Qub3B0aW9uKHtcbiAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgIGxhbmc6IHMubGFuZyxcbiAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgb25UZXh0OiBzLm9uVGV4dCxcbiAgICAgICAgICAgICAgb2ZmVGV4dDogcy5vZmZUZXh0LFxuICAgICAgICAgICAgICBzdG9wUHJvcDogcy5zdG9wUHJvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY29udHJvbC5pZCkge1xuICAgICAgICAgICAgY29udHJvbC5pZCA9ICdtYnNjLWZvcm0tY29udHJvbC0nICsgKytpZCQyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IEJ1dHRvbihjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgU3dpdGNoKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwLFxuICAgICAgICAgICAgICAgIG9uVGV4dDogcy5vblRleHQsXG4gICAgICAgICAgICAgICAgb2ZmVGV4dDogcy5vZmZUZXh0LFxuICAgICAgICAgICAgICAgIHN0b3BQcm9wOiBzLnN0b3BQcm9wXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBDaGVja0JveChjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGFwOiBzLnRhcCxcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICAgICAgICBpZiAoISQkMShjb250cm9sKS5wYXJlbnQoKS5oYXNDbGFzcygnbWJzYy1zbGlkZXInKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFNsaWRlcihjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICAgIGxhbmc6IHMubGFuZyxcbiAgICAgICAgICAgICAgICAgIHJ0bDogcy5ydGwsXG4gICAgICAgICAgICAgICAgICBzdG9wUHJvcDogcy5zdG9wUHJvcCxcbiAgICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IHMubGFiZWxTdHlsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhdGluZyc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFJhdGluZyhjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgbGFuZzogcy5sYW5nLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGwsXG4gICAgICAgICAgICAgICAgc3RvcFByb3A6IHMuc3RvcFByb3BcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFByb2dyZXNzKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgICBsYWJlbFN0eWxlOiBzLmxhYmVsU3R5bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFJhZGlvKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBTZWxlY3QoY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRhcDogcy50YXAsXG4gICAgICAgICAgICAgICAgaW5wdXRTdHlsZTogcy5pbnB1dFN0eWxlLFxuICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IHMubGFiZWxTdHlsZSxcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBUZXh0QXJlYShjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGFwOiBzLnRhcCxcbiAgICAgICAgICAgICAgICBpbnB1dFN0eWxlOiBzLmlucHV0U3R5bGUsXG4gICAgICAgICAgICAgICAgbGFiZWxTdHlsZTogcy5sYWJlbFN0eWxlLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzZWdtZW50ZWQnOlxuICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBTZWdtZW50ZWRJdGVtKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsLFxuICAgICAgICAgICAgICAgIHRhcDogcy50YXAsXG4gICAgICAgICAgICAgICAgaW5wdXRTdHlsZTogcy5pbnB1dFN0eWxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3RlcHBlcic6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFN0ZXBwZXIoY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IElucHV0KGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwLFxuICAgICAgICAgICAgICAgIGlucHV0U3R5bGU6IHMuaW5wdXRTdHlsZSxcbiAgICAgICAgICAgICAgICBsYWJlbFN0eWxlOiBzLmxhYmVsU3R5bGUsXG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH0pO1xuICAkJDEoJ1tkYXRhLWNvbGxhcHNpYmxlXTpub3QoLm1ic2MtY29sbGFwc2libGUpJywgJGN0eCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLFxuICAgICAgICAkY29udHJvbCA9ICQkMShjb250cm9sKSxcbiAgICAgICAgaXNPcGVuID0gJGNvbnRyb2wuYXR0cignZGF0YS1vcGVuJyk7XG5cbiAgICBpZiAoIWNvbnRyb2wuaWQpIHtcbiAgICAgIGNvbnRyb2wuaWQgPSAnbWJzYy1mb3JtLWNvbnRyb2wtJyArICsraWQkMjtcbiAgICB9XG5cbiAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBDb2xsYXBzaWJsZUJhc2UoY29udHJvbCwge1xuICAgICAgaXNPcGVuOiBpc09wZW4gIT09IHVuZGVmaW5lZCAmJiBpc09wZW4gIT0gJ2ZhbHNlJ1xuICAgIH0pO1xuICAgIGluc3RhbmNlc1tjb250cm9sLmlkXSA9IGNvbnRyb2xzW2NvbnRyb2wuaWRdO1xuICB9KTsgLy8gU2V0IGluaXRpYWwgaGVpZ2h0IGZvciB0ZXh0YXJlYXNcblxuICBpZiAoIXNoYWxsb3cpIHtcbiAgICBzaXplVGV4dEFyZWFzKCk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgQ2FyZCA9IGZ1bmN0aW9uIENhcmQoZWwsIHNldHRpbmdzKSB7XG4gIHZhciBzLFxuICAgICAgY29sbGFwc2libGVJbnN0LFxuICAgICAgY3NzQ2xhc3MgPSAnJyxcbiAgICAgICRlbG0gPSAkJDEoZWwpLFxuICAgICAgY29udHJvbHMgPSB7fSxcbiAgICAgIHRoYXQgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHRvdWNoZWQoKSB7XG4gICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1uby10b3VjaCcpO1xuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgQmFzZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5yZWZyZXNoID0gZnVuY3Rpb24gKHNoYWxsb3cpIHtcbiAgICBpbml0Q29udHJvbHMoJGVsbSwgY29udHJvbHMsIHMsIHNoYWxsb3cpO1xuICB9O1xuICAvKipcbiAgICogQ2FyZCBpbml0aWFsaXphdGlvbi5cbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc0NvbGxhcHNpYmxlID0gcy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkIHx8ICRlbG0uYXR0cignZGF0YS1jb2xsYXBzaWJsZScpICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoISRlbG0uaGFzQ2xhc3MoJ21ic2MtY2FyZCcpKSB7XG4gICAgICAkZWxtLnNob3coKTtcbiAgICAgIGxpc3RlbihlbCwgJ3RvdWNoc3RhcnQnLCB0b3VjaGVkLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgJGVsbS5yZW1vdmVDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIC8qXG4gICAgY3NzQ2xhc3MgPSAnbWJzYy1jYXJkIG1ic2MtZm9ybSBtYnNjLW5vLXRvdWNoIG1ic2MtJyArIHMudGhlbWUgK1xuICAgICAgICAoaGFsZkJvcmRlciA/ICcgbWJzYy1mb3JtLWhiJyA6ICcnKSArXG4gICAgICAgIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgK1xuICAgICAgICAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKTtcbiAgICAqL1xuICAgIC8vIC0tLSBSRU1PVEUgVFJJQUwgQ09ERSBTVEFSVCAtLS1cblxuXG4gICAgY3NzQ2xhc3MgPSB0aGF0LnJlbW90ZS5jYXJkcy5jc3NDbGFzczsgLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIEVORCAtLS1cblxuICAgICRlbG0uYWRkQ2xhc3MoY3NzQ2xhc3MpLnJlbW92ZUNsYXNzKCdtYnNjLWNsb2FrJyk7XG5cbiAgICBpZiAoaXNDb2xsYXBzaWJsZSAmJiAhY29sbGFwc2libGVJbnN0KSB7XG4gICAgICB2YXIgaXNPcGVuID0gJGVsbS5hdHRyKCdkYXRhLW9wZW4nKTtcbiAgICAgIGNvbGxhcHNpYmxlSW5zdCA9IG5ldyBDb2xsYXBzaWJsZUJhc2UoZWwsIHtcbiAgICAgICAgaXNPcGVuOiBpc09wZW4gIT09IHVuZGVmaW5lZCAmJiBpc09wZW4gIT0gJ2ZhbHNlJyB8fCBzLmNvbGxhcHNpYmxlID09PSB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkZWxtLmFwcGVuZCh0aGF0Ll9nZXRUZXh0KG1vYmlzY3JvbGwsIDAuNSkpO1xuICAgIHRoYXQucmVmcmVzaCgpO1xuICB9O1xuICAvKipcbiAgICogRGVzdHJveXMgdGhlIG1vYmlzY3JvbGwgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgdGhhdC5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB1bmxpc3RlbihlbCwgJ3RvdWNoc3RhcnQnLCB0b3VjaGVkLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBjb250cm9scykge1xuICAgICAgY29udHJvbHNbaWRdLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBpZiAoY29sbGFwc2libGVJbnN0KSB7XG4gICAgICBjb2xsYXBzaWJsZUluc3QuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29sbGFwc2libGVJbnN0KSB7XG4gICAgICBjb2xsYXBzaWJsZUluc3QudG9nZ2xlKCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29sbGFwc2libGVJbnN0KSB7XG4gICAgICBjb2xsYXBzaWJsZUluc3QuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbGxhcHNpYmxlSW5zdCkge1xuICAgICAgY29sbGFwc2libGVJbnN0LnNob3coKTtcbiAgICB9XG4gIH07IC8vIENvbnN0cnVjdG9yXG5cblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdGhhdC5pbml0KCk7XG59OyAvLyBFeHRlbmQgZGVmYXVsdHNcblxuQ2FyZC5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9jbGFzczogJ2NhcmQnLFxuICBfZGVmYXVsdHM6IHtcbiAgICB0YXA6IGhhc0dob3N0Q2xpY2ssXG4gICAgc3RvcFByb3A6IHRydWUsXG4gICAgcnRsOiBmYWxzZVxuICB9XG59O1xuY2xhc3Nlcy5DYXJkID0gQ2FyZDsgLy8gSW5pdCBtYnNjLWNhcmQgZWxlbWVudHMgb24gcGFnZSBsb2FkIG9yIHdoZW4gbWJzYy1lbmhhbmNlIGV2ZW50IGlzIHRyaWdnZXJlc1xuXG5hdXRvSW5pdCgnW21ic2MtY2FyZF0nLCBDYXJkLCB0cnVlKTtcblxudmFyIFNFTEVDVEVEX0NMQVNTID0gJ21ic2Mtc2VsZWN0ZWQnO1xudmFyIEFDVElWRV9DTEFTUyA9ICdtYnNjLWx2LWl0ZW0tYWN0aXZlJztcbnZhciBjb25maXJtcyxcbiAgICBndWlkID0gMSxcbiAgICB0cmFuc3AgPSAndHJhbnNwYXJlbnQnO1xudmFyIExpc3RWaWV3ID0gZnVuY3Rpb24gTGlzdFZpZXcoZWxlbSwgc2V0dGluZ3MpIHtcbiAgdmFyIGFjdGlvbixcbiAgICAgIGFjdGlvbldpZHRoLFxuICAgICAgYWN0aXZlVGltZXIsXG4gICAgICBhbmltUG9zLFxuICAgICAgY2FuY2VsLFxuICAgICAgY29uZmlybUl0ZW0sXG4gICAgICBjb25maXJtSW5kZXgsXG4gICAgICBjb250LFxuICAgICAgY29udDAsXG4gICAgICBjdXJySW5kZXgsXG4gICAgICBjdXJyTGlzdCxcbiAgICAgIGN1cnJQaCxcbiAgICAgIGN1cnJQYXJlbnQsXG4gICAgICBjdXJyU2libGluZ3MsXG4gICAgICBjdXJyU3RhZ2UsXG4gICAgICBjdXJyU3RhZ2VJZHgsXG4gICAgICBkZWJvdW5jZSxcbiAgICAgIGRlbW9Nb2RlLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBkaWZmWCxcbiAgICAgIGRpZmZZLFxuICAgICAgZHJvcERvd24sXG4gICAgICBkcm9wVXAsXG4gICAgICBkcmFnZ2VkLFxuICAgICAgZHVtbXlDb250LFxuICAgICAgZW5kVGltZXIsXG4gICAgICBlbmRYLFxuICAgICAgZW5kWSxcbiAgICAgIGV2ZW50LFxuICAgICAgZmlsbCxcbiAgICAgIGZvdW5kLFxuICAgICAgZ3JvdXBIZWFkZXIsXG4gICAgICBoYWRFbmhhbmNlLFxuICAgICAgaGFuZGxlUG9zLFxuICAgICAgaGFzQ29udGV4dCxcbiAgICAgIGhhbmRsZURpdixcbiAgICAgIGhvdmVyRGlyLFxuICAgICAgaG92ZXJJdGVtLFxuICAgICAgaG92ZXJJdGVtT3BlbmVkLFxuICAgICAgaG92ZXJUaW1lLFxuICAgICAgaG92ZXJUaW1lb3V0LFxuICAgICAgaG92ZXJUaW1lcixcbiAgICAgIGh0bWxMZWZ0LFxuICAgICAgaHRtbFJpZ2h0LFxuICAgICAgaWNvbixcbiAgICAgIGljb25jLFxuICAgICAgc3RhZ2VjLFxuICAgICAgaXNDbGljayxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzVG91Y2gsXG4gICAgICBpdGVtdyxcbiAgICAgIGl0ZW0sXG4gICAgICBpdGVtSGVpZ2h0LFxuICAgICAgaXRlbUluZGV4LFxuICAgICAgaXRlbU5vZGUsXG4gICAgICBpdGVtU2VsZWN0b3IsXG4gICAgICBpdGVtVG9wLFxuICAgICAgbGlzdE5vZGUsXG4gICAgICBsaXN0U2VsZWN0b3IsXG4gICAgICBsb2FkaW5nLFxuICAgICAgbWF4RHJhZyxcbiAgICAgIG1pbkRyYWcsXG4gICAgICBtdWx0aWMsXG4gICAgICBtdWx0aXBsZSxcbiAgICAgIG5leHRJdGVtLFxuICAgICAgbmV4dE9mZnNldCxcbiAgICAgIG5leHRTdGFnZSxcbiAgICAgIG5leHRJdGVtcyxcbiAgICAgIG9uU2Nyb2xsVGhyb3R0bGUsXG4gICAgICBvblNjcm9sbERlYm91bmNlLFxuICAgICAgcHJldkNsaWNrLFxuICAgICAgcHJldmVudEhvdmVyLFxuICAgICAgcHJldmVudFRpbWVyLFxuICAgICAgcHJldkl0ZW1zLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBwcmV2SXRlbSxcbiAgICAgIHByZXZPZmZzZXQsXG4gICAgICBwcmV2U3RhZ2UsXG4gICAgICBxdWlja1N3aXBlLFxuICAgICAgcmFmSUQsXG4gICAgICByYWZSdW5uaW5nLFxuICAgICAgcyxcbiAgICAgIHNjcm9sbCxcbiAgICAgIHNlbGVjdGFibGUsXG4gICAgICBzaW11bGF0aW5nLFxuICAgICAgc2xpZGVDb250LFxuICAgICAgc3RhZ2VOcixcbiAgICAgIHN0YWdlcyxcbiAgICAgIHN0YXJ0UG9zLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3R5bGUsXG4gICAgICBzd2lwZSxcbiAgICAgIHN3aXBlSW50ZXJ2YWwsXG4gICAgICBzd2lwZVRpbWVvdXQsXG4gICAgICB0YXBIaWdobGlnaHQsXG4gICAgICB0ZXh0LFxuICAgICAgdGltZXIsXG4gICAgICB0eXBlLFxuICAgICAgdHlwZXMsXG4gICAgICB1bmRvUmVmLFxuICAgICAgdW5kb0FuaW0sXG4gICAgICB3bmQsXG4gICAgICB3bmQwLFxuICAgICAgd25kSGVpZ2h0LFxuICAgICAgd25kU2Nyb2xsLFxuICAgICAgd25kVG9wLFxuICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICBlID0gZWxlbSxcbiAgICAgIGVsbSA9ICQkMShlKSxcbiAgICAgIHRyYW5zaXRpb24gPSAwLFxuICAgICAgc2xpZGVMZXZlbCA9IDAsXG4gICAgICBzdGFydFRvcCA9IDAsXG4gICAgICBzdGFnZU9iaiA9IHt9LFxuICAgICAgYWN0aW9uUXVldWUgPSB7fSxcbiAgICAgIHRyZWVNYXAgPSB7fTtcblxuICBmdW5jdGlvbiBvbkFjdGlvblN0YXJ0KCkge1xuICAgIHF1aWNrU3dpcGUgPSBmYWxzZTtcbiAgICBwcmV2Q2xpY2sgPSBmYWxzZTtcbiAgICBhbmltUG9zID0gMDtcbiAgICBzdGFydFBvcyA9IDA7XG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBpdGVtdyA9IGN1cnJMaXN0LndpZHRoKCk7XG4gICAgY3VyclNpYmxpbmdzID0gZ2V0Q2hpbGRyZW4oY3Vyckxpc3QpO1xuICAgIGl0ZW1JbmRleCA9IGN1cnJTaWJsaW5ncy5pbmRleChpdGVtKTtcbiAgICBpdGVtSGVpZ2h0ID0gaXRlbVswXS5vZmZzZXRIZWlnaHQ7XG4gICAgc3RhcnRUb3AgPSBpdGVtWzBdLm9mZnNldFRvcDtcbiAgICB0eXBlID0gdHlwZXNbaXRlbS5hdHRyKCdkYXRhLXR5cGUnKSB8fCAnZGVmYXVsdHMnXTtcbiAgICBzdGFnZXMgPSB0eXBlLnN0YWdlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoZXYpIHtcbiAgICB2YXIgaXRtO1xuICAgIHZhciB0YXJnZXQgPSBjbG9zZXN0KGNvbnQwLCBldi50YXJnZXQsICcubWJzYy1sdi1pdGVtJyk7XG5cbiAgICBpZiAoIXRhcmdldCB8fCAhY29udDAuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgIGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgICAgIHByZXZlbnRIb3ZlciA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQocHJldmVudFRpbWVyKTtcbiAgICB9XG5cbiAgICBpZiAodGVzdFRvdWNoKGV2LCB0YXJnZXQpICYmICFhY3Rpb24gJiYgIXRyYW5zaXRpb24gJiYgIWNvbmZpcm1zICYmICF1bmRvaW5nICYmIG1vYmlzY3JvbGwuRW10akMpIHtcbiAgICAgIGFjdGlvbiA9IHRydWU7XG4gICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgaXNDbGljayA9IGZhbHNlO1xuICAgICAgaXNUb3VjaCA9IGV2LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICBkaWZmWCA9IDA7XG4gICAgICBkaWZmWSA9IDA7XG4gICAgICBpdGVtID0gJCQxKHRhcmdldCk7XG4gICAgICBpdG0gPSBpdGVtOyAvLyBMb2NhbCByZWZlcmVuY2VcblxuICAgICAgb25BY3Rpb25TdGFydCgpO1xuICAgICAgdGFwSGlnaGxpZ2h0ID0gdHlwZS5hY3Rpb25hYmxlIHx8IGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykgfHwgaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJyk7XG4gICAgICBpdGVtVG9wID0gaXRlbS5vZmZzZXQoKS50b3A7XG5cbiAgICAgIGlmICh0YXBIaWdobGlnaHQpIHtcbiAgICAgICAgYWN0aXZlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpdG0uYWRkQ2xhc3MoaXNUb3VjaCA/IEFDVElWRV9DTEFTUyA6ICcnKTtcbiAgICAgICAgICBldmVudCgnb25JdGVtQWN0aXZhdGUnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGl0bVswXSxcbiAgICAgICAgICAgIGRvbUV2ZW50OiBldlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMjApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhhdC5zb3J0YWJsZSAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgaWYgKCF0aGF0LnNvcnRhYmxlLmdyb3VwKSB7XG4gICAgICAgICAgbmV4dEl0ZW1zID0gaXRlbS5uZXh0VW50aWwoJy5tYnNjLWx2LWdyLXRpdGxlJykuZmlsdGVyKCcubWJzYy1sdi1pdGVtJyk7XG4gICAgICAgICAgcHJldkl0ZW1zID0gaXRlbS5wcmV2VW50aWwoJy5tYnNjLWx2LWdyLXRpdGxlJykuZmlsdGVyKCcubWJzYy1sdi1pdGVtJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5EcmFnID0gKCF0aGF0LnNvcnRhYmxlLmdyb3VwID8gcHJldkl0ZW1zLmxlbmd0aCA/IHByZXZJdGVtcy5lcSgtMSkgOiBpdGVtIDogY3Vyckxpc3QuY2hpbGRyZW4oaXRlbVNlbGVjdG9yKS5lcSgwKSlbMF0ub2Zmc2V0VG9wIC0gc3RhcnRUb3A7XG4gICAgICAgIG1heERyYWcgPSAoIXRoYXQuc29ydGFibGUuZ3JvdXAgPyBuZXh0SXRlbXMubGVuZ3RoID8gbmV4dEl0ZW1zLmVxKC0xKSA6IGl0ZW0gOiBjdXJyTGlzdC5jaGlsZHJlbihpdGVtU2VsZWN0b3IpLmVxKC0xKSlbMF0ub2Zmc2V0VG9wIC0gc3RhcnRUb3A7XG5cbiAgICAgICAgaWYgKHRoYXQuc29ydGFibGUuaGFuZGxlKSB7XG4gICAgICAgICAgaWYgKCQkMShldi50YXJnZXQpLmhhc0NsYXNzKCdtYnNjLWx2LWhhbmRsZScpKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgb25Tb3J0U3RhcnQoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaWxsLmFwcGVuZFRvKGl0ZW0pO1xuICAgICAgICAgICAgZmlsbFswXS5zdHlsZVtqc1ByZWZpeCArICdBbmltYXRpb24nXSA9ICdtYnNjLWx2LWZpbGwgJyArIChzLnNvcnREZWxheSAtIDEwMCkgKyAnbXMgbGluZWFyJztcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlbmRUaW1lcik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuICAgICAgICAgICAgY2FuY2VsID0gZmFsc2U7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmaWxsWzBdLnN0eWxlW2pzUHJlZml4ICsgJ0FuaW1hdGlvbiddID0gJyc7XG4gICAgICAgICAgICAgIG9uU29ydFN0YXJ0KCk7XG4gICAgICAgICAgICB9LCBzLnNvcnREZWxheSAtIDgwKTtcbiAgICAgICAgICB9LCA4MCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vbignbW91c2V1cCcsIG9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICB2YXIgc29ydENoYW5nZSA9IGZhbHNlLFxuICAgICAgICBkcm9wQ2hhbmdlID0gdHJ1ZSxcbiAgICAgICAgcHJldlBvcyA9IGFuaW1Qb3M7XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBlbmRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBlbmRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICBkaWZmWCA9IGVuZFggLSBzdGFydFg7XG4gICAgICBkaWZmWSA9IGVuZFkgLSBzdGFydFk7XG4gICAgICBjbGVhclRpbWVvdXQoZW5kVGltZXIpO1xuXG4gICAgICBpZiAoIWRyYWdnZWQgJiYgIXN3aXBlICYmICFzY3JvbGwgJiYgIWl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtYmFjaycpKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmWSkgPiAxMCkge1xuICAgICAgICAgIC8vIEl0J3MgYSBzY3JvbGxcbiAgICAgICAgICBzY3JvbGwgPSB0cnVlO1xuICAgICAgICAgIG9uRW5kKGV4dGVuZCQxKHt9LCBldiwge1xuICAgICAgICAgICAgdHlwZTogZXYudHlwZSA9PSAnbW91c2Vtb3ZlJyA/ICdtb3VzZXVwJyA6ICd0b3VjaGVuZCdcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGFjdGl2ZVRpbWVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaWZmWCkgPiA3KSB7XG4gICAgICAgICAgLy8gSXQncyBhIHN3aXBlXG4gICAgICAgICAgb25Td2lwZVN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFuaW1Qb3MgPSBkaWZmWCAvIGl0ZW13ICogMTAwO1xuICAgICAgICBvblN3aXBlTW92ZShwcmV2UG9zKTtcbiAgICAgIH0gZWxzZSBpZiAoZHJhZ2dlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgc2Nyb2xsZWQsXG4gICAgICAgICAgICBzdCA9IHduZC5zY3JvbGxUb3AoKSxcbiAgICAgICAgICAgIGRpZmYgPSBNYXRoLm1heChtaW5EcmFnLCBNYXRoLm1pbihkaWZmWSArIHduZFNjcm9sbCwgbWF4RHJhZykpLFxuICAgICAgICAgICAgdG9wID0gaGFzQ29udGV4dCA/IGl0ZW1Ub3AgLSB3bmRUb3AgKyBzdCAtIHduZFNjcm9sbCA6IGl0ZW1Ub3A7IC8vIENoZWNrIGlmIHNjcm9sbCBpcyBuZWVkZWRcblxuICAgICAgICBpZiAod25kSGVpZ2h0ICsgc3QgPCB0b3AgKyBkaWZmICsgaXRlbUhlaWdodCkge1xuICAgICAgICAgIHduZC5zY3JvbGxUb3AodG9wICsgZGlmZiAtIHduZEhlaWdodCArIGl0ZW1IZWlnaHQpO1xuICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3AgKyBkaWZmIDwgc3QpIHtcbiAgICAgICAgICB3bmQuc2Nyb2xsVG9wKHRvcCArIGRpZmYpO1xuICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgc2Nyb2xsIHZhbHVlcyBpZiB3aW5kb3cgd2FzIHNjcm9sbGVkXG5cblxuICAgICAgICBpZiAoc2Nyb2xsZWQpIHtcbiAgICAgICAgICB3bmRTY3JvbGwgKz0gd25kLnNjcm9sbFRvcCgpIC0gc3Q7XG4gICAgICAgIH0gLy8gQ2hlY2sgb3ZlcmxhcCB3aXRoIG5leHQgaXRlbVxuXG5cbiAgICAgICAgaWYgKG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAvLyBJZiBzdWJ0cmVlIGV4aXN0cywgZHJvcCBlbGVtZW50IG9uIHN1YnRyZWUgYXQgMS80LCBjaGFuZ2Ugc29ydCBvcmRlciBhdCAzLzQgb3ZlcmxhcFxuICAgICAgICAgIGlmICh0aGF0LnNvcnRhYmxlLm11bHRpTGV2ZWwgJiYgbmV4dEl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRvcCArIGl0ZW1IZWlnaHQgLyA0ICsgZGlmZiA+IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgc29ydENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0VG9wICsgaXRlbUhlaWdodCAtIGl0ZW1IZWlnaHQgLyA0ICsgZGlmZiA+IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgZHJvcERvd24gPSBuZXh0SXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pdGVtLWhsJyk7XG4gICAgICAgICAgICAgIGRyb3BDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgMS8yIG92ZXJsYXBcblxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRUb3AgKyBpdGVtSGVpZ2h0IC8gMiArIGRpZmYgPiBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBJZiBvdmVyIGJhY2sgYnV0dG9uLCBoaWdobGlnaHQgdG8gZHJvcCB0byBwYXJlbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChuZXh0SXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgICAgICAgaWYgKHRoYXQuc29ydGFibGUubXVsdGlMZXZlbCkge1xuICAgICAgICAgICAgICAgIGRyb3BVcCA9IG5leHRJdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgICAgICBkcm9wQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvcnRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5pbnNlcnRBZnRlcihuZXh0SXRlbSk7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IG5leHRJdGVtO1xuICAgICAgICAgICAgbmV4dEl0ZW0gPSBnZXROZXh0UHJldihuZXh0SXRlbSwgJ25leHQnKTtcbiAgICAgICAgICAgIHByZXZPZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgICAgICAgICAgbmV4dE9mZnNldCA9IG5leHRJdGVtLmxlbmd0aCAmJiBuZXh0SXRlbVswXS5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjdXJySW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hlY2sgb3ZlcmxhcCB3aXRoIHByZXYgaXRlbVxuXG5cbiAgICAgICAgaWYgKCFzb3J0Q2hhbmdlICYmIHByZXZPZmZzZXQpIHtcbiAgICAgICAgICAvLyBJZiBzdWJ0cmVlIGV4aXN0cywgZHJvcCBlbGVtZW50IG9uIHN1YnRyZWUgYXQgMS8zLCBjaGFuZ2Ugc29ydCBvcmRlciBhdCAyLzMgb3ZlcmxhcFxuICAgICAgICAgIGlmICh0aGF0LnNvcnRhYmxlLm11bHRpTGV2ZWwgJiYgcHJldkl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykpIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRvcCArIGl0ZW1IZWlnaHQgLSBpdGVtSGVpZ2h0IC8gNCArIGRpZmYgPCBwcmV2T2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHNvcnRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFRvcCArIGl0ZW1IZWlnaHQgLyA0ICsgZGlmZiA8IHByZXZPZmZzZXQpIHtcbiAgICAgICAgICAgICAgZHJvcERvd24gPSBwcmV2SXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pdGVtLWhsJyk7XG4gICAgICAgICAgICAgIGRyb3BDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgMS8yIG92ZXJsYXBcblxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRUb3AgKyBpdGVtSGVpZ2h0IC8gMiArIGRpZmYgPCBwcmV2T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBJZiBvdmVyIGJhY2sgYnV0dG9uLCBoaWdobGlnaHQgdG8gZHJvcCB0byBwYXJlbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChwcmV2SXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgICAgICAgaWYgKHRoYXQuc29ydGFibGUubXVsdGlMZXZlbCkge1xuICAgICAgICAgICAgICAgIGRyb3BVcCA9IHByZXZJdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgICAgICBkcm9wQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvcnRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5pbnNlcnRCZWZvcmUocHJldkl0ZW0pO1xuICAgICAgICAgICAgbmV4dEl0ZW0gPSBwcmV2SXRlbTtcbiAgICAgICAgICAgIHByZXZJdGVtID0gZ2V0TmV4dFByZXYocHJldkl0ZW0sICdwcmV2Jyk7XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gcHJldk9mZnNldDtcbiAgICAgICAgICAgIHByZXZPZmZzZXQgPSBwcmV2SXRlbS5sZW5ndGggJiYgcHJldkl0ZW1bMF0ub2Zmc2V0VG9wICsgcHJldkl0ZW1bMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgY3VyckluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyb3BDaGFuZ2UpIHtcbiAgICAgICAgICBpZiAoZHJvcERvd24pIHtcbiAgICAgICAgICAgIGRyb3BEb3duLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgIGRyb3BEb3duID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRyb3BVcCkge1xuICAgICAgICAgICAgZHJvcFVwLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgIGRyb3BVcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgZXZlbnQoJ29uU29ydENoYW5nZScsIHtcbiAgICAgICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgICAgIGluZGV4OiBjdXJySW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWcoaXRlbSwgZGlmZik7XG4gICAgICAgIGV2ZW50KCdvblNvcnQnLCB7XG4gICAgICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgICAgIGluZGV4OiBjdXJySW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZYKSA+IDUgfHwgTWF0aC5hYnMoZGlmZlkpID4gNSkge1xuICAgICAgICAvLyBDYW5jZWwgZHJhZ3N0YXJ0IGlmIG1vdmVtZW50IGlzID4gNXB4XG4gICAgICAgIHN0b3BUaW1lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kKGV2KSB7XG4gICAgdmFyIGRpc3QsXG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpdG0gPSBpdGVtO1xuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgYWN0aW9uID0gZmFsc2U7XG4gICAgICBzdG9wVGltZXIoKTtcblxuICAgICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNldXAnKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub2ZmKCdtb3VzZW1vdmUnLCBvbk1vdmUpLm9mZignbW91c2V1cCcsIG9uRW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzY3JvbGwpIHtcbiAgICAgICAgcHJldmVudFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJldmVudEhvdmVyID0gZmFsc2U7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZSB8fCBzY3JvbGwgfHwgZHJhZ2dlZCkge1xuICAgICAgICBwcmV2Q2xpY2sgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGUpIHtcbiAgICAgICAgb25Td2lwZUVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgIC8vIFNvcnQgZW5kXG4gICAgICAgIHBhcmVudCA9IGN1cnJMaXN0O1xuXG4gICAgICAgIGlmIChkcm9wRG93bikge1xuICAgICAgICAgIHJlc2V0SXRlbShpdGVtLmRldGFjaCgpKTtcbiAgICAgICAgICBtYXAgPSB0cmVlTWFwW2Ryb3BEb3duLmF0dHIoJ2RhdGEtcmVmJyldO1xuICAgICAgICAgIGN1cnJJbmRleCA9IGdldENoaWxkcmVuKG1hcC5jaGlsZCkubGVuZ3RoO1xuICAgICAgICAgIGRyb3BEb3duLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcblxuICAgICAgICAgIGlmIChzLm5hdmlnYXRlT25Ecm9wKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZShkcm9wRG93biwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGF0LmFkZChudWxsLCBpdGVtLCBudWxsLCBudWxsLCBkcm9wRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHNjcm9sbFRvSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgb25Tb3J0RW5kKGl0ZW0sIGl0ZW1JbmRleCwgcGFyZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmFkZChudWxsLCBpdGVtLCBudWxsLCBudWxsLCBkcm9wRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICBvblNvcnRFbmQoaXRlbSwgaXRlbUluZGV4LCBwYXJlbnQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkcm9wVXApIHtcbiAgICAgICAgICByZXNldEl0ZW0oaXRlbS5kZXRhY2goKSk7XG4gICAgICAgICAgbWFwID0gdHJlZU1hcFtkcm9wVXAuYXR0cignZGF0YS1iYWNrJyldO1xuICAgICAgICAgIGN1cnJJbmRleCA9IGdldENoaWxkcmVuKG1hcC5wYXJlbnQpLmluZGV4KG1hcC5pdGVtKSArIDE7XG4gICAgICAgICAgZHJvcFVwLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcblxuICAgICAgICAgIGlmIChzLm5hdmlnYXRlT25Ecm9wKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZShkcm9wVXAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC5hZGQobnVsbCwgaXRlbSwgY3VyckluZGV4LCBudWxsLCBjdXJyTGlzdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHNjcm9sbFRvSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgb25Tb3J0RW5kKGl0ZW0sIGl0ZW1JbmRleCwgcGFyZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmFkZChudWxsLCBpdGVtLCBjdXJySW5kZXgsIG51bGwsIG1hcC5wYXJlbnQsIHRydWUpO1xuICAgICAgICAgICAgb25Tb3J0RW5kKGl0ZW0sIGl0ZW1JbmRleCwgcGFyZW50LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzdCA9IHBsYWNlaG9sZGVyWzBdLm9mZnNldFRvcCAtIHN0YXJ0VG9wOyAvLyBBbmltYXRlIGl0ZW0gdG8gaXRzIHBsYWNlXG5cbiAgICAgICAgICBkcmFnKGl0ZW0sIGRpc3QsIE1hdGguYWJzKGRpc3QgLSBNYXRoLm1heChtaW5EcmFnLCBNYXRoLm1pbihkaWZmWSArIHduZFNjcm9sbCwgbWF4RHJhZykpKSAqIDYsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc2V0SXRlbShpdGVtKTtcbiAgICAgICAgICAgIGl0ZW0uaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIG9uU29ydEVuZChpdGVtLCBpdGVtSW5kZXgsIHBhcmVudCwgY3VyckluZGV4ICE9PSBpdGVtSW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc2Nyb2xsICYmIE1hdGguYWJzKGRpZmZYKSA8IDUgJiYgTWF0aC5hYnMoZGlmZlkpIDwgNSkge1xuICAgICAgICAvLyBUYXBcbiAgICAgICAgaXNDbGljayA9IHRydWU7IC8vIFRyaWdnZXIgY2xpY2sgYW5kIGFjdGl2YXRlIHRhcmdldCwgaWYgaXQncyBhIGZvcm0gY29udHJvbFxuXG4gICAgICAgIGlmIChldi50eXBlID09PSAndG91Y2hlbmQnICYmIHMudGFwKSB7XG4gICAgICAgICAgYWN0aXZhdGVDb250cm9sKGV2LnRhcmdldCwgZ2V0Q29udHJvbFR5cGUoJCQxKGV2LnRhcmdldCkpLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGFjdGl2ZVRpbWVyKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpdG0ucmVtb3ZlQ2xhc3MoQUNUSVZFX0NMQVNTKTtcbiAgICAgICAgZXZlbnQoJ29uSXRlbURlYWN0aXZhdGUnLCB7XG4gICAgICAgICAgdGFyZ2V0OiBpdG1bMF1cbiAgICAgICAgfSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgc2Nyb2xsID0gZmFsc2U7XG4gICAgICBjdXJyU3RhZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICB2YXIgaXNTZWxlY3RlZCwgcmV0O1xuXG4gICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgIGlzU2VsZWN0ZWQgPSBpdGVtLmF0dHIoJ2RhdGEtc2VsZWN0ZWQnKSA9PSAndHJ1ZSc7XG5cbiAgICAgIGlmICh0eXBlLnRhcCkge1xuICAgICAgICByZXQgPSB0eXBlLnRhcC5jYWxsKGUsIHtcbiAgICAgICAgICB0YXJnZXQ6IGl0ZW0sXG4gICAgICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcbiAgICAgICAgICBkb21FdmVudDogZXZcbiAgICAgICAgfSwgdGhhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXBIaWdobGlnaHQgJiYgIWl0ZW0uaGFzQ2xhc3MoQUNUSVZFX0NMQVNTKSkge1xuICAgICAgICBpdGVtLmFkZENsYXNzKGlzVG91Y2ggPyBBQ1RJVkVfQ0xBU1MgOiAnJyk7XG4gICAgICAgIGV2ZW50KCdvbkl0ZW1BY3RpdmF0ZScsIHtcbiAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgZG9tRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBzZWxlY3Qgb3IgZGVzZWxlY3QgaXRlbSBvbiB0YXBcblxuXG4gICAgICBpZiAoc2VsZWN0YWJsZSkge1xuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZGVzZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXNlbGVjdEl0ZW0oJCQxKGl0ZW1TZWxlY3RvciwgY29udCkuZmlsdGVyKCcuJyArIFNFTEVDVEVEX0NMQVNTKSk7XG4gICAgICAgICAgc2VsZWN0SXRlbShpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSBldmVudCgnb25JdGVtVGFwJywge1xuICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgIGRvbUV2ZW50OiBldixcbiAgICAgICAgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmV0ICE9PSBmYWxzZSkge1xuICAgICAgICBuYXZpZ2F0ZShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkljb25TdGFydChldikge1xuICAgIHZhciB0YXJnZXQgPSBjbG9zZXN0KGNvbnQwLCBldi50YXJnZXQsICcubWJzYy1sdi1pYy1tJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVtb01vZGUpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBzdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3dpcGVTdGFydCgpIHtcbiAgICBzd2lwZSA9IHZhbHVlT3JGdW5jKHR5cGUuc3dpcGUsIHtcbiAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgIGluZGV4OiBpdGVtSW5kZXgsXG4gICAgICBkaXJlY3Rpb246IGRpZmZYID4gMCA/ICdyaWdodCcgOiAnbGVmdCdcbiAgICB9KTtcblxuICAgIGlmIChzd2lwZSkge1xuICAgICAgc3RvcFRpbWVyKCk7XG4gICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuXG4gICAgICBpZiAodHlwZS5hY3Rpb25zKSB7XG4gICAgICAgIC8vIEdldCB0aGUgd2lkdGggb2YgdGhlIGFjdGlvbiBtZW51IGZyb20gc2V0dGluZ3NcbiAgICAgICAgLy8gTnVtZXJpYyB2YWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBzdHJpbmcsIGJlY2F1c2UgMCBpcyBhbHNvIGFjY2VwdGVkLCB3ZSBjb252ZXJ0IGJhY2sgdG8gbnVtYmVyIGF0IHRoZSBlbmRcbiAgICAgICAgYWN0aW9uV2lkdGggPSBnZXRBY3Rpb25XaWR0aCh0eXBlLCBkaWZmWCk7IC8vIFNob3cgYWN0aW9uIGljb25zIGFuZCBzZXQgd2lkdGhcblxuICAgICAgICBtdWx0aWMuaHRtbCh0eXBlLmljb25zKS5zaG93KCkuY2hpbGRyZW4oKS5jc3MoJ3dpZHRoJywgYWN0aW9uV2lkdGggKyAnJScpOyAvLyBIaWRlIHN0YWdlIGljb25zXG5cbiAgICAgICAgaWNvbmMuaGlkZSgpOyAvLyBTZXQgZGlzYWJsZWQgYWN0aW9uc1xuXG4gICAgICAgICQkMSgnLm1ic2MtbHYtaWMtbScsIHN0YWdlYykucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaWMtZGlzYWJsZWQnKTtcbiAgICAgICAgJCQxKHR5cGUubGVmdE1lbnUpLmVhY2goZGlzYWJsZUFjdGlvbnMpO1xuICAgICAgICAkJDEodHlwZS5yaWdodE1lbnUpLmVhY2goZGlzYWJsZUFjdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWNvbmMuc2hvdygpO1xuICAgICAgICBtdWx0aWMuaGlkZSgpO1xuICAgICAgICBjdXJyU3RhZ2VJZHggPSB0eXBlLnN0YXJ0O1xuICAgICAgICBjdXJyU3RhZ2UgPSBzdGFnZXNbY3VyclN0YWdlSWR4XTtcbiAgICAgICAgcHJldlN0YWdlID0gc3RhZ2VzW2N1cnJTdGFnZUlkeCAtIDFdO1xuICAgICAgICBuZXh0U3RhZ2UgPSBzdGFnZXNbY3VyclN0YWdlSWR4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYWRkQ2xhc3MoJ21ic2MtbHYtaXRlbS1zd2lwaW5nJykucmVtb3ZlQ2xhc3MoQUNUSVZFX0NMQVNTKTtcbiAgICAgIHRleHQuY3NzKCdsaW5lLWhlaWdodCcsIGl0ZW1IZWlnaHQgKyAncHgnKTtcbiAgICAgIHN0YWdlYy5jc3Moe1xuICAgICAgICB0b3A6IHN0YXJ0VG9wLFxuICAgICAgICBoZWlnaHQ6IGl0ZW1IZWlnaHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZ2V0Rmlyc3RDb2xvcihkaWZmWClcbiAgICAgIH0pLmFkZENsYXNzKCdtYnNjLWx2LXN0YWdlLWMtdicpLmFwcGVuZFRvKGN1cnJMaXN0LnBhcmVudCgpKTtcblxuICAgICAgaWYgKHMuaWNvblNsaWRlKSB7XG4gICAgICAgIGl0ZW0uYXBwZW5kKGljb25jKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQoJ29uU2xpZGVTdGFydCcsIHtcbiAgICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblN3aXBlTW92ZShwcmV2UG9zKSB7XG4gICAgdmFyIHN0YWdlQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFyYWZSdW5uaW5nKSB7XG4gICAgICBpZiAodHlwZS5hY3Rpb25zKSB7XG4gICAgICAgIHN0YWdlYy5hdHRyKCdjbGFzcycsICdtYnNjLWx2LXN0YWdlLWMtdiBtYnNjLWx2LXN0YWdlLWMgbWJzYy1sdi0nICsgKGFuaW1Qb3MgPCAwID8gJ3JpZ2h0JyA6ICdsZWZ0JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZTdGFnZSAmJiAoYW5pbVBvcyA8IDAgPyBhbmltUG9zIDw9IHByZXZTdGFnZS5wZXJjZW50IDogYW5pbVBvcyA8IGN1cnJTdGFnZS5wZXJjZW50KSkge1xuICAgICAgICAgIGN1cnJTdGFnZUlkeC0tO1xuICAgICAgICAgIG5leHRTdGFnZSA9IGN1cnJTdGFnZTtcbiAgICAgICAgICBjdXJyU3RhZ2UgPSBwcmV2U3RhZ2U7XG4gICAgICAgICAgcHJldlN0YWdlID0gc3RhZ2VzW2N1cnJTdGFnZUlkeCAtIDFdO1xuICAgICAgICAgIHN0YWdlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YWdlICYmIChhbmltUG9zIDwgMCA/IGFuaW1Qb3MgPiBjdXJyU3RhZ2UucGVyY2VudCA6IGFuaW1Qb3MgPj0gbmV4dFN0YWdlLnBlcmNlbnQpKSB7XG4gICAgICAgICAgY3VyclN0YWdlSWR4Kys7XG4gICAgICAgICAgcHJldlN0YWdlID0gY3VyclN0YWdlO1xuICAgICAgICAgIGN1cnJTdGFnZSA9IG5leHRTdGFnZTtcbiAgICAgICAgICBuZXh0U3RhZ2UgPSBzdGFnZXNbY3VyclN0YWdlSWR4ICsgMV07XG4gICAgICAgICAgc3RhZ2VDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyU3RhZ2UpIHtcbiAgICAgICAgICBpZiAoc3RhZ2VDaGFuZ2VkIHx8IGFuaW1Qb3MgPiAwID09IHByZXZQb3MgPD0gMCkge1xuICAgICAgICAgICAgLy8gQWxzbyBuZWVkIHRvIHVwZGF0ZSBzdGFnZSBiYWNrZ3JvdW5kIGlmIHN3aXBlIGRpcmVjdGlvbiBjaGFuZ2VkXG4gICAgICAgICAgICBzZXRTdGFnZVByb3BzKGN1cnJTdGFnZSwgcy5pY29uU2xpZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFnZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGV2ZW50KCdvblN0YWdlQ2hhbmdlJywge1xuICAgICAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgICAgICAgIHN0YWdlOiBjdXJyU3RhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNpbXVsYXRpbmcpIHtcbiAgICAgICAgcmFmUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJhZklEID0gcmFmKHNsaWRlTW92ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Td2lwZUVuZChjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIG9uQ2xvc2VBY3Rpb25zKGV2KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gY2xvc2VzdChjb250MCwgZXYudGFyZ2V0LCAnLm1ic2MtbHYtaWMtbScpO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzbGlkZUVuZChpdGVtLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHF1aWNrU3dpcGVMZWZ0LFxuICAgICAgICBxdWlja1N3aXBlUmlnaHQsXG4gICAgICAgIHRpbWVEaWZmLFxuICAgICAgICBpdG0gPSBpdGVtWzBdLFxuICAgICAgICBwZW5kaW5nID0gZmFsc2UsXG4gICAgICAgIHJldmVydCA9IHRydWU7XG4gICAgcmFmYyhyYWZJRCk7XG4gICAgcmFmUnVubmluZyA9IGZhbHNlOyAvLyBXZSBuZWVkIGFuIGFkZGl0aW9uYWwgY2FsbCB0byBzZXQgdGhlIHBvc2l0aW9uIGluIGNhc2Ugd2hlblxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBkaWQgbm90IGNhbGwgaXQgYXQgbGVhc3Qgb25jZVxuICAgIC8vIEUuZy4gaW4gYSBjYXNlIG9mIGEgcXVpY2sgc3dpcGUgYW5pbWF0aW9uIGZyYW1lIGlzXG4gICAgLy8gY2FuY2VsbGVkIGJlZm9yZSB0aGUgZmlyc3QgY2FsbFxuXG4gICAgaWYgKCFzaW11bGF0aW5nKSB7XG4gICAgICBzbGlkZU1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5hY3Rpb25zKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYW5pbVBvcykgPiAxMCAmJiBhY3Rpb25XaWR0aCkge1xuICAgICAgICBzbGlkZShpdGVtLCBhbmltUG9zIDwgMCA/IC1hY3Rpb25XaWR0aCA6IGFjdGlvbldpZHRoLCAyMDApO1xuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uZmlybXMgPSB0cnVlO1xuICAgICAgICBjb25maXJtSXRlbSA9IGl0ZW07XG4gICAgICAgIGNvbmZpcm1JbmRleCA9IGl0ZW1JbmRleDtcblxuICAgICAgICBpZiAoaXRtLl9fbWJzY09mZikge1xuICAgICAgICAgIGl0bS5fX21ic2NPZmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbkNsb3NlQWN0aW9ucywge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZWRvd24nLCBvbkNsb3NlQWN0aW9ucyk7XG5cbiAgICAgICAgaXRtLl9fbWJzY09mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbkNsb3NlQWN0aW9ucywge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ21vdXNlZG93bicsIG9uQ2xvc2VBY3Rpb25zKTtcbiAgICAgICAgICBkZWxldGUgaXRtLl9fbWJzY09mZjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuaW1Qb3MpIHtcbiAgICAgIGlmIChzLnF1aWNrU3dpcGUgJiYgIXNpbXVsYXRpbmcpIHtcbiAgICAgICAgdGltZURpZmYgPSBuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgICBxdWlja1N3aXBlTGVmdCA9IHRpbWVEaWZmIDwgMzAwICYmIGRpZmZYIDwgLTUwO1xuICAgICAgICBxdWlja1N3aXBlUmlnaHQgPSB0aW1lRGlmZiA8IDMwMCAmJiBkaWZmWCA+IDUwO1xuXG4gICAgICAgIGlmIChxdWlja1N3aXBlTGVmdCkge1xuICAgICAgICAgIHF1aWNrU3dpcGUgPSB0cnVlO1xuICAgICAgICAgIGN1cnJTdGFnZSA9IHR5cGUubGVmdDtcbiAgICAgICAgICBzZXRTdGFnZVByb3BzKGN1cnJTdGFnZSwgcy5pY29uU2xpZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHF1aWNrU3dpcGVSaWdodCkge1xuICAgICAgICAgIHF1aWNrU3dpcGUgPSB0cnVlO1xuICAgICAgICAgIGN1cnJTdGFnZSA9IHR5cGUucmlnaHQ7XG4gICAgICAgICAgc2V0U3RhZ2VQcm9wcyhjdXJyU3RhZ2UsIHMuaWNvblNsaWRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VyclN0YWdlICYmIGN1cnJTdGFnZS5hY3Rpb24pIHtcbiAgICAgICAgZGlzYWJsZWQgPSB2YWx1ZU9yRnVuYyhjdXJyU3RhZ2UuZGlzYWJsZWQsIHtcbiAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgaW5kZXg6IGl0ZW1JbmRleFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgY29uZmlybXMgPSBzaW11bGF0aW5nIHx8IHZhbHVlT3JGdW5jKGN1cnJTdGFnZS5jb25maXJtLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY29uZmlybXMpIHtcbiAgICAgICAgICAgIC8vIFNsaWRlIHRvIHRleHQgKyBpY29uIHdpZHRoXG4gICAgICAgICAgICBzbGlkZShpdGVtLCAoYW5pbVBvcyA8IDAgPyAtMSA6IDEpICogaWNvbmNbMF0ub2Zmc2V0V2lkdGggKiAxMDAgLyBpdGVtdywgMjAwLCB0cnVlKTsgLy8gVGFwIHRvIGNvbmZpcm1cblxuICAgICAgICAgICAgc2V0Q29uZmlybShjdXJyU3RhZ2UsIGl0ZW0sIGl0ZW1JbmRleCwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuQWN0aW9uKGN1cnJTdGFnZSwgaXRlbSwgaXRlbUluZGV4LCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBzbGlkZUVuZChpdGVtLCByZXZlcnQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBzd2lwZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Tb3J0U3RhcnQoKSB7XG4gICAgZHJhZ2dlZCA9IHRydWU7XG4gICAgZHJvcERvd24gPSBmYWxzZTtcbiAgICBkcm9wVXAgPSBmYWxzZTtcbiAgICB3bmRTY3JvbGwgPSAwO1xuICAgIGN1cnJJbmRleCA9IGl0ZW1JbmRleDtcblxuICAgIGlmIChzLnZpYnJhdGUpIHtcbiAgICAgIHZpYnJhdGUoKTtcbiAgICB9XG5cbiAgICBuZXh0SXRlbSA9IGdldE5leHRQcmV2KGl0ZW0sICduZXh0Jyk7XG4gICAgbmV4dE9mZnNldCA9IG5leHRJdGVtLmxlbmd0aCAmJiBuZXh0SXRlbVswXS5vZmZzZXRUb3A7XG4gICAgcHJldkl0ZW0gPSBnZXROZXh0UHJldihpdGVtLCAncHJldicpO1xuICAgIHByZXZPZmZzZXQgPSBwcmV2SXRlbS5sZW5ndGggJiYgcHJldkl0ZW1bMF0ub2Zmc2V0VG9wICsgcHJldkl0ZW1bMF0ub2Zmc2V0SGVpZ2h0O1xuICAgIHBsYWNlaG9sZGVyLmhlaWdodChpdGVtSGVpZ2h0KS5pbnNlcnRBZnRlcihpdGVtKTsgLy8gSXRlbSBpcyByZW1vdmVkIGZyb20gb3JpZ2luYWwgbGlzdCwgb3RoZXJ3aXNlIG1lc3NlcyB1cCBzdHJpcGVkIGxheW91dFxuXG4gICAgaXRlbS5jc3Moe1xuICAgICAgdG9wOiBzdGFydFRvcFxuICAgIH0pLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0tZHJhZ2dpbmcnKS5yZW1vdmVDbGFzcyhBQ1RJVkVfQ0xBU1MpLmFwcGVuZFRvKGR1bW15Q29udCk7XG4gICAgZXZlbnQoJ29uU29ydFN0YXJ0Jywge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Tb3J0RW5kKGl0ZW0sIGl0ZW1JbmRleCwgcGFyZW50LCB1cGRhdGUpIHtcbiAgICBpdGVtLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0tZHJhZ2dpbmcnKTtcbiAgICBwbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICBldmVudCgnb25Tb3J0RW5kJywge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgIH0pO1xuXG4gICAgaWYgKHMudmlicmF0ZSkge1xuICAgICAgdmlicmF0ZSgpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoYXQuYWRkVW5kb0FjdGlvbihmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICB0aGF0Lm1vdmUoaXRlbSwgaXRlbUluZGV4LCBudWxsLCBuZXh0LCBwYXJlbnQsIHRydWUpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBldmVudCgnb25Tb3J0VXBkYXRlJywge1xuICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgIGluZGV4OiBjdXJySW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICBpZiAoIXByZXZlbnRIb3Zlcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZXIpO1xuXG4gICAgICBpZiAoY29uZmlybXMpIHtcbiAgICAgICAgdHJpZ2dlcihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvdmVySXRlbU9wZW5lZCkge1xuICAgICAgICB0aGF0LmNsb3NlKGhvdmVySXRlbSwgaG92ZXJUaW1lKTtcbiAgICAgICAgaG92ZXJJdGVtT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIGhvdmVySXRlbSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlKTtcbiAgICBkZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgd25kSGVpZ2h0ID0gd25kMC5pbm5lckhlaWdodCB8fCB3bmQuaW5uZXJIZWlnaHQoKTtcbiAgICAgIHduZFRvcCA9IGhhc0NvbnRleHQgPyB3bmQub2Zmc2V0KCkudG9wIDogMDtcblxuICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAvLyBSZXBvc2l0aW9uIHN0YWdlIGJhY2tncm91bmQsIGljb24gYW5kIHRleHRcbiAgICAgICAgc3RhcnRUb3AgPSBpdGVtWzBdLm9mZnNldFRvcDtcbiAgICAgICAgaXRlbUhlaWdodCA9IGl0ZW1bMF0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBzdGFnZWMuY3NzKHtcbiAgICAgICAgICB0b3A6IHN0YXJ0VG9wLFxuICAgICAgICAgIGhlaWdodDogaXRlbUhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25MaXN0Q2xpY2soZXYpIHtcbiAgICBpZiAocHJldkNsaWNrKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwcmV2Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbEJvdHRvbSgpIHtcbiAgICBpZiAoIWlzTG9hZGluZykge1xuICAgICAgY2xlYXJUaW1lb3V0KG9uU2Nyb2xsRGVib3VuY2UpO1xuICAgICAgb25TY3JvbGxEZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaGFzQ29udGV4dCA/IHduZDAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgd25kLmlubmVySGVpZ2h0KCkgOiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICByZWFjaGVkQm90dG9tID0gbG9hZGluZ1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSAzIDwgaGVpZ2h0O1xuXG4gICAgICAgIGlmICghaXNMb2FkaW5nICYmIHJlYWNoZWRCb3R0b20pIHtcbiAgICAgICAgICBldmVudCgnb25MaXN0RW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDI1MCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgaWYgKGRyYWdnZWQgfHwgIWFjdGlvbikge1xuICAgICAgdmFyIGdyb3VwLFxuICAgICAgICAgIHN0ID0gd25kLnNjcm9sbFRvcCgpLFxuICAgICAgICAgIGVsbVRvcCA9IGVsbS5vZmZzZXQoKS50b3AsXG4gICAgICAgICAgZWxtSGVpZ2h0ID0gZWxtWzBdLm9mZnNldEhlaWdodCxcbiAgICAgICAgICB3bmRUb3AgPSBoYXNDb250ZXh0ID8gd25kLm9mZnNldCgpLnRvcCA6IHN0O1xuICAgICAgJCQxKCcubWJzYy1sdi1nci10aXRsZScsIGVsbSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICBpZiAoJCQxKHYpLm9mZnNldCgpLnRvcCA8IHduZFRvcCkge1xuICAgICAgICAgIGdyb3VwID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChlbG1Ub3AgPCB3bmRUb3AgJiYgZWxtVG9wICsgZWxtSGVpZ2h0ID4gd25kVG9wKSB7XG4gICAgICAgIGdyb3VwSGVhZGVyLnNob3coKS5lbXB0eSgpLmFwcGVuZCgkJDEoZ3JvdXApLmNsb25lKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBIZWFkZXIuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVBY3Rpb25zKGksIHYpIHtcbiAgICBpZiAodmFsdWVPckZ1bmModi5kaXNhYmxlZCwge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGl0ZW1JbmRleFxuICAgIH0pKSB7XG4gICAgICAkJDEoJy5tYnNjLWljLScgKyB2Lmljb24sIHN0YWdlYykuYWRkQ2xhc3MoJ21ic2MtbHYtaWMtZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5BY3Rpb24oc3RhZ2UsIGl0ZW0sIGluZGV4LCBjYWxsYmFjaykge1xuICAgIHZhciByZXZlcnQsXG4gICAgICAgIHVuZG9TdGFnZSA9IHtcbiAgICAgIGljb246ICd1bmRvMicsXG4gICAgICB0ZXh0OiBzLnVuZG9UZXh0LFxuICAgICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gICAgICAgIHRoYXQudW5kbygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3RhZ2UudW5kbykge1xuICAgICAgdGhhdC5zdGFydEFjdGlvblRyYWNrKCk7IC8vIEFkZCB1c2VyIGRlZmluZWQgdW5kb1xuXG4gICAgICBpZiAoJCQxLmlzRnVuY3Rpb24oc3RhZ2UudW5kbykpIHtcbiAgICAgICAgdGhhdC5hZGRVbmRvQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGFnZS51bmRvLmNhbGwoZSwge1xuICAgICAgICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgfSwgdGhhdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBSZW1lbWJlciB0aGUgaXRlbSB3aGVyZSB0aGUgdW5kbyBpcyBkaXNwbGF5ZWRcblxuXG4gICAgICB1bmRvUmVmID0gaXRlbS5hdHRyKCdkYXRhLXJlZicpO1xuICAgIH1cblxuICAgIHJldmVydCA9IHN0YWdlLmFjdGlvbi5jYWxsKGUsIHtcbiAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0sIHRoYXQpO1xuXG4gICAgaWYgKHN0YWdlLnVuZG8pIHtcbiAgICAgIHRoYXQuZW5kQWN0aW9uVHJhY2soKTtcblxuICAgICAgaWYgKHJldmVydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2xpZGUoaXRlbSwgK2l0ZW0uYXR0cignZGF0YS1wb3MnKSA8IDAgPyAtMTAwIDogMTAwLCAyMDApO1xuICAgICAgfVxuXG4gICAgICBwbGFjZWhvbGRlci5oZWlnaHQoaXRlbUhlaWdodCkuaW5zZXJ0QWZ0ZXIoaXRlbSk7XG4gICAgICBpdGVtLmNzcygndG9wJywgc3RhcnRUb3ApLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0tdW5kbycpO1xuICAgICAgbXVsdGljLmhpZGUoKTtcbiAgICAgIGljb25jLnNob3coKTtcbiAgICAgIHN0YWdlYy5hcHBlbmQoaWNvbmMpO1xuICAgICAgc2V0U3RhZ2VQcm9wcyh1bmRvU3RhZ2UpO1xuICAgICAgc2V0Q29uZmlybSh1bmRvU3RhZ2UsIGl0ZW0sIGluZGV4LCB0cnVlLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlRW5kKGl0ZW0sIHJldmVydCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbmZpcm0oc3RhZ2UsIGl0ZW0sIGluZGV4LCBwaCwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBvbkFjdGlvbkNhbmNlbChldikge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHBoKSB7XG4gICAgICAgIGNsZWFuVW5kbyhpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2xpZGVFbmQoaXRlbSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uQ29uZmlybVN0YXJ0KGV2KSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25BY3Rpb25Db25maXJtRW5kKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICBwcmV2ZW50Q2xpY2soKTtcbiAgICAgIH0gLy8gSWYgbW92ZW1lbnQgaXMgbGVzcyB0aGFuIDEwcHgsIGl0J3MgYSB0YXBcblxuXG4gICAgICBpZiAoTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdYJykgLSBzdGFydFgpIDwgMTAgJiYgTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdZJykgLSBzdGFydFkpIDwgMTApIHtcbiAgICAgICAgcnVuQWN0aW9uKHN0YWdlLCBpdGVtLCBpbmRleCwgY2FsbGJhY2spO1xuXG4gICAgICAgIGlmIChwaCkge1xuICAgICAgICAgIHVuZG9BbmltID0gbnVsbDtcbiAgICAgICAgICBjbGVhblVuZG8oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRYLFxuICAgICAgICBzdGFydFksXG4gICAgICAgIGl0bSA9IGl0ZW1bMF07XG4gICAgY29uZmlybXMgPSB0cnVlO1xuXG4gICAgaWYgKGl0bS5fX21ic2NPZmYpIHtcbiAgICAgIGl0bS5fX21ic2NPZmYoKTtcbiAgICB9XG5cbiAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25BY3Rpb25DYW5jZWwsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgbGlzdGVuKGRvY3VtZW50LCAnbW91c2Vkb3duJywgb25BY3Rpb25DYW5jZWwpO1xuXG4gICAgaWYgKCFkZW1vTW9kZSkge1xuICAgICAgbGlzdGVuKGljb25jWzBdLCAndG91Y2hzdGFydCcsIG9uQWN0aW9uQ29uZmlybVN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGljb25jWzBdLCAnbW91c2Vkb3duJywgb25BY3Rpb25Db25maXJtU3RhcnQpO1xuICAgICAgbGlzdGVuKGljb25jWzBdLCAndG91Y2hlbmQnLCBvbkFjdGlvbkNvbmZpcm1FbmQpO1xuICAgICAgbGlzdGVuKGljb25jWzBdLCAnbW91c2V1cCcsIG9uQWN0aW9uQ29uZmlybUVuZCk7XG4gICAgfVxuXG4gICAgaXRtLl9fbWJzY09mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uQWN0aW9uQ2FuY2VsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAnbW91c2Vkb3duJywgb25BY3Rpb25DYW5jZWwpO1xuICAgICAgdW5saXN0ZW4oaWNvbmNbMF0sICd0b3VjaHN0YXJ0Jywgb25BY3Rpb25Db25maXJtU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihpY29uY1swXSwgJ21vdXNlZG93bicsIG9uQWN0aW9uQ29uZmlybVN0YXJ0KTtcbiAgICAgIHVubGlzdGVuKGljb25jWzBdLCAndG91Y2hlbmQnLCBvbkFjdGlvbkNvbmZpcm1FbmQpO1xuICAgICAgdW5saXN0ZW4oaWNvbmNbMF0sICdtb3VzZXVwJywgb25BY3Rpb25Db25maXJtRW5kKTtcbiAgICAgIGRlbGV0ZSBpdG0uX19tYnNjT2ZmO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzbGlkZU1vdmUoKSB7XG4gICAgc2xpZGUoaXRlbSwgc3RhcnRQb3MgKyBkaWZmWCAqIDEwMCAvIGl0ZW13KTtcbiAgICByYWZSdW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzbGlkZUVuZChpdGVtLCByZXZlcnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGl0ZW1bMF0uX19tYnNjT2ZmKSB7XG4gICAgICBpdGVtWzBdLl9fbWJzY09mZigpO1xuICAgIH1cblxuICAgIGlmIChyZXZlcnQgIT09IGZhbHNlKSB7XG4gICAgICBzbGlkZShpdGVtLCAwLCBpdGVtLmF0dHIoJ2RhdGEtcG9zJykgIT09ICcwJyA/IDIwMCA6IDAsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFuU3RhZ2UoaXRlbSwgY2FsbGJhY2spO1xuICAgICAgICByZXNldEl0ZW0oaXRlbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYW5TdGFnZShpdGVtLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY29uZmlybXMgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWRlKGl0ZW0sIHBvcywgdGltZSwgcHgsIGNhbGxiYWNrKSB7XG4gICAgcG9zID0gTWF0aC5tYXgoc3dpcGUgPT0gJ3JpZ2h0JyA/IDAgOiAtMTAwLCBNYXRoLm1pbihwb3MsIHN3aXBlID09ICdsZWZ0JyA/IDAgOiAxMDApKTtcbiAgICBzdHlsZSA9IGl0ZW1bMF0uc3R5bGU7XG4gICAgaXRlbS5hdHRyKCdkYXRhLXBvcycsIHBvcyk7XG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlM2QoJyArIChweCA/IGl0ZW13ICogcG9zIC8gMTAwICsgJ3B4JyA6IHBvcyArICclJykgKyAnLDAsMCknO1xuICAgIHN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9IGNzc1ByZWZpeCArICd0cmFuc2Zvcm0gJyArICh0aW1lIHx8IDApICsgJ21zJztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdHJhbnNpdGlvbisrO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHRyYW5zaXRpb24tLTtcbiAgICAgIH0sIHRpbWUpO1xuICAgIH1cblxuICAgIGFuaW1Qb3MgPSBwb3M7XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnKGl0ZW0sIHRvcCwgdGltZSwgY2FsbGJhY2spIHtcbiAgICB0b3AgPSBNYXRoLm1heChtaW5EcmFnLCBNYXRoLm1pbih0b3AsIG1heERyYWcpKTtcbiAgICBzdHlsZSA9IGl0ZW1bMF0uc3R5bGU7XG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlM2QoMCwnICsgdG9wICsgJ3B4LDApJztcbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2l0aW9uJ10gPSBjc3NQcmVmaXggKyAndHJhbnNmb3JtICcgKyAodGltZSB8fCAwKSArICdtcyBlYXNlLW91dCc7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRyYW5zaXRpb24rKztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB0cmFuc2l0aW9uLS07XG4gICAgICB9LCB0aW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgIGlmICghY2FuY2VsICYmIHRoYXQuc29ydGFibGUpIHtcbiAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICBmaWxsLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0YWdlUHJvcHMoc3RhZ2UsIGljb25TbGlkZSkge1xuICAgIHZhciB0eHQgPSB2YWx1ZU9yRnVuYyhzdGFnZS50ZXh0LCB7XG4gICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgfSkgfHwgJyc7XG5cbiAgICBpZiAodmFsdWVPckZ1bmMoc3RhZ2UuZGlzYWJsZWQsIHtcbiAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgIGluZGV4OiBpdGVtSW5kZXhcbiAgICB9KSkge1xuICAgICAgc3RhZ2VjLmFkZENsYXNzKCdtYnNjLWx2LWljLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWdlYy5yZW1vdmVDbGFzcygnbWJzYy1sdi1pYy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIHN0YWdlYy5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzdGFnZS5jb2xvciB8fCAoc3RhZ2UucGVyY2VudCA9PT0gMCA/IGdldEZpcnN0Q29sb3IoYW5pbVBvcykgOiB0cmFuc3ApKTtcbiAgICBpY29uYy5hdHRyKCdjbGFzcycsICdtYnNjLWx2LWljLWMgbWJzYy1sdi1pYy0nICsgKGljb25TbGlkZSA/ICdtb3ZlLScgOiAnJykgKyAoYW5pbVBvcyA8IDAgPyAncmlnaHQnIDogJ2xlZnQnKSk7XG4gICAgaWNvbi5hdHRyKCdjbGFzcycsICcgbWJzYy1sdi1pYy1zIG1ic2MtbHYtaWMgbWJzYy1pYyBtYnNjLWljLScgKyAoc3RhZ2UuaWNvbiB8fCAnbm9uZScpKTtcbiAgICB0ZXh0LmF0dHIoJ2NsYXNzJywgJ21ic2MtbHYtaWMtdGV4dCcgKyAoc3RhZ2UuaWNvbiA/ICcnIDogJyBtYnNjLWx2LWljLXRleHQtb25seScpICsgKHR4dCA/ICcnIDogJyBtYnNjLWx2LWljLW9ubHknKSkuaHRtbCh0eHQgfHwgJyZuYnNwOycpO1xuXG4gICAgaWYgKHMuYW5pbWF0ZUljb25zKSB7XG4gICAgICBpZiAocXVpY2tTd2lwZSkge1xuICAgICAgICBpY29uLmFkZENsYXNzKCdtYnNjLWx2LWljLXYnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGljb24uYWRkQ2xhc3MoJ21ic2MtbHYtaWMtYScpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5TdGFnZShpdGVtLCBjYWxsYmFjaykge1xuICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAvLyBEb24ndCBjbGVhbiBzdGFnZXMgaWYgYW5vdGhlciBhY3Rpb24gc3RhcnRlZFxuICAgICAgaWNvbi5hdHRyKCdjbGFzcycsICdtYnNjLWx2LWljLXMgbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtbm9uZScpO1xuICAgICAgc3RhZ2VjLmF0dHIoJ3N0eWxlJywgJycpLnJlbW92ZUNsYXNzKCdtYnNjLWx2LXN0YWdlLWMtdicpO1xuICAgICAgdGV4dC5odG1sKCcnKTtcbiAgICB9XG5cbiAgICBzdGFnZWMucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtbGVmdCBtYnNjLWx2LXJpZ2h0Jyk7XG5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgZXZlbnQoJ29uU2xpZGVFbmQnLCB7XG4gICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgaW5kZXg6IGl0ZW1JbmRleFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuVW5kbyhpdGVtKSB7XG4gICAgaXRlbS5jc3MoJ3RvcCcsICcnKS5yZW1vdmVDbGFzcygnbWJzYy1sdi1pdGVtLXVuZG8nKTsgLy8gUmVtb3ZlIHBsYWNlaG9sZGVyXG5cbiAgICBpZiAodW5kb0FuaW0pIHtcbiAgICAgIHRoYXQuYW5pbWF0ZShwbGFjZWhvbGRlciwgJ2NvbGxhcHNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBjbGVhblN0YWdlKCk7XG4gICAgdW5kb1JlZiA9IG51bGw7XG4gICAgdW5kb0FuaW0gPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJdGVtKGl0ZW0pIHtcbiAgICBzdHlsZSA9IGl0ZW1bMF0uc3R5bGU7XG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAnJztcbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2l0aW9uJ10gPSAnJztcbiAgICBzdHlsZS50b3AgPSAnJztcbiAgICBpdGVtLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0tc3dpcGluZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVPckZ1bmModmFsLCBhcmdzKSB7XG4gICAgcmV0dXJuICQkMS5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwuY2FsbCh0aGlzLCBhcmdzLCB0aGF0KSA6IHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VsZWN0YWJsZShpdGVtKSB7XG4gICAgcmV0dXJuIHNlbGVjdGFibGUgJiYgIWl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykgJiYgIWl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtYmFjaycpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEl0ZW0oaXRlbSkge1xuICAgIHZhciBpZCA9IGl0ZW0uYXR0cignZGF0YS1yZWYnKSxcbiAgICAgICAgcm9sZSA9IGl0ZW0uYXR0cignZGF0YS1yb2xlJyksXG4gICAgICAgIHR5cGUgPSB0eXBlc1tpdGVtLmF0dHIoJ2RhdGEtdHlwZScpIHx8ICdkZWZhdWx0cyddLFxuICAgICAgICBzZWxlY3RlZCA9IGlzU2VsZWN0YWJsZShpdGVtKSAmJiBpdGVtLmF0dHIoJ2RhdGEtc2VsZWN0ZWQnKSA9PSAndHJ1ZSc7XG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICBpZCA9IGd1aWQrKztcbiAgICAgIGl0ZW0uYXR0cignZGF0YS1yZWYnLCBpZCk7XG4gICAgfVxuXG4gICAgdHJlZU1hcFtpZF0gPSB7XG4gICAgICBpdGVtOiBpdGVtLFxuICAgICAgY2hpbGQ6IGl0ZW0uY2hpbGRyZW4obGlzdFNlbGVjdG9yKSxcbiAgICAgIHBhcmVudDogaXRlbS5wYXJlbnQoKSxcbiAgICAgIHJlZjogaXRlbS5wYXJlbnQoKVswXSA9PT0gZSA/IG51bGwgOiBpdGVtLnBhcmVudCgpLnBhcmVudCgpLmF0dHIoJ2RhdGEtcmVmJylcbiAgICB9O1xuICAgIGl0ZW0uYWRkQ2xhc3Mocm9sZSA9PSAnbGlzdC1kaXZpZGVyJyA/ICdtYnNjLWx2LWdyLXRpdGxlJyA6ICdtYnNjLWx2LWl0ZW0nICsgKHR5cGUuYWN0aW9uYWJsZSA/ICcgbWJzYy1sdi1pdGVtLWFjdGlvbmFibGUnIDogJycpICsgKHNlbGVjdGVkID8gJyAnICsgU0VMRUNURURfQ0xBU1MgOiAnJykpO1xuICAgIGl0ZW0uYXR0cignYXJpYS1zZWxlY3RlZCcsIHNlbGVjdGVkID8gJ3RydWUnIDogJ2ZhbHNlJyk7IC8vIEFkZCBzb3J0IGhhbmRsZVxuXG4gICAgaWYgKHRoYXQuc29ydGFibGUuaGFuZGxlICYmIHJvbGUgIT0gJ2xpc3QtZGl2aWRlcicgJiYgIWl0ZW0uY2hpbGRyZW4oJy5tYnNjLWx2LWhhbmRsZS1jJykubGVuZ3RoKSB7XG4gICAgICBpdGVtLmFwcGVuZChoYW5kbGVEaXYpO1xuICAgIH1cblxuICAgIGlmIChzLmVuaGFuY2UgJiYgIWl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtaXRlbS1lbmhhbmNlZCcpKSB7XG4gICAgICB2YXIgaXRlbUljb24gPSBpdGVtLmF0dHIoJ2RhdGEtaWNvbicpLFxuICAgICAgICAgIGl0ZW1JbWcgPSBpdGVtLmZpbmQoJ2ltZycpLmVxKDApLmFkZENsYXNzKCdtYnNjLWx2LWltZycpO1xuXG4gICAgICBpZiAoaXRlbUltZy5pcygnOmZpcnN0LWNoaWxkJykpIHtcbiAgICAgICAgaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pbWctJyArIChzLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCcpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbUltZy5sZW5ndGgpIHtcbiAgICAgICAgaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pbWctJyArIChzLnJ0bCA/ICdsZWZ0JyA6ICdyaWdodCcpKTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pdGVtLWVuaGFuY2VkJykuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIHYgPSAkJDEodik7XG5cbiAgICAgICAgaWYgKHYuaXMoJ3AsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYnKSkge1xuICAgICAgICAgIHYuYWRkQ2xhc3MoJ21ic2MtbHYtdHh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXRlbUljb24pIHtcbiAgICAgICAgaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pdGVtLWljLScgKyAoaXRlbS5hdHRyKCdkYXRhLWljb24tYWxpZ24nKSB8fCAocy5ydGwgPyAncmlnaHQnIDogJ2xlZnQnKSkpLmFwcGVuZCgnPGRpdiBjbGFzcz1cIm1ic2MtbHYtaXRlbS1pYyBtYnNjLWljIG1ic2MtaWMtJyArIGl0ZW1JY29uICsgJ1wiPjwvZGl2PicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGl0ZW0uYXBwZW5kKHRoYXQuX2dldFRleHQobW9iaXNjcm9sbCwgMC4yKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0QnJhbmNoKGVsbSkge1xuICAgIC8vIENyZWF0ZSBtYXAgb2JqZWN0XG4gICAgJCQxKGl0ZW1TZWxlY3RvciwgZWxtKS5ub3QoJy5tYnNjLWx2LWJhY2snKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGluaXRJdGVtKCQkMSh0aGlzKSk7XG4gICAgfSk7IC8vIEFkZCBleHRyYSBjbGFzc2VzIGFuZCBtYXJrdXAgKGFycm93cyBhbmQgYmFjayBpdGVtcylcblxuICAgICQkMShsaXN0U2VsZWN0b3IsIGVsbSkubm90KCcubWJzYy1sdicpLmFkZENsYXNzKCdtYnNjLWx2JykucHJlcGVuZChodG1sTGVmdCkucGFyZW50KCkuYWRkQ2xhc3MoJ21ic2MtbHYtcGFyZW50IG1ic2MtbHYtaXRlbS1hY3Rpb25hYmxlJykucHJlcGVuZChodG1sUmlnaHQpOyAvLyBBZGQgcGFyZW50IHJlZmVyZW5jZSBmb3IgYmFjayBidXR0b25zXG5cbiAgICAkJDEoJy5tYnNjLWx2LWJhY2snLCBlbG0pLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgJCQxKHRoaXMpLmF0dHIoJ2RhdGEtYmFjaycsICQkMSh0aGlzKS5wYXJlbnQoKS5wYXJlbnQoKS5hdHRyKCdkYXRhLXJlZicpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoaWxkcmVuKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5jaGlsZHJlbihpdGVtU2VsZWN0b3IpLm5vdCgnLm1ic2MtbHYtYmFjaycpLm5vdCgnLm1ic2MtbHYtcmVtb3ZlZCcpLm5vdCgnLm1ic2MtbHYtcGgnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZW1CeUlEKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVtID0gJCQxKGl0ZW1TZWxlY3RvciwgY29udCkuZmlsdGVyKCdbZGF0YS1pZD1cIicgKyBpdGVtICsgJ1wiXScpO1xuICAgIH1cblxuICAgIHJldHVybiAkJDEoaXRlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVtTGV2ZWwoaXRlbSkge1xuICAgIHZhciBsZXZlbCA9IDAsXG4gICAgICAgIG1hcCA9IHRyZWVNYXBbaXRlbS5hdHRyKCdkYXRhLXJlZicpXTtcblxuICAgIHdoaWxlIChtYXAgJiYgbWFwLnJlZikge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIG1hcCA9IHRyZWVNYXBbbWFwLnJlZl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dFByZXYoaXRlbSwgZGlyKSB7XG4gICAgaXRlbSA9IGl0ZW1bZGlyXSgpOyAvLyBSZXR1cm5zIG5leHQgb3IgcHJldmlvdXMgaXRlbSBmaWx0ZXJpbmcgb3V0IHBsYWNlaG9sZGVyIG9yIGN1cnJlbnRseSBkcmFnZ2VkIGVsZW1lbnRcblxuICAgIHdoaWxlIChpdGVtLmxlbmd0aCAmJiAoIWl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtaXRlbScpIHx8IGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGgnKSB8fCBpdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWl0ZW0tZHJhZ2dpbmcnKSkpIHtcbiAgICAgIGlmICghdGhhdC5zb3J0YWJsZS5ncm91cCAmJiBpdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWdyLXRpdGxlJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpdGVtID0gaXRlbVtkaXJdKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdENvbG9yKHBvcykge1xuICAgIHJldHVybiAocG9zID4gMCA/IHR5cGUucmlnaHQgOiB0eXBlLmxlZnQpLmNvbG9yIHx8IHRyYW5zcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE51bVN0cihzKSB7XG4gICAgcmV0dXJuIGlzTnVtZXJpYyhzKSA/IHMgKyAnJyA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBY3Rpb25XaWR0aCh0eXBlLCBkaWZmWCkge1xuICAgIHJldHVybiArKGRpZmZYIDwgMCA/IGdldE51bVN0cigodHlwZS5hY3Rpb25zV2lkdGggfHwgMCkucmlnaHQpIHx8IGdldE51bVN0cih0eXBlLmFjdGlvbnNXaWR0aCkgfHwgZ2V0TnVtU3RyKHMuYWN0aW9uc1dpZHRoLnJpZ2h0KSB8fCBnZXROdW1TdHIocy5hY3Rpb25zV2lkdGgpIDogZ2V0TnVtU3RyKCh0eXBlLmFjdGlvbnNXaWR0aCB8fCAwKS5sZWZ0KSB8fCBnZXROdW1TdHIodHlwZS5hY3Rpb25zV2lkdGgpIHx8IGdldE51bVN0cihzLmFjdGlvbnNXaWR0aC5sZWZ0KSB8fCBnZXROdW1TdHIocy5hY3Rpb25zV2lkdGgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvSXRlbShpdGVtLCBzY3JvbGxUb1RvcCkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gd25kLnNjcm9sbFRvcCgpLFxuICAgICAgICAgIGl0ZW1IZWlnaHQgPSBpdGVtLmlzKCcubWJzYy1sdi1pdGVtJykgPyBpdGVtWzBdLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgaXRlbVRvcCA9IGl0ZW0ub2Zmc2V0KCkudG9wICsgKGhhc0NvbnRleHQgPyBzY3JvbGxUb3AgLSB3bmRUb3AgOiAwKTtcblxuICAgICAgaWYgKHNjcm9sbFRvVG9wKSB7XG4gICAgICAgIGlmIChpdGVtVG9wIDwgc2Nyb2xsVG9wIHx8IGl0ZW1Ub3AgKyBpdGVtSGVpZ2h0ID4gc2Nyb2xsVG9wICsgd25kSGVpZ2h0KSB7XG4gICAgICAgICAgd25kLnNjcm9sbFRvcChpdGVtVG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1Ub3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgICB3bmQuc2Nyb2xsVG9wKGl0ZW1Ub3ApO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub3AgKyBpdGVtSGVpZ2h0ID4gc2Nyb2xsVG9wICsgd25kSGVpZ2h0KSB7XG4gICAgICAgICAgd25kLnNjcm9sbFRvcChNYXRoLm1pbihpdGVtVG9wLCBpdGVtVG9wICsgaXRlbUhlaWdodCAtIHduZEhlaWdodCAvIDIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyaWxsKGRpciwgbGlzdCwgaXRlbSwgY2FsbGJhY2ssIHNjcm9sbFRvVG9wKSB7XG4gICAgdmFyIHBhcmVudCA9IGxpc3QucGFyZW50KCksXG4gICAgICAgIHBoID0gbGlzdC5wcmV2KCk7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXG4gICAgaWYgKHBoWzBdID09PSBpY29uY1swXSkge1xuICAgICAgcGggPSBpY29uYy5wcmV2KCk7XG4gICAgfVxuXG4gICAgaWYgKHMucnRsKSB7XG4gICAgICBkaXIgPSBkaXIgPT09ICdsJyA/ICdyJyA6ICdsJztcbiAgICB9XG5cbiAgICBpZiAoY3Vyckxpc3RbMF0gIT09IGxpc3RbMF0pIHtcbiAgICAgIGV2ZW50KCdvbk5hdlN0YXJ0Jywge1xuICAgICAgICBsZXZlbDogc2xpZGVMZXZlbCxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXIsXG4gICAgICAgIGxpc3Q6IGxpc3RbMF1cbiAgICAgIH0pO1xuICAgICAgc2xpZGVDb250LnByZXBlbmQobGlzdC5hZGRDbGFzcygnbWJzYy1sdi12IG1ic2MtbHYtc2wtbmV3JykpOyAvLyBJZiB0b3Agb2YgdGhlIGxpc3QgaXMgbm90IHZpc2libGUsIHNjcm9sbCB0byB0b3BcblxuICAgICAgc2Nyb2xsVG9JdGVtKGNvbnQpO1xuICAgICAgYW5pbWF0ZShzbGlkZUNvbnQsICdtYnNjLWx2LXNsLScgKyBkaXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3Vyckxpc3QucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtc2wtY3VycicpO1xuICAgICAgICBsaXN0LnJlbW92ZUNsYXNzKCdtYnNjLWx2LXNsLW5ldycpLmFkZENsYXNzKCdtYnNjLWx2LXNsLWN1cnInKTtcblxuICAgICAgICBpZiAoY3VyclBoICYmIGN1cnJQaC5sZW5ndGgpIHtcbiAgICAgICAgICBjdXJyTGlzdC5yZW1vdmVDbGFzcygnbWJzYy1sdi12JykuaW5zZXJ0QWZ0ZXIoY3VyclBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyUGFyZW50LmFwcGVuZChjdXJyTGlzdC5yZW1vdmVDbGFzcygnbWJzYy1sdi12JykpO1xuICAgICAgICB9IC8vIFJlbWVtYmVyIHRoZSBwcmV2aW91cyBlbGVtZW50IHdoZXJlIHdlIG5lZWQgdG8gcHV0IGJhY2sgdGhlIGxpc3QgbGF0ZXJcbiAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGJlY2F1c2Ugc29tZSBmcmFtZXdvcmtzIGxpa2UgZW1iZXIganMgcHV0IGFkZGl0aW9uYWwgZWxlbWVudHMgKHNjcmlwdCB0YWdzKVxuICAgICAgICAvLyBhbmQgYXBwZW5kaW5nIHRvIHBhcmVudCBlbGVtZW50IGlzIG5vdCBva1xuXG5cbiAgICAgICAgY3VyclBoID0gcGg7XG4gICAgICAgIGN1cnJQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGN1cnJMaXN0ID0gbGlzdDtcbiAgICAgICAgc2Nyb2xsVG9JdGVtKGl0ZW0sIHNjcm9sbFRvVG9wKTtcbiAgICAgICAgY2FsbGJhY2suY2FsbChlLCBpdGVtKTtcbiAgICAgICAgZXZlbnQoJ29uTmF2RW5kJywge1xuICAgICAgICAgIGxldmVsOiBzbGlkZUxldmVsLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyLFxuICAgICAgICAgIGxpc3Q6IGxpc3RbMF1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9JdGVtKGl0ZW0sIHNjcm9sbFRvVG9wKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoZSwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmF2aWdhdGUoaXRlbSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRyYW5zaXRpb24pIHtcbiAgICAgIGlmIChpdGVtLmhhc0NsYXNzKCdtYnNjLWx2LXBhcmVudCcpKSB7XG4gICAgICAgIHNsaWRlTGV2ZWwrKztcbiAgICAgICAgZHJpbGwoJ3InLCB0cmVlTWFwW2l0ZW0uYXR0cignZGF0YS1yZWYnKV0uY2hpbGQsIG51bGwsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgc2xpZGVMZXZlbC0tO1xuICAgICAgICBkcmlsbCgnbCcsIHRyZWVNYXBbaXRlbS5hdHRyKCdkYXRhLWJhY2snKV0ucGFyZW50LCB0cmVlTWFwW2l0ZW0uYXR0cignZGF0YS1iYWNrJyldLml0ZW0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKGVsLCBhbmltLCBjYWxsYmFjaykge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIG9uQW5pbUVuZCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0cmFuc2l0aW9uLS07XG4gICAgICBlbC5vZmYoYW5pbUVuZCwgb25BbmltRW5kKS5yZW1vdmVDbGFzcyhhbmltKTtcbiAgICAgIGNhbGxiYWNrLmNhbGwoZSwgZWwpO1xuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgIGlmIChzLmFuaW1hdGlvbiAmJiBhbmltICE9PSAnbWJzYy1sdi1pdGVtLW5vbmUnKSB7XG4gICAgICB0cmFuc2l0aW9uKys7XG4gICAgICBlbC5vbihhbmltRW5kLCBvbkFuaW1FbmQpLmFkZENsYXNzKGFuaW0pOyAvLyBhbmltRW5kIGV2ZW50IHdpbGwgbm90IGV4ZWN1dGUgd2l0aCBzb21lIGludGVncmF0aW9uIHBsdWdpbnMsIHRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIG1ha2Ugc3VyZSBpdCdzIGV4ZWN1dGVkXG5cbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChvbkFuaW1FbmQsIDI1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoZSwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvQWN0aW9uKGVsLCBhY3Rpb24pIHtcbiAgICB2YXIgcXVldWUsXG4gICAgICAgIGlkID0gZWwuYXR0cignZGF0YS1yZWYnKTtcbiAgICBxdWV1ZSA9IGFjdGlvblF1ZXVlW2lkXSA9IGFjdGlvblF1ZXVlW2lkXSB8fCBbXTtcblxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIHF1ZXVlLnB1c2goYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoZWwuYXR0cignZGF0YS1hY3Rpb24nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGlvbiA9IHF1ZXVlLnNoaWZ0KCk7IC8vIENoZWNrIHRoaXMgZm9yIHNhZmV0eVxuICAgIC8vIFRoZXJlIHdhcyBhIGNhc2UgaW4gYW5ndWxhciB3ZXJlIHRoZSBkYXRhLXJlZiBhdHRyaWJ1dGUgd2FzIGxvc3QsXG4gICAgLy8gc28gdGhlIHF1ZXVlIHdhcyBlbXB0eVxuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgZWwuYXR0cignZGF0YS1hY3Rpb24nLCAxKTtcbiAgICAgIGFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHIoJ2RhdGEtYWN0aW9uJyk7XG5cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIGRvQWN0aW9uKGVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgYWN0aW9uUXVldWVbaWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzU3RhZ2VzKHN0YWdlcywgZGlyLCBkdXBsaWNhdGUpIHtcbiAgICB2YXIgY291bnQsIHRlbXA7XG5cbiAgICBpZiAoc3RhZ2VzICYmIHN0YWdlcy5sZW5ndGgpIHtcbiAgICAgIGNvdW50ID0gMTAwIC8gKHN0YWdlcy5sZW5ndGggKyAyKTtcbiAgICAgICQkMS5lYWNoKHN0YWdlcywgZnVuY3Rpb24gKGksIHN0YWdlKSB7XG4gICAgICAgIGlmIChzdGFnZS5rZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0YWdlLmtleSA9IHN0YWdlTnIrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFnZS5wZXJjZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBpZiBubyBwZXJjZW50IHBhc3NlZCB0aGVuIGdlbmVyYXRlIHRvIGJvdGggc2lkZXNcbiAgICAgICAgICBzdGFnZS5wZXJjZW50ID0gZGlyICogY291bnQgKiAoaSArIDEpO1xuXG4gICAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgdGVtcCA9IGV4dGVuZCQxKHt9LCBzdGFnZSk7XG4gICAgICAgICAgICB0ZW1wLmtleSA9IHN0YWdlTnIrKztcbiAgICAgICAgICAgIHRlbXAucGVyY2VudCA9IC1jb3VudCAqIChpICsgMSk7XG4gICAgICAgICAgICBzdGFnZXMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgIHN0YWdlT2JqW3RlbXAua2V5XSA9IHRlbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhZ2VPYmpbc3RhZ2Uua2V5XSA9IHN0YWdlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0SXRlbSgkaXRlbSkge1xuICAgIGlmIChpc1NlbGVjdGFibGUoJGl0ZW0pKSB7XG4gICAgICAkaXRlbS5hZGRDbGFzcyhTRUxFQ1RFRF9DTEFTUykuYXR0cignZGF0YS1zZWxlY3RlZCcsICd0cnVlJykuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzZWxlY3RJdGVtKCRpdGVtKSB7XG4gICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoU0VMRUNURURfQ0xBU1MpLnJlbW92ZUF0dHIoJ2RhdGEtc2VsZWN0ZWQnKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBCYXNlLmNhbGwodGhpcywgZWxlbSwgc2V0dGluZ3MsIHRydWUpO1xuICAvKipcbiAgICogQW5pbWF0ZSBhIGxpc3QgaXRlbVxuICAgKi9cblxuICB0aGF0LmFuaW1hdGUgPSBmdW5jdGlvbiAobGksIGFuaW0sIGNhbGxiYWNrKSB7XG4gICAgYW5pbWF0ZShsaSwgJ21ic2MtbHYtaXRlbS0nICsgYW5pbSwgY2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICogQWRkIGEgbmV3IGxpc3QgaXRlbVxuICAgKi9cblxuXG4gIHRoYXQuYWRkID0gZnVuY3Rpb24gKGlkLCBtYXJrdXAsIGluZGV4LCBjYWxsYmFjaywgcCwgaXNVbmRvKSB7XG4gICAgdmFyIGJhY2tCdG4sXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgc2libGluZ3MsXG4gICAgICAgIHN1YmxldmVsLFxuICAgICAgICBtYXAsXG4gICAgICAgIHByZWYsXG4gICAgICAgIGNzc0NsYXNzID0gJycsXG4gICAgICAgICRwYXJlbnQgPSBwID09PSB1bmRlZmluZWQgPyBlbG0gOiBnZXRJdGVtQnlJRChwKSxcbiAgICAgICAgJGxpc3QgPSAkcGFyZW50LFxuICAgICAgICAkaXRlbSA9IHR5cGVvZiBtYXJrdXAgIT09ICdvYmplY3QnID8gJCQxKCc8JyArIGl0ZW1Ob2RlICsgJyBkYXRhLXJlZj1cIicgKyBndWlkKysgKyAnXCIgZGF0YS1pZD1cIicgKyBpZCArICdcIj4nICsgbWFya3VwICsgJzwvJyArIGl0ZW1Ob2RlICsgJz4nKSA6ICQkMShtYXJrdXApLFxuICAgICAgICBpdGVtID0gJGl0ZW1bMF0sXG4gICAgICAgIHN0eWxlID0gaXRlbS5zdHlsZSxcbiAgICAgICAgZGlyID0gJGl0ZW0uYXR0cignZGF0YS1wb3MnKSA8IDAgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICByZWYgPSAkaXRlbS5hdHRyKCdkYXRhLXJlZicpO1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgIGlmICghcmVmKSB7XG4gICAgICByZWYgPSBndWlkKys7XG4gICAgICAkaXRlbS5hdHRyKCdkYXRhLXJlZicsIHJlZik7XG4gICAgfVxuXG4gICAgaW5pdEl0ZW0oJGl0ZW0pOyAvLyBQdXQgYWN0aW9uIGluIHVuZG8gc3RhY2tcblxuICAgIGlmICghaXNVbmRvKSB7XG4gICAgICB0aGF0LmFkZFVuZG9BY3Rpb24oZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgaWYgKHN1YmxldmVsKSB7XG4gICAgICAgICAgdGhhdC5uYXZpZ2F0ZSgkcGFyZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkbGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykuY2hpbGRyZW4oJy5tYnNjLWx2LWFycicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgbWFwLmNoaWxkID0gJHBhcmVudC5jaGlsZHJlbihsaXN0U2VsZWN0b3IpO1xuICAgICAgICAgICAgdGhhdC5yZW1vdmUoJGl0ZW0sIG51bGwsIG5leHQsIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQucmVtb3ZlKCRpdGVtLCBudWxsLCBuZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZG9BY3Rpb24oJGl0ZW0sIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXNldEl0ZW0oJGl0ZW0uY3NzKCd0b3AnLCAnJykucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS11bmRvJykpOyAvLyBJZiBwYXJlbnQgaXMgYSBsaXN0IGl0ZW0sIGluc2VydCBuZXcgZWxlbWVudCBpbiB0aGUgc3VibGlzdFxuXG4gICAgICBpZiAoJHBhcmVudC5pcyhpdGVtU2VsZWN0b3IpKSB7XG4gICAgICAgIHByZWYgPSAkcGFyZW50LmF0dHIoJ2RhdGEtcmVmJyk7IC8vIElmIHRoZXJlIGlzIG5vIHN1Ymxpc3QgeWV0LCBjcmVhdGUgaXRcblxuICAgICAgICBpZiAoISRwYXJlbnQuY2hpbGRyZW4obGlzdFNlbGVjdG9yKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdWJsZXZlbCA9IHRydWU7XG4gICAgICAgICAgJHBhcmVudC5hcHBlbmQoJzwnICsgbGlzdE5vZGUgKyAnPjwvJyArIGxpc3ROb2RlICsgJz4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZiA9ICRwYXJlbnQuY2hpbGRyZW4oJy5tYnNjLWx2LWJhY2snKS5hdHRyKCdkYXRhLWJhY2snKTtcbiAgICAgIH1cblxuICAgICAgbWFwID0gdHJlZU1hcFtwcmVmXTtcblxuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBpZiAoIW1hcC5jaGlsZC5sZW5ndGgpIHtcbiAgICAgICAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLWx2LXBhcmVudCcpLnByZXBlbmQoaHRtbFJpZ2h0KTsgLy8gU2V0IHBhcmVudCB0byBiZSB0aGUgc3VibGlzdFxuXG4gICAgICAgICAgJGxpc3QgPSAkcGFyZW50LmNoaWxkcmVuKGxpc3RTZWxlY3RvcikucHJlcGVuZChodG1sTGVmdCkuYWRkQ2xhc3MoJ21ic2MtbHYnKTtcbiAgICAgICAgICBtYXAuY2hpbGQgPSAkbGlzdDtcbiAgICAgICAgICAkJDEoJy5tYnNjLWx2LWJhY2snLCAkcGFyZW50KS5hdHRyKCdkYXRhLWJhY2snLCBwcmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkbGlzdCA9IG1hcC5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmVlTWFwW3JlZl0gPSB7XG4gICAgICAgIGl0ZW06ICRpdGVtLFxuICAgICAgICBjaGlsZDogJGl0ZW0uY2hpbGRyZW4obGlzdFNlbGVjdG9yKSxcbiAgICAgICAgcGFyZW50OiAkbGlzdCxcbiAgICAgICAgcmVmOiBwcmVmXG4gICAgICB9O1xuICAgICAgc2libGluZ3MgPSBnZXRDaGlsZHJlbigkbGlzdCk7XG4gICAgICBsZW5ndGggPSBzaWJsaW5ncy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbmRvKSB7XG4gICAgICAgIGNzc0NsYXNzID0gJ21ic2MtbHYtaXRlbS1uZXctJyArIChpc1VuZG8gPyBkaXIgOiAnJyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRCcmFuY2goJGl0ZW0uYWRkQ2xhc3MoY3NzQ2xhc3MpKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIGJhY2tCdG4gPSAkJDEoJy5tYnNjLWx2LWJhY2snLCAkbGlzdCk7XG5cbiAgICAgICAgICBpZiAoYmFja0J0bi5sZW5ndGgpIHtcbiAgICAgICAgICAgICRpdGVtLmluc2VydEFmdGVyKGJhY2tCdG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbGlzdC5hcHBlbmQoJGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICRpdGVtLmluc2VydEJlZm9yZShzaWJsaW5ncy5lcShpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRpdGVtLmluc2VydEFmdGVyKHNpYmxpbmdzLmVxKGxlbmd0aCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250LnRyaWdnZXIoJ21ic2MtcmVmcmVzaCcpOyAvLyBJZiBjdXJyZW50IGxldmVsIGlzIHZpc2libGVcblxuICAgICAgaWYgKHMuYW5pbWF0ZUFkZFJlbW92ZSAmJiAkbGlzdC5oYXNDbGFzcygnbWJzYy1sdi12JykpIHtcbiAgICAgICAgLy8gRG9uJ3QgcnVuIGV4cGFuZCBhbmltYXRpb24gaWYgYWRkIGlzIHJ1bm5pbmcgb24gdGhlIFwidW5kb1wiIGVsZW1lbnRcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaXRlbS5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGF0LmFuaW1hdGUoJGl0ZW0sIGlzVW5kbyAmJiB1bmRvUmVmID09PSByZWYgPyAnbm9uZScgOiAnZXhwYW5kJywgZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgICAgICAgdGhhdC5hbmltYXRlKCRpdGVtLCBpc1VuZG8gPyAnYWRkLScgKyBkaXIgOiAncG9wLWluJywgZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZSwgJGl0ZW0ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGUsICRpdGVtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKSk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQoJ29uSXRlbUFkZCcsIHtcbiAgICAgICAgdGFyZ2V0OiBpdGVtXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFN3aXBlIGEgbGlzdCBpdGVtIHByb2dyYW1hdGljYWxseVxuICAgKi9cblxuXG4gIHRoYXQuc3dpcGUgPSBmdW5jdGlvbiAobGksIHBlcmNlbnQsIHRpbWUsIGRlbW8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByZXZQb3M7XG4gICAgbGkgPSBnZXRJdGVtQnlJRChsaSk7XG4gICAgaXRlbSA9IGxpO1xuICAgIGRlbW9Nb2RlID0gZGVtbztcbiAgICBzaW11bGF0aW5nID0gdHJ1ZTtcbiAgICBhY3Rpb24gPSB0cnVlO1xuICAgIHRpbWUgPSB0aW1lID09PSB1bmRlZmluZWQgPyAzMDAgOiB0aW1lO1xuICAgIGRpZmZYID0gcGVyY2VudCA+IDAgPyAxIDogLTE7XG4gICAgb25BY3Rpb25TdGFydCgpO1xuICAgIG9uU3dpcGVTdGFydCgpO1xuICAgIHNsaWRlKGxpLCBwZXJjZW50LCB0aW1lKTtcbiAgICBjbGVhclRpbWVvdXQoc3dpcGVUaW1lb3V0KTtcbiAgICBjbGVhckludGVydmFsKHN3aXBlSW50ZXJ2YWwpO1xuICAgIHN3aXBlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2UG9zID0gYW5pbVBvcztcbiAgICAgIGFuaW1Qb3MgPSBnZXRQb3NpdGlvbihsaSkgLyBpdGVtdyAqIDEwMDtcbiAgICAgIG9uU3dpcGVNb3ZlKHByZXZQb3MpO1xuICAgIH0sIDEwKTtcbiAgICBzd2lwZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc3dpcGVJbnRlcnZhbCk7XG4gICAgICBwcmV2UG9zID0gYW5pbVBvcztcbiAgICAgIGFuaW1Qb3MgPSBwZXJjZW50OyAvLyBXZSBuZWVkIG9uZSBhZGRpdGlvbmFsIG1vdmUgd2l0aCB0aGUgZmluYWwgcGVyY2VudCB0byBnZXQgdGhlIGNvcnJlY3Qgc3RhZ2VcblxuICAgICAgb25Td2lwZU1vdmUocHJldlBvcyk7XG4gICAgICBvblN3aXBlRW5kKGNhbGxiYWNrKTtcbiAgICAgIGRlbW9Nb2RlID0gZmFsc2U7XG4gICAgICBzaW11bGF0aW5nID0gZmFsc2U7XG4gICAgICBhY3Rpb24gPSBmYWxzZTtcbiAgICB9LCB0aW1lKTtcbiAgfTtcblxuICB0aGF0Lm9wZW5TdGFnZSA9IGZ1bmN0aW9uIChsaSwgc3RhZ2UsIHRpbWUsIGRlbW8pIHtcbiAgICBpZiAoc3RhZ2VPYmpbc3RhZ2VdKSB7XG4gICAgICB0aGF0LnN3aXBlKGxpLCBzdGFnZU9ialtzdGFnZV0ucGVyY2VudCwgdGltZSwgZGVtbyk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQub3BlbkFjdGlvbnMgPSBmdW5jdGlvbiAobGksIGRpciwgdGltZSwgZGVtbykge1xuICAgIGxpID0gZ2V0SXRlbUJ5SUQobGkpO1xuICAgIHZhciBwZXJjZW50ID0gZ2V0QWN0aW9uV2lkdGgodHlwZXNbbGkuYXR0cignZGF0YS10eXBlJykgfHwgJ2RlZmF1bHRzJ10sIGRpciA9PSAnbGVmdCcgPyAtMSA6IDEpO1xuICAgIHRoYXQuc3dpcGUobGksIGRpciA9PSAnbGVmdCcgPyAtcGVyY2VudCA6IHBlcmNlbnQsIHRpbWUsIGRlbW8pO1xuICB9O1xuXG4gIHRoYXQuY2xvc2UgPSBmdW5jdGlvbiAobGksIHRpbWUpIHtcbiAgICB0aGF0LnN3aXBlKGxpLCAwLCB0aW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxpc3QgaXRlbVxuICAgKi9cblxuXG4gIHRoYXQucmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBkaXIsIGNhbGxiYWNrLCBpc1VuZG8pIHtcbiAgICB2YXIgJGl0ZW0sICRwYXJlbnQsIGFuaW0sIGluZGV4LCByZWYsIHNob3VsZE5hdmlnYXRlLCBzdHlsZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVN1YlRyZWUoJGNoaWxkKSB7XG4gICAgICBpZiAoJGNoaWxkKSB7XG4gICAgICAgIHNob3VsZE5hdmlnYXRlID0gc2hvdWxkTmF2aWdhdGUgfHwgJGNoaWxkLmhhc0NsYXNzKCdtYnNjLWx2LXYnKTtcbiAgICAgICAgJGNoaWxkLmNoaWxkcmVuKCdbZGF0YS1yZWZdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlZiA9ICQkMSh0aGlzKS5hdHRyKCdkYXRhLXJlZicpO1xuXG4gICAgICAgICAgaWYgKHRyZWVNYXBbcmVmXSkge1xuICAgICAgICAgICAgZGVsZXRlU3ViVHJlZSh0cmVlTWFwW3JlZl0uY2hpbGQpO1xuICAgICAgICAgICAgZGVsZXRlIHRyZWVNYXBbcmVmXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAkaXRlbSA9IGdldEl0ZW1CeUlEKGlkKTtcbiAgICByZWYgPSAkaXRlbS5hdHRyKCdkYXRhLXJlZicpO1xuXG4gICAgaWYgKCRpdGVtLmxlbmd0aCAmJiB0cmVlTWFwW3JlZl0pIHtcbiAgICAgICRwYXJlbnQgPSAkaXRlbS5wYXJlbnQoKTtcbiAgICAgIGluZGV4ID0gZ2V0Q2hpbGRyZW4oJHBhcmVudCkuaW5kZXgoJGl0ZW0pO1xuICAgICAgc3R5bGUgPSAkaXRlbVswXS5zdHlsZTtcbiAgICAgIGRlbGV0ZVN1YlRyZWUodHJlZU1hcFtyZWZdLmNoaWxkKTtcblxuICAgICAgaWYgKHNob3VsZE5hdmlnYXRlKSB7XG4gICAgICAgIGFuaW0gPSBzLmFuaW1hdGlvbjtcbiAgICAgICAgcy5hbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhhdC5uYXZpZ2F0ZSgkaXRlbSk7XG4gICAgICAgIHMuYW5pbWF0aW9uID0gYW5pbTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRyZWVNYXBbcmVmXTsgLy8gUHV0IGFjdGlvbiBpbiB1bmRvIHN0YWNrXG5cbiAgICAgIGlmICghaXNVbmRvKSB7XG4gICAgICAgIC8vIElmIHVuZG8gZWxlbWVudCBpcyByZW1vdmVkLCB1bmRvIHBsYWNlaG9sZGVyIHNob3VsZCBiZSByZW1vdmVkIHdpdGggYW5pbWF0aW9uXG4gICAgICAgIGlmICgkaXRlbS5hdHRyKCdkYXRhLXJlZicpID09PSB1bmRvUmVmKSB7XG4gICAgICAgICAgdW5kb0FuaW0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZGRVbmRvQWN0aW9uKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgdGhhdC5hZGQobnVsbCwgJGl0ZW0sIGluZGV4LCBuZXh0LCAkcGFyZW50LCB0cnVlKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRvQWN0aW9uKCRpdGVtLCBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBkaXIgPSBkaXIgfHwgKCRpdGVtLmF0dHIoJ2RhdGEtcG9zJykgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKHMuYW5pbWF0ZUFkZFJlbW92ZSAmJiAkcGFyZW50Lmhhc0NsYXNzKCdtYnNjLWx2LXYnKSkge1xuICAgICAgICAgIHRoYXQuYW5pbWF0ZSgkaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1yZW1vdmVkJyksIGlzVW5kbyA/ICdwb3Atb3V0JyA6ICdyZW1vdmUtJyArIGRpciwgZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSAkaXRlbVswXS5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdGhhdC5hbmltYXRlKCRpdGVtLCAnY29sbGFwc2UnLCBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgIHJlc2V0SXRlbSgkaXRlbS5yZW1vdmVDbGFzcygnbWJzYy1sdi1yZW1vdmVkJykpO1xuXG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGUsICRpdGVtKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAkaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGUsICRpdGVtKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICRpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50KCdvbkl0ZW1SZW1vdmUnLCB7XG4gICAgICAgICAgdGFyZ2V0OiAkaXRlbVswXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIE1vdmVzIGFuIGl0ZW0gaW4gdGhlIGxpc3RcbiAgICovXG5cblxuICB0aGF0Lm1vdmUgPSBmdW5jdGlvbiAobGksIGluZGV4LCBkaXIsIGNhbGxiYWNrLCBwLCBpc1VuZG8pIHtcbiAgICBsaSA9IGdldEl0ZW1CeUlEKGxpKTsgLy9pZiAoZ2V0Q2hpbGRyZW4obGkucGFyZW50KCkpLmluZGV4KGxpKSAhPT0gaW5kZXgpIHtcblxuICAgIGlmICghaXNVbmRvKSB7XG4gICAgICB0aGF0LnN0YXJ0QWN0aW9uVHJhY2soKTtcbiAgICB9XG5cbiAgICBzdGFnZWMuYXBwZW5kKGljb25jKTtcbiAgICB0aGF0LnJlbW92ZShsaSwgZGlyLCBudWxsLCBpc1VuZG8pO1xuICAgIHRoYXQuYWRkKG51bGwsIGxpLCBpbmRleCwgY2FsbGJhY2ssIHAsIGlzVW5kbyk7XG5cbiAgICBpZiAoIWlzVW5kbykge1xuICAgICAgdGhhdC5lbmRBY3Rpb25UcmFjaygpO1xuICAgIH0gLy99XG5cbiAgfTtcbiAgLyoqXG4gICAqIE5hdmlnYXRlIGFuZCBzY3JvbGwgdG8gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICovXG5cblxuICB0aGF0Lm5hdmlnYXRlID0gZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgdmFyIG1hcCwgbGV2ZWw7XG4gICAgaXRlbSA9IGdldEl0ZW1CeUlEKGl0ZW0pO1xuICAgIG1hcCA9IHRyZWVNYXBbaXRlbS5hdHRyKCdkYXRhLXJlZicpXTtcbiAgICBsZXZlbCA9IGdldEl0ZW1MZXZlbChpdGVtKTtcblxuICAgIGlmIChtYXApIHtcbiAgICAgIGRyaWxsKGxldmVsID49IHNsaWRlTGV2ZWwgPyAncicgOiAnbCcsIG1hcC5wYXJlbnQsIGl0ZW0sIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHNsaWRlTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5zaG93TG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpc0xvYWRpbmcgPSB0cnVlO1xuICAgIGxvYWRpbmcuYWRkQ2xhc3MoJ21ic2Mtc2hvdy1sdi1sb2FkaW5nJyk7XG4gICAgd25kLnNjcm9sbFRvcChoYXNDb250ZXh0ID8gd25kMC5zY3JvbGxIZWlnaHQgOiAkJDEocy5jb250ZXh0KVswXS5zY3JvbGxIZWlnaHQpO1xuICB9O1xuXG4gIHRoYXQuaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9hZGluZy5yZW1vdmVDbGFzcygnbWJzYy1zaG93LWx2LWxvYWRpbmcnKTsgLy8gTmVlZHMgdGltZW91dCB0byBwcmV2ZW50IHRyaWdnZXJpbmcgXG4gICAgLy8gdGhlIG9uTGlzdEVuZCBldmVudCBmcm9tIHRoZSBzY3JvbGwgbGlzdGVuZXJcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICB0aGF0LnNlbGVjdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgZGVzZWxlY3RJdGVtKCQkMShpdGVtU2VsZWN0b3IsIGNvbnQpLmZpbHRlcignLicgKyBTRUxFQ1RFRF9DTEFTUykpO1xuICAgIH1cblxuICAgIHNlbGVjdEl0ZW0oZ2V0SXRlbUJ5SUQoaXRlbSkpO1xuICB9O1xuXG4gIHRoYXQuZGVzZWxlY3QgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGRlc2VsZWN0SXRlbShnZXRJdGVtQnlJRChpdGVtKSk7XG4gIH07XG5cbiAgdGhhdC5fcHJvY2Vzc1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbG0uaXMoJ1ttYnNjLWVuaGFuY2VdJykpIHtcbiAgICAgIGhhZEVuaGFuY2UgPSB0cnVlO1xuICAgICAgZWxtLnJlbW92ZUF0dHIoJ21ic2MtZW5oYW5jZScpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIExpc3R2aWV3IGluaXRpYWxpemF0aW9uLlxuICAgKi9cblxuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRDbGFzcyxcbiAgICAgICAgaGVhZGVyQ2xhc3MsXG4gICAgICAgIHNvcnRhYmxlLFxuICAgICAgICAvL2RlZlNvcnRIYW5kbGUgPSBlbG0uZmluZChsaXN0U2VsZWN0b3IpLmxlbmd0aCA/ICdsZWZ0JyA6ICdyaWdodCcsXG4gICAgaSA9IDAsXG4gICAgICAgIGljb25zID0gJycsXG4gICAgICAgIGljb25zTGVmdCA9ICcnLFxuICAgICAgICBpY29uc1JpZ2h0ID0gJyc7XG4gICAgbGlzdE5vZGUgPSBzLmxpc3ROb2RlO1xuICAgIGxpc3RTZWxlY3RvciA9IHMubGlzdFNlbGVjdG9yO1xuICAgIGl0ZW1Ob2RlID0gcy5pdGVtTm9kZTtcbiAgICBpdGVtU2VsZWN0b3IgPSBzLml0ZW1TZWxlY3RvcjtcbiAgICBtdWx0aXBsZSA9IHMuc2VsZWN0ID09ICdtdWx0aXBsZSc7XG4gICAgc2VsZWN0YWJsZSA9IHMuc2VsZWN0ICE9ICdvZmYnO1xuICAgIC8qXG4gICAgc29ydGFibGUgPSBzLnNvcnQgfHwgcy5zb3J0YWJsZSB8fCBmYWxzZTtcbiAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJsaXR5IGZvciAnZ3JvdXAnIGFuZCBzb3J0SGFuZGxlIHNldHRpbmdzXG4gICAgLy8gLS0tXG4gICAgaWYgKHNvcnRhYmxlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIHNvcnRhYmxlID0ge1xuICAgICAgICAgICAgZ3JvdXA6IGZhbHNlLFxuICAgICAgICAgICAgbXVsdGlMZXZlbDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAgaWYgKHNvcnRhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHNvcnRhYmxlID0ge1xuICAgICAgICAgICAgZ3JvdXA6IHRydWUsXG4gICAgICAgICAgICBtdWx0aUxldmVsOiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlOiBzLnNvcnRIYW5kbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgIGlmIChzb3J0YWJsZSAmJiBzb3J0YWJsZS5oYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzb3J0YWJsZS5oYW5kbGUgPSBzLnNvcnRIYW5kbGU7XG4gICAgfVxuICAgIC8vIC0tLVxuICAgICBpZiAoc29ydGFibGUuaGFuZGxlKSB7XG4gICAgICAgIGhhbmRsZVBvcyA9IHNvcnRhYmxlLmhhbmRsZSA9PT0gdHJ1ZSA/IGRlZlNvcnRIYW5kbGUgOiBzb3J0YWJsZS5oYW5kbGU7XG4gICAgICAgIGhhbmRsZURpdiA9ICc8ZGl2IGNsYXNzPVwibWJzYy1sdi1oYW5kbGUtYyBtYnNjLWx2LWl0ZW0taC0nICsgaGFuZGxlUG9zICsgJyBtYnNjLWx2LWhhbmRsZVwiPjxkaXYgY2xhc3M9XCInICsgcy5oYW5kbGVDbGFzcyArICcgbWJzYy1sdi1oYW5kbGUtYmFyLWMgbWJzYy1sdi1oYW5kbGVcIj4nICsgcy5oYW5kbGVNYXJrdXAgKyAnPC9kaXY+PC9kaXY+JztcbiAgICB9XG4gICAgIGh0bWxMZWZ0ID0gJzwnICsgaXRlbU5vZGUgKyAnIGNsYXNzPVwibWJzYy1sdi1pdGVtIG1ic2MtbHYtYmFjayBtYnNjLWx2LWl0ZW0tYWN0aW9uYWJsZVwiPicgKyBzLmJhY2tUZXh0ICsgJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWFyciBtYnNjLWx2LWljIG1ic2MtaWMgJyArIHMubGVmdEFycm93Q2xhc3MgKyAnXCI+PC9kaXY+PC8nICsgaXRlbU5vZGUgKyAnPic7XG4gICAgaHRtbFJpZ2h0ID0gJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWFyciBtYnNjLWx2LWljIG1ic2MtaWMgJyArIHMucmlnaHRBcnJvd0NsYXNzICsgJ1wiPjwvZGl2Pic7XG4gICAgIGNvbnRDbGFzcyA9ICdtYnNjLW5vLXRvdWNoIG1ic2MtbHYtY29udCBtYnNjLWx2LScgKyBzLnRoZW1lICsgJyBtYnNjLScgKyBzLnRoZW1lICtcbiAgICAgICAgKGhhbGZCb3JkZXIgPyAnIG1ic2MtbHYtaGInIDogJycpICtcbiAgICAgICAgKHMucnRsID8gJyBtYnNjLWx2LXJ0bCBtYnNjLXJ0bCcgOiAnIG1ic2MtbHRyJykgK1xuICAgICAgICAocy5iYXNlVGhlbWUgPyAnIG1ic2MtbHYtJyArIHMuYmFzZVRoZW1lICsgJyBtYnNjLScgKyBzLmJhc2VUaGVtZSA6ICcnKSArXG4gICAgICAgIChzLmFuaW1hdGVJY29ucyA/ICcgbWJzYy1sdi1pYy1hbmltJyA6ICcnKSArXG4gICAgICAgIChzLnN0cmlwZWQgPyAnIG1ic2MtbHYtYWx0LXJvdycgOiAnJykgK1xuICAgICAgICAocy5maXhlZEhlYWRlciA/ICcgbWJzYy1sdi1oYXMtZml4ZWQtaGVhZGVyJyA6ICcnKSArXG4gICAgICAgIChzb3J0YWJsZS5oYW5kbGUgPyAnIG1ic2MtbHYtaGFuZGxlLScgKyBoYW5kbGVQb3MgOiAnJyk7XG4gICAgKi9cbiAgICAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgU1RBUlQgLS0tXG5cbiAgICBzb3J0YWJsZSA9IHRoYXQucmVtb3RlLmxpc3R2aWV3LnNvcnRhYmxlO1xuICAgIGhhbmRsZVBvcyA9IHRoYXQucmVtb3RlLmxpc3R2aWV3LmhhbmRsZVBvcztcbiAgICBoYW5kbGVEaXYgPSB0aGF0LnJlbW90ZS5saXN0dmlldy5oYW5kbGVEaXY7XG4gICAgaHRtbExlZnQgPSB0aGF0LnJlbW90ZS5saXN0dmlldy5odG1sTGVmdDtcbiAgICBodG1sUmlnaHQgPSB0aGF0LnJlbW90ZS5saXN0dmlldy5odG1sUmlnaHQ7XG4gICAgY29udENsYXNzID0gdGhhdC5yZW1vdGUubGlzdHZpZXcuY29udENsYXNzOyAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG4gICAgdGhhdC5zb3J0YWJsZSA9IHNvcnRhYmxlIHx8IGZhbHNlO1xuXG4gICAgaWYgKCFjb250KSB7XG4gICAgICAvLyBJY29uIG1lbnUgY29udGFpbmVyXG4gICAgICBpY29ucyArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtbXVsdGktY1wiPjwvZGl2Pic7IC8vIFN0YWdlIGljb25zIGNvbnRhaW5lclxuXG4gICAgICBpY29ucyArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtaWMtY1wiPjxkaXYgY2xhc3M9XCJtYnNjLWx2LWljLXMgbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtbm9uZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWx2LWljLXRleHRcIj48L2Rpdj48L2Rpdj4nOyAvLyBBZGQgY2xhc3Nlc1xuXG4gICAgICBlbG0uYWRkQ2xhc3MoJ21ic2MtbHYgbWJzYy1sdi12IG1ic2MtbHYtcm9vdCcpLnJlbW92ZUNsYXNzKCdtYnNjLWNsb2FrJykuc2hvdygpO1xuICAgICAgc3RhZ2VjID0gJCQxKCc8ZGl2IGNsYXNzPVwibWJzYy1sdi1zdGFnZS1jXCI+JyArIGljb25zICsgJzwvZGl2PicpO1xuICAgICAgaWNvbmMgPSAkJDEoJy5tYnNjLWx2LWljLWMnLCBzdGFnZWMpO1xuICAgICAgbXVsdGljID0gJCQxKCcubWJzYy1sdi1tdWx0aS1jJywgc3RhZ2VjKTtcbiAgICAgIGljb24gPSAkJDEoJy5tYnNjLWx2LWljLXMnLCBzdGFnZWMpO1xuICAgICAgdGV4dCA9ICQkMSgnLm1ic2MtbHYtaWMtdGV4dCcsIHN0YWdlYyk7XG4gICAgICBwbGFjZWhvbGRlciA9ICQkMSgnPCcgKyBpdGVtTm9kZSArICcgY2xhc3M9XCJtYnNjLWx2LWl0ZW0gbWJzYy1sdi1waFwiPjwvJyArIGl0ZW1Ob2RlICsgJz4nKTtcbiAgICAgIGZpbGwgPSAkJDEoJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWZpbGwtaXRlbVwiPjwvZGl2PicpO1xuICAgICAgY29udCA9ICQkMSgnPGRpdiBjbGFzcz1cIicgKyBjb250Q2xhc3MgKyAnXCI+PCcgKyBsaXN0Tm9kZSArICcgY2xhc3M9XCJtYnNjLWx2IG1ic2MtbHYtZHVtbXlcIj48LycgKyBsaXN0Tm9kZSArICc+PGRpdiBjbGFzcz1cIm1ic2MtbHYtc2wtY1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtbG9hZGluZ1wiPjxzcGFuIGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLScgKyAocy5sb2FkaW5nSWNvbiB8fCAnbG9vcDInKSArICdcIj48L3NwYW4+PC9kaXY+PC9kaXY+Jyk7XG4gICAgICBjb250MCA9IGNvbnRbMF07XG4gICAgICBkdW1teUNvbnQgPSAkJDEoJy5tYnNjLWx2LWR1bW15JywgY29udCk7XG4gICAgICBsb2FkaW5nID0gJCQxKCcubWJzYy1sdi1sb2FkaW5nJywgY29udCk7XG4gICAgICBjb250Lmluc2VydEFmdGVyKGVsbSk7XG4gICAgICBvblJlc2l6ZSgpOyAvLyBTbGlkZSBldmVudHNcblxuICAgICAgbGlzdGVuKGNvbnQwLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgICBsaXN0ZW4oY29udDAsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250Lm9uKCd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsICcubWJzYy1sdi1pdGVtJywgb25FbmQpLm9uKCdjbGljaycsICcubWJzYy1sdi1pdGVtJywgb25DbGljayk7IC8vIFByZXZlbnQgY2xpY2sgb24gc3dpcGVcblxuICAgICAgbGlzdGVuKGUsICdjbGljaycsIG9uTGlzdENsaWNrLCB0cnVlKTsgLy8gSW5pdCBhY3Rpb24gaWNvbnNcbiAgICAgIC8vIC0tLVxuXG4gICAgICBsaXN0ZW4oY29udDAsICdtb3VzZWRvd24nLCBvbkljb25TdGFydCk7XG4gICAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25JY29uU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgY29udC5vbigndG91Y2hlbmQgbW91c2V1cCcsICcubWJzYy1sdi1pYy1tJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICghZGVtb01vZGUpIHtcbiAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgcHJldmVudENsaWNrKCk7XG4gICAgICAgICAgfSAvLyBJZiBtb3ZlbWVudCBpcyBsZXNzIHRoYW4gMTBweCwgZmlyZSB0aGUgY2xpY2sgZXZlbnQgaGFuZGxlclxuXG5cbiAgICAgICAgICBpZiAoY29uZmlybXMgJiYgISQkMSh0aGlzKS5oYXNDbGFzcygnbWJzYy1sdi1pYy1kaXNhYmxlZCcpICYmIE1hdGguYWJzKGdldENvb3JkKGV2LCAnWCcpIC0gc3RhcnRYKSA8IDEwICYmIE1hdGguYWJzKGdldENvb3JkKGV2LCAnWScpIC0gc3RhcnRZKSA8IDEwKSB7XG4gICAgICAgICAgICBydW5BY3Rpb24oKGFuaW1Qb3MgPCAwID8gdHlwZS5yaWdodE1lbnUgOiB0eXBlLmxlZnRNZW51KVskJDEodGhpcykuaW5kZXgoKV0sIGNvbmZpcm1JdGVtLCBjb25maXJtSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7IC8vIC0tLVxuICAgICAgLy8gSW5pdCBoaWVyYXJjaGljYWwgbmF2aWdhdGlvblxuICAgICAgLy8gLS0tXG5cbiAgICAgIHNsaWRlQ29udCA9ICQkMSgnLm1ic2MtbHYtc2wtYycsIGNvbnQpLmFwcGVuZChlbG0uYWRkQ2xhc3MoJ21ic2MtbHYtc2wtY3VycicpKS5hdHRyKCdkYXRhLXJlZicsIGd1aWQrKyk7XG4gICAgICBjdXJyTGlzdCA9IGVsbTtcbiAgICAgIGN1cnJQYXJlbnQgPSBjb250OyAvLyAtLS1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udC5hdHRyKCdjbGFzcycsIGNvbnRDbGFzcyk7IC8vIHJlaW5pdCBzb3J0IGhhbmRsZXNcblxuICAgICAgJCQxKCcubWJzYy1sdi1oYW5kbGUtYycsIGNvbnQpLnJlbW92ZSgpOyAvLyByZW1vdmUgdG8gcmVpbml0IGxpc3QgaXRlbXNcblxuICAgICAgJCQxKGl0ZW1TZWxlY3RvciwgY29udCkubm90KCcubWJzYy1sdi1iYWNrJykucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbScpO1xuICAgICAgdW5saXN0ZW4od25kMCwgJ29yaWVudGF0aW9uY2hhbmdlJywgb25SZXNpemUpO1xuICAgICAgdW5saXN0ZW4od25kMCwgJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIHVubGlzdGVuKHduZDAsICdzY3JvbGwnLCBvblNjcm9sbEJvdHRvbSk7XG4gICAgICB1bmxpc3Rlbih3bmQwLCAndG91Y2htb3ZlJywgb25TY3JvbGxCb3R0b20sIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvblNjcm9sbFRocm90dGxlKSB7XG4gICAgICAgIHVubGlzdGVuKHduZDAsICdzY3JvbGwnLCBvblNjcm9sbFRocm90dGxlKTtcbiAgICAgICAgdW5saXN0ZW4od25kMCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsVGhyb3R0bGUsIHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc0NvbnRleHQgPSBzLmNvbnRleHQgIT09ICdib2R5JztcbiAgICB3bmQgPSAkJDEoaGFzQ29udGV4dCA/IHMuY29udGV4dCA6IHdpbmRvdyk7XG4gICAgd25kMCA9IHduZFswXTsgLy8gUmVjYWxjdWxhdGUgc2l6ZXMgb24gcmVzaXplIC8gb3JpZW50YXRpb25jaGFuZ2VcblxuICAgIGxpc3Rlbih3bmQwLCAnb3JpZW50YXRpb25jaGFuZ2UnLCBvblJlc2l6ZSk7XG4gICAgbGlzdGVuKHduZDAsICdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgbGlzdGVuKHduZDAsICdzY3JvbGwnLCBvblNjcm9sbEJvdHRvbSk7XG4gICAgbGlzdGVuKHduZDAsICd0b3VjaG1vdmUnLCBvblNjcm9sbEJvdHRvbSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pOyAvLyBJbml0IHN0YWdlcyBhbmQgYWN0aW9uc1xuICAgIC8vIC0tLVxuXG4gICAgc3RhZ2VOciA9IDA7XG4gICAgdHlwZXMgPSBzLml0ZW1Hcm91cHMgfHwge307XG4gICAgdHlwZXMuZGVmYXVsdHMgPSB7XG4gICAgICBzd2lwZWxlZnQ6IHMuc3dpcGVsZWZ0LFxuICAgICAgc3dpcGVyaWdodDogcy5zd2lwZXJpZ2h0LFxuICAgICAgc3RhZ2VzOiBzLnN0YWdlcyxcbiAgICAgIGFjdGlvbnM6IHMuYWN0aW9ucyxcbiAgICAgIGFjdGlvbnNXaWR0aDogcy5hY3Rpb25zV2lkdGgsXG4gICAgICBhY3Rpb25hYmxlOiBzLmFjdGlvbmFibGVcbiAgICB9O1xuICAgIGluaXRCcmFuY2goZWxtKTtcbiAgICAkJDEuZWFjaCh0eXBlcywgZnVuY3Rpb24gKG4sIHYpIHtcbiAgICAgIHYuc3dpcGUgPSB2LnN3aXBlICE9PSB1bmRlZmluZWQgPyB2LnN3aXBlIDogcy5zd2lwZTtcbiAgICAgIHYuYWN0aW9uYWJsZSA9IHYuYWN0aW9uYWJsZSAhPT0gdW5kZWZpbmVkID8gdi5hY3Rpb25hYmxlIDogcy5hY3Rpb25hYmxlO1xuICAgICAgdi5zdGFnZXMgPSB2LnN0YWdlcyB8fCBbXTsgLy8gSW5pdCBzdGFnZXNcblxuICAgICAgcHJvY2Vzc1N0YWdlcyh2LnN0YWdlcywgMSwgdHJ1ZSk7XG4gICAgICBwcm9jZXNzU3RhZ2VzKHYuc3RhZ2VzLmxlZnQsIDEpO1xuICAgICAgcHJvY2Vzc1N0YWdlcyh2LnN0YWdlcy5yaWdodCwgLTEpO1xuXG4gICAgICBpZiAodi5zdGFnZXMubGVmdCB8fCB2LnN0YWdlcy5yaWdodCkge1xuICAgICAgICB2LnN0YWdlcyA9IFtdLmNvbmNhdCh2LnN0YWdlcy5sZWZ0IHx8IFtdLCB2LnN0YWdlcy5yaWdodCB8fCBbXSk7XG4gICAgICB9XG5cbiAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgIGlmICghdi5zdGFnZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh2LnN3aXBlbGVmdCkge1xuICAgICAgICAgIHYuc3RhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcGVyY2VudDogLTMwLFxuICAgICAgICAgICAgYWN0aW9uOiB2LnN3aXBlbGVmdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYuc3dpcGVyaWdodCkge1xuICAgICAgICAgIHYuc3RhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcGVyY2VudDogMzAsXG4gICAgICAgICAgICBhY3Rpb246IHYuc3dpcGVyaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQkMS5lYWNoKHYuc3RhZ2VzLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAvLyBmaW5kIHRoZSAwXG4gICAgICAgIGlmICh2LnBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICB2LnN0YWdlcy5wdXNoKHtcbiAgICAgICAgICBwZXJjZW50OiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2LnN0YWdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnBlcmNlbnQgLSBiLnBlcmNlbnQ7XG4gICAgICB9KTtcbiAgICAgICQkMS5lYWNoKHYuc3RhZ2VzLCBmdW5jdGlvbiAoaSwgcykge1xuICAgICAgICAvLyBmaW5kIHRoZSAwXG4gICAgICAgIGlmIChzLnBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICB2LnN0YXJ0ID0gaTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgdi5sZWZ0ID0gdi5yaWdodCA9IHYuc3RhZ2VzW3Yuc3RhcnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi5sZWZ0ID0gdi5zdGFnZXNbdi5zdGFydCAtIDFdIHx8IHt9O1xuICAgICAgICB2LnJpZ2h0ID0gdi5zdGFnZXNbdi5zdGFydCArIDFdIHx8IHt9O1xuICAgICAgfSAvLyBJbml0IGFjdGlvbnNcblxuXG4gICAgICBpZiAodi5hY3Rpb25zKSB7XG4gICAgICAgIHYubGVmdE1lbnUgPSB2LmFjdGlvbnMubGVmdCB8fCB2LmFjdGlvbnM7XG4gICAgICAgIHYucmlnaHRNZW51ID0gdi5hY3Rpb25zLnJpZ2h0IHx8IHYubGVmdE1lbnU7XG4gICAgICAgIGljb25zTGVmdCA9ICcnO1xuICAgICAgICBpY29uc1JpZ2h0ID0gJyc7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYubGVmdE1lbnUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpY29uc0xlZnQgKz0gJzxkaXYgJyArICh2LmxlZnRNZW51W2ldLmNvbG9yID8gJ3N0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogJyArIHYubGVmdE1lbnVbaV0uY29sb3IgKyAnXCInIDogJycpICsgJyBjbGFzcz1cIm1ic2MtbHYtaWMtbSBtYnNjLWx2LWljIG1ic2MtaWMgbWJzYy1pYy0nICsgdi5sZWZ0TWVudVtpXS5pY29uICsgJ1wiPicgKyAodi5sZWZ0TWVudVtpXS50ZXh0IHx8ICcnKSArICc8L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYucmlnaHRNZW51Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWNvbnNSaWdodCArPSAnPGRpdiAnICsgKHYucmlnaHRNZW51W2ldLmNvbG9yID8gJ3N0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogJyArIHYucmlnaHRNZW51W2ldLmNvbG9yICsgJ1wiJyA6ICcnKSArICcgY2xhc3M9XCJtYnNjLWx2LWljLW0gbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtJyArIHYucmlnaHRNZW51W2ldLmljb24gKyAnXCI+JyArICh2LnJpZ2h0TWVudVtpXS50ZXh0IHx8ICcnKSArICc8L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYuYWN0aW9ucy5sZWZ0KSB7XG4gICAgICAgICAgdi5zd2lwZSA9IHYuYWN0aW9ucy5yaWdodCA/IHYuc3dpcGUgOiAncmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYuYWN0aW9ucy5yaWdodCkge1xuICAgICAgICAgIHYuc3dpcGUgPSB2LmFjdGlvbnMubGVmdCA/IHYuc3dpcGUgOiAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICB2Lmljb25zID0gJzxkaXYgY2xhc3M9XCJtYnNjLWx2LW11bHRpIG1ic2MtbHYtbXVsdGktaWMtbGVmdFwiPicgKyBpY29uc0xlZnQgKyAnPC9kaXY+PGRpdiBjbGFzcz1cIm1ic2MtbHYtbXVsdGkgbWJzYy1sdi1tdWx0aS1pYy1yaWdodFwiPicgKyBpY29uc1JpZ2h0ICsgJzwvZGl2Pic7XG4gICAgICB9XG4gICAgfSk7IC8vIC0tLVxuICAgIC8vIEluaXQgZml4ZWQgaGVhZGVyXG4gICAgLy8gLS0tXG5cbiAgICBpZiAocy5maXhlZEhlYWRlcikge1xuICAgICAgaGVhZGVyQ2xhc3MgPSAnbWJzYy1sdi1maXhlZC1oZWFkZXInICsgKGhhc0NvbnRleHQgPyAnIG1ic2MtbHYtZml4ZWQtaGVhZGVyLWN0eCBtYnNjLWx2LScgKyBzLnRoZW1lICsgJyBtYnNjLScgKyBzLnRoZW1lICsgKHMuYmFzZVRoZW1lID8gJyBtYnNjLWx2LScgKyBzLmJhc2VUaGVtZSArICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgOiAnJyk7XG5cbiAgICAgIGlmICghZ3JvdXBIZWFkZXIpIHtcbiAgICAgICAgZ3JvdXBIZWFkZXIgPSAkJDEoJzxkaXYgY2xhc3M9XCInICsgaGVhZGVyQ2xhc3MgKyAnXCI+PC9kaXY+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cEhlYWRlci5hdHRyKCdjbGFzcycsIGhlYWRlckNsYXNzKTtcbiAgICAgICAgb25TY3JvbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgd25kLmJlZm9yZShncm91cEhlYWRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250LnByZXBlbmQoZ3JvdXBIZWFkZXIpO1xuICAgICAgfVxuXG4gICAgICBvblNjcm9sbFRocm90dGxlID0gdGhyb3R0bGUob25TY3JvbGwsIDIwMCk7XG4gICAgICBsaXN0ZW4od25kMCwgJ3Njcm9sbCcsIG9uU2Nyb2xsVGhyb3R0bGUpO1xuICAgICAgbGlzdGVuKHduZDAsICd0b3VjaG1vdmUnLCBvblNjcm9sbFRocm90dGxlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gLy8gLS0tXG5cblxuICAgIGlmIChzLmhvdmVyKSB7XG4gICAgICBpZiAoIWhvdmVyVGltZSkge1xuICAgICAgICBjb250Lm9uKCdtb3VzZW92ZXIubWJzYy1sdicsICcubWJzYy1sdi1pdGVtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaG92ZXJJdGVtIHx8IGhvdmVySXRlbVswXSAhPSB0aGlzKSB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUoKTtcbiAgICAgICAgICAgIGhvdmVySXRlbSA9ICQkMSh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzW2hvdmVySXRlbS5hdHRyKCdkYXRhLXR5cGUnKSB8fCAnZGVmYXVsdHMnXS5hY3Rpb25zKSB7XG4gICAgICAgICAgICAgIGhvdmVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRIb3Zlcikge1xuICAgICAgICAgICAgICAgICAgaG92ZXJJdGVtT3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHRoYXQub3BlbkFjdGlvbnMoaG92ZXJJdGVtLCBob3ZlckRpciwgaG92ZXJUaW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGhvdmVySXRlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ21vdXNlbGVhdmUubWJzYy1sdicsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9XG5cbiAgICAgIGhvdmVyVGltZSA9IHMuaG92ZXIudGltZSB8fCAyMDA7XG4gICAgICBob3ZlclRpbWVvdXQgPSBzLmhvdmVyLnRpbWVvdXQgfHwgMjAwO1xuICAgICAgaG92ZXJEaXIgPSBzLmhvdmVyLmRpcmVjdGlvbiB8fCBzLmhvdmVyIHx8ICdyaWdodCc7XG4gICAgfVxuXG4gICAgaWYgKGhhZEVuaGFuY2UpIHtcbiAgICAgIGNvbnQuYXR0cignbWJzYy1lbmhhbmNlJywgJycpO1xuICAgIH1cblxuICAgIGNvbnQudHJpZ2dlcignbWJzYy1lbmhhbmNlJywgW3tcbiAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgbGFuZzogcy5sYW5nXG4gICAgfV0pO1xuICB9O1xuICAvKipcbiAgICogTGlzdHZpZXcgZGVzdHJveTogcmVtb3ZlcyBldmVudCBoYW5kbGVycywgY2xhc3NlcyBhbmQgYWRkaXRpb25hbCBtYXJrdXAuXG4gICAqL1xuXG5cbiAgdGhhdC5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9ybTtcbiAgICBjdXJyUGFyZW50LmFwcGVuZChjdXJyTGlzdCk7XG5cbiAgICBpZiAoaGFzQ29udGV4dCAmJiBncm91cEhlYWRlcikge1xuICAgICAgZ3JvdXBIZWFkZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhZEVuaGFuY2UpIHtcbiAgICAgIGVsbS5hdHRyKCdtYnNjLWVuaGFuY2UnLCAnJyk7IC8vIERlc3Ryb3kgZm9ybSBpbnN0YW5jZSBpZiBhbnlcblxuICAgICAgZm9ybSA9IGluc3RhbmNlc1tjb250MC5pZF07XG5cbiAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgIGZvcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uSWNvblN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHVubGlzdGVuKGUsICdjbGljaycsIG9uTGlzdENsaWNrLCB0cnVlKTtcbiAgICBjb250LmZpbmQoJy5tYnNjLWx2LXR4dCwubWJzYy1sdi1pbWcnKS5yZW1vdmVDbGFzcygnbWJzYy1sdi10eHQgbWJzYy1sdi1pbWcnKTtcbiAgICBjb250LmZpbmQobGlzdFNlbGVjdG9yKS5yZW1vdmVDbGFzcygnbWJzYy1sdiBtYnNjLWx2LXYgbWJzYy1sdi1yb290IG1ic2MtbHYtc2wtY3VycicpLmZpbmQoaXRlbVNlbGVjdG9yKS5yZW1vdmVDbGFzcygnbWJzYy1sdi1nci10aXRsZSBtYnNjLWx2LWl0ZW0gbWJzYy1sdi1pdGVtLWVuaGFuY2VkIG1ic2MtbHYtcGFyZW50IG1ic2MtbHYtaW1nLWxlZnQgbWJzYy1sdi1pbWctcmlnaHQgbWJzYy1sdi1pdGVtLWljLWxlZnQgbWJzYy1sdi1pdGVtLWljLXJpZ2h0JykucmVtb3ZlQXR0cignZGF0YS1yZWYnKTtcbiAgICAkJDEoJy5tYnNjLWx2LWJhY2ssLm1ic2MtbHYtaGFuZGxlLWMsLm1ic2MtbHYtYXJyLC5tYnNjLWx2LWl0ZW0taWMnLCBjb250KS5yZW1vdmUoKTtcbiAgICBlbG0uaW5zZXJ0QWZ0ZXIoY29udCk7XG4gICAgY29udC5yZW1vdmUoKTtcbiAgICBzdGFnZWMucmVtb3ZlKCk7XG4gICAgdW5saXN0ZW4od25kMCwgJ29yaWVudGF0aW9uY2hhbmdlJywgb25SZXNpemUpO1xuICAgIHVubGlzdGVuKHduZDAsICdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgdW5saXN0ZW4od25kMCwgJ3Njcm9sbCcsIG9uU2Nyb2xsQm90dG9tKTtcbiAgICB1bmxpc3Rlbih3bmQwLCAndG91Y2htb3ZlJywgb25TY3JvbGxCb3R0b20sIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChvblNjcm9sbFRocm90dGxlKSB7XG4gICAgICB1bmxpc3Rlbih3bmQwLCAnc2Nyb2xsJywgb25TY3JvbGxUaHJvdHRsZSk7XG4gICAgICB1bmxpc3Rlbih3bmQwLCAndG91Y2htb3ZlJywgb25TY3JvbGxUaHJvdHRsZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIFVuZG8gbWFuYWdlciwgbWF5IGJlIHJlbW92ZWQgbGF0ZXIgaW4gc2VwYXJhdGUgY2xhc3NcbiAgLy8gLS0tXG5cblxuICB2YXIgdW5kb2luZyxcbiAgICAgIHVuZG9RdWV1ZSA9IFtdLFxuICAgICAgdW5kb1N0YWNrID0gW10sXG4gICAgICB1bmRvR3JvdXAgPSBbXSxcbiAgICAgIHVuZG9MaXN0ZW5lciA9IDA7XG5cbiAgdGhhdC5zdGFydEFjdGlvblRyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0YXJ0IGEgbmV3IHVuZG8gZ3JvdXAgaWYgbm90IHJ1bm5pbmdcbiAgICBpZiAoIXVuZG9MaXN0ZW5lcikge1xuICAgICAgdW5kb0dyb3VwID0gW107XG4gICAgfVxuXG4gICAgdW5kb0xpc3RlbmVyKys7XG4gIH07XG5cbiAgdGhhdC5lbmRBY3Rpb25UcmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBFbmQgdW5kbyBncm91cCwgaWYgdGhpcyB0aGUgb3V0ZXJtb3N0IGxpc3RlbmVyICh1bmRvTGlzdGVuZXIgY291bnRlciBpcyAwKTtcbiAgICB1bmRvTGlzdGVuZXItLTtcblxuICAgIGlmICghdW5kb0xpc3RlbmVyKSB7XG4gICAgICB1bmRvU3RhY2sucHVzaCh1bmRvR3JvdXApO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LmFkZFVuZG9BY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCBhc3luYykge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGFzeW5jOiBhc3luY1xuICAgIH07IC8vaWYgKCF1bmRvaW5nKSB7XG5cbiAgICBpZiAodW5kb0xpc3RlbmVyKSB7XG4gICAgICAvLyBBZGQgdW5kbyBhY3Rpb24gaW4gY3VycmVudCBncm91cCwgaWYgYSBsaXN0ZW5lciBpcyBydW5uaW5nXG4gICAgICB1bmRvR3JvdXAucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgdW5kbyBhY3Rpb24gd2l0aGluIGEgbmV3IGdyb3VwXG4gICAgICB1bmRvU3RhY2sucHVzaChbb2JqXSk7XG5cbiAgICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID4gcy51bmRvTGltaXQpIHtcbiAgICAgICAgdW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfSAvL31cblxuICB9O1xuXG4gIHRoYXQudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9uLCBpLCBncm91cDtcblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICB1bmRvaW5nID0gZmFsc2U7IC8vIElmIHRoZXJlIGlzIGRhdGEgaW4gdGhlIHF1ZXVlLCBrZWVwIGNhbGxpbmcgdGhlIHVuZG9cblxuICAgICAgICB1bmRvKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb24gPSBncm91cFtpXTtcbiAgICAgICAgaS0tO1xuXG4gICAgICAgIGlmIChhY3Rpb24uYXN5bmMpIHtcbiAgICAgICAgICAvLyBSdW4gYWN0aW9uLCBuZXh0IGFjdGlvbiBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgdGhlIGFjdGlvblxuICAgICAgICAgIGFjdGlvbi5hY3Rpb24ocnVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSdW4gYWN0aW9uXG4gICAgICAgICAgYWN0aW9uLmFjdGlvbigpOyAvLyBSdW4gbmV4dCBhY3Rpb25cblxuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgIGdyb3VwID0gdW5kb1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICB1bmRvaW5nID0gdHJ1ZTtcbiAgICAgICAgaSA9IGdyb3VwLmxlbmd0aCAtIDE7IC8vIENhbGwgYWN0aW9ucyBmcm9tIHRoZSBncm91cCByZWNvdXJzaXZlbHlcblxuICAgICAgICBydW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCkge1xuICAgICAgdW5kb1F1ZXVlLnB1c2godW5kb1N0YWNrLnBvcCgpKTtcbiAgICB9IC8vIElmIHVuZG8gaXMgY3VycmVudGx5IHJ1bm5pbmcsIGRvbid0IGRvIGFueXRoaW5nIChpdCB3aWxsIGJlIGNhbGxlZCBsYXRlciBmcm9tIHF1ZXVlKVxuXG5cbiAgICBpZiAoIXVuZG9pbmcpIHtcbiAgICAgIHVuZG8oKTtcbiAgICB9XG4gIH07IC8vIC0tLVxuICAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gIGV2ZW50ID0gdGhhdC50cmlnZ2VyO1xuICB0aGF0LmluaXQoKTtcbn07IC8vIERlZmF1bHRzXG5cbkxpc3RWaWV3LnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnbGlzdHZpZXcnLFxuICBfaGFzRGVmOiB0cnVlLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfZGVmYXVsdHM6IHtcbiAgICBjb250ZXh0OiAnYm9keScsXG4gICAgYWN0aW9uc1dpZHRoOiA5MCxcbiAgICBzb3J0RGVsYXk6IDI1MCxcbiAgICB1bmRvTGltaXQ6IDEwLFxuICAgIHRhcDogaGFzR2hvc3RDbGljayxcbiAgICBzd2lwZTogdHJ1ZSxcbiAgICBxdWlja1N3aXBlOiB0cnVlLFxuICAgIGFuaW1hdGVBZGRSZW1vdmU6IHRydWUsXG4gICAgYW5pbWF0ZUljb25zOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICByZXZlcnQ6IHRydWUsXG4gICAgdmlicmF0ZTogdHJ1ZSxcbiAgICBhY3Rpb25hYmxlOiB0cnVlLFxuICAgIGhhbmRsZUNsYXNzOiAnJyxcbiAgICBoYW5kbGVNYXJrdXA6ICc8ZGl2IGNsYXNzPVwibWJzYy1sdi1oYW5kbGUtYmFyIG1ic2MtbHYtaGFuZGxlXCI+PC9kaXY+PGRpdiBjbGFzcz1cIm1ic2MtbHYtaGFuZGxlLWJhciBtYnNjLWx2LWhhbmRsZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWx2LWhhbmRsZS1iYXIgbWJzYy1sdi1oYW5kbGVcIj48L2Rpdj4nLFxuICAgIGxpc3ROb2RlOiAndWwnLFxuICAgIGxpc3RTZWxlY3RvcjogJ3VsLG9sJyxcbiAgICBpdGVtTm9kZTogJ2xpJyxcbiAgICBpdGVtU2VsZWN0b3I6ICdsaScsXG4gICAgbGVmdEFycm93Q2xhc3M6ICdtYnNjLWljLWFycm93LWxlZnQ0JyxcbiAgICByaWdodEFycm93Q2xhc3M6ICdtYnNjLWljLWFycm93LXJpZ2h0NCcsXG4gICAgYmFja1RleHQ6ICdCYWNrJyxcbiAgICB1bmRvVGV4dDogJ1VuZG8nLFxuICAgIHN0YWdlczogW10sXG4gICAgc2VsZWN0OiAnb2ZmJ1xuICB9XG59O1xuY2xhc3Nlcy5MaXN0VmlldyA9IExpc3RWaWV3O1xubW9iaXNjcm9sbC50aGVtZXMubGlzdHZpZXcubW9iaXNjcm9sbCA9IHtcbiAgbGVmdEFycm93Q2xhc3M6ICdtYnNjLWljLWFycm93LWxlZnQ1JyxcbiAgcmlnaHRBcnJvd0NsYXNzOiAnbWJzYy1pYy1hcnJvdy1yaWdodDUnXG59O1xuXG52YXIgTWJzY0xpc3R2aWV3U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0xpc3R2aWV3U2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5hZGRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jYXJkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5pbnN0ID0gbnVsbDtcbiAgICB9XG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUubm90aWZ5SW5zdGFuY2VSZWFkeSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmluc3QgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZU9ic2VydmFibGUubmV4dChpbnN0YW5jZSk7XG4gICAgfTtcbiAgICBNYnNjTGlzdHZpZXdTZXJ2aWNlLnByb3RvdHlwZS5vbkluc3RhbmNlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlT2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UucHJvdG90eXBlLm5vdGlmeUFkZGVkID0gZnVuY3Rpb24gKGl0ZW0sIHBhcmVudCkge1xuICAgICAgICB0aGlzLmFkZE9ic2VydmFibGUubmV4dCh7IGl0ZW06IGl0ZW0sIHBhcmVudDogcGFyZW50IH0pO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUubm90aWZ5UmVtb3ZlZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlT2JzZXJ2YWJsZS5uZXh0KGl0ZW0pO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUubm90aWZ5Q2FyZFByZXNlbmNlID0gZnVuY3Rpb24gKGlzQ2FyZCkge1xuICAgICAgICB0aGlzLmNhcmRPYnNlcnZhYmxlLm5leHQoaXNDYXJkKTtcbiAgICB9O1xuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UucHJvdG90eXBlLm9uQ2FyZENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcmRPYnNlcnZhYmxlO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUub25JdGVtQWRkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE9ic2VydmFibGU7XG4gICAgfTtcbiAgICBNYnNjTGlzdHZpZXdTZXJ2aWNlLnByb3RvdHlwZS5vbkl0ZW1SZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVPYnNlcnZhYmxlO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0xpc3R2aWV3U2VydmljZTtcbn0oKSk7XG52YXIgTWJzY1N1Ymxpc3RTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjU3VibGlzdFNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlT2JzZXJhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICB9XG4gICAgTWJzY1N1Ymxpc3RTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlBZGRlZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2YWJsZS5uZXh0KGl0ZW0pO1xuICAgIH07XG4gICAgTWJzY1N1Ymxpc3RTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlSZW1vdmVkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPYnNlcmFibGUubmV4dChpdGVtKTtcbiAgICB9O1xuICAgIE1ic2NTdWJsaXN0U2VydmljZS5wcm90b3R5cGUub25JdGVtQWRkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE9ic2VydmFibGU7XG4gICAgfTtcbiAgICBNYnNjU3VibGlzdFNlcnZpY2UucHJvdG90eXBlLm9uSXRlbVJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU9ic2VyYWJsZTtcbiAgICB9O1xuICAgIE1ic2NTdWJsaXN0U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIE1ic2NTdWJsaXN0U2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjU3VibGlzdFNlcnZpY2U7XG59KCkpO1xudmFyIE1ic2NMaXN0aXRlbVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NMaXN0aXRlbVNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuc3VibGlzdFN1YmplY3QgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmluc3QgPSBudWxsO1xuICAgIH1cbiAgICBNYnNjTGlzdGl0ZW1TZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlTdWJsaXN0Q3JlYXRlZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuc3VibGlzdFN1YmplY3QubmV4dChpdGVtKTtcbiAgICB9O1xuICAgIE1ic2NMaXN0aXRlbVNlcnZpY2UucHJvdG90eXBlLm9uU3VibGlzdENyZWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ymxpc3RTdWJqZWN0O1xuICAgIH07XG4gICAgTWJzY0xpc3RpdGVtU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIE1ic2NMaXN0aXRlbVNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0xpc3RpdGVtU2VydmljZTtcbn0oKSk7XG52YXIgTWJzY0xpc3R2aWV3U3VibGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0xpc3R2aWV3U3VibGlzdChwYXJlbnRTZXJ2LCBzdWJTZXJ2LCBpdGVtU2VydmljZSkge1xuICAgICAgICB0aGlzLnBhcmVudFNlcnYgPSBwYXJlbnRTZXJ2O1xuICAgICAgICB0aGlzLnN1YlNlcnYgPSBzdWJTZXJ2O1xuICAgICAgICB0aGlzLml0ZW1TZXJ2aWNlID0gaXRlbVNlcnZpY2U7XG4gICAgfVxuICAgIE1ic2NMaXN0dmlld1N1Ymxpc3QucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLml0ZW1TZXJ2aWNlLm5vdGlmeVN1Ymxpc3RDcmVhdGVkKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3U3VibGlzdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWxpc3R2aWV3LXN1Ymxpc3QnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjU3VibGlzdFNlcnZpY2VdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTGlzdHZpZXdTdWJsaXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IE1ic2NMaXN0dmlld1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY1N1Ymxpc3RTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NMaXN0aXRlbVNlcnZpY2UsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY0xpc3R2aWV3U3VibGlzdDtcbn0oKSk7XG52YXIgTWJzY0xpc3R2aWV3SXRlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0xpc3R2aWV3SXRlbShlbGVtLCBsdlNlcnZpY2UsIGx2SXRlbVNlcnZpY2UsIHN1YlNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5sdlNlcnZpY2UgPSBsdlNlcnZpY2U7XG4gICAgICAgIHRoaXMubHZJdGVtU2VydmljZSA9IGx2SXRlbVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc3ViU2VydmljZSA9IHN1YlNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2xvbmUgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdWJpdGVtT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN1Ymxpc3RPYnNlcnZlciA9IGx2SXRlbVNlcnZpY2Uub25TdWJsaXN0Q3JlYXRlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoc3VibGlzdCkge1xuICAgICAgICAgICAgX3RoaXMuaXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuc3VibGlzdCA9IHN1Ymxpc3Q7XG4gICAgICAgICAgICBfdGhpcy5zdWJpdGVtT2JzZXJ2ZXIgPSBzdWJsaXN0LnN1YlNlcnYub25JdGVtQWRkZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN1Ykl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sdlNlcnZpY2Uubm90aWZ5QWRkZWQoc3ViSXRlbSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZU9ic2VydmVyID0gdGhpcy5sdlNlcnZpY2Uub25JbnN0YW5jZVJlYWR5KCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgX3RoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobHZTZXJ2aWNlLmluc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbHZTZXJ2aWNlLmluc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLCBcIkluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0VsZW0gPSAkJDEodGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpc0VsZW0ucGFyZW50KCkuY2hpbGRyZW4oJ21ic2MtbGlzdHZpZXctaXRlbSwgbWJzYy1saXN0dmlldy1oZWFkZXInKS5ub3QoJy5tYnNjLWx2LWJhY2snKS5pbmRleCh0aGlzRWxlbSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJFbGVtZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSB8fCAkJDEodGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YlNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc3ViU2VydmljZS5ub3RpZnlBZGRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubHZTZXJ2aWNlLm5vdGlmeUFkZGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sdkl0ZW1TZXJ2aWNlLm9uU3VibGlzdENyZWF0ZWQoKS51bnN1YnNjcmliZSh0aGlzLnN1Ymxpc3RPYnNlcnZlcik7XG4gICAgICAgIHRoaXMubHZTZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnVuc3Vic2NyaWJlKHRoaXMuaW5zdGFuY2VPYnNlcnZlcik7XG4gICAgICAgIGlmICh0aGlzLnN1Yml0ZW1PYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdWJsaXN0LnN1YlNlcnYub25JdGVtQWRkZWQoKS51bnN1YnNjcmliZSh0aGlzLnN1Yml0ZW1PYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLnN1Ymxpc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkZWxtID0gdGhpcy5FbGVtZW50LCAkY2xvbmUgPSAkZWxtLmNsb25lKCk7XG4gICAgICAgIGlmICgkZWxtLnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgJGNsb25lLmluc2VydEJlZm9yZSgkZWxtKTtcbiAgICAgICAgICAgIHRoaXMuY2xvbmUgPSAkY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3ViU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJTZXJ2aWNlLm5vdGlmeVJlbW92ZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmx2U2VydmljZS5ub3RpZnlSZW1vdmVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0xpc3R2aWV3SXRlbS5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNlbGVjdCh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5kZXNlbGVjdCh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gIXRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fc2VsZWN0ZWQpO1xuICAgIH07XG4gICAgTWJzY0xpc3R2aWV3SXRlbS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWxpc3R2aWV3LWl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTGlzdGl0ZW1TZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWljb25dJzogJ2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWNvbi1hbGlnbl0nOiAnaWNvbkFsaWduJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS10eXBlXSc6ICd0eXBlJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTGlzdHZpZXdJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0xpc3R2aWV3U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTGlzdGl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NTdWJsaXN0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTGlzdHZpZXdJdGVtLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ljb24nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICd0eXBlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzZWxlY3RlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2VsZWN0ZWRDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld0l0ZW07XG59KCkpO1xudmFyIE1ic2NMaXN0dmlld0hlYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NMaXN0dmlld0hlYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTGlzdHZpZXdIZWFkZXIoZWxlbSwgbHZTZXJ2aWNlLCBpdGVtU2VydmljZSwgc3ViU2VydmljZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWxlbSwgbHZTZXJ2aWNlLCBpdGVtU2VydmljZSwgc3ViU2VydmljZSkgfHwgdGhpcztcbiAgICB9XG4gICAgTWJzY0xpc3R2aWV3SGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtbGlzdHZpZXctaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0xpc3RpdGVtU2VydmljZV0sXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWlkXSc6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1yb2xlJzogJ2xpc3QtZGl2aWRlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0xpc3R2aWV3SGVhZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0xpc3R2aWV3U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTGlzdGl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NTdWJsaXN0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY0xpc3R2aWV3SGVhZGVyO1xufShNYnNjTGlzdHZpZXdJdGVtKSk7XG52YXIgTWJzY0xpc3R2aWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0xpc3R2aWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NMaXN0dmlldyhlbGVtLCB6b25lLCBsdlNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZWxlbSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgIF90aGlzLmx2U2VydmljZSA9IGx2U2VydmljZTtcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLm9uSXRlbVRhcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25JdGVtQWRkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkl0ZW1SZW1vdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTGlzdEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25OYXZFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTmF2U3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU2xpZGVFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU2xpZGVTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25Tb3J0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblNvcnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU29ydFN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblNvcnRFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU29ydFVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25TdGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuY2FyZENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYWRkT2JzZXJ2ZXIgPSBsdlNlcnZpY2Uub25JdGVtQWRkZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdC5pdGVtLCBwYXJlbnQgPSB0LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLmFkZChudWxsLCBpdGVtLkVsZW1lbnQsIGl0ZW0uSW5kZXgsIHVuZGVmaW5lZCwgcGFyZW50ICYmIHBhcmVudC5FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnJlbW92ZU9ic2VydmVyID0gbHZTZXJ2aWNlLm9uSXRlbVJlbW92ZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlbW92ZShpdGVtLkVsZW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5jYXJkT2JzZXJ2ZXIgPSBsdlNlcnZpY2Uub25DYXJkQ29udGVudCgpLnN1YnNjcmliZShmdW5jdGlvbiAoaXNDYXJkKSB7XG4gICAgICAgICAgICBfdGhpcy5jYXJkQ29udGVudCA9IGlzQ2FyZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY0xpc3R2aWV3LnByb3RvdHlwZS50YXBIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdCB8fCAoaW5zdCAmJiBpbnN0LnNldHRpbmdzLnNlbGVjdCk7XG4gICAgICAgIHN3aXRjaCAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2dldEl0ZW0oZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5pc1BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2dldEl0ZW0oZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV2ZW50Lmluc3QgPSBpbnN0O1xuICAgICAgICB0aGlzLm9uSXRlbVRhcC5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIE1ic2NMaXN0dmlldy5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAobmF0aXZlRWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZWxlbS5uYXRpdmVFbGVtZW50ID09PSBuYXRpdmVFbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYnNjTGlzdHZpZXcucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb25JdGVtVGFwID0gdGhpcy50YXBIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBvbkl0ZW1UYXBVc2VyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5vbkl0ZW1UYXA7XG4gICAgICAgIGlmIChvbkl0ZW1UYXBVc2VyKSB7XG4gICAgICAgICAgICBvbkl0ZW1UYXAgPSBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50YXBIYW5kbGVyKGV2ZW50LCBpbnN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25JdGVtVGFwVXNlcihldmVudCwgaW5zdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe1xuICAgICAgICAgICAgbGlzdE5vZGU6ICdtYnNjLWxpc3R2aWV3JyxcbiAgICAgICAgICAgIGxpc3RTZWxlY3RvcjogJ21ic2MtbGlzdHZpZXcsIG1ic2MtbGlzdHZpZXctc3VibGlzdCcsXG4gICAgICAgICAgICBpdGVtTm9kZTogJ21ic2MtbGlzdHZpZXctaXRlbScsXG4gICAgICAgICAgICBpdGVtU2VsZWN0b3I6ICdtYnNjLWxpc3R2aWV3LWl0ZW0sIG1ic2MtbGlzdHZpZXctaGVhZGVyJ1xuICAgICAgICB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgeyBvbkl0ZW1UYXA6IG9uSXRlbVRhcCB9KTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBMaXN0Vmlldyh0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubHZTZXJ2aWNlLm5vdGlmeUluc3RhbmNlUmVhZHkodGhpcy5pbnN0YW5jZSk7XG4gICAgfTtcbiAgICBNYnNjTGlzdHZpZXcucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmx2U2VydmljZS5vbkNhcmRDb250ZW50KCkudW5zdWJzY3JpYmUodGhpcy5jYXJkT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLmx2U2VydmljZS5vbkl0ZW1BZGRlZCgpLnVuc3Vic2NyaWJlKHRoaXMuYWRkT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLmx2U2VydmljZS5vbkl0ZW1SZW1vdmVkKCkudW5zdWJzY3JpYmUodGhpcy5yZW1vdmVPYnNlcnZlcik7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NMaXN0dmlldy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWxpc3R2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTGlzdHZpZXdTZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21ic2MtY2xvYWsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWNhcmQtbGlzdF0nOiAnY2FyZENvbnRlbnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NMaXN0dmlldy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTGlzdHZpZXdTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTGlzdHZpZXcucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdhY3Rpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdhY3Rpb25zV2lkdGgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NvbnRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0cmlwZWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2FuaW1hdGVBZGRSZW1vdmUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2FjdGlvbmFibGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2FuaW1hdGVJY29ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZW5oYW5jZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZmlsbEFuaW1hdGlvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZml4ZWRIZWFkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2hvdmVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpY29uU2xpZGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2l0ZW1Hcm91cHMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2xvYWRpbmdJY29uJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICduYXZpZ2F0ZU9uRHJvcCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncXVpY2tTd2lwZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2VsZWN0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzb3J0YWJsZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc29ydERlbGF5JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGFnZXMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N3aXBlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzd2lwZWxlZnQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N3aXBlcmlnaHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZpYnJhdGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3VuZG9UZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdiYWNrVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25JdGVtVGFwJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uSXRlbUFkZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkl0ZW1SZW1vdmUnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25MaXN0RW5kJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uTmF2RW5kJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uTmF2U3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25TbGlkZUVuZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblNsaWRlU3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25Tb3J0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uU29ydENoYW5nZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblNvcnRTdGFydCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblNvcnRFbmQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25Tb3J0VXBkYXRlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uU3RhZ2VDaGFuZ2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICdpdGVtcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01ic2NMaXN0dmlld0l0ZW0sIHsgZGVzY2VuZGFudHM6IHRydWUgfSxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTGlzdHZpZXc7XG59KE1ic2NCYXNlKSk7XG52YXIgY29tcCA9IFtcbiAgICBNYnNjTGlzdHZpZXcsXG4gICAgTWJzY0xpc3R2aWV3SXRlbSxcbiAgICBNYnNjTGlzdHZpZXdIZWFkZXIsXG4gICAgTWJzY0xpc3R2aWV3U3VibGlzdFxuXTtcbnZhciBNYnNjTGlzdHZpZXdNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NMaXN0dmlld01vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY0xpc3R2aWV3TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNYnNjQmFzZU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogY29tcCxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogY29tcFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0xpc3R2aWV3TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld01vZHVsZTtcbn0oKSk7XG5cbnZhciBNYnNjQ2FyZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDYXJkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NDYXJkKGhvc3QsIG9wdGlvbnNTZXJ2aWNlLCBsdlNlcnZpY2UsIHpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdCwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uc1NlcnZpY2UgPSBvcHRpb25zU2VydmljZTtcbiAgICAgICAgX3RoaXMubHZTZXJ2aWNlID0gbHZTZXJ2aWNlO1xuICAgICAgICBfdGhpcy5fY29sbGFwc2libGVJbnB1dCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIGlmIChfdGhpcy5sdlNlcnZpY2UpIHtcbiAgICAgICAgICAgIF90aGlzLmx2U2VydmljZS5ub3RpZnlDYXJkUHJlc2VuY2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0NhcmQucHJvdG90eXBlLCBcImNvbGxhcHNpYmxlSW5wdXRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsYXBzaWJsZUlucHV0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuaW5saW5lT3B0aW9uc09iai5jb2xsYXBzaWJsZSA9IHRoaXMuX29wZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ2FyZC5wcm90b3R5cGUsIFwib3BlblwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVuICE9IHYgJiYgdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3BlbiA9ICEhdjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsYXBzaWJsZUlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVPcHRpb25zT2JqLmNvbGxhcHNpYmxlID0gdGhpcy5fb3BlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY0NhcmQucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvbnNTZXJ2aWNlID8gdGhpcy5vcHRpb25zU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDYXJkKHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBNYnNjQ2FyZC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1jYXJkXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDYXJkLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTGlzdHZpZXdTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ2FyZC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2NvbGxhcHNpYmxlSW5wdXQnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2NvbGxhcHNpYmxlJyxdIH0sXSxcbiAgICAgICAgJ29wZW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjQ2FyZDtcbn0oTWJzY0Jhc2UpKTtcbnZhciBNYnNjQ2FyZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDYXJkQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NDYXJkQ29tcG9uZW50KGhvc3QsIG9wdGlvbnNTZXJ2aWNlLCBsdlNlcnZpY2UsIHpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdCwgb3B0aW9uc1NlcnZpY2UsIGx2U2VydmljZSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uc1NlcnZpY2UgPSBvcHRpb25zU2VydmljZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQ2FyZENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhcmQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jayB9J11cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDYXJkQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTGlzdHZpZXdTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ2FyZENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjQ2FyZENvbXBvbmVudDtcbn0oTWJzY0NhcmQpKTtcbnZhciBNYnNjQ2FyZEhlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0NhcmRIZWFkZXIoKSB7XG4gICAgfVxuICAgIE1ic2NDYXJkSGVhZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2FyZC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLWhlYWRlcidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0NhcmRIZWFkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0NhcmRIZWFkZXI7XG59KCkpO1xudmFyIE1ic2NDYXJkQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0NhcmRDb250ZW50KCkge1xuICAgIH1cbiAgICBNYnNjQ2FyZENvbnRlbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1jYXJkLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLWNvbnRlbnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDYXJkQ29udGVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjQ2FyZENvbnRlbnQ7XG59KCkpO1xudmFyIE1ic2NDYXJkRm9vdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjQ2FyZEZvb3RlcigpIHtcbiAgICB9XG4gICAgTWJzY0NhcmRGb290ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1jYXJkLWZvb3RlcicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J10sXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYnNjLWNhcmQtZm9vdGVyJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FyZEZvb3Rlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjQ2FyZEZvb3Rlcjtcbn0oKSk7XG52YXIgTWJzY0NhcmRUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0NhcmRUaXRsZSgpIHtcbiAgICB9XG4gICAgTWJzY0NhcmRUaXRsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhcmQtdGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLXRpdGxlJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FyZFRpdGxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NDYXJkVGl0bGU7XG59KCkpO1xudmFyIE1ic2NDYXJkU3VidGl0bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NDYXJkU3VidGl0bGUoKSB7XG4gICAgfVxuICAgIE1ic2NDYXJkU3VidGl0bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1jYXJkLXN1YnRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2s7IH0nXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21ic2MtY2FyZC1zdWJ0aXRsZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0NhcmRTdWJ0aXRsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjQ2FyZFN1YnRpdGxlO1xufSgpKTtcbnZhciBjb21wJDEgPSBbXG4gICAgTWJzY0NhcmQsIE1ic2NDYXJkQ29tcG9uZW50LFxuICAgIE1ic2NDYXJkSGVhZGVyLCBNYnNjQ2FyZENvbnRlbnQsIE1ic2NDYXJkRm9vdGVyLFxuICAgIE1ic2NDYXJkVGl0bGUsIE1ic2NDYXJkU3VidGl0bGVcbl07XG52YXIgTWJzY0NhcmRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NDYXJkTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjQ2FyZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWJzY0Jhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXAkMSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogY29tcCQxXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ2FyZE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjQ2FyZE1vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogQ29udmVydCByZ2IgY29sb3IgdG8gaGV4XG4gKi9cblxuZnVuY3Rpb24gcmdiMmhleChyZ2IpIHtcbiAgdmFyIGhleCA9IFtNYXRoLnJvdW5kKHJnYi5yKS50b1N0cmluZygxNiksIE1hdGgucm91bmQocmdiLmcpLnRvU3RyaW5nKDE2KSwgTWF0aC5yb3VuZChyZ2IuYikudG9TdHJpbmcoMTYpXTtcbiAgJCQxLmVhY2goaGV4LCBmdW5jdGlvbiAobnIsIHZhbCkge1xuICAgIGlmICh2YWwubGVuZ3RoID09IDEpIHtcbiAgICAgIGhleFtucl0gPSAnMCcgKyB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICcjJyArIGhleC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydCBoZXggY29sb3IgdG8gcmdiXG4gKi9cblxuXG5mdW5jdGlvbiBoZXgycmdiKGhleCkge1xuICBoZXggPSBwYXJzZUludChoZXguaW5kZXhPZignIycpID4gLTEgPyBoZXguc3Vic3RyaW5nKDEpIDogaGV4LCAxNik7XG4gIHJldHVybiB7XG4gICAgcjogaGV4ID4+IDE2LFxuICAgIGc6IChoZXggJiAweDAwRkYwMCkgPj4gOCxcbiAgICBiOiBoZXggJiAweDAwMDBGRixcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5yICsgJywnICsgdGhpcy5nICsgJywnICsgdGhpcy5iICsgJyknO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ29udmVydCBoc3YgY29sb3IgdG8gcmdiXG4gKi9cblxuXG5mdW5jdGlvbiBoc3YycmdiKGhzdikge1xuICB2YXIgcixcbiAgICAgIGcsXG4gICAgICBiLFxuICAgICAgaCA9IGhzdi5oLFxuICAgICAgcyA9IGhzdi5zICogMjU1IC8gMTAwLFxuICAgICAgdiA9IGhzdi52ICogMjU1IC8gMTAwO1xuXG4gIGlmIChzID09PSAwKSB7XG4gICAgciA9IGcgPSBiID0gdjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdDEgPSB2LFxuICAgICAgICB0MiA9ICgyNTUgLSBzKSAqIHYgLyAyNTUsXG4gICAgICAgIHQzID0gKHQxIC0gdDIpICogKGggJSA2MCkgLyA2MDtcblxuICAgIGlmIChoID09IDM2MCkge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgciA9IHQxO1xuICAgICAgYiA9IHQyO1xuICAgICAgZyA9IHQyICsgdDM7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICBnID0gdDE7XG4gICAgICBiID0gdDI7XG4gICAgICByID0gdDEgLSB0MztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgIGcgPSB0MTtcbiAgICAgIHIgPSB0MjtcbiAgICAgIGIgPSB0MiArIHQzO1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgYiA9IHQxO1xuICAgICAgciA9IHQyO1xuICAgICAgZyA9IHQxIC0gdDM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICBiID0gdDE7XG4gICAgICBnID0gdDI7XG4gICAgICByID0gdDIgKyB0MztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgIHIgPSB0MTtcbiAgICAgIGcgPSB0MjtcbiAgICAgIGIgPSB0MSAtIHQzO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gZyA9IGIgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHRoaXMuciArICcsJyArIHRoaXMuZyArICcsJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIENvbnZlcnQgcmdiIGNvbG9yIHRvIGhzdlxuICovXG5cblxuZnVuY3Rpb24gcmdiMmhzdihyZ2IpIHtcbiAgdmFyIGggPSAwLFxuICAgICAgcyxcbiAgICAgIHYsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyZ2IuciwgcmdiLmcsIHJnYi5iKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHJnYi5yLCByZ2IuZywgcmdiLmIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW47XG4gIHYgPSBtYXg7XG4gIHMgPSBtYXggPyAyNTUgKiBkZWx0YSAvIG1heCA6IDA7XG5cbiAgaWYgKHMpIHtcbiAgICBpZiAocmdiLnIgPT0gbWF4KSB7XG4gICAgICBoID0gKHJnYi5nIC0gcmdiLmIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChyZ2IuZyA9PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKHJnYi5iIC0gcmdiLnIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSA0ICsgKHJnYi5yIC0gcmdiLmcpIC8gZGVsdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGggPSAtMTtcbiAgfVxuXG4gIGggKj0gNjA7XG5cbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cblxuICBzICo9IDEwMCAvIDI1NTtcbiAgdiAqPSAxMDAgLyAyNTU7XG4gIHJldHVybiB7XG4gICAgaDogaCxcbiAgICBzOiBzLFxuICAgIHY6IHYsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdoc3YoJyArIE1hdGgucm91bmQodGhpcy5oKSArICcsJyArIE1hdGgucm91bmQodGhpcy5zKSArICclLCcgKyBNYXRoLnJvdW5kKHRoaXMudikgKyAnJSknO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogQ29udmVydCByZ2IgY29sb3IgdG8gaHNsXG4gKi9cblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYi5yIC8gMjU1LFxuICAgICAgZyA9IHJnYi5nIC8gMjU1LFxuICAgICAgYiA9IHJnYi5iIC8gMjU1LFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDIsXG4gICAgICBoLFxuICAgICAgcztcblxuICBpZiAobWF4ID09IG1pbikge1xuICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICB9IGVsc2Uge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaCAvPSA2O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoOiBNYXRoLnJvdW5kKGggKiAzNjApLFxuICAgIHM6IE1hdGgucm91bmQocyAqIDEwMCksXG4gICAgbDogTWF0aC5yb3VuZChsICogMTAwKSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2hzbCgnICsgdGhpcy5oICsgJywnICsgdGhpcy5zICsgJyUsJyArIHRoaXMubCArICclKSc7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGhzbCBjb2xvciB0byByZ2JcbiAqL1xuXG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBtLFxuICAgICAgYyxcbiAgICAgIHgsXG4gICAgICBoID0gaHNsLmgsXG4gICAgICBzID0gaHNsLnMsXG4gICAgICBsID0gaHNsLmw7XG5cbiAgaWYgKCFpc0Zpbml0ZShoKSkge1xuICAgIGggPSAwO1xuICB9XG5cbiAgaWYgKCFpc0Zpbml0ZShzKSkge1xuICAgIHMgPSAwO1xuICB9XG5cbiAgaWYgKCFpc0Zpbml0ZShsKSkge1xuICAgIGwgPSAwO1xuICB9XG5cbiAgaCAvPSA2MDtcblxuICBpZiAoaCA8IDApIHtcbiAgICBoID0gNiAtIC1oICUgNjtcbiAgfVxuXG4gIGggJT0gNjtcbiAgcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHMgLyAxMDApKTtcbiAgbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGwgLyAxMDApKTtcbiAgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICB4ID0gYyAqICgxIC0gTWF0aC5hYnMoaCAlIDIgLSAxKSk7XG5cbiAgaWYgKGggPCAxKSB7XG4gICAgciA9IGM7XG4gICAgZyA9IHg7XG4gICAgYiA9IDA7XG4gIH0gZWxzZSBpZiAoaCA8IDIpIHtcbiAgICByID0geDtcbiAgICBnID0gYztcbiAgICBiID0gMDtcbiAgfSBlbHNlIGlmIChoIDwgMykge1xuICAgIHIgPSAwO1xuICAgIGcgPSBjO1xuICAgIGIgPSB4O1xuICB9IGVsc2UgaWYgKGggPCA0KSB7XG4gICAgciA9IDA7XG4gICAgZyA9IHg7XG4gICAgYiA9IGM7XG4gIH0gZWxzZSBpZiAoaCA8IDUpIHtcbiAgICByID0geDtcbiAgICBnID0gMDtcbiAgICBiID0gYztcbiAgfSBlbHNlIHtcbiAgICByID0gYztcbiAgICBnID0gMDtcbiAgICBiID0geDtcbiAgfVxuXG4gIG0gPSBsIC0gYyAvIDI7XG4gIHJldHVybiB7XG4gICAgcjogTWF0aC5yb3VuZCgociArIG0pICogMjU1KSxcbiAgICBnOiBNYXRoLnJvdW5kKChnICsgbSkgKiAyNTUpLFxuICAgIGI6IE1hdGgucm91bmQoKGIgKyBtKSAqIDI1NSksXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHRoaXMuciArICcsJyArIHRoaXMuZyArICcsJyArIHRoaXMuYiArICcpJztcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHRvIGhzbFxuICovXG5cblxuZnVuY3Rpb24gaGV4MmhzbChoZXgpIHtcbiAgcmV0dXJuIHJnYjJoc2woaGV4MnJnYihoZXgpKTtcbn1cbi8qKlxuICogQ29udmVydCBoc2wgY29sb3IgdG8gaGV4XG4gKi9cblxuXG5mdW5jdGlvbiBoc2wyaGV4KGhzbCkge1xuICByZXR1cm4gcmdiMmhleChoc2wycmdiKGhzbCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhzdiBjb2xvciB0byBoZXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGhzdjJoZXgoaHN2KSB7XG4gIHJldHVybiByZ2IyaGV4KGhzdjJyZ2IoaHN2KSk7XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHRvIGhzdlxuICovXG5cblxuZnVuY3Rpb24gaGV4MmhzdihoZXgpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaGV4MnJnYihoZXgpKTtcbn1cblxudmFyIENvbG9yID0gZnVuY3Rpb24gQ29sb3IoZWwsIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciBzLFxuICAgICAgZGVmLFxuICAgICAgdGVtcENvbG9ycyxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBzY3JvbGxWaWV3LFxuICAgICAgcHJldmlld1Njcm9sbFZpZXcsXG4gICAgICBoYXNDbGVhcixcbiAgICAgIGN1cnJWYWx1ZSxcbiAgICAgIGN1cnJIc2xWYWx1ZSxcbiAgICAgIGlzSG9yaXpvbnRhbFNjcm9sbCxcbiAgICAgIGhhc1ByZXZpZXcsXG4gICAgICBzbGlkZXJUcmFjayxcbiAgICAgIHJlZmluZU1vZGUsXG4gICAgICByb3dJdGVtcyxcbiAgICAgIHNsaWRlcixcbiAgICAgIGNvbG9ySW5kZXgsXG4gICAgICBlbmhhbmNlSW5wdXQsXG4gICAgICBzaW5nbGVTZWxlY3QsXG4gICAgICBtYXhTZWxlY3QsXG4gICAgICByZXR1cm5PYmosXG4gICAgICAkaW5wdXQsXG4gICAgICAkY29sb3JJdGVtcyxcbiAgICAgICRjb2xvclByZXZpZXdJdGVtcyxcbiAgICAgICRjdXJySXRlbSxcbiAgICAgICRzbGlkZXJFbG0sXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWwpLFxuICAgICAgY29sb3JQcmV2aWV3SW5kID0gMCxcbiAgICAgIHByZXZpZXdWYWx1ZXMgPSB7fSxcbiAgICAgIHRlbXBQcmV2aWV3VmFsdWVzID0ge307XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWUoZmlsbCwgY2hhbmdlLCB0ZW1wKSB7XG4gICAgaWYgKCF0ZW1wKSB7XG4gICAgICB0aGF0Ll92YWx1ZSA9IHRoYXQuX2hhc1ZhbHVlID8gdGhhdC5fdGVtcFZhbHVlLnNsaWNlKDApIDogbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wQ29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0ZW1wQ29sb3JzW2ldLnRlbXBDaGFuZ2VkQ29sb3IgJiYgdGhhdC5fdmFsdWUgJiYgdGhhdC5fdmFsdWUuaW5kZXhPZih0ZW1wQ29sb3JzW2ldLnRlbXBDaGFuZ2VkQ29sb3IpICE9IC0xKSB7XG4gICAgICAgICAgLy8gc2V0IGNoYW5nZWQgY29sb3IgaWYgd2FzIHNldFxuICAgICAgICAgIHRlbXBDb2xvcnNbaV0uY2hhbmdlZENvbG9yID0gdGVtcENvbG9yc1tpXS50ZW1wQ2hhbmdlZENvbG9yO1xuICAgICAgICB9IC8vIGVsc2UgaWYgKHRlbXBDb2xvcnNbaV0uY2hhbmdlZENvbG9yICYmIHRoYXQuX3ZhbHVlLmluZGV4T2YodGVtcENvbG9yc1tpXS5jaGFuZ2VkQ29sb3IpID09IC0xKSB7IC8vIGRlbGV0ZSBjaGFuZ2VkIGNvbG9yIGlmIHdhcyB1bnNldFxuICAgICAgICAvLyAgICBkZWxldGUgdGVtcENvbG9yc1tpXS5jaGFuZ2VkQ29sb3I7XG4gICAgICAgIC8vfVxuXG5cbiAgICAgICAgZGVsZXRlIHRlbXBDb2xvcnNbaV0udGVtcENoYW5nZWRDb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlsbCkge1xuICAgICAgaWYgKHRoYXQuX2lzSW5wdXQpIHtcbiAgICAgICAgJGVsbS52YWwodGhhdC5faGFzVmFsdWUgPyB0aGF0Ll90ZW1wVmFsdWUgOiAnJyk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXIoJ29uRmlsbCcsIHtcbiAgICAgICAgdmFsdWVUZXh0OiB0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnLFxuICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcHJldmlld1ZhbHVlcyA9IGV4dGVuZCQxKHRydWUsIHt9LCB0ZW1wUHJldmlld1ZhbHVlcyk7XG4gICAgICAgIHRoYXQuX3ByZXZlbnRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAkZWxtLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICByZWZyZXNoU2VsZWN0ZWRWYWx1ZXModGhhdC5fdmFsdWUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElucHV0Q29sb3JJdGVtKHZhbHVlLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZCA/IGluZGV4IDogZ2V0Q29sb3JJbmRleCh2YWx1ZSk7XG4gICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1pbnB1dC1pdGVtXCIgZGF0YS1jb2xvcj1cIicgKyAoaW5kZXggIT09IHVuZGVmaW5lZCA/IGluZGV4IDogdmFsdWUpICsgJ1wiIHN0eWxlPVwiYmFja2dyb3VuZDogJyArIHZhbHVlICsgJztcIj4nICsgKHNpbmdsZVNlbGVjdCA/ICcnIDogJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWlucHV0LWl0ZW0tY2xvc2UgbWJzYy1pYyBtYnNjLWljLW1hdGVyaWFsLWNsb3NlXCI+PC9kaXY+JykgKyAnPC9kaXY+JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVNsaWRlclN0ZXBzQ29sb3IoY29sb3IpIHtcbiAgICBzbGlkZXJUcmFja1swXS5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3IgPyBjc3NQcmVmaXggKyAnbGluZWFyLWdyYWRpZW50KGxlZnQsICcgKyAocy5ydGwgPyAnIzAwMDAwMCcgOiAnI0ZGRkZGRicpICsgJyAwJSwgJyArIGNvbG9yICsgJyA1MCUsICcgKyAocy5ydGwgPyAnI0ZGRkZGRicgOiAnIzAwMDAwMCcpICsgJyAxMDAlKScgOiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoY29sb3IpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGVtcFByZXZpZXdWYWx1ZXMpLmxlbmd0aCAmJiAhaXNOYU4oY29sb3IpKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYyBpbiB0ZW1wQ29sb3JzKSB7XG4gICAgICBpZiAoY29sb3IgPT0gdGVtcENvbG9yc1tjXS5jb2xvciB8fCBjb2xvciA9PSB0ZW1wQ29sb3JzW2NdLmNoYW5nZWRDb2xvcikge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUlucHV0SXRlbXMoKSB7XG4gICAgaWYgKGVuaGFuY2VJbnB1dCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaW5wdXRDb2xvckl0ZW1zID0gJyc7XG4gICAgICAkaW5wdXQuZW1wdHkoKTtcblxuICAgICAgaWYgKHRoYXQuX2hhc1ZhbHVlKSB7XG4gICAgICAgIGlmIChzaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICBpbnB1dENvbG9ySXRlbXMgKz0gZ2V0SW5wdXRDb2xvckl0ZW0odGhhdC5fdmFsdWUsIGNvbG9ySW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGF0Ll92YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaW5wdXRDb2xvckl0ZW1zICs9IGdldElucHV0Q29sb3JJdGVtKHRoYXQuX3ZhbHVlW2ldLCBPYmplY3Qua2V5cyh0ZW1wUHJldmlld1ZhbHVlcykubGVuZ3RoICYmIHRlbXBQcmV2aWV3VmFsdWVzW2ldLmNvbG9ySW5kZXggPyB0ZW1wUHJldmlld1ZhbHVlc1tpXS5jb2xvckluZGV4IDogZ2V0Q29sb3JJbmRleCh0aGF0Ll92YWx1ZVtpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRpbnB1dC5hcHBlbmQoaW5wdXRDb2xvckl0ZW1zKTtcbiAgICAgICAgdGhhdC50YXAoJCQxKCcubWJzYy1jb2xvci1pbnB1dC1pdGVtJywgJGlucHV0KSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgaWYgKCQkMShldi50YXJnZXQpLmhhc0NsYXNzKCdtYnNjLWNvbG9yLWlucHV0LWl0ZW0tY2xvc2UnKSkge1xuICAgICAgICAgICAgdmFyIGluZHggPSAkJDEodGhpcykuaW5kZXgoKTtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb2xvckluZGV4ID0gJCQxKGV2LnRhcmdldCkucGFyZW50KCkuYXR0cignZGF0YS1jb2xvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzUHJldmlldyAmJiB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdKSB7XG4gICAgICAgICAgICAgIGNvbG9yUHJldmlld0luZCA9IHRlbXBDb2xvcnNbY29sb3JJbmRleF0ucHJldmlld0luZDtcbiAgICAgICAgICAgICAgJGNvbG9yUHJldmlld0l0ZW1zLmVxKGNvbG9yUHJldmlld0luZCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ21ic2MtY29sb3ItYWN0aXZlJyk7XG4gICAgICAgICAgICAgIHByZXZpZXdWYWx1ZXNbaW5keF0gPSB7fTtcbiAgICAgICAgICAgICAgdGVtcFByZXZpZXdWYWx1ZXNbaW5keF0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5fdmFsdWUuc3BsaWNlKGluZHgsIDEpO1xuXG4gICAgICAgICAgICB0aGF0LnNldFZhbCh0aGF0Ll92YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWZpbmVNb2RlICYmIHMuZGlzcGxheSAhPT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgIGNvbG9ySW5kZXggPSAkJDEoZXYudGFyZ2V0KS5hdHRyKCdkYXRhLWNvbG9yJyk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjb2xvckluZGV4KSkge1xuICAgICAgICAgICAgICBjb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleChjb2xvckluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXggJiYgdGVtcENvbG9yc1tjb2xvckluZGV4XSkge1xuICAgICAgICAgICAgICB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29sb3JQcmV2aWV3SW5kID0gdGVtcENvbG9yc1tjb2xvckluZGV4XS5wcmV2aWV3SW5kOyAvLyBzY3JvbGwgdG8gdmlldywgaWYgdGhlIHNlbGVjdGVkIGNvbG9yIGlzIG5vdCByZXNlbnQgaW4gdGhlIHZpZXdcblxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbCgkY29sb3JJdGVtcy5lcShjb2xvckluZGV4KSwgNDAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgICBwcmV2aWV3U2Nyb2xsVmlldy5zY3JvbGwoJGNvbG9yUHJldmlld0l0ZW1zLmVxKGNvbG9yUHJldmlld0luZCksIDQwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFRvRm9ybWF0KGNvbG9yLCB0eXBlKSB7XG4gICAgdmFyIGNvbG9ySGV4LFxuICAgICAgICBjb2xvclZhbHVlcyA9IGNvbG9yLm1hdGNoKC9cXGQrL2dtaSk7XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgY29sb3IuaW5kZXhPZigncmdiJykgPiAtMTpcbiAgICAgICAgY29sb3JIZXggPSByZ2IyaGV4KHtcbiAgICAgICAgICByOiBjb2xvclZhbHVlc1swXSxcbiAgICAgICAgICBnOiBjb2xvclZhbHVlc1sxXSxcbiAgICAgICAgICBiOiBjb2xvclZhbHVlc1syXVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgY29sb3IuaW5kZXhPZignaHNsJykgPiAtMTpcbiAgICAgICAgY29sb3JIZXggPSBoc2wyaGV4KHtcbiAgICAgICAgICBoOiBjb2xvclZhbHVlc1swXSxcbiAgICAgICAgICBzOiBjb2xvclZhbHVlc1sxXSxcbiAgICAgICAgICBsOiBjb2xvclZhbHVlc1syXVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgY29sb3IuaW5kZXhPZignaHN2JykgPiAtMTpcbiAgICAgICAgY29sb3JIZXggPSBoc3YyaGV4KHtcbiAgICAgICAgICBoOiBjb2xvclZhbHVlc1swXSxcbiAgICAgICAgICBzOiBjb2xvclZhbHVlc1sxXSxcbiAgICAgICAgICB2OiBjb2xvclZhbHVlc1syXVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgY29sb3IuaW5kZXhPZignIycpID4gLTE6XG4gICAgICAgIGNvbG9ySGV4ID0gY29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0RnJvbUhleChjb2xvckhleCwgdHlwZSB8fCBzLmZvcm1hdCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0RnJvbUhleChjb2xvciwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgcmV0dXJuIGhleDJyZ2IoY29sb3IpO1xuXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICByZXR1cm4gaGV4MmhzbChjb2xvcik7XG5cbiAgICAgIGNhc2UgJ2hzdic6XG4gICAgICAgIHJldHVybiBoZXgyaHN2KGNvbG9yKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0RW1wdHlQcmV2aWV3SW5kZXgoKSB7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5zZWxlY3Q7ICsraSkge1xuICAgICAgaWYgKHRlbXBQcmV2aWV3VmFsdWVzW2ldLmNvbG9ySW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVDb2xvcigkY29sb3IsIGN0eCkge1xuICAgICQkMSgnLm1ic2MtY29sb3ItYWN0aXZlJywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1hY3RpdmUnKTtcblxuICAgIGlmIChyZWZpbmVNb2RlKSB7XG4gICAgICAkY29sb3IucGFyZW50KCkuYWRkQ2xhc3MoJ21ic2MtY29sb3ItYWN0aXZlJyk7XG5cbiAgICAgIGlmIChoYXNQcmV2aWV3ICYmICRjb2xvcikge1xuICAgICAgICBpZiAoY29sb3JQcmV2aWV3SW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkY29sb3JQcmV2aWV3SXRlbXMuZXEoY29sb3JQcmV2aWV3SW5kKS5wYXJlbnQoKS5hZGRDbGFzcygnbWJzYy1jb2xvci1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hTZWxlY3RlZFZhbHVlcyhuZXd0ZW1wQ29sb3JzLCB1cGRhdGVJbnB1dCkge1xuICAgIHZhciBpLFxuICAgICAgICB0ZW1wLFxuICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgIHByZXZJbmQgPSAwLFxuICAgICAgICBjb2xvclZhbHVlcyA9ICQkMS5tYXAodGVtcENvbG9ycywgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LmNoYW5nZWRDb2xvciB8fCB2LmNvbG9yO1xuICAgIH0pOyAvLyBjaGVjayB0aGUgaW5kZXhlcyBpbiB0aGUgdGVtcENvbG9yc1xuXG4gICAgaWYgKHNpbmdsZVNlbGVjdCkge1xuICAgICAgbmV3dGVtcENvbG9ycyA9ICQkMS5pc0FycmF5KG5ld3RlbXBDb2xvcnMpID8gbmV3dGVtcENvbG9yc1swXSA6IG5ld3RlbXBDb2xvcnM7XG4gICAgICB0ZW1wID0gY29sb3JWYWx1ZXMuaW5kZXhPZihuZXd0ZW1wQ29sb3JzKTtcblxuICAgICAgaWYgKHRlbXAgPiAtMSkge1xuICAgICAgICBpbmRleGVzLnB1c2godGVtcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXd0ZW1wQ29sb3JzICYmICFpbmRleGVzLmxlbmd0aCAmJiByZWZpbmVNb2RlKSB7XG4gICAgICAgIHZhciBpbnB1dEluZGV4ID0gKyQkMSgnLm1ic2MtY29sb3ItaW5wdXQtaXRlbScsICRpbnB1dCkuYXR0cignZGF0YS1jb2xvcicpO1xuXG4gICAgICAgIGlmIChpc05hTihpbnB1dEluZGV4KSkge1xuICAgICAgICAgIGlucHV0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGlucHV0SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sb3JJbmRleCA9IGlucHV0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXd0ZW1wQ29sb3JzKSB7XG4gICAgICBpZiAoaGFzUHJldmlldyAmJiByZWZpbmVNb2RlKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gcHJldmlld1ZhbHVlcykge1xuICAgICAgICAgIGlmIChwcmV2aWV3VmFsdWVzW2NdLmNvbG9ySW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKCtwcmV2aWV3VmFsdWVzW2NdLmNvbG9ySW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ld3RlbXBDb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0ZW1wID0gY29sb3JWYWx1ZXMuaW5kZXhPZihuZXd0ZW1wQ29sb3JzW2ldKTtcblxuICAgICAgICAgIGlmICh0ZW1wID4gLTEpIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgIGNvbG9yVmFsdWVzW3RlbXBdID0gJ3RlbXAnICsgaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGxvb3AgdHJvdWdoIG5ldyBjb2xvciBpbmRleGVzIGFuZCBjaGVjayB0aGUgY29sb3JzXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGVtcENvbG9yc1tpbmRleGVzW2ldXSkge1xuICAgICAgICB0b2dnbGVDb2xvcih0cnVlLCBpbmRleGVzW2ldLCBwcmV2SW5kKyssIHRlbXBDb2xvcnNbaW5kZXhlc1tpXV0uY2hhbmdlZENvbG9yIHx8IHRlbXBDb2xvcnNbaW5kZXhlc1tpXV0uY29sb3IsIHRydWUpO1xuICAgICAgfVxuICAgIH0gLy8gbG9vcCB0cm91Z2ggb3RoZXIgY29sb3IgaW5kZXhlcyBhbmQgdW5jaGVjayB0aGUgY29sb3JzXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wQ29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaW5kZXhlcy5pbmRleE9mKGkpID09IC0xKSB7XG4gICAgICAgIHRvZ2dsZUNvbG9yKGZhbHNlLCBpLCB1bmRlZmluZWQsIHRlbXBDb2xvcnNbaV0uY2hhbmdlZENvbG9yIHx8IHRlbXBDb2xvcnNbaV0uY29sb3IsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IC8vIGdlbmVyYXRlIG5ldyBwcmV2aWV3IG9iamVjdFxuXG5cbiAgICBpZiAoaGFzUHJldmlldykge1xuICAgICAgZm9yIChpID0gcHJldkluZDsgaSA8IHMuc2VsZWN0OyArK2kpIHtcbiAgICAgICAgdGVtcFByZXZpZXdWYWx1ZXNbaV0gPSB7fTtcblxuICAgICAgICBpZiAoJGNvbG9yUHJldmlld0l0ZW1zKSB7XG4gICAgICAgICAgJGNvbG9yUHJldmlld0l0ZW1zLmVxKGkpLmFkZENsYXNzKCdtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1lbXB0eScpLmNzcyh7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmV2aWV3VmFsdWVzID0gZXh0ZW5kJDEodHJ1ZSwge30sIHRlbXBQcmV2aWV3VmFsdWVzKTtcblxuICAgIGlmICh1cGRhdGVJbnB1dCAhPT0gZmFsc2UpIHtcbiAgICAgIGdlbmVyYXRlSW5wdXRJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNvbG9yKGFkZCwgY29sb3JJbmRleCwgY29sb3JQcmV2aWV3SW5kLCBjdXJyVmFsdWUsIHVwZGF0ZVByZXZpZXcsIHVwZGF0ZVZhbHVlKSB7XG4gICAgaWYgKGhhc1ByZXZpZXcgJiYgdXBkYXRlUHJldmlldykge1xuICAgICAgdGVtcFByZXZpZXdWYWx1ZXNbY29sb3JQcmV2aWV3SW5kXS5jb2xvckluZGV4ID0gYWRkID8gY29sb3JJbmRleCA6IHVuZGVmaW5lZDtcbiAgICAgIHRlbXBQcmV2aWV3VmFsdWVzW2NvbG9yUHJldmlld0luZF0uY29sb3IgPSBhZGQgPyBjdXJyVmFsdWUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICgkY29sb3JQcmV2aWV3SXRlbXMpIHtcbiAgICAgICAgdmFyIGNvbG9yUHJldkl0ZW0gPSAkY29sb3JQcmV2aWV3SXRlbXMuZXEoY29sb3JQcmV2aWV3SW5kKTtcbiAgICAgICAgY29sb3JQcmV2SXRlbS5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0tZW1wdHknKS5jc3Moe1xuICAgICAgICAgIGJhY2tncm91bmQ6IGFkZCA/IGN1cnJWYWx1ZSA6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICBjb2xvclByZXZJdGVtLmFkZENsYXNzKCdtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1lbXB0eScpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZVZhbHVlKSB7XG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHRoYXQuX3RlbXBWYWx1ZS5zcGxpY2UoY29sb3JQcmV2aWV3SW5kLCAwLCBjdXJyVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5fdGVtcFZhbHVlLnNwbGljZSh0aGF0Ll90ZW1wVmFsdWUuaW5kZXhPZihjdXJyVmFsdWUpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGNvbG9ySXRlbXMpIHtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgJGNvbG9ySXRlbXMuZXEoY29sb3JJbmRleCkuYWRkQ2xhc3MoJ21ic2MtY29sb3Itc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRjb2xvckl0ZW1zLmVxKGNvbG9ySW5kZXgpLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLXNlbGVjdGVkJykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ21ic2MtY29sb3ItYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGVtcENvbG9yc1tjb2xvckluZGV4XS5wcmV2aWV3SW5kID0gYWRkID8gY29sb3JQcmV2aWV3SW5kIDogdW5kZWZpbmVkO1xuICAgIHRlbXBDb2xvcnNbY29sb3JJbmRleF0uc2VsZWN0ZWQgPSBhZGQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREZWZhdWx0VmFsdWVzKGNvbG9ySW5kLCBjdHgpIHtcbiAgICBpZiAoY29sb3JJbmQgIT09IHVuZGVmaW5lZCAmJiAoc2luZ2xlU2VsZWN0IHx8IHRlbXBDb2xvcnNbY29sb3JJbmRdICYmIHRlbXBDb2xvcnNbY29sb3JJbmRdLnNlbGVjdGVkKSkge1xuICAgICAgY29sb3JJbmRleCA9IGNvbG9ySW5kO1xuXG4gICAgICBpZiAodGVtcENvbG9yc1tjb2xvckluZF0pIHtcbiAgICAgICAgY3VyclZhbHVlID0gdGVtcENvbG9yc1tjb2xvckluZF0uY2hhbmdlZENvbG9yIHx8IHRlbXBDb2xvcnNbY29sb3JJbmRdLmNvbG9yO1xuICAgICAgICAkY3Vyckl0ZW0gPSAkY29sb3JJdGVtcy5lcShjb2xvckluZCk7IC8vIHJlZnJlc2ggc2xpZGVyIHRlbXBDb2xvcnNcblxuICAgICAgICBpZiAocmVmaW5lTW9kZSkge1xuICAgICAgICAgIGhpZ2hsaWdodEFjdGl2ZUNvbG9yKCRjb2xvckl0ZW1zLmVxKGNvbG9ySW5kKSwgY3R4IHx8ICcnKTtcbiAgICAgICAgICBjdXJySHNsVmFsdWUgPSBjb252ZXJ0VG9Gb3JtYXQodGVtcENvbG9yc1tjb2xvckluZF0uY29sb3IsICdoc2wnKTtcbiAgICAgICAgICBjdXJySHNsVmFsdWUubCA9IGNvbnZlcnRUb0Zvcm1hdChjdXJyVmFsdWUsICdoc2wnKS5sO1xuICAgICAgICAgIGNoYW5nZVNsaWRlclN0ZXBzQ29sb3IodGVtcENvbG9yc1tjb2xvckluZF0uY29sb3IpO1xuICAgICAgICAgIHNsaWRlci5zZXRWYWwoMTAwIC0gY3VyckhzbFZhbHVlLmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZmluZU1vZGUpIHtcbiAgICAgIGNoYW5nZVNsaWRlclN0ZXBzQ29sb3IoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2xvck9iamVjdHMoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGFyciA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRlbXBDb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0ZW1wQ29sb3JzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgIGFyci5wdXNoKHRlbXBDb2xvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xvclByZXZpZXdUYXAoZXYsICRtKSB7XG4gICAgdmFyIGluZGV4ID0gJCQxKGV2LnRhcmdldCkuaW5kZXgoKTtcbiAgICBjb2xvckluZGV4ID0gdGVtcFByZXZpZXdWYWx1ZXNbaW5kZXhdLmNvbG9ySW5kZXg7XG4gICAgJGN1cnJJdGVtID0gJGNvbG9ySXRlbXMuZXEoY29sb3JJbmRleCk7IC8vIHJlZnJlc2ggdmFsdWVzXG5cbiAgICBjb2xvclByZXZpZXdJbmQgPSBpbmRleDtcbiAgICBzZXREZWZhdWx0VmFsdWVzKGNvbG9ySW5kZXgsICRtKTtcbiAgICBzY3JvbGxWaWV3LnNjcm9sbCgkY3Vyckl0ZW0sIDI1MCk7XG4gICAgdHJpZ2dlcignb25QcmV2aWV3SXRlbVRhcCcsIHtcbiAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgdmFsdWU6IHRlbXBQcmV2aWV3VmFsdWVzW2luZGV4XS5jb2xvcixcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sb3JUYXAoZXYsICRtKSB7XG4gICAgdmFyIGhhc1NlbGVjdCA9IGZhbHNlLFxuICAgICAgICAkc2VsZWN0ZWR0ZW1wQ29sb3JzID0gJCQxKCcubWJzYy1jb2xvci1zZWxlY3RlZCcsICRtKTtcbiAgICAkY3Vyckl0ZW0gPSAkJDEoZXYudGFyZ2V0KTtcblxuICAgIGlmICgkY3Vyckl0ZW0uaGFzQ2xhc3MoJ21ic2MtY29sb3ItY2xlYXItaXRlbScpKSB7XG4gICAgICBjdXJyVmFsdWUgPSAnJztcbiAgICAgIHRoYXQuY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoKHNpbmdsZVNlbGVjdCB8fCBtYXhTZWxlY3QgPiArJHNlbGVjdGVkdGVtcENvbG9ycy5sZW5ndGggfHwgJGN1cnJJdGVtLmhhc0NsYXNzKCdtYnNjLWNvbG9yLXNlbGVjdGVkJykpICYmIG1vYmlzY3JvbGwuRW10akMpIHtcbiAgICAgIGNvbG9ySW5kZXggPSAkY3Vyckl0ZW0uYXR0cignZGF0YS1pbmRleCcpO1xuXG4gICAgICBpZiAoaGFzUHJldmlldykge1xuICAgICAgICBjb2xvclByZXZpZXdJbmQgPSB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnByZXZpZXdJbmQgIT09IHVuZGVmaW5lZCA/IHRlbXBDb2xvcnNbY29sb3JJbmRleF0ucHJldmlld0luZCA6IGdldEZpcnN0RW1wdHlQcmV2aWV3SW5kZXgoKTtcbiAgICAgICAgaGFzU2VsZWN0ID0gcmVmaW5lTW9kZSAmJiAkY3Vyckl0ZW0uaGFzQ2xhc3MoJ21ic2MtY29sb3Itc2VsZWN0ZWQnKSAmJiAhJGN1cnJJdGVtLnBhcmVudCgpLmhhc0NsYXNzKCdtYnNjLWNvbG9yLWFjdGl2ZScpOyAvLyBzY3JvbGwgdG8gdGhlIHByZXZpZXcgY29sb3JcblxuICAgICAgICBpZiAoJGNvbG9yUHJldmlld0l0ZW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICBwcmV2aWV3U2Nyb2xsVmlldy5zY3JvbGwoJGNvbG9yUHJldmlld0l0ZW1zLmVxKGNvbG9yUHJldmlld0luZCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJWYWx1ZSA9IHRlbXBDb2xvcnNbY29sb3JJbmRleF0uY2hhbmdlZENvbG9yIHx8IHRlbXBDb2xvcnNbY29sb3JJbmRleF0uY29sb3I7XG5cbiAgICAgIGlmIChzaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgJHNlbGVjdGVkdGVtcENvbG9ycy5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1zZWxlY3RlZCcpO1xuICAgICAgICB0aGF0Ll90ZW1wVmFsdWUgPSBjdXJyVmFsdWU7XG5cbiAgICAgICAgaWYgKGN1cnJWYWx1ZSkge1xuICAgICAgICAgICRjdXJySXRlbS50b2dnbGVDbGFzcygnbWJzYy1jb2xvci1zZWxlY3RlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlnaGxpZ2h0QWN0aXZlQ29sb3IoJGN1cnJJdGVtLCAkbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaWdobGlnaHRBY3RpdmVDb2xvcigkY3Vyckl0ZW0sICRtKTtcblxuICAgICAgICBpZiAoIWhhc1NlbGVjdCkge1xuICAgICAgICAgIHRvZ2dsZUNvbG9yKCF0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnNlbGVjdGVkLCBjb2xvckluZGV4LCBjb2xvclByZXZpZXdJbmQsIGN1cnJWYWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0RGVmYXVsdFZhbHVlcyhjb2xvckluZGV4LCAkbSk7XG5cbiAgICAgIGlmICh0aGF0LmxpdmUpIHtcbiAgICAgICAgdGhhdC5fZmlsbFZhbHVlKCk7XG5cbiAgICAgICAgdHJpZ2dlcignb25TZXQnLCB7XG4gICAgICAgICAgdmFsdWU6IHRoYXQuX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyKCdvbkl0ZW1UYXAnLCB7XG4gICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgICB2YWx1ZTogY3VyclZhbHVlLFxuICAgICAgICBzZWxlY3RlZDogdGVtcENvbG9yc1tjb2xvckluZGV4XS5zZWxlY3RlZCxcbiAgICAgICAgaW5kZXg6IGNvbG9ySW5kZXhcbiAgICAgIH0pO1xuXG4gICAgICB0aGF0Ll91cGRhdGVIZWFkZXIoKTtcbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBGcmFtZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7IC8vIFB1YmxpYyBmdW5jdGlvbnNcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWVcbiAgICovXG5cbiAgdGhhdC5zZXRWYWwgPSB0aGF0Ll9zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXApIHtcbiAgICB0aGF0Ll9oYXNWYWx1ZSA9IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZDtcbiAgICB0aGF0Ll90ZW1wVmFsdWUgPSBzaW5nbGVTZWxlY3QgPyAkJDEuaXNBcnJheSh2YWwpID8gdmFsWzBdIDogdmFsIDogJCQxLmlzQXJyYXkodmFsKSA/IHZhbCA6IHZhbCA/IFt2YWxdIDogW107XG4gICAgc2V0VmFsdWUoZmlsbCwgY2hhbmdlID09PSB1bmRlZmluZWQgPyBmaWxsIDogY2hhbmdlLCB0ZW1wKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAqL1xuXG5cbiAgdGhhdC5nZXRWYWwgPSB0aGF0Ll9nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0aGF0Ll9oYXNWYWx1ZSB8fCB0ZW1wID8gcmV0dXJuT2JqID8gZ2V0Q29sb3JPYmplY3RzKCkgOiB0aGF0W3RlbXAgPyAnX3RlbXBWYWx1ZScgOiAnX3ZhbHVlJ10gOiBudWxsO1xuICB9O1xuXG4gIHRoYXQuX3JlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9ICRlbG0udmFsKCkgfHwgJyc7XG4gICAgdGhhdC5faGFzVmFsdWUgPSBmYWxzZTtcblxuICAgIGlmICh2Lmxlbmd0aCAhPT0gMCAmJiB2ICE9PSAnJykge1xuICAgICAgdGhhdC5faGFzVmFsdWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGF0Ll9oYXNWYWx1ZSkge1xuICAgICAgdGhhdC5fdGVtcFZhbHVlID0gc2luZ2xlU2VsZWN0ID8gdiA6IHMuZm9ybWF0ID09ICdoZXgnID8gdi5zcGxpdCgnLCcpIDogdi5tYXRjaCgvW2Etel17M31cXCgoXFxkK1xcLj9cXGR7MCx9PyksXFxzKihbXFxkLl0rKSV7MCx9LFxccyooW1xcZC5dKyklezAsfVxcKS9nbWkpO1xuICAgICAgc2V0VmFsdWUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3RlbXBWYWx1ZSA9IFtdO1xuICAgIH1cblxuICAgIHJlZnJlc2hTZWxlY3RlZFZhbHVlcyh0aGF0Ll90ZW1wVmFsdWUsIHRoYXQuX2hhc1ZhbHVlKTtcbiAgfTtcblxuICB0aGF0Ll9maWxsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5faGFzVmFsdWUgPSB0cnVlO1xuICAgIHNldFZhbHVlKHRydWUsIHRydWUpO1xuICB9O1xuXG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaHRtbCxcbiAgICAgICAgY3VyckNvbG9yLFxuICAgICAgICBjb2xvck9mZnNldCA9IGhhc0NsZWFyID8gMSA6IDA7XG4gICAgcm93SXRlbXMgPSBpc0hvcml6b250YWxTY3JvbGwgPyBNYXRoLmNlaWwoKHRlbXBDb2xvcnMubGVuZ3RoICsgY29sb3JPZmZzZXQpIC8gcy5yb3dzKSA6IHMucm93czsgLy8gZ2VuZXJhdGUgY29sb3IgY29udGVudFxuXG4gICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1zY3JvbGwtY29udCBtYnNjLXctcCAnICsgKGlzSG9yaXpvbnRhbFNjcm9sbCA/ICcnIDogJ21ic2MtY29sb3ItdmVydGljYWwnKSArICdcIj48ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1jb250XCI+JyArIChpc0hvcml6b250YWxTY3JvbGwgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY29sb3Itcm93XCI+JyA6ICcnKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wQ29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXJyQ29sb3IgPSB0ZW1wQ29sb3JzW2ldLmNoYW5nZWRDb2xvciB8fCB0ZW1wQ29sb3JzW2ldLmNvbG9yO1xuXG4gICAgICBpZiAoaGFzQ2xlYXIgJiYgaSA9PT0gMCkge1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1pdGVtLWNcIj48ZGl2IHRhYmluZGV4PVwiMFwiIGNsYXNzPVwibWJzYy1jb2xvci1jbGVhci1pdGVtIG1ic2MtYnRuLWUgbWJzYy1jb2xvci1zZWxlY3RlZFwiPjxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWNsZWFyLWNyb3NzXCI+PC9kaXY+PC9kaXY+PC9kaXY+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgIT09IDAgJiYgKGkgKyBjb2xvck9mZnNldCkgJSByb3dJdGVtcyA9PT0gMCkge1xuICAgICAgICBodG1sICs9IGlzSG9yaXpvbnRhbFNjcm9sbCA/ICc8L2Rpdj48ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1yb3dcIj4nIDogJyc7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWl0ZW0tY1wiPjxkaXYgdGFiaW5kZXg9XCIwXCIgZGF0YS1pbmRleD1cIicgKyBpICsgJ1wiIGNsYXNzPVwibWJzYy1jb2xvci1pdGVtIG1ic2MtYnRuLWUgbWJzYy1pYyBtYnNjLWljLW1hdGVyaWFsLWNoZWNrIG1ic2MtY29sb3ItYnRuLWUgJyArICh0ZW1wQ29sb3JzW2ldLnNlbGVjdGVkID8gJ21ic2MtY29sb3Itc2VsZWN0ZWQnIDogJycpICsgJ1wiICBzdHlsZT1cImJhY2tncm91bmQ6JyArIGN1cnJDb2xvciArICdcIj48L2Rpdj4nICsgdGhhdC5fZ2V0VGV4dChtb2Jpc2Nyb2xsLCAwLjIpICsgJzwvZGl2Pic7XG4gICAgfVxuXG4gICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+JyArIChpc0hvcml6b250YWxTY3JvbGwgPyAnPC9kaXY+JyA6ICcnKTtcblxuICAgIGlmIChyZWZpbmVNb2RlKSB7XG4gICAgICAvLyBhZGQgcmVmaW5lIHNsaWRlciBcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXNsaWRlci1jb250XCI+PGlucHV0IGNsYXNzPVwibWJzYy1jb2xvci1zbGlkZXJcIiB0eXBlPVwicmFuZ2VcIiBkYXRhLWhpZ2hsaWdodD1cImZhbHNlXCIgdmFsdWU9XCI1MFwiIG1pbj1cIjBcIiBtYXg9XCIxMDBcIi8+PC9kaXY+JztcbiAgICB9IC8vIGFkZCBwcmV2aWV3IGNvbnRhaW5lciBcblxuXG4gICAgaWYgKGhhc1ByZXZpZXcpIHtcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXByZXZpZXctY29udFwiPjxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXJlZmluZS1wcmV2aWV3XCI+JztcblxuICAgICAgZm9yICh2YXIgYyBpbiBwcmV2aWV3VmFsdWVzKSB7XG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1jIG1ic2MtYnRuLWUgbWJzYy1jb2xvci1idG4tZVwiIHRhYmluZGV4PVwiMFwiPjxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXByZXZpZXctaXRlbSAnICsgKHByZXZpZXdWYWx1ZXNbY10uY29sb3IgPyAnJyA6ICdtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1lbXB0eScpICsgJ1wiIHN0eWxlPVwiYmFja2dyb3VuZDogJyArIChwcmV2aWV3VmFsdWVzW2NdLmNvbG9yIHx8ICdpbml0aWFsJykgKyAnO1wiPjwvZGl2PjwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2Pic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG5cbiAgdGhhdC5fcG9zaXRpb24gPSBmdW5jdGlvbiAoJG0pIHtcbiAgICB2YXIgY29sb3JDb250LCBjb2xvckl0ZW1XaWR0aDtcblxuICAgIGlmICghaXNIb3Jpem9udGFsU2Nyb2xsKSB7XG4gICAgICBjb2xvckNvbnQgPSAkbS5maW5kKCcubWJzYy1jb2xvci1jb250Jyk7XG4gICAgICBjb2xvckl0ZW1XaWR0aCA9IE1hdGguY2VpbChjb2xvckNvbnQuZmluZCgnLm1ic2MtY29sb3ItaXRlbS1jJylbMF0ub2Zmc2V0V2lkdGgpO1xuICAgICAgY29sb3JDb250LndpZHRoKE1hdGgubWluKE1hdGguZmxvb3IoJG0uZmluZCgnLm1ic2MtZnItYycpLndpZHRoKCkgLyBjb2xvckl0ZW1XaWR0aCksIE1hdGgucm91bmQodGVtcENvbG9ycy5sZW5ndGggLyBzLnJvd3MpKSAqIGNvbG9ySXRlbVdpZHRoICsgMSk7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFZpZXcpIHtcbiAgICAgIHNjcm9sbFZpZXcucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aWV3U2Nyb2xsVmlldykge1xuICAgICAgcHJldmlld1Njcm9sbFZpZXcucmVmcmVzaCgpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBJbnNlcnRlZCA9IGZ1bmN0aW9uICgkbWFya3VwKSB7XG4gICAgaWYgKCFpc0hvcml6b250YWxTY3JvbGwpIHtcbiAgICAgICRtYXJrdXAuZmluZCgnLm1ic2MtY29sb3Itc2Nyb2xsLWNvbnQnKS5jc3MoJ21heC1oZWlnaHQnLCAkbWFya3VwLmZpbmQoJy5tYnNjLWNvbG9yLWl0ZW0tYycpWzBdLm9mZnNldEhlaWdodCAqIHMucm93cyk7XG4gICAgfSAvLyBpbml0IGNvbG9yIHNjcm9sbFZpZXdcblxuXG4gICAgc2Nyb2xsVmlldyA9IG5ldyBTY3JvbGxWaWV3QmFzZSgkbWFya3VwLmZpbmQoJy5tYnNjLWNvbG9yLXNjcm9sbC1jb250JylbMF0sIHtcbiAgICAgIGF4aXM6IGlzSG9yaXpvbnRhbFNjcm9sbCA/ICdYJyA6ICdZJyxcbiAgICAgIHJ0bDogcy5ydGwsXG4gICAgICBlbGFzdGljOiA2MCxcbiAgICAgIHN0b3BQcm9wOiBmYWxzZSxcbiAgICAgIG1vdXNld2hlZWw6IHMubW91c2V3aGVlbCxcbiAgICAgIG9uQnRuVGFwOiBmdW5jdGlvbiBvbkJ0blRhcChldikge1xuICAgICAgICBjb2xvclRhcChldiwgJG1hcmt1cCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdGhhdC5fYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gKCRtYXJrdXApIHtcbiAgICB2YXIgbW9kaWZpZWRDb2xvcjtcbiAgICAkY29sb3JJdGVtcyA9ICQkMSgnLm1ic2MtY29sb3ItaXRlbScsICRtYXJrdXApOyAvLyBoYW5kbGUgY29sb3Igc2VsZWN0aW9uIHdpdGggc3BhY2VcblxuICAgICRtYXJrdXAub24oJ2tleWRvd24nLCAnLm1ic2MtY29sb3ItYnRuLWUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoZXYua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAvLyBTcGFjZSBcbiAgICAgICAgaWYgKGV2LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21ic2MtY29sb3ItaXRlbScpKSB7XG4gICAgICAgICAgY29sb3JUYXAoZXYsICRtYXJrdXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yUHJldmlld1RhcChldiwgJG1hcmt1cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICAkY29sb3JQcmV2aWV3SXRlbXMgPSAkJDEoJy5tYnNjLWNvbG9yLXByZXZpZXctaXRlbScsICRtYXJrdXApO1xuICAgIH0gLy8gcmVmaW5lIG1vZGUgXG5cblxuICAgIGlmIChyZWZpbmVNb2RlKSB7XG4gICAgICAkbWFya3VwLmFkZENsYXNzKCdtYnNjLWNvbG9yLXJlZmluZScpO1xuICAgICAgJHNsaWRlckVsbSA9ICQkMSgnLm1ic2MtY29sb3Itc2xpZGVyJywgJG1hcmt1cCk7XG4gICAgICBzbGlkZXIgPSBuZXcgU2xpZGVyKCRzbGlkZXJFbG1bMF0sIHtcbiAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgIHJ0bDogcy5ydGxcbiAgICAgIH0pO1xuICAgICAgc2xpZGVyVHJhY2sgPSAkbWFya3VwLmZpbmQoJy5tYnNjLXByb2dyZXNzLXRyYWNrJyk7IC8vIGNoYW5nZSBzbGlkZXIgdHJhY2sgc3RlcCBjb2xvclxuXG4gICAgICBpZiAoY29sb3JJbmRleCAmJiB0aGF0Ll92YWx1ZSkge1xuICAgICAgICBzZXREZWZhdWx0VmFsdWVzKGNvbG9ySW5kZXgsICRtYXJrdXApO1xuICAgICAgfVxuXG4gICAgICAkc2xpZGVyRWxtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjb2xvckluZGV4ICE9PSB1bmRlZmluZWQgJiYgKHNpbmdsZVNlbGVjdCB8fCB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdICYmIHRlbXBDb2xvcnNbY29sb3JJbmRleF0uc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgY3VyckhzbFZhbHVlLmwgPSAxMDAgLSB0aGlzLnZhbHVlO1xuICAgICAgICAgIG1vZGlmaWVkQ29sb3IgPSBjb252ZXJ0VG9Gb3JtYXQoY3VyckhzbFZhbHVlLnRvU3RyaW5nKCkpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICBpZiAoc2luZ2xlU2VsZWN0KSB7XG4gICAgICAgICAgICB0aGF0Ll90ZW1wVmFsdWUgPSBtb2RpZmllZENvbG9yO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0Ll90ZW1wVmFsdWVbY29sb3JQcmV2aWV3SW5kICE9PSB1bmRlZmluZWQgPyBjb2xvclByZXZpZXdJbmQgOiB0aGF0Ll90ZW1wVmFsdWUubGVuZ3RoXSA9IG1vZGlmaWVkQ29sb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGVtcENvbG9yc1tjb2xvckluZGV4XS50ZW1wQ2hhbmdlZENvbG9yID0gbW9kaWZpZWRDb2xvcjtcbiAgICAgICAgICAkY29sb3JJdGVtcy5lcShjb2xvckluZGV4KS5jc3MoJ2JhY2tncm91bmQnLCBtb2RpZmllZENvbG9yKTtcblxuICAgICAgICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICAgICAgICB0ZW1wUHJldmlld1ZhbHVlc1tjb2xvclByZXZpZXdJbmRdLmNvbG9yID0gbW9kaWZpZWRDb2xvcjtcbiAgICAgICAgICAgICRjb2xvclByZXZpZXdJdGVtcy5lcShjb2xvclByZXZpZXdJbmQpLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1lbXB0eScpLmNzcyh7XG4gICAgICAgICAgICAgICdiYWNrZ3JvdW5kJzogbW9kaWZpZWRDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoYXQubGl2ZSkge1xuICAgICAgICAgICAgdGhyb3R0bGUodGhhdC5fZmlsbFZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ByZXZpZXcpIHtcbiAgICAgIC8vIGluaXQgY29sb3JwcmV2aXJldyBzY3JvbGx2aWV3XG4gICAgICBwcmV2aWV3U2Nyb2xsVmlldyA9IG5ldyBTY3JvbGxWaWV3QmFzZSgkbWFya3VwLmZpbmQoJy5tYnNjLWNvbG9yLXByZXZpZXctY29udCcpWzBdLCB7XG4gICAgICAgIGF4aXM6ICdYJyxcbiAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgc3RvcFByb3A6IGZhbHNlLFxuICAgICAgICBtb3VzZXdoZWVsOiBzLm1vdXNld2hlZWwsXG4gICAgICAgIG9uQnRuVGFwOiBmdW5jdGlvbiBvbkJ0blRhcChldikge1xuICAgICAgICAgIGNvbG9yUHJldmlld1RhcChldiwgJG1hcmt1cCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoYXQuX3VwZGF0ZUhlYWRlcigpO1xuICB9O1xuXG4gIHRoYXQuX21hcmt1cFJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsVmlldykge1xuICAgICAgc2Nyb2xsVmlldy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKHNsaWRlcikge1xuICAgICAgc2xpZGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlld1Njcm9sbFZpZXcpIHtcbiAgICAgIHByZXZpZXdTY3JvbGxWaWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fX3Byb2Nlc3NTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSwgZGF0YTtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICB0cmlnZ2VyID0gdGhhdC50cmlnZ2VyO1xuICAgIGlzSG9yaXpvbnRhbFNjcm9sbCA9IHMubmF2aWdhdGlvbiA9PSAnaG9yaXpvbnRhbCc7XG4gICAgdGhhdC5fdmFsdWUgPSBbXTtcbiAgICB0aGF0Ll90ZW1wVmFsdWUgPSBbXTtcbiAgICBzaW5nbGVTZWxlY3QgPSBzLnNlbGVjdCA9PSAnc2luZ2xlJztcbiAgICBoYXNDbGVhciA9IHMuY2xlYXIgIT09IHVuZGVmaW5lZCA/IHMuY2xlYXIgOiBzaW5nbGVTZWxlY3Q7XG4gICAgZGF0YSA9IHMuZGF0YSB8fCBbXTtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAocy5mb3JtYXQpIHtcbiAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICBkYXRhID0gW1wicmdiKDI1NSwyMzUsNjApXCIsIFwicmdiKDI1NSwxNTMsMClcIiwgXCJyZ2IoMjQ0LDY4LDU1KVwiLCBcInJnYigyMzQsMzAsOTkpXCIsIFwicmdiKDE1NiwzOCwxNzYpXCIsIFwicmdiKDEwNCw1OCwxODMpXCIsIFwicmdiKDYzLDgxLDE4MSlcIiwgXCJyZ2IoMzMsMTUwLDI0MylcIiwgXCJyZ2IoMCwxNTEsMTM2KVwiLCBcInJnYig3NSwxNzUsNzkpXCIsIFwicmdiKDEyNiw5Myw3OClcIiwgXCJyZ2IoMTU4LDE1OCwxNTgpXCJdO1xuXG4gICAgICAgICAgaWYgKGhhc0NsZWFyKSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZSgxMCwgMCwgJ3JnYig4MywgNzEsIDY1KScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgZGF0YSA9IFtcImhzbCg1NCwxMDAlLDYyJSlcIiwgXCJoc2woMzYsMTAwJSw1MCUpXCIsIFwiaHNsKDQsOTAlLDU5JSlcIiwgXCJoc2woMzQwLDgzJSw1MiUpXCIsIFwiaHNsKDI5MSw2NCUsNDIlKVwiLCBcImhzbCgyNjIsNTIlLDQ3JSlcIiwgXCJoc2woMjMxLDQ4JSw0OCUpXCIsIFwiaHNsKDIwNyw5MCUsNTQlKVwiLCBcImhzbCgxNzQsMTAwJSwzMCUpXCIsIFwiaHNsKDEyMiw0MCUsNDklKVwiLCBcImhzbCgxOSwyNCUsNDAlKVwiLCBcImhzbCgwLDAlLDYyJSlcIl07XG5cbiAgICAgICAgICBpZiAoaGFzQ2xlYXIpIHtcbiAgICAgICAgICAgIGRhdGEuc3BsaWNlKDEwLCAwLCAnaHNsKDIwLCAxMiUsIDI5JSknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRhdGEgPSBbJyNmZmViM2MnLCAnI2ZmOTkwMCcsICcjZjQ0NDM3JywgJyNlYTFlNjMnLCAnIzljMjZiMCcsICcjNjgzYWI3JywgJyMzZjUxYjUnLCAnIzIxOTZmMycsICcjMDA5Nzg4JywgJyM0YmFmNGYnLCAnIzdlNWQ0ZScsICcjOWU5ZTllJ107XG5cbiAgICAgICAgICBpZiAoaGFzQ2xlYXIpIHtcbiAgICAgICAgICAgIGRhdGEuc3BsaWNlKDEwLCAwLCAnIzUzNDc0MScpO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIHJlZmluZU1vZGUgPSBzLm1vZGUgPT0gJ3JlZmluZSc7XG4gICAgaGFzUHJldmlldyA9ICFpc05hTihzLnNlbGVjdCk7XG4gICAgbWF4U2VsZWN0ID0gaXNOYU4ocy5zZWxlY3QpID8gc2luZ2xlU2VsZWN0ID8gMiA6IGRhdGEubGVuZ3RoIDogcy5zZWxlY3Q7XG4gICAgcmV0dXJuT2JqID0gJCQxLmlzUGxhaW5PYmplY3QoZGF0YVswXSk7IC8vIGdlbmVyYXRlIHByZXZpZXcgb2JqZWN0XG5cbiAgICBpZiAoaGFzUHJldmlldyAmJiAhT2JqZWN0LmtleXMocHJldmlld1ZhbHVlcykubGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcy5zZWxlY3Q7ICsraSkge1xuICAgICAgICBwcmV2aWV3VmFsdWVzW2ldID0ge307XG4gICAgICAgIHRlbXBQcmV2aWV3VmFsdWVzW2ldID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGVtcENvbG9ycyA9IGRhdGEuc2xpY2UoMCk7IC8vIGNvbnZlcnQgdGVtcENvbG9ycyBpbnRvIG9iamVjdHNcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wQ29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoISQkMS5pc1BsYWluT2JqZWN0KGRhdGFbaV0pKSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRlbXBDb2xvcnNbaV0gPSB7XG4gICAgICAgICAga2V5OiBpLFxuICAgICAgICAgIG5hbWU6IGRhdGFbaV0sXG4gICAgICAgICAgY29sb3I6IGRhdGFbaV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBDb2xvcnNbaV0uY29sb3IgPSBkYXRhW2ldLmNvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiA9IHMuZGVmYXVsdFZhbHVlIHx8IHRlbXBDb2xvcnNbMF0uY29sb3I7XG4gICAgY3VyclZhbHVlID0gZGVmO1xuICAgIGN1cnJIc2xWYWx1ZSA9IGNvbnZlcnRUb0Zvcm1hdChjdXJyVmFsdWUsICdoc2wnKTtcbiAgICBlbmhhbmNlSW5wdXQgPSBzLmVuaGFuY2UgJiYgJGVsbS5pcygnaW5wdXQnKTsgLy8gQ3JlYXRlIGR1bW15IGlucHV0XG5cbiAgICBpZiAoZW5oYW5jZUlucHV0KSB7XG4gICAgICBpZiAoJGVsbS5oYXNDbGFzcygnbWJzYy1jb2xvci1pbnB1dC1oZG4nKSkge1xuICAgICAgICAkaW5wdXQgPSAkZWxtLnByZXYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpbnB1dCA9ICQkMSgnPGRpdiAnICsgKGVsLnBsYWNlaG9sZGVyID8gJ2RhdGEtcGxhY2Vob2xkZXI9XCInICsgZWwucGxhY2Vob2xkZXIgKyAnXCInIDogJycpICsgJyBjbGFzcz1cIm1ic2MtY29udHJvbCBtYnNjLWNvbG9yLWlucHV0ICcgKyAocy5pbnB1dENsYXNzIHx8ICcnKSArICdcIiByZWFkb25seSA+PC9kaXY+Jyk7XG4gICAgICAgICRpbnB1dC5pbnNlcnRCZWZvcmUoJGVsbSk7XG4gICAgICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtY29sb3ItaW5wdXQtaGRuJykuYXR0cigndGFiaW5kZXgnLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIHMuYW5jaG9yID0gJGlucHV0O1xuICAgICAgdGhhdC5hdHRhY2hTaG93KCRpbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmhhbmNlSW5wdXQpIHtcbiAgICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtY29sb3ItaW5wdXQtaGRuJyk7XG4gICAgICAkaW5wdXQucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2NoZWNrU2l6ZSA9IHRydWU7IC8vIENvbnN0cnVjdG9yXG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07IC8vIEV4dGVuZCBkZWZhdWx0c1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9jbGFzczogJ2NvbG9yJyxcbiAgX2RlZmF1bHRzOiBleHRlbmQkMSh7fSwgRnJhbWUucHJvdG90eXBlLl9kZWZhdWx0cywge1xuICAgIGhlYWRlclRleHQ6IGZhbHNlLFxuICAgIHZhbGlkYXRlOiBub29wLFxuICAgIHBhcnNlVmFsdWU6IG5vb3AsXG4gICAgZW5oYW5jZTogdHJ1ZSxcbiAgICByb3dzOiAyLFxuICAgIHNlbGVjdDogJ3NpbmdsZScsXG4gICAgZm9ybWF0OiAnaGV4JyxcbiAgICBuYXZpZ2F0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgY29tcENsYXNzOiAnbWJzYy1jb2xvcidcbiAgfSlcbn07XG5jbGFzc2VzLkNvbG9yID0gQ29sb3I7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5jb2xvciA9IG1vYmlzY3JvbGwudGhlbWVzLmZyYW1lOyAvLyBFeHBvc2UgdXRpbGl0eSBmdW5jdGlvbnNcblxudXRpbC5jb2xvciA9IHtcbiAgaHN2MmhleDogaHN2MmhleCxcbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmhleDogcmdiMmhleCxcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgaGV4MnJnYjogaGV4MnJnYixcbiAgaGV4MmhzdjogaGV4MmhzdixcbiAgaGV4MmhzbDogaGV4MmhzbFxufTtcblxudmFyIE1ic2NDb2xvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NDb2xvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjQ29sb3IoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgX3RoaXMuZW5oYW5jZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5vblNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25JdGVtVGFwID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblByZXZpZXdJdGVtVGFwID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY0NvbG9yLnByb3RvdHlwZS5yZWZyZXNoRGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uub3B0aW9uKCdkYXRhJywgbmV3RGF0YSk7XG4gICAgfTtcbiAgICBNYnNjQ29sb3IucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDb2xvcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0NvbG9yLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gIWRlZXBFcXVhbHNBcnJheSh2LCB0aGlzLmluc3RhbmNlLmdldFZhbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gaW5uZXJWYWx1ZSAhPT0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjQ29sb3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTXVsdGkgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNlbGVjdCAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0ICE9PSAnc2luZ2xlJztcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkuZGF0YSA9IFtdO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNYnNjQ29sb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtY29sb3JdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0NvbG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY0NvbG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnY2xlYXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RhdGEnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtZGF0YScsXSB9LF0sXG4gICAgICAgICdkZWZhdWx0VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2VuaGFuY2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Zvcm1hdCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW5wdXRDbGFzcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbW9kZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbmF2aWdhdGlvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncHJldmlldyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncHJldmlld1RleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Jvd3MnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbHVlVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2VsZWN0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvblNldCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNsZWFyJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uSXRlbVRhcCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblByZXZpZXdJdGVtVGFwJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1jb2xvcicsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1jb2xvckNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0NvbG9yO1xufShNYnNjRnJhbWVCYXNlKSk7XG52YXIgTWJzY0NvbG9yQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0NvbG9yQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NDb2xvckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICBfdGhpcy5lbmhhbmNlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQ29sb3JDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NDb2xvckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQ29sb3JDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY0NvbG9yQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGF0YSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZW5oYW5jZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NDb2xvckNvbXBvbmVudDtcbn0oTWJzY0NvbG9yKSk7XG52YXIgTWJzY0NvbG9yTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjQ29sb3JNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NDb2xvck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjRnJhbWVCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjQ29sb3IsIE1ic2NDb2xvckNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjQ29sb3IsIE1ic2NDb2xvckNvbXBvbmVudF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDb2xvck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjQ29sb3JNb2R1bGU7XG59KCkpO1xuXG52YXIgRGF0ZVRpbWUkMSA9IFNjcm9sbGVyO1xucHJlc2V0cy5kYXRlID0gRGF0ZVRpbWU7XG5wcmVzZXRzLnRpbWUgPSBEYXRlVGltZTtcbnByZXNldHMuZGF0ZXRpbWUgPSBEYXRlVGltZTtcblxudmFyIE1ic2NEYXRlQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NEYXRlQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZUJhc2UoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnZGF0ZSc7XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0RhdGVCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY0RhdGVCYXNlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICBpZiAoKCFpbm5lclZhbHVlICYmIHYpIHx8XG4gICAgICAgICAgICAgICAgKGlubmVyVmFsdWUgJiYgIXYpIHx8XG4gICAgICAgICAgICAgICAgKGlubmVyVmFsdWUgJiYgdiAmJiBpbm5lclZhbHVlLnRvU3RyaW5nKCkgIT09IHYudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NEYXRlQmFzZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6IHRoaXMucHJlc2V0IH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IERhdGVUaW1lJDEodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbml0aWFsVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NEYXRlQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1kdC1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRGF0ZUJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRGF0ZUJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtZGF0ZScsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1kYXRlQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRGF0ZUJhc2U7XG59KE1ic2NEYXRldGltZUJhc2UpKTtcbnZhciBNYnNjRGF0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NEYXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NEYXRlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2RhdGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NEYXRlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWRhdGVdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0RhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY0RhdGU7XG59KE1ic2NEYXRlQmFzZSkpO1xudmFyIE1ic2NEYXRlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0RhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0RhdGVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY0RhdGVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1kYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRGF0ZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRGF0ZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRGF0ZUNvbXBvbmVudDtcbn0oTWJzY0RhdGUpKTtcbnZhciBNYnNjVGltZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NUaW1lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NUaW1lKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5wcmVzZXQgPSAndGltZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NUaW1lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1RpbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtdGltZV0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjVGltZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUaW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtdGltZScsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy10aW1lQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjVGltZTtcbn0oTWJzY0RhdGVCYXNlKSk7XG52YXIgTWJzY1RpbWVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjVGltZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjVGltZUNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NUaW1lQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjVGltZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRpbWUnLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUaW1lQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUaW1lQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NUaW1lQ29tcG9uZW50O1xufShNYnNjVGltZSkpO1xudmFyIE1ic2NEYXRldGltZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NEYXRldGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLnByZXNldCA9ICdkYXRldGltZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NEYXRldGltZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NEYXRldGltZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1kYXRldGltZV0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRGF0ZXRpbWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRGF0ZXRpbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1kYXRldGltZScsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1kYXRldGltZUNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lO1xufShNYnNjRGF0ZUJhc2UpKTtcbnZhciBNYnNjRGF0ZXRpbWVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjRGF0ZXRpbWVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0RhdGV0aW1lQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY0RhdGV0aW1lQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjRGF0ZXRpbWVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1kYXRldGltZScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0RhdGV0aW1lQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NEYXRldGltZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRGF0ZXRpbWVDb21wb25lbnQ7XG59KE1ic2NEYXRldGltZSkpO1xudmFyIGNvbXAkMiA9IFtNYnNjRGF0ZUJhc2UsIE1ic2NEYXRlLCBNYnNjRGF0ZUNvbXBvbmVudCwgTWJzY1RpbWUsIE1ic2NUaW1lQ29tcG9uZW50LCBNYnNjRGF0ZXRpbWUsIE1ic2NEYXRldGltZUNvbXBvbmVudF07XG52YXIgTWJzY0RhdGV0aW1lTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWVNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NEYXRldGltZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjRGF0ZXRpbWVCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXAkMixcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogY29tcCQyXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRGF0ZXRpbWVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lTW9kdWxlO1xufSgpKTtcblxudmFyIFBvcHVwID0gZnVuY3Rpb24gUG9wdXAoZWwsIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIGZ1bmN0aW9uIGFkZENvbnRlbnQoJG0pIHtcbiAgICAkJDEoJy5tYnNjLWZyLWMnLCAkbSkuYXBwZW5kKHRoYXQuX2dldFRleHQobW9iaXNjcm9sbCwgMC43KSk7XG5cbiAgICBpZiAoISQkMSgnLm1ic2MtZnItYycsICRtKS5oYXNDbGFzcygnbWJzYy13ZGctYycpICYmIG1vYmlzY3JvbGwuRW10akMpIHtcbiAgICAgICQkMSgnLm1ic2MtZnItYycsICRtKS5hZGRDbGFzcygnbWJzYy13ZGctYycpLmFwcGVuZCgkZWxtLnNob3coKSk7XG5cbiAgICAgIGlmICghJCQxKCcubWJzYy13LXAnLCAkbSkubGVuZ3RoKSB7XG4gICAgICAgICQkMSgnLm1ic2MtZnItYycsICRtKS5hZGRDbGFzcygnbWJzYy13LXAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcyxcbiAgICAgICRwcmV2LFxuICAgICAgJGVsbSA9ICQkMShlbCksXG4gICAgICB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgRnJhbWUuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVhZHkgPSBmdW5jdGlvbiAoJG0pIHtcbiAgICBpZiAocy5kaXNwbGF5ICE9ICdpbmxpbmUnKSB7XG4gICAgICBhZGRDb250ZW50KCRtKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwSW5zZXJ0ZWQgPSBmdW5jdGlvbiAoJG0pIHtcbiAgICBpZiAocy5kaXNwbGF5ID09ICdpbmxpbmUnKSB7XG4gICAgICBhZGRDb250ZW50KCRtKTtcbiAgICB9XG5cbiAgICAkbS50cmlnZ2VyKCdtYnNjLWVuaGFuY2UnLCBbe1xuICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICBsYW5nOiBzLmxhbmdcbiAgICB9XSk7XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICRlbG0uaGlkZSgpO1xuXG4gICAgaWYgKCRwcmV2ICYmICRwcmV2LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgJHByZXYuYWZ0ZXIoJGVsbSk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgdGhhdC5idXR0b25zLm9rID0ge1xuICAgICAgdGV4dDogcy5va1RleHQsXG4gICAgICBpY29uOiBzLm9rSWNvbixcbiAgICAgIGhhbmRsZXI6ICdzZXQnXG4gICAgfTtcbiAgICBzLmJ1dHRvbnMgPSBzLmJ1dHRvbnMgfHwgKHMuZGlzcGxheSA9PSAnaW5saW5lJyA/IFtdIDogWydvayddKTtcblxuICAgIGlmICghJHByZXYgJiYgJGVsbS5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICRwcmV2ID0gJCQxKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3BvcHVwJykpO1xuICAgICAgJGVsbS5iZWZvcmUoJHByZXYpO1xuICAgIH1cblxuICAgICRlbG0uaGlkZSgpO1xuICB9OyAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5Qb3B1cC5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0NvbnRlbnQ6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgX2NsYXNzOiAncG9wdXAnLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBGcmFtZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgY29tcENsYXNzOiAnbWJzYy13ZGcnLFxuICAgIG9rVGV4dDogJ09LJyxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZVxuICB9KVxufTtcbmNsYXNzZXMuUG9wdXAgPSBQb3B1cDtcbmNsYXNzZXMuV2lkZ2V0ID0gUG9wdXA7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5wb3B1cCA9IG1vYmlzY3JvbGwudGhlbWVzLmZyYW1lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBFdmVudGNhbGVuZGFyID0gU2Nyb2xsZXI7XG5cbmZ1bmN0aW9uIGdldEhlaWdodChlbCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgcmV0dXJuIGVsLmlubmVySGVpZ2h0IHx8IGVsLmNsaWVudEhlaWdodCAtIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pO1xufVxuXG52YXIgZGVmYXVsdHMkNCA9IHtcbiAgdmlldzoge1xuICAgIGNhbGVuZGFyOiB7XG4gICAgICB0eXBlOiAnbW9udGgnLFxuICAgICAgcG9wb3ZlcjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGFsbERheVRleHQ6ICdBbGwtZGF5JyxcbiAgbGFiZWxzU2hvcnQ6IFsnWXJzJywgJ010aHMnLCAnRGF5cycsICdIcnMnLCAnTWlucycsICdTZWNzJ10sXG4gIGV2ZW50VGV4dDogJ2V2ZW50JyxcbiAgZXZlbnRzVGV4dDogJ2V2ZW50cycsXG4gIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cydcbn0sXG4gICAgb3ZlcnJpZGVzID0ge1xuICB5ZWFyQ2hhbmdlOiBmYWxzZSxcbiAgd2Vla0RheXM6ICdzaG9ydCdcbn07XG5cbnByZXNldHMuZXZlbnRjYWxlbmRhciA9IGZ1bmN0aW9uIChpbnN0LCBzZXR0aW5ncywgcmVzcCkge1xuICAvLyBQcml2YXRlIGZ1bmN0aW9uc1xuICAvLyAtLS1cbiAgZnVuY3Rpb24gcHJvY2Vzc1NldHRpbmdzKCkge1xuICAgIHZhciB2aWV3ID0gcy52aWV3LFxuICAgICAgICBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXIsXG4gICAgICAgIGxpc3QgPSB2aWV3LmV2ZW50TGlzdCxcbiAgICAgICAgbW9udGhzID0gcy5tb250aHMsXG4gICAgICAgIHdlZWtzID0gcy53ZWVrcztcblxuICAgIGlmIChjYWxlbmRhcikge1xuICAgICAgaWYgKGNhbGVuZGFyLnR5cGUgPT0gJ3dlZWsnKSB7XG4gICAgICAgIHdlZWtzID0gY2FsZW5kYXIuc2l6ZSB8fCAxO1xuICAgICAgfSBlbHNlIGlmIChjYWxlbmRhci5zaXplKSB7XG4gICAgICAgIG1vbnRocyA9IGNhbGVuZGFyLnNpemU7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Vla3MgPSAwO1xuICAgICAgaXNMaXN0T25seSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIGxpc3RUeXBlID0gbGlzdC50eXBlO1xuICAgICAgbGlzdFNpemUgPSBsaXN0LnNpemUgfHwgMTtcbiAgICB9XG5cbiAgICBtdWx0aUxhYmVsID0gY2FsZW5kYXIgJiYgY2FsZW5kYXIubGFiZWxzO1xuICAgIHNjcm9sbEV2ZW50TGlzdCA9IGxpc3QgJiYgbGlzdC5zY3JvbGxhYmxlO1xuICAgIHNob3dFdmVudExpc3QgPSB2aWV3LmV2ZW50TGlzdDtcbiAgICBzaG93RXZlbnRCdWJibGUgPSBzLmV2ZW50QnViYmxlID09PSB1bmRlZmluZWQgPyBjYWxlbmRhciAmJiBjYWxlbmRhci5wb3BvdmVyIDogcy5ldmVudEJ1YmJsZTtcbiAgICBzLndlZWtzID0gd2Vla3M7XG4gICAgcy5tb250aHMgPSBtb250aHM7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUaXRsZShmaXJzdERheSwgbGFzdERheSkge1xuICAgIHZhciB0aXRsZSxcbiAgICAgICAgbW9udGhJbmRleCA9IChzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0KS5zZWFyY2goL20vaSksXG4gICAgICAgIHllYXJJbmRleCA9IChzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0KS5zZWFyY2goL3kvaSksXG4gICAgICAgIGZpcnN0WWVhciA9IHMuZ2V0WWVhcihmaXJzdERheSksXG4gICAgICAgIGZpcnN0TW9udGggPSBzLmdldE1vbnRoKGZpcnN0RGF5KSxcbiAgICAgICAgbGFzdFllYXIgPSBzLmdldFllYXIobGFzdERheSksXG4gICAgICAgIGxhc3RNb250aCA9IHMuZ2V0TW9udGgobGFzdERheSk7XG5cbiAgICBpbnN0Ll9jaGVja0J0bigkJDEoJy5tYnNjLWNhbC1wcmV2LW0nLCAkY3R4KSwgZ2V0RGF0ZU9ubHkoZmlyc3REYXkpIDw9IGluc3QuX21pbkRhdGUpO1xuXG4gICAgaW5zdC5fY2hlY2tCdG4oJCQxKCcubWJzYy1jYWwtbmV4dC1tJywgJGN0eCksIGdldERhdGVPbmx5KGxhc3REYXkpID49IGluc3QuX21heERhdGUpO1xuXG4gICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICB0aXRsZSA9IGZvcm1hdERhdGUocy5kYXRlRm9ybWF0LCBmaXJzdERheSwgcykgKyAobGlzdFNpemUgPiAxID8gJyAtICcgKyBmb3JtYXREYXRlKHMuZGF0ZUZvcm1hdCwgbGFzdERheSwgcykgOiAnJyk7XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgIHRpdGxlID0gZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGZpcnN0RGF5LCBzKSArICcgLSAnICsgZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGxhc3REYXksIHMpO1xuICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ21vbnRoJykge1xuICAgICAgaWYgKGxpc3RTaXplID09IDEpIHtcbiAgICAgICAgdGl0bGUgPSB5ZWFySW5kZXggPCBtb250aEluZGV4ID8gZmlyc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzW2ZpcnN0TW9udGhdIDogcy5tb250aE5hbWVzW2ZpcnN0TW9udGhdICsgJyAnICsgZmlyc3RZZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUgPSB5ZWFySW5kZXggPCBtb250aEluZGV4ID8gZmlyc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzU2hvcnRbZmlyc3RNb250aF0gKyAnIC0gJyArIGxhc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzU2hvcnRbbGFzdE1vbnRoXSA6IHMubW9udGhOYW1lc1Nob3J0W2ZpcnN0TW9udGhdICsgJyAnICsgZmlyc3RZZWFyICsgJyAtICcgKyBzLm1vbnRoTmFtZXNTaG9ydFtsYXN0TW9udGhdICsgJyAnICsgbGFzdFllYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAneWVhcicpIHtcbiAgICAgIHRpdGxlID0gZmlyc3RZZWFyICsgKGxpc3RTaXplID4gMSA/IFwiIC0gXCIgKyBsYXN0WWVhciA6ICcnKTtcbiAgICB9XG5cbiAgICAkdmlld1RpdGxlLmh0bWwodGl0bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5LCBldmVudE9iaikge1xuICAgIHZhciBkLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBldixcbiAgICAgICAgJGl0ZW1zLFxuICAgICAgICBjb3VudCA9IDAsXG4gICAgICAgIGFsbEV2ZW50cyA9IFtdLFxuICAgICAgICBldmVudEh0bWwgPSAnJyxcbiAgICAgICAgZXZlbnRzID0gW107XG5cbiAgICBpZiAoIWV2ZW50T2JqKSB7XG4gICAgICBldmVudE9iaiA9IGluc3QuX3ByZXBhcmVPYmooZXZlbnRMaXN0LCBmaXJzdERheSwgbGFzdERheSk7XG4gICAgfVxuXG4gICAgZm9yIChkID0gZ2V0RGF0ZU9ubHkoZmlyc3REYXkpOyBkIDw9IGxhc3REYXk7IGQuc2V0RGF0ZShkLmdldERhdGUoKSArIDEpKSB7XG4gICAgICBldiA9IGV2ZW50T2JqW2dldERhdGVPbmx5KGQpXTtcblxuICAgICAgaWYgKGV2ICYmIGV2Lmxlbmd0aCkge1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgZDogbmV3IERhdGUoZCksXG4gICAgICAgICAgbGlzdDogc29ydEV2ZW50cyhldilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2ID0gZXZlbnRzW2ldO1xuICAgICAgICBldmVudEh0bWwgKz0gJzxkaXY+PGRpdiBjbGFzcz1cIm1ic2MtbHYtZ3ItdGl0bGUgbWJzYy1ldmVudC1kYXlcIiBkYXRhLWZ1bGw9XCInICsgZ2V0RGF0ZVN0cihldi5kKSArICdcIj4nICsgZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGV2LmQsIHMpICsgJzwvZGl2Pic7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2Lmxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBldi5saXN0W2pdLFxuICAgICAgICAgICAgICBzdGFydCA9IGV2ZW50LnN0YXJ0ID8gbWFrZURhdGUoZXZlbnQuc3RhcnQpIDogbnVsbCxcbiAgICAgICAgICAgICAgZW5kID0gZXZlbnQuZW5kID8gbWFrZURhdGUoZXZlbnQuZW5kKSA6IG51bGwsXG4gICAgICAgICAgICAgIGNvbG9yID0gZXZlbnQuY29sb3IsXG4gICAgICAgICAgICAgIGlzUmVwZWF0aW5nID0gREFZX09GX1dFRUsudGVzdChldmVudC5kKSB8fCBEQVlfT0ZfTU9OVEgudGVzdChldmVudC5kKSxcbiAgICAgICAgICAgICAgaXNNdWx0aURheSA9IHN0YXJ0ICYmIGVuZCAmJiAhaXNTYW1lRGF5KHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICBpc0ZpcnN0RGF5ID0gaXNNdWx0aURheSA/IGlzU2FtZURheShzdGFydCwgZXYuZCkgOiB0cnVlLFxuICAgICAgICAgICAgICBpc0xhc3REYXkgPSBpc011bHRpRGF5ID8gaXNTYW1lRGF5KGVuZCwgZXYuZCkgOiB0cnVlLFxuICAgICAgICAgICAgICBkdCA9IGV2ZW50LmQgPyBpc1JlcGVhdGluZyA/IGV2ZW50LmQgOiBtYWtlRGF0ZShldmVudC5kKSA6IHN0YXJ0LFxuICAgICAgICAgICAgICBhbGxEYXkgPSBldmVudC5hbGxEYXkgfHwgaXNSZXBlYXRpbmcgfHwgaXNNdWx0aURheSAmJiAhaXNGaXJzdERheSAmJiAhaXNMYXN0RGF5O1xuICAgICAgICAgIGFsbEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGQ6IGV2LmQsXG4gICAgICAgICAgICBlOiBldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50SHRtbCArPSAnPGRpdiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9XCJtYnNjLWx2LWl0ZW0gbWJzYy1sdi1pdGVtLWFjdGlvbmFibGVcIiBkYXRhLWluZGV4PVwiJyArIGNvdW50ICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLWV2ZW50LXRpbWVcIj4nICsgKGFsbERheSA/IHMuYWxsRGF5VGV4dCA6IGlzRmlyc3REYXkgJiYgZHQgJiYgZHQuZ2V0VGltZSA/IGZvcm1hdERhdGUocy50aW1lRm9ybWF0LCBkdCkgOiBpc011bHRpRGF5ICYmIGlzTGFzdERheSA/IHMudG9UZXh0IDogJycpICsgKCFhbGxEYXkgJiYgaXNMYXN0RGF5ICYmIGVuZCAmJiBlbmQuZ2V0VGltZSA/ICc8YnIvPicgKyBmb3JtYXREYXRlKHMudGltZUZvcm1hdCwgZW5kKSA6ICcnKSArICc8L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWV2ZW50LWNvbG9yXCInICsgKGNvbG9yID8gJyBzdHlsZT1cImJhY2tncm91bmQ6JyArIGNvbG9yICsgJztcIicgOiAnJykgKyAnPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtZXZlbnQtdHh0XCI+JyArIGV2ZW50LnRleHQgKyAnPC9kaXY+JyArIGluc3QuX2dldFRleHQobW9iaXNjcm9sbCwgMC4zKSArICc8L2Rpdj4nO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudEh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50SHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtZ3ItdGl0bGUgbWJzYy1ldmVudC1lbXB0eVwiPjxkaXYgY2xhc3M9XCJtYnNjLWVtcHR5XCI+PGgzPicgKyBzLm5vRXZlbnRzVGV4dCArICc8L2gzPjwvZGl2PjwvZGl2Pic7XG4gICAgfVxuXG4gICAgcHJldmVudFNjcm9sbFdhdGNoKys7XG4gICAgJGV2ZW50TGlzdENvbnQuaHRtbCgnPGRpdiBjbGFzcz1cIm1ic2MtbHYgbWJzYy1sdi12XCI+JyArIGV2ZW50SHRtbCArICc8L2Rpdj4nKS5zY3JvbGxUb3AoMCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBOZWVkIHNldFRpbWVvdXQgc2luY2Ugc2Nyb2xsIGxpc3RlbmVyIGlzIHRocm90dGVsZWRcbiAgICAgIHByZXZlbnRTY3JvbGxXYXRjaC0tO1xuICAgIH0sIDE1MCk7XG4gICAgJGl0ZW1zID0gJCQxKCcubWJzYy1sdi1pdGVtJywgJGV2ZW50TGlzdENvbnQpOyAvLyBBc3NpZ24gZXZlbnQgY2xpY2tcblxuICAgIGluc3QudGFwKCRpdGVtcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkYXRhID0gYWxsRXZlbnRzWyQkMSh0aGlzKS5hdHRyKCdkYXRhLWluZGV4JyldO1xuICAgICAgdHJpZ2dlcignb25FdmVudFNlbGVjdCcsIHtcbiAgICAgICAgZG9tRXZlbnQ6IGUsXG4gICAgICAgIGV2ZW50OiBkYXRhLmUsXG4gICAgICAgIGRhdGU6IGRhdGEuZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaGFuZGxlRm9jdXMoJGl0ZW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCRpdGVtcykge1xuICAgICRpdGVtcy5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGV2LmtleUNvZGUgPT09IDEzIHx8IGV2LmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgIHRoaXMuY2xpY2soKTtcbiAgICAgIH1cbiAgICB9KS5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod2luZG93Ll9fbWJzY0ZvY3VzVmlzaWJsZSkge1xuICAgICAgICAkJDEodGhpcykuYWRkQ2xhc3MoJ21ic2MtZm9jdXMnKTtcbiAgICAgIH1cbiAgICB9KS5vbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICQkMSh0aGlzKS5yZW1vdmVDbGFzcygnbWJzYy1mb2N1cycpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRQb3BvdmVyKCkge1xuICAgIGlmIChwb3BvdmVyRGF0YSkge1xuICAgICAgdmFyIGQgPSBnZXREYXRlT25seShwb3BvdmVyRGF0YS5kKSxcbiAgICAgICAgICBldmVudHMgPSBwb3BvdmVyRGF0YS5ldmVudHMgfHwgZXZlbnRPYmpbZF0sXG4gICAgICAgICAgY2VsbCA9IHBvcG92ZXJEYXRhLmNlbGwgfHwgJCQxKCcubWJzYy1jYWwtc2xpZGUtYSAubWJzYy1jYWwtZGF5W2RhdGEtZnVsbD1cIicgKyBnZXREYXRlU3RyKGQpICsgJ1wiXScsIGluc3QuX21hcmt1cClbMF07XG4gICAgICBzaG93RXZlbnRzKGV2ZW50cywgZCwgY2VsbCk7XG4gICAgICBwb3BvdmVyRGF0YSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBsYmwgPSBzLmxhYmVsc1Nob3J0LFxuICAgICAgICB0aW1lID0gZW5kIC0gc3RhcnQsXG4gICAgICAgIHNlY29uZHMgPSBNYXRoLmFicyh0aW1lKSAvIDEwMDAsXG4gICAgICAgIG1pbnV0ZXMgPSBzZWNvbmRzIC8gNjAsXG4gICAgICAgIGhvdXJzID0gbWludXRlcyAvIDYwLFxuICAgICAgICBkYXlzID0gaG91cnMgLyAyNCxcbiAgICAgICAgeWVhcnMgPSBkYXlzIC8gMzY1O1xuICAgIHJldHVybiBzZWNvbmRzIDwgNDUgJiYgTWF0aC5yb3VuZChzZWNvbmRzKSArICcgJyArIGxibFs1XS50b0xvd2VyQ2FzZSgpIHx8IC8vc2Vjb25kcyA8IDkwICYmICcxIG1pbnV0ZScgfHxcbiAgICBtaW51dGVzIDwgNDUgJiYgTWF0aC5yb3VuZChtaW51dGVzKSArICcgJyArIGxibFs0XS50b0xvd2VyQ2FzZSgpIHx8IC8vbWludXRlcyA8IDkwICYmICcxIGhvdXInIHx8XG4gICAgaG91cnMgPCAyNCAmJiBNYXRoLnJvdW5kKGhvdXJzKSArICcgJyArIGxibFszXS50b0xvd2VyQ2FzZSgpIHx8IC8vaG91cnMgPCA0MiAmJiAnMSBkYXknIHx8XG4gICAgZGF5cyA8IDMwICYmIE1hdGgucm91bmQoZGF5cykgKyAnICcgKyBsYmxbMl0udG9Mb3dlckNhc2UoKSB8fCAvL2RheXMgPCA0NSAmJiAnMSBtb250aCcgfHxcbiAgICBkYXlzIDwgMzY1ICYmIE1hdGgucm91bmQoZGF5cyAvIDMwKSArICcgJyArIGxibFsxXS50b0xvd2VyQ2FzZSgpIHx8IC8veWVhcnMgPCAxLjUgJiYgJzEgeWVhcicgfHxcbiAgICBNYXRoLnJvdW5kKHllYXJzKSArICcgJyArIGxibFswXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc29ydEV2ZW50cyhldmVudHMpIHtcbiAgICByZXR1cm4gZXZlbnRzLnNsaWNlKDApLnNvcnQocy5ldmVudE9yZGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dFdmVudHMoZXZlbnRzLCBkLCBjZWxsKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdmFyICRldmVudENvbnQsXG4gICAgICAgICAgJGV2ZW50Q29udElubmVyLFxuICAgICAgICAgICRldmVudFNjcm9sbGVyLFxuICAgICAgICAgIGV2ZW50U2Nyb2xsZXIsXG4gICAgICAgICAgJGl0ZW1zLFxuICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LWxpc3RcIj4nO1xuICAgICAgJGV2ZW50Q29udCA9ICQkMSgnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50cyAnICsgKHMuZXZlbnRCdWJibGVDbGFzcyB8fCAnJykgKyAnXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnRzLWlcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnRzLXNjXCI+JyArICc8L2Rpdj48ZGl2IGNsYXNzPVwibWJzYy1zYy1iYXItY1wiPjxkaXYgY2xhc3M9XCJtYnNjLXNjLWJhclwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PicpO1xuICAgICAgJGV2ZW50Q29udElubmVyID0gJCQxKCcubWJzYy1jYWwtZXZlbnRzLWknLCAkZXZlbnRDb250KTtcbiAgICAgICRldmVudFNjcm9sbGVyID0gJCQxKCcubWJzYy1jYWwtZXZlbnRzLXNjJywgJGV2ZW50Q29udCk7XG4gICAgICBpbnN0LnRhcCgkZXZlbnRDb250SW5uZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFldmVudFNjcm9sbGVyLnNjcm9sbGVkKSB7XG4gICAgICAgICAgaGlkZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBvcHVwID0gbmV3IFBvcHVwKCRldmVudENvbnRbMF0sIHtcbiAgICAgICAgZGlzcGxheTogJ2J1YmJsZScsXG4gICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgIGNvbnRleHQ6IHMuY29udGV4dCxcbiAgICAgICAgYnV0dG9uczogW10sXG4gICAgICAgIGFuY2hvcjogY2VsbCxcbiAgICAgICAgc2hvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICBjc3NDbGFzczogJ21ic2Mtbm8tcGFkZGluZyBtYnNjLWNhbC1ldmVudHMtcG9wdXAnLFxuICAgICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgICBldmVudFNjcm9sbGVyID0gbmV3IFNjcm9sbFZpZXdCYXNlKCRldmVudENvbnRJbm5lclswXSwge1xuICAgICAgICAgICAgc2Nyb2xsYmFyOiAkJDEoJy5tYnNjLXNjLWJhci1jJywgJGV2ZW50Q29udCksXG4gICAgICAgICAgICBzdG9wUHJvcDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkJDEoZG9jdW1lbnQpLm9uKCdjbGljaycsIGhpZGVFdmVudHNPbkNsaWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZShldmVudCwgaW5zdCkge1xuICAgICAgICAgIGluc3QuZGVzdHJveSgpO1xuXG4gICAgICAgICAgaWYgKGV2ZW50U2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50U2Nyb2xsZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkMShkb2N1bWVudCkub2ZmKCdjbGljaycsIGhpZGVFdmVudHNPbkNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFN0b3JlIHRoZSBwb3B1cCBvbiB0aGUgaW5zdGFuY2UsIHdlIG5lZWQgdG8gZGVzdHJveSBpdCBpbiBjYXNlIG9mIGFuIG9wdGlvbiBjYWxsIG9yIHJlLWluaXRcblxuICAgICAgaW5zdC5fcG9wdXAgPSBwb3B1cDtcbiAgICAgIGV2ZW50RGF5ID0gY2VsbDtcbiAgICAgIGV2ZW50cyA9IHNvcnRFdmVudHMoZXZlbnRzKTtcbiAgICAgICQkMS5lYWNoKGV2ZW50cywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZS5zdGFydCA/IG1ha2VEYXRlKGUuc3RhcnQpIDogbnVsbCxcbiAgICAgICAgICAgIGVuZCA9IGUuZW5kID8gbWFrZURhdGUoZS5lbmQpIDogbnVsbCxcbiAgICAgICAgICAgIGlzUmVwZWF0aW5nID0gREFZX09GX1dFRUsudGVzdChlLmQpIHx8IERBWV9PRl9NT05USC50ZXN0KGUuZCksXG4gICAgICAgICAgICBkdCA9IGUuZCA/IGlzUmVwZWF0aW5nID8gZS5kIDogbWFrZURhdGUoZS5kKSA6IHN0YXJ0LFxuICAgICAgICAgICAgaXNNdWx0aURheSA9IHN0YXJ0ICYmIGVuZCAmJiAhaXNTYW1lRGF5KHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgaXNGaXJzdERheSA9IGlzTXVsdGlEYXkgPyBpc1NhbWVEYXkoc3RhcnQsIGQpIDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFzdERheSA9IGlzTXVsdGlEYXkgPyBpc1NhbWVEYXkoZW5kLCBkKSA6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXkgPSBlLmFsbERheSB8fCBpc1JlcGVhdGluZyB8fCBpc011bHRpRGF5ICYmICFpc0ZpcnN0RGF5ICYmICFpc0xhc3REYXksXG4gICAgICAgICAgICBiZyA9IGUuY29sb3IsXG4gICAgICAgICAgICBhcmlhRnJvbSA9ICcnLFxuICAgICAgICAgICAgYXJpYVRvID0gJycsXG4gICAgICAgICAgICBhcmlhTGFiZWwgPSAkJDEoJzxkaXY+JyArIGUudGV4dCArICc8L2Rpdj4nKS50ZXh0KCk7XG5cbiAgICAgICAgaWYgKGR0LmdldFRpbWUpIHtcbiAgICAgICAgICBhcmlhRnJvbSA9IGZvcm1hdERhdGUoKGlzTXVsdGlEYXkgPyAnTU0gZCB5eSAnIDogJycpICsgcy50aW1lRm9ybWF0LCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgYXJpYVRvID0gZm9ybWF0RGF0ZSgoaXNNdWx0aURheSA/ICdNTSBkIHl5ICcgOiAnJykgKyBzLnRpbWVGb3JtYXQsIGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8ZGl2IHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIiB0aXRsZT1cIicgKyBhcmlhTGFiZWwgKyAnXCIgYXJpYS1sYWJlbD1cIicgKyBhcmlhTGFiZWwgKyAoYXJpYUZyb20gPyAnLCAnICsgcy5mcm9tVGV4dCArICc6ICcgKyBhcmlhRnJvbSA6ICcnKSArIChhcmlhVG8gPyAnLCAnICsgcy50b1RleHQgKyAnOiAnICsgYXJpYVRvIDogJycpICsgJ1wiIGNsYXNzPVwibWJzYy1jYWwtZXZlbnQgbWJzYy1sdi1pdGVtIG1ic2MtbHYtaXRlbS1hY3Rpb25hYmxlXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnQtY29sb3JcIiBzdHlsZT1cIicgKyAoYmcgPyAnYmFja2dyb3VuZDonICsgYmcgKyAnOycgOiAnJykgKyAnXCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnQtdGV4dFwiPicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LXRpbWVcIj4nICsgKGFsbERheSA/IHMuYWxsRGF5VGV4dCA6IGlzRmlyc3REYXkgJiYgZHQuZ2V0VGltZSA/IGZvcm1hdERhdGUocy50aW1lRm9ybWF0LCBkdCkgOiAnJykgKyAnPC9kaXY+JyArIGUudGV4dCArICc8L2Rpdj4nICsgKHN0YXJ0ICYmIGVuZCAmJiAhZS5hbGxEYXkgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LWR1clwiPicgKyBzLmZvcm1hdER1cmF0aW9uKHN0YXJ0LCBlbmQsIGUpICsgJzwvZGl2PicgOiAnJykgKyAnPC9kaXY+JztcbiAgICAgIH0pO1xuICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgICRldmVudFNjcm9sbGVyLmh0bWwoaHRtbCk7XG4gICAgICBwb3B1cC5zaG93KCk7XG4gICAgICB0cmlnZ2VyKCdvbkV2ZW50QnViYmxlU2hvdycsIHtcbiAgICAgICAgdGFyZ2V0OiBldmVudERheSxcbiAgICAgICAgZXZlbnRMaXN0OiAkZXZlbnRDb250WzBdXG4gICAgICB9KTtcbiAgICAgICRpdGVtcyA9ICQkMSgnLm1ic2MtY2FsLWV2ZW50JywgJGV2ZW50U2Nyb2xsZXIpOyAvLyBBc3NpZ24gZXZlbnQgY2xpY2tcblxuICAgICAgaW5zdC50YXAoJGl0ZW1zLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWV2ZW50U2Nyb2xsZXIuc2Nyb2xsZWQpIHtcbiAgICAgICAgICB0cmlnZ2VyKCdvbkV2ZW50U2VsZWN0Jywge1xuICAgICAgICAgICAgZG9tRXZlbnQ6IGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnRzWyQkMSh0aGlzKS5pbmRleCgpXSxcbiAgICAgICAgICAgIGRhdGU6IGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBoYW5kbGVGb2N1cygkaXRlbXMpO1xuICAgICAgaGFzRXZlbnRCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICAgIHZhciBkLCB0b3AsIHBhcnRzO1xuXG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsV2F0Y2gpIHtcbiAgICAgICQkMSgnLm1ic2MtZXZlbnQtZGF5JywgdGhpcykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRvcCA9IHRoaXMub2Zmc2V0VG9wIC0gZXZlbnRMaXN0Q29udC5zY3JvbGxUb3A7XG5cbiAgICAgICAgaWYgKHRvcCA+PSAwICYmIHRvcCA8IDM1KSB7XG4gICAgICAgICAgcGFydHMgPSAkJDEodGhpcykuYXR0cignZGF0YS1mdWxsJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICBkID0gYWRqdXN0ZWREYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTtcblxuICAgICAgICAgIGlmICghaXNTYW1lRGF5KGQsIGN1cnJEYXkpKSB7XG4gICAgICAgICAgICBwcmV2ZW50RXZlbnRTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgaW5zdC5zZXRWYWwoZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlRXZlbnRzKCkge1xuICAgIGlmIChwb3B1cCAmJiBoYXNFdmVudEJ1YmJsZSkge1xuICAgICAgcG9wdXAuaGlkZSgpO1xuICAgIH1cblxuICAgIGV2ZW50RGF5ID0gbnVsbDtcbiAgICBoYXNFdmVudEJ1YmJsZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUV2ZW50c09uQ2xpY2soZSkge1xuICAgIGlmICgkJDEoZS50YXJnZXQpLmNsb3Nlc3QoJy5tYnNjLWNhbC1kYXknKS5sZW5ndGggPT0gMCkge1xuICAgICAgaGlkZUV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgaGlkZUV2ZW50cygpO1xuICAgIGluc3QucmVkcmF3KCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdExhc3QoZGF5KSB7XG4gICAgdmFyIHkgPSBzLmdldFllYXIoZGF5KSxcbiAgICAgICAgbSA9IHMuZ2V0TW9udGgoZGF5KSxcbiAgICAgICAgZCA9IHMuZ2V0RGF5KGRheSk7XG4gICAgY3VyckZpcnN0RGF5ID0gZGF5O1xuXG4gICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgbGlzdFNpemUgLSAxKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RUeXBlID09ICd3ZWVrJykge1xuICAgICAgLy8gZ2V0IGZpcnN0IGRheSBvZiB3ZWVrXG4gICAgICB2YXIgZGlmZixcbiAgICAgICAgICB3ZWVrRGF5ID0gY3VyckZpcnN0RGF5LmdldERheSgpO1xuICAgICAgZGlmZiA9IGQgKyBzLmZpcnN0RGF5IC0gKHMuZmlyc3REYXkgLSB3ZWVrRGF5ID4gMCA/IDcgOiAwKSAtIHdlZWtEYXk7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgZGlmZik7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkaWZmICsgbGlzdFNpemUgKiA3IC0gMSk7XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnbW9udGgnKSB7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgMSk7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtICsgbGlzdFNpemUsIDApO1xuICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ3llYXInKSB7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgMCwgMSk7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5ICsgbGlzdFNpemUsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvRGF5KGQsIHByZXZBbmltKSB7XG4gICAgLy8gU2Nyb2xsIHRvIHRoZSBkYXkgaW4gdGhlIGxpc3QsIGlmIGFueVxuICAgIGlmIChzaG93RXZlbnRMaXN0ICYmICFwcmV2ZW50RXZlbnRTY3JvbGwpIHtcbiAgICAgIHZhciAkZGF5ID0gJCQxKCcubWJzYy1ldmVudC1kYXlbZGF0YS1mdWxsPVwiJyArIGdldERhdGVTdHIoZCkgKyAnXCJdJywgJGV2ZW50TGlzdENvbnQpO1xuXG4gICAgICBpZiAoJGRheS5sZW5ndGgpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFdhdGNoKys7XG4gICAgICAgIHNtb290aFNjcm9sbChldmVudExpc3RDb250LCAkZGF5LnBhcmVudCgpWzBdLm9mZnNldFRvcCwgcHJldkFuaW0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBOZWVkIHNldFRpbWVvdXQgc2luY2Ugc2Nyb2xsIGxpc3RlbmVyIGlzIHRocm90dGVsZWRcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxXYXRjaC0tO1xuICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJMb2FkaW5nKGNoYW5nZSwgcmVuZGVyKSB7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgdHJpZ2dlcignb25QYWdlQ2hhbmdlJywge1xuICAgICAgICBmaXJzdERheTogY3VyckZpcnN0RGF5LFxuICAgICAgICBsYXN0RGF5OiBjdXJyTGFzdERheVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZW5kZXIpIHtcbiAgICAgIHRyaWdnZXIoJ29uUGFnZUxvYWRpbmcnLCB7XG4gICAgICAgIGZpcnN0RGF5OiBjdXJyRmlyc3REYXksXG4gICAgICAgIGxhc3REYXk6IGN1cnJMYXN0RGF5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkZWQnLCB7XG4gICAgICBmaXJzdERheTogY3VyckZpcnN0RGF5LFxuICAgICAgbGFzdERheTogY3Vyckxhc3REYXlcbiAgICB9KTtcbiAgfSAvLyAtLS1cblxuXG4gIHZhciBiYXNlLFxuICAgICAgJGN0eCxcbiAgICAgICRldmVudExpc3RDb250LFxuICAgICAgJHZpZXdUaXRsZSxcbiAgICAgIGN1cnJEYXksXG4gICAgICBjdXJyRmlyc3REYXksXG4gICAgICBjdXJyTGFzdERheSxcbiAgICAgIGV2ZW50RGF5LFxuICAgICAgZXZlbnRMaXN0Q29udCxcbiAgICAgIGV2ZW50T2JqLFxuICAgICAgaGFzRXZlbnRCdWJibGUsXG4gICAgICBpc0NoYW5naW5nLFxuICAgICAgaXNMYWJlbFRhcCxcbiAgICAgIGlzTGlzdE9ubHksXG4gICAgICBsaXN0VHlwZSxcbiAgICAgIGxpc3RTaXplLFxuICAgICAgbXVsdGlMYWJlbCxcbiAgICAgIHBvcG92ZXJEYXRhLFxuICAgICAgcG9wdXAsXG4gICAgICBwcmV2ZW50RXZlbnRTY3JvbGwsXG4gICAgICBwcmV2ZW50U2Nyb2xsQW5pbSxcbiAgICAgIHByZXZGaXJzdERheSxcbiAgICAgIHByZXZMYXN0RGF5LFxuICAgICAgc2Nyb2xsRXZlbnRMaXN0LFxuICAgICAgc2hvd0V2ZW50TGlzdCxcbiAgICAgIHNob3dFdmVudEJ1YmJsZSxcbiAgICAgIHNob3dNb3JlLFxuICAgICAgZWxtID0gdGhpcyxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgZGVmYXVsdHMkNCwgb3JpZywgb3ZlcnJpZGVzLCBzZXR0aW5ncywgcmVzcCksXG4gICAgICBwcmV2ZW50U2Nyb2xsV2F0Y2ggPSAwLFxuICAgICAgZXZlbnRJRCA9IDAsXG4gICAgICBldmVudExpc3QgPSBleHRlbmQkMSh0cnVlLCBbXSwgcy5kYXRhKSxcbiAgICAgIGZpcnN0TG9hZCA9IHRydWUsXG4gICAgICB0cmlnZ2VyID0gaW5zdC50cmlnZ2VyOyAvLyBLZWVwIHRyYWNraW5nIGV2ZW50cyBpbiBzZXR0aW5ncyxcbiAgLy8gb3RoZXJ3aXNlIGNoYW5nZXMgd2lsbCBiZSBsb3N0IG9uIGFuIGV2ZW50dWFsIG9wdGlvbiBjYWxsXG5cbiAgcy5kYXRhID0gZXZlbnRMaXN0O1xuICAkJDEuZWFjaChldmVudExpc3QsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgaWYgKGUuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGUuX2lkID0gZXZlbnRJRCsrO1xuICAgIH1cbiAgfSk7XG4gIHByb2Nlc3NTZXR0aW5ncygpO1xuICBiYXNlID0gQ2FsZW5kYXJCYXNlLmNhbGwodGhpcywgaW5zdCk7IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cbiAgaW5zdC5fb25HZW5Nb250aCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgZXZlbnRPYmogPSBpbnN0Ll9wcmVwYXJlT2JqKGV2ZW50TGlzdCwgc3RhcnQsIGVuZCk7XG4gICAgaW5zdC5fbGFiZWxzID0gbXVsdGlMYWJlbCA/IGV2ZW50T2JqIDogbnVsbDtcbiAgfTtcblxuICBpbnN0Ll9vblJlZnJlc2ggPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgcHJldmVudFNjcm9sbEFuaW0gPSB0cnVlOyAvLyBXaWxsIHJlLWNyZWF0ZSB0aGUgbGlzdFxuXG4gICAgcHJldkZpcnN0RGF5ID0gbnVsbDtcbiAgICBwcmV2TGFzdERheSA9IG51bGw7XG5cbiAgICBpZiAoaXNMaXN0T25seSkge1xuICAgICAgdHJpZ2dlckxvYWRpbmcoZmFsc2UsIHJlbmRlcik7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuX29uU2V0RGF0ZSA9IGZ1bmN0aW9uIChkLCBkaWZmKSB7XG4gICAgY3VyckRheSA9IGQ7XG5cbiAgICBpZiAoaXNMaXN0T25seSkge1xuICAgICAgaWYgKCFwcmV2ZW50RXZlbnRTY3JvbGwgJiYgIWlzQ2hhbmdpbmcpIHtcbiAgICAgICAgZ2V0Rmlyc3RMYXN0KGQpO1xuXG4gICAgICAgIGlmICghcHJldkZpcnN0RGF5IHx8ICFwcmV2TGFzdERheSB8fCAhaXNTYW1lRGF5KHByZXZGaXJzdERheSwgY3VyckZpcnN0RGF5KSB8fCAhaXNTYW1lRGF5KHByZXZMYXN0RGF5LCBjdXJyTGFzdERheSkpIHtcbiAgICAgICAgICB0cmlnZ2VyTG9hZGluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWRpZmYgJiYgIWlzQ2hhbmdpbmcpIHtcbiAgICAgIGhpZGVFdmVudHMoKTtcblxuICAgICAgaWYgKHNob3dFdmVudExpc3QgJiYgbGlzdFR5cGUgPT0gJ2RheScpIHtcbiAgICAgICAgLy8gTGlzdCBldmVudHMgZm9yIHRoZSBkYXlcbiAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGQsIGQsIGV2ZW50T2JqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzaG93RXZlbnRCdWJibGUgfHwgc2hvd01vcmUpICYmICFpc0xhYmVsVGFwKSB7XG4gICAgICAgIC8vIFNob3cgZXZlbnQgcG9wb3ZlclxuICAgICAgICBjcmVhdGVFdmVudFBvcG92ZXIoKTtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsVG9EYXkoZCk7XG4gICAgfVxuXG4gICAgcHJldmVudEV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgc2hvd01vcmUgPSBmYWxzZTtcbiAgICBpc0xhYmVsVGFwID0gZmFsc2U7XG4gIH07XG5cbiAgaW5zdC5fZ2V0RGF5UHJvcHMgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBldmVudHMgPSBldmVudE9ialtkXSxcbiAgICAgICAgcmV0ID0ge1xuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9O1xuXG4gICAgaWYgKCFzLm1hcmtlZCAmJiAhcy5sYWJlbHMgJiYgIW11bHRpTGFiZWwpIHtcbiAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgcmV0LmJhY2tncm91bmQgPSBldmVudHNbMF0gJiYgZXZlbnRzWzBdLmJhY2tncm91bmQ7XG4gICAgICAgIHJldC5tYXJrZWQgPSBldmVudHM7IC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgcmV0Lm1hcmt1cCA9IHMuc2hvd0V2ZW50Q291bnQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXR4dFwiPicgKyBldmVudHMubGVuZ3RoICsgJyAnICsgKGV2ZW50cy5sZW5ndGggPiAxID8gcy5ldmVudHNUZXh0IDogcy5ldmVudFRleHQpICsgJzwvZGl2PicgOiAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtzXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm1hcmt1cCA9IHMuc2hvd0V2ZW50Q291bnQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXR4dC1waFwiPjwvZGl2PicgOiAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIGluc3QuYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGV2ZW50cyA9IGV4dGVuZCQxKHRydWUsIFtdLCAkJDEuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogW2V2ZW50c10pO1xuICAgICQkMS5lYWNoKGV2ZW50cywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgIGlmIChlLl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGUuX2lkID0gZXZlbnRJRCsrO1xuICAgICAgfVxuXG4gICAgICBldmVudExpc3QucHVzaChlKTtcbiAgICAgIHJldC5wdXNoKGUuX2lkKTtcbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBpbnN0LnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgJCQxLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbiAoaiwgZSkge1xuICAgICAgaWYgKGUuX2lkID09PSBldmVudC5faWQpIHtcbiAgICAgICAgZXZlbnRMaXN0LnNwbGljZShqLCAxLCBldmVudCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gIH07XG5cbiAgaW5zdC5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlaWRzKSB7XG4gICAgZWlkcyA9ICQkMS5pc0FycmF5KGVpZHMpID8gZWlkcyA6IFtlaWRzXTtcbiAgICAkJDEuZWFjaChlaWRzLCBmdW5jdGlvbiAoaSwgZWlkKSB7XG4gICAgICAkJDEuZWFjaChldmVudExpc3QsIGZ1bmN0aW9uIChqLCBlKSB7XG4gICAgICAgIGlmIChlLl9pZCA9PT0gZWlkKSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlZnJlc2goKTtcbiAgfTtcblxuICBpbnN0LmdldEV2ZW50cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIG9iajtcblxuICAgIGlmIChkKSB7XG4gICAgICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgb2JqID0gaW5zdC5fcHJlcGFyZU9iaihldmVudExpc3QsIGQsIGQpO1xuICAgICAgcmV0dXJuIG9ialtkXSA/IHNvcnRFdmVudHMob2JqW2RdKSA6IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQkMSh0cnVlLCBbXSwgZXZlbnRMaXN0KTtcbiAgfTtcblxuICBpbnN0LnNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgcy5kYXRhID0gZXZlbnRMaXN0ID0gZXh0ZW5kJDEodHJ1ZSwgW10sIGV2ZW50cyk7XG4gICAgJCQxLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgaWYgKGUuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZS5faWQgPSBldmVudElEKys7XG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKGUuX2lkKTtcbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBpbnN0Lm5hdmlnYXRlID0gZnVuY3Rpb24gKGQsIGFuaW0sIHBvcCkge1xuICAgIGQgPSBtYWtlRGF0ZShkLCBpbnN0Ll9mb3JtYXQsIHMpO1xuICAgIHBvcG92ZXJEYXRhID0gcG9wID8ge1xuICAgICAgZDogZFxuICAgIH0gOiBudWxsO1xuICAgIGluc3Quc2V0VmFsKGQsIHRydWUsIHRydWUsIGZhbHNlLCBhbmltID8gMjAwIDogMCk7XG4gIH07IC8vIC0tLVxuXG5cbiAgcmV0dXJuIGV4dGVuZCQxKHt9LCBiYXNlLCB7XG4gICAgbXVsdGlMYWJlbDogbXVsdGlMYWJlbCxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICBidXR0b25zOiBzLmRpc3BsYXkgIT09ICdpbmxpbmUnID8gWydjbG9zZSddIDogcy5idXR0b25zLFxuICAgIGNvbXBDbGFzczogJ21ic2MtZXYtY2FsIG1ic2MtY2FsZW5kYXIgbWJzYy1kdCBtYnNjLXNjJyxcbiAgICBmb3JtYXREdXJhdGlvbjogZm9ybWF0RHVyYXRpb24sXG4gICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldiwgaW5zdCkge1xuICAgICAgJGN0eCA9ICQkMShldi50YXJnZXQpO1xuICAgICAgY3VyckRheSA9IGluc3QuZ2V0RGF0ZSh0cnVlKTtcblxuICAgICAgaWYgKHNob3dFdmVudExpc3QpIHtcbiAgICAgICAgJGV2ZW50TGlzdENvbnQgPSAkJDEoJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWNvbnQgbWJzYy1sdi0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy1sdi0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAoc2Nyb2xsRXZlbnRMaXN0ID8gJyBtYnNjLWV2ZW50LWxpc3QtaCcgOiAnJykgKyAnIG1ic2MtZXZlbnQtbGlzdFwiPjwvZGl2PicpLmFwcGVuZFRvKCQkMSgnLm1ic2MtZnItdycsICRjdHgpKTtcbiAgICAgICAgJGV2ZW50TGlzdENvbnQub24oJ3Njcm9sbCcsIHRocm90dGxlKG9uU2Nyb2xsKSk7XG4gICAgICAgIGV2ZW50TGlzdENvbnQgPSAkZXZlbnRMaXN0Q29udFswXTtcbiAgICAgIH1cblxuICAgICAgYmFzZS5vbk1hcmt1cFJlYWR5LmNhbGwodGhpcywgZXYpO1xuICAgICAgJHZpZXdUaXRsZSA9ICQkMSgnLm1ic2MtY2FsLW1vbnRoJywgJGN0eCk7XG4gICAgICBoYXNFdmVudEJ1YmJsZSA9IGZhbHNlO1xuICAgICAgZ2V0Rmlyc3RMYXN0KGN1cnJEYXkpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50TGlzdCAmJiBpc0xpc3RPbmx5KSB7XG4gICAgICAgIHRyaWdnZXJMb2FkaW5nKCk7IC8vIEluaXQgbmF2aWdhdGlvbiBhcnJvd3NcblxuICAgICAgICBjcmVhdGVTdGVwcGVyKCQkMSgnLm1ic2MtY2FsLWJ0bicsICRjdHgpLCBmdW5jdGlvbiAoaSwgZGlmZikge1xuICAgICAgICAgIHZhciB5ID0gcy5nZXRZZWFyKGN1cnJGaXJzdERheSksXG4gICAgICAgICAgICAgIG0gPSBzLmdldE1vbnRoKGN1cnJGaXJzdERheSksXG4gICAgICAgICAgICAgIGQgPSBzLmdldERheShjdXJyRmlyc3REYXkpO1xuXG4gICAgICAgICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICAgICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgZCArIGRpZmYgKiBsaXN0U2l6ZSk7XG4gICAgICAgICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgKGRpZmYgKyAxKSAqIGxpc3RTaXplIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgICAgICAgIGN1cnJGaXJzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgZGlmZiAqIGxpc3RTaXplICogNyk7XG4gICAgICAgICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgKGRpZmYgKyAxKSAqIGxpc3RTaXplICogNyAtIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ21vbnRoJykge1xuICAgICAgICAgICAgY3VyckZpcnN0RGF5ID0gcy5nZXREYXRlKHksIG0gKyBkaWZmICogbGlzdFNpemUsIDEpO1xuICAgICAgICAgICAgY3Vyckxhc3REYXkgPSBzLmdldERhdGUoeSwgbSArIChkaWZmICsgMSkgKiBsaXN0U2l6ZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAneWVhcicpIHtcbiAgICAgICAgICAgIGN1cnJGaXJzdERheSA9IHMuZ2V0RGF0ZSh5ICsgZGlmZiAqIGxpc3RTaXplLCAwLCAxKTtcbiAgICAgICAgICAgIGN1cnJMYXN0RGF5ID0gcy5nZXREYXRlKHkgKyAoZGlmZiArIDEpICogbGlzdFNpemUsIDAsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXJMb2FkaW5nKHRydWUpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfVxuXG4gICAgICBhZGRXaW5kb3dGb2N1cygpO1xuICAgIH0sXG4gICAgb25EYXlDaGFuZ2U6IGZ1bmN0aW9uIG9uRGF5Q2hhbmdlKGRheSkge1xuICAgICAgdmFyIGNlbGwgPSBkYXkudGFyZ2V0LFxuICAgICAgICAgIHNob3cgPSBjZWxsICE9PSBldmVudERheTtcblxuICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgc2hvd01vcmUgPSBzaG93RXZlbnRCdWJibGUgIT09IGZhbHNlICYmICQkMSgnLm1ic2MtY2FsLXR4dC1tb3JlJywgY2VsbCkubGVuZ3RoO1xuICAgICAgICBwb3BvdmVyRGF0YSA9IHtcbiAgICAgICAgICBkOiBkYXkuZGF0ZSxcbiAgICAgICAgICBjZWxsOiBzLm91dGVyTW9udGhDaGFuZ2UgJiYgJCQxKGNlbGwpLmhhc0NsYXNzKCdtYnNjLWNhbC1kYXktZGlmZicpID8gbnVsbCA6IGNlbGwsXG4gICAgICAgICAgZXZlbnRzOiBkYXkuZXZlbnRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkxhYmVsVGFwOiBmdW5jdGlvbiBvbkxhYmVsVGFwKGV2KSB7XG4gICAgICBpZiAoZXYubGFiZWwpIHtcbiAgICAgICAgdHJpZ2dlcignb25FdmVudFNlbGVjdCcsIHtcbiAgICAgICAgICBkb21FdmVudDogZXYuZG9tRXZlbnQsXG4gICAgICAgICAgZXZlbnQ6IGV2LmxhYmVsLFxuICAgICAgICAgIGRhdGU6IGV2LmRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlzTGFiZWxUYXAgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25QYWdlQ2hhbmdlOiBmdW5jdGlvbiBvblBhZ2VDaGFuZ2UoZXYpIHtcbiAgICAgIGhpZGVFdmVudHMoKTtcbiAgICAgIGlzQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWluc3QuX2lzU2V0RGF0ZSkge1xuICAgICAgICBpbnN0LnNldFZhbChldi5maXJzdERheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblBhZ2VMb2FkZWQ6IGZ1bmN0aW9uIG9uUGFnZUxvYWRlZChldikge1xuICAgICAgdmFyIGZpcnN0RGF5ID0gZXYuZmlyc3REYXksXG4gICAgICAgICAgbGFzdERheSA9IGV2Lmxhc3REYXk7XG5cbiAgICAgIGlmIChzaG93RXZlbnRMaXN0KSB7XG4gICAgICAgIGlmIChpc0xpc3RPbmx5KSB7XG4gICAgICAgICAgaWYgKCFwcmV2Rmlyc3REYXkgfHwgIXByZXZMYXN0RGF5IHx8ICFpc1NhbWVEYXkocHJldkZpcnN0RGF5LCBmaXJzdERheSkgfHwgIWlzU2FtZURheShwcmV2TGFzdERheSwgbGFzdERheSkpIHtcbiAgICAgICAgICAgIHByZXZGaXJzdERheSA9IGZpcnN0RGF5O1xuICAgICAgICAgICAgcHJldkxhc3REYXkgPSBsYXN0RGF5O1xuICAgICAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5KTtcbiAgICAgICAgICAgIHVwZGF0ZVRpdGxlKGZpcnN0RGF5LCBsYXN0RGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxpc3RUeXBlID09ICdtb250aCcpIHtcbiAgICAgICAgICAgIC8vIG1vbnRoIHZpZXdcbiAgICAgICAgICAgIGxhc3REYXkgPSBzLmdldERhdGUocy5nZXRZZWFyKGZpcnN0RGF5KSwgcy5nZXRNb250aChmaXJzdERheSkgKyBsaXN0U2l6ZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgICAgICAgIC8vIHdlZWsgdmlld1xuICAgICAgICAgICAgbGFzdERheSA9IHMuZ2V0RGF0ZShzLmdldFllYXIoZmlyc3REYXkpLCBzLmdldE1vbnRoKGZpcnN0RGF5KSwgcy5nZXREYXkoZmlyc3REYXkpICsgbGlzdFNpemUgKiA3IC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gaW5zdC5nZXRWYWwodHJ1ZSk7XG4gICAgICAgICAgICBsYXN0RGF5ID0gZmlyc3REYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5LCBldmVudE9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpcnN0TG9hZCAmJiAhaXNTYW1lRGF5KGN1cnJEYXksIGZpcnN0RGF5KSkge1xuICAgICAgICAgIHNjcm9sbFRvRGF5KGN1cnJEYXksIHByZXZlbnRTY3JvbGxBbmltKTtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsQW5pbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93RXZlbnRCdWJibGUpIHtcbiAgICAgICAgY3JlYXRlRXZlbnRQb3BvdmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uUG9zaXRpb246IGZ1bmN0aW9uIG9uUG9zaXRpb24oZXYpIHtcbiAgICAgIGJhc2Uub25Qb3NpdGlvbi5jYWxsKHRoaXMsIGV2KTtcblxuICAgICAgaWYgKHBvcHVwKSB7XG4gICAgICAgIHBvcHVwLnBvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93RXZlbnRMaXN0ICYmIHNjcm9sbEV2ZW50TGlzdCkge1xuICAgICAgICAkZXZlbnRMaXN0Q29udC5hZGRDbGFzcygnbWJzYy1ldmVudC1saXN0LWgnKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBzLmRpc3BsYXkgPT0gJ2lubGluZScgPyBlbG0ucGFyZW50Tm9kZSA6IHdpbmRvdyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGdldEhlaWdodChjb250ZXh0KSxcbiAgICAgICAgICAgIGxpc3RIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQgLSBldi5wb3B1cC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGV2ZW50TGlzdENvbnQuc3R5bGUuaGVpZ2h0ID0gbGlzdEhlaWdodCA+IDIwMCA/IGxpc3RIZWlnaHQgKyAncHgnIDogJyc7XG4gICAgICAgICRldmVudExpc3RDb250LnJlbW92ZUNsYXNzKCdtYnNjLWV2ZW50LWxpc3QtaCcpO1xuXG4gICAgICAgIGlmIChmaXJzdExvYWQgJiYgbGlzdEhlaWdodCkge1xuICAgICAgICAgIHNjcm9sbFRvRGF5KGN1cnJEYXksIHRydWUpO1xuICAgICAgICAgIGZpcnN0TG9hZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgIGJhc2Uub25IaWRlLmNhbGwodGhpcyk7IC8vIERlc3Ryb3kgdGhlIHBvcHVwIHN0b3JlZCBvbiB0aGUgaW5zdGFuY2UsXG4gICAgICAvLyB0aGUgbG9jYWwgdmFyaWFibGUgaXMgbG9zdCBpbiBjYXNlIG9mIG9wdGlvbiBjYWxsIG9yIHJlLWluaXRcblxuICAgICAgaWYgKGluc3QuX3BvcHVwKSB7XG4gICAgICAgIGluc3QuX3BvcHVwLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlV2luZG93Rm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIE1ic2NFdmVudGNhbGVuZGFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0V2ZW50Y2FsZW5kYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0V2ZW50Y2FsZW5kYXIoaW5pdGlhbEVsZW0sIHpvbmUsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG51bGwsIG51bGwsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5vbkV2ZW50U2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkNlbGxIb3ZlckluID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkNlbGxIb3Zlck91dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25EYXlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU2V0RGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZS5yZWZyZXNoRGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0RXZlbnRzKG5ld0RhdGEpO1xuICAgIH07XG4gICAgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAnZXZlbnRjYWxlbmRhcicgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRXZlbnRjYWxlbmRhcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5kYXRhID0gW107XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBNYnNjRXZlbnRjYWxlbmRhci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1ldmVudGNhbGVuZGFyXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NFdmVudGNhbGVuZGFyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRXZlbnRjYWxlbmRhci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2RhdGEnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtZGF0YScsXSB9LF0sXG4gICAgICAgICdsYXlvdXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Nob3dFdmVudENvdW50JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdldmVudEJ1YmJsZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZm9ybWF0RHVyYXRpb24nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZpZXcnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2FsbERheVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2V2ZW50VGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXZlbnRzVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWxzU2hvcnQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ25vRXZlbnRzVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25FdmVudFNlbGVjdCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNlbGxIb3ZlckluJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQ2VsbEhvdmVyT3V0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uRGF5Q2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uU2V0RGF0ZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NFdmVudGNhbGVuZGFyO1xufShNYnNjQ2FsQmFzZSkpO1xudmFyIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG9wdGlvblNlcnZpY2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5kaXNwbGF5IHx8IHRoaXMuZGlzcGxheTtcbiAgICAgICAgaWYgKCFkaXNwbGF5KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIHRoaXMuaW5saW5lT3B0aW9uc09iai5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZXZlbnRjYWxlbmRhcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdkYXRhJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQ7XG59KE1ic2NFdmVudGNhbGVuZGFyKSk7XG52YXIgTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NFdmVudGNhbGVuZGFyTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjRXZlbnRjYWxlbmRhck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWJzY0NhbEJhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjRXZlbnRjYWxlbmRhciwgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY0V2ZW50Y2FsZW5kYXIsIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50XVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGU7XG59KCkpO1xuXG52YXIgaGFzUHJvbWlzZSA9IGlzQnJvd3NlciAmJiAhIXdpbmRvdy5Qcm9taXNlO1xudmFyIHBvcHVwUXVldWUgPSBbXTtcbnZhciBub3RpZmljYXRpb25RdWV1ZSA9IFtdO1xudmFyIGFjdGl2ZU5vdGlmaWNhdGlvbjtcblxuZnVuY3Rpb24gc2hvd1BvcHVwKHBvcHVwKSB7XG4gIGlmICghcG9wdXBRdWV1ZS5sZW5ndGgpIHtcbiAgICBwb3B1cC5zaG93KCk7XG4gIH1cblxuICBwb3B1cFF1ZXVlLnB1c2gocG9wdXApO1xufVxuXG5mdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICB2YXIgaXNBbnkgPSBub3RpZmljYXRpb25RdWV1ZS5sZW5ndGg7XG4gIG5vdGlmaWNhdGlvblF1ZXVlLnB1c2gobm90aWZpY2F0aW9uKTsgLy8gT25seSBzaG93IG5vdGlmaWNhdGlvbiBpZiBubyBwb3B1cCBpcyB2aXNpYmxlXG4gIC8vIG90aGVyd2lzZSBwb3N0cG9uZSBpdCB1bnRpbCBwb3B1cCBpcyBjbG9zZWRcblxuICBpZiAoIXBvcHVwUXVldWUubGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlcmUncyBhIHZpc2libGUgbm90aWZpY2F0aW9uLCBoaWRlIGl0LlxuICAgIC8vIFRoZSBub3RpZmljYXRpb24gd2lsbCBiZSBzaG93biBhZnRlciBoaWRlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuICAgIGlmIChpc0FueSkge1xuICAgICAgbm90aWZpY2F0aW9uUXVldWVbMF0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcmV2ZW50IGZvY3VzIG9uIHNob3cgZm9yIG5vdGlmaWNhdGlvbnNcbiAgICAgIG5vdGlmaWNhdGlvbi5zaG93KGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0dGluZ3MocXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCBtb3JlKSB7XG4gIC8vY29uc3QgYWN0aXZlID0gbW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZTtcbiAgcmV0dXJuIGV4dGVuZCQxKHtcbiAgICBkaXNwbGF5OiBzZXR0aW5ncy5kaXNwbGF5IHx8ICdjZW50ZXInLFxuICAgIGNzc0NsYXNzOiAnbWJzYy1hbGVydCcsXG4gICAgb2tUZXh0OiBzZXR0aW5ncy5va1RleHQsXG4gICAgY2FuY2VsVGV4dDogc2V0dGluZ3MuY2FuY2VsVGV4dCxcbiAgICBjb250ZXh0OiBzZXR0aW5ncy5jb250ZXh0LFxuICAgIHRoZW1lOiBzZXR0aW5ncy50aGVtZSxcbiAgICBjbG9zZU9uT3ZlcmxheVRhcDogZmFsc2UsXG4gICAgb25CZWZvcmVDbG9zZTogZnVuY3Rpb24gb25CZWZvcmVDbG9zZSgpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZShldiwgaW5zdCkge1xuICAgICAgLy9tb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID0gYWN0aXZlO1xuICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbnN0Ll9yZXNvbHZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmNhbGxiYWNrKSB7XG4gICAgICAgIHNldHRpbmdzLmNhbGxiYWNrKGluc3QuX3Jlc29sdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICBpbnN0LmRlc3Ryb3koKTtcbiAgICAgIH0gLy8gU2hvdyBuZXh0XG5cblxuICAgICAgaWYgKHBvcHVwUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHBvcHVwUXVldWVbMF0uc2hvdygpO1xuICAgICAgfSBlbHNlIGlmIChub3RpZmljYXRpb25RdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBvbiBzaG93IGZvciBub3RpZmljYXRpb25zXG4gICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlWzBdLnNob3coZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgbW9yZSk7XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2V0dGluZ3MpIHtcbiAgcmV0dXJuIChzZXR0aW5ncy50aXRsZSA/ICc8aDI+JyArIHNldHRpbmdzLnRpdGxlICsgJzwvaDI+JyA6ICcnKSArICc8cD4nICsgKHNldHRpbmdzLm1lc3NhZ2UgfHwgJycpICsgJzwvcD4nO1xufVxuXG5mdW5jdGlvbiBzaG93QWxlcnQocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKSB7XG4gIHZhciBpbnN0ID0gbmV3IFBvcHVwKHBvcHVwLCBnZXRTZXR0aW5ncyhwb3B1cFF1ZXVlLCBzZXR0aW5ncywgcmVzb2x2ZSkpO1xuICBzaG93UG9wdXAoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHNob3dDb25maXJtKHBvcHVwLCBzZXR0aW5ncywgcmVzb2x2ZSkge1xuICB2YXIgaW5zdCA9IG5ldyBQb3B1cChwb3B1cCwgZ2V0U2V0dGluZ3MocG9wdXBRdWV1ZSwgc2V0dGluZ3MsIHJlc29sdmUsIHtcbiAgICBidXR0b25zOiBbJ2NhbmNlbCcsICdvayddLFxuICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldCgpIHtcbiAgICAgIGluc3QuX3Jlc29sdmUgPSB0cnVlO1xuICAgIH1cbiAgfSkpO1xuICBpbnN0Ll9yZXNvbHZlID0gZmFsc2U7XG4gIHNob3dQb3B1cChpbnN0KTtcbn1cblxuZnVuY3Rpb24gc2hvd1Byb21wdChwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUpIHtcbiAgdmFyIGlucHV0LCBsYWJlbDtcbiAgdmFyIGluc3QgPSBuZXcgUG9wdXAocG9wdXAsIGdldFNldHRpbmdzKHBvcHVwUXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCB7XG4gICAgYnV0dG9uczogWydjYW5jZWwnLCAnb2snXSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2ZW50LCBpbnN0KSB7XG4gICAgICB2YXIgcyA9IGluc3Quc2V0dGluZ3M7XG4gICAgICBsYWJlbCA9IGluc3QuX21hcmt1cC5maW5kKCdsYWJlbCcpO1xuICAgICAgbGFiZWwuYWRkQ2xhc3MoJ21ic2MtJyArIHMudGhlbWUgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpKTtcbiAgICAgIGlucHV0ID0gaW5zdC5fbWFya3VwLmZpbmQoJ2lucHV0JylbMF07XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgfSxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoKSB7XG4gICAgICBpbnN0Ll9yZXNvbHZlID0gaW5wdXQudmFsdWU7XG4gICAgfVxuICB9KSk7XG4gIGluc3QuX3Jlc29sdmUgPSBudWxsO1xuICBzaG93UG9wdXAoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHNob3dTbmFja2Jhcihwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUsIGNzc0NsYXNzLCBhbmltYXRpb24pIHtcbiAgdmFyIG5vdGlmaWNhdGlvblRpbWVyO1xuICB2YXIgaW5zdCA9IG5ldyBQb3B1cChwb3B1cCwgZ2V0U2V0dGluZ3Mobm90aWZpY2F0aW9uUXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCB7XG4gICAgZGlzcGxheTogc2V0dGluZ3MuZGlzcGxheSB8fCAnYm90dG9tJyxcbiAgICBhbmltYXRlOiBhbmltYXRpb24sXG4gICAgY3NzQ2xhc3M6IChjc3NDbGFzcyB8fCAnbWJzYy1zbmFja2JhcicpICsgKHNldHRpbmdzLmNvbG9yID8gJyBtYnNjLScgKyBzZXR0aW5ncy5jb2xvciA6ICcnKSxcbiAgICBzY3JvbGxMb2NrOiBmYWxzZSxcbiAgICBmb2N1c1RyYXA6IGZhbHNlLFxuICAgIGJ1dHRvbnM6IFtdLFxuICAgIG9uTWFya3VwUmVhZHk6IGZ1bmN0aW9uIG9uTWFya3VwUmVhZHkoZXZlbnQsIGluc3QpIHtcbiAgICAgIHZhciBzID0gaW5zdC5zZXR0aW5ncztcblxuICAgICAgdmFyIGJ1dHRvbiA9IGluc3QuX21hcmt1cC5maW5kKCdidXR0b24nKTtcblxuICAgICAgYnV0dG9uLmFkZENsYXNzKCdtYnNjLScgKyBzLnRoZW1lICsgKHMuYmFzZVRoZW1lID8gJyBtYnNjLScgKyBzLmJhc2VUaGVtZSA6ICcnKSk7XG4gICAgfSxcbiAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdyhldiwgaW5zdCkge1xuICAgICAgYWN0aXZlTm90aWZpY2F0aW9uID0gaW5zdDtcblxuICAgICAgaWYgKHNldHRpbmdzLmR1cmF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICBub3RpZmljYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgICBpbnN0LmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNldHRpbmdzLmR1cmF0aW9uIHx8IDMwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3MuYnV0dG9uKSB7XG4gICAgICAgIGluc3QudGFwKCQkMSgnLm1ic2Mtc25hY2tiYXItYnRuJywgZXYudGFyZ2V0KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGlkZSgpO1xuXG4gICAgICAgICAgaWYgKHNldHRpbmdzLmJ1dHRvbi5hY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmJ1dHRvbi5hY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZSgpIHtcbiAgICAgIGFjdGl2ZU5vdGlmaWNhdGlvbiA9IG51bGw7XG4gICAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uVGltZXIpO1xuICAgIH1cbiAgfSkpO1xuICBzaG93Tm90aWZpY2F0aW9uKGluc3QpO1xufVxuXG5mdW5jdGlvbiBzaG93VG9hc3QocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKSB7XG4gIHNob3dTbmFja2Jhcihwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUsICdtYnNjLXRvYXN0JywgJ2ZhZGUnKTtcbn1cblxuZnVuY3Rpb24gc2hvdyhmdW5jLCBwb3B1cCwgc2V0dGluZ3MpIHtcbiAgdmFyIHA7XG5cbiAgaWYgKGhhc1Byb21pc2UpIHtcbiAgICBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGZ1bmMocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmdW5jKHBvcHVwLCBzZXR0aW5ncyk7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxubW9iaXNjcm9sbC5hbGVydCA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gZ2V0TWVzc2FnZShzZXR0aW5ncyk7XG4gIHJldHVybiBzaG93KHNob3dBbGVydCwgcG9wdXAsIHNldHRpbmdzKTtcbn07XG5cbm1vYmlzY3JvbGwuY29uZmlybSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gZ2V0TWVzc2FnZShzZXR0aW5ncyk7XG4gIHJldHVybiBzaG93KHNob3dDb25maXJtLCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC5wcm9tcHQgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgdmFyIHBvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHBvcHVwLmlubmVySFRNTCA9IGdldE1lc3NhZ2Uoc2V0dGluZ3MpICsgJzxsYWJlbCBjbGFzcz1cIm1ic2MtaW5wdXRcIj4nICsgKHNldHRpbmdzLmxhYmVsID8gJzxzcGFuIGNsYXNzPVwibWJzYy1sYWJlbFwiPicgKyBzZXR0aW5ncy5sYWJlbCArICc8L3NwYW4+JyA6ICcnKSArICc8aW5wdXQgY2xhc3M9XCJtYnNjLWNvbnRyb2xcIiB0YWJpbmRleD1cIjBcIiB0eXBlPVwiJyArIChzZXR0aW5ncy5pbnB1dFR5cGUgfHwgJ3RleHQnKSArICdcIiBwbGFjZWhvbGRlcj1cIicgKyAoc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgJycpICsgJ1wiIHZhbHVlPVwiJyArIChzZXR0aW5ncy52YWx1ZSB8fCAnJykgKyAnXCI+JyArICc8L2xhYmVsPic7XG4gIHJldHVybiBzaG93KHNob3dQcm9tcHQsIHBvcHVwLCBzZXR0aW5ncyk7XG59O1xuXG5tb2Jpc2Nyb2xsLnNuYWNrYmFyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gIHZhciBwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgYnRuID0gc2V0dGluZ3MuYnV0dG9uO1xuICBwb3B1cC5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cIm1ic2Mtc25hY2tiYXItY29udFwiPjxkaXYgY2xhc3M9XCJtYnNjLXNuYWNrYmFyLW1zZ1wiPicgKyAoc2V0dGluZ3MubWVzc2FnZSB8fCAnJykgKyAnPC9kaXY+JyArIChidG4gPyAnPGJ1dHRvbiBjbGFzcz1cIm1ic2Mtc25hY2tiYXItYnRuIG1ic2MtYnRuIG1ic2MtYnRuLWZsYXRcIj4nICsgKGJ0bi5pY29uID8gJzxzcGFuIGNsYXNzPVwibWJzYy1pYyAnICsgKGJ0bi50ZXh0ID8gJ21ic2MtYnRuLWljICcgOiAnJykgKyAnbWJzYy1pYy0nICsgYnRuLmljb24gKyAnXCI+PC9zcGFuPicgOiAnJykgKyAoYnRuLnRleHQgfHwgJycpICsgJzwvYnV0dG9uPicgOiAnJykgKyAnPC9kaXY+JztcbiAgcmV0dXJuIHNob3coc2hvd1NuYWNrYmFyLCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC50b2FzdCA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJtYnNjLXRvYXN0LW1zZ1wiPicgKyAoc2V0dGluZ3MubWVzc2FnZSB8fCAnJykgKyAnPC9kaXY+JztcbiAgcmV0dXJuIHNob3coc2hvd1RvYXN0LCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC5ub3RpZmljYXRpb24gPSB7XG4gIGRpc21pc3M6IGZ1bmN0aW9uIGRpc21pc3MoKSB7XG4gICAgaWYgKGFjdGl2ZU5vdGlmaWNhdGlvbikge1xuICAgICAgYWN0aXZlTm90aWZpY2F0aW9uLmhpZGUoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYWxmQm9yZGVyJDEgPSBvcyA9PSAnaW9zJyAmJiBtYWpvclZlcnNpb24gPiA3O1xudmFyIEZvcm0gPSBmdW5jdGlvbiBGb3JtKGVsLCBzZXR0aW5ncykge1xuICB2YXIgcyxcbiAgICAgIGNzc0NsYXNzID0gJycsXG4gICAgICAkY3R4ID0gJCQxKGVsKSxcbiAgICAgIGNvbnRyb2xzID0ge30sXG4gICAgICB0aGF0ID0gdGhpcztcblxuICBmdW5jdGlvbiB0b3VjaGVkKCkge1xuICAgICRjdHgucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQucmVmcmVzaCA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gICAgaWYgKHMuZW5oYW5jZSkge1xuICAgICAgaW5pdENvbnRyb2xzKCRjdHgsIGNvbnRyb2xzLCBzLCBzaGFsbG93KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBGb3JtIGluaXRpYWxpemF0aW9uLlxuICAgKi9cblxuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFtb2Jpc2Nyb2xsLnRoZW1lcy5mb3JtW3MudGhlbWVdKSB7XG4gICAgICBzLnRoZW1lID0gJ21vYmlzY3JvbGwnO1xuICAgIH1cblxuICAgIGlmICghJGN0eC5oYXNDbGFzcygnbWJzYy1mb3JtJykpIHtcbiAgICAgICRjdHguc2hvdygpO1xuICAgICAgbGlzdGVuKCRjdHhbMF0sICd0b3VjaHN0YXJ0JywgdG91Y2hlZCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY3NzQ2xhc3MpIHtcbiAgICAgICRjdHgucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgIH0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgICBjc3NDbGFzcyA9ICdtYnNjLWZvcm0gbWJzYy1uby10b3VjaCBtYnNjLScgKyBzLnRoZW1lICsgKGhhbGZCb3JkZXIkMSA/ICcgbWJzYy1mb3JtLWhiJyA6ICcnKSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKSArIChzLmlucHV0U3R5bGUgPT0gJ2JveCcgPyAnIG1ic2MtZm9ybS1ib3gnIDogJycpICsgKHMuaW5wdXRTdHlsZSA9PSAnb3V0bGluZScgPyAnIG1ic2MtZm9ybS1vdXRsaW5lJyA6ICcnKTsgLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIEVORCAtLS1cblxuICAgICRjdHguYWRkQ2xhc3MoY3NzQ2xhc3MpLnJlbW92ZUNsYXNzKCdtYnNjLWNsb2FrJyk7XG4gICAgdGhhdC5yZWZyZXNoKCk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgbW9iaXNjcm9sbCBpbnN0YW5jZS5cbiAgICovXG5cblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICRjdHgucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgIHVubGlzdGVuKCRjdHhbMF0sICd0b3VjaHN0YXJ0JywgdG91Y2hlZCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gY29udHJvbHMpIHtcbiAgICAgIGNvbnRyb2xzW2lkXS5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogT2JqZWN0IHdpdGggdGhlIHVuZGVybHlpbmcgZm9ybSBjb250cm9sIGluc3RhbmNlc1xuICAgKiBrZXlzIGFyZSB0aGUgZWxlbWVudCBpZCdzXG4gICAqL1xuXG5cbiAgdGhhdC5jb250cm9scyA9IGNvbnRyb2xzOyAvLyBDb25zdHJ1Y3RvclxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuICB0aGF0LmluaXQoKTtcbn07IC8vIEV4dGVuZCBkZWZhdWx0c1xuXG5Gb3JtLnByb3RvdHlwZSA9IHtcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2NsYXNzOiAnZm9ybScsXG4gIF9kZWZhdWx0czoge1xuICAgIHRhcDogaGFzR2hvc3RDbGljayxcbiAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICBydGw6IGZhbHNlLFxuICAgIGVuaGFuY2U6IHRydWVcbiAgfVxufTtcbmNsYXNzZXMuRm9ybSA9IEZvcm07IC8vIEluaXQgbWJzYy1mb3JtIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtZW5oYW5jZV0sW21ic2MtZm9ybV0nLCBGb3JtLCB0cnVlKTtcblxudmFyIE1ic2NGb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0Zvcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0Zvcm0oaW5pdGlhbEVsZW0sIF9mb3JtU2VydmljZSwgem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2Zvcm1TZXJ2aWNlID0gX2Zvcm1TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5lbmhhbmNlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY0Zvcm0ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnNPYmogPSBleHRlbmQkMSh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xuICAgICAgICB0aGlzLl9mb3JtU2VydmljZS5vcHRpb25zID0gdGhpcy5vcHRpb25zT2JqO1xuICAgIH07XG4gICAgTWJzY0Zvcm0ucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0ICYmIG9wdC5lbmhhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdC5lbmhhbmNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgb3B0LCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEZvcm0odGhpcy5yb290RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1ic2NGb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZm9ybScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgI3Jvb3RFbGVtZW50PjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY09wdGlvbnNTZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Zvcm0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgTWJzY0Zvcm0ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydvcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ2VuaGFuY2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NvbnRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2lucHV0U3R5bGUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2lucHV0LXN0eWxlJyxdIH0sXSxcbiAgICAgICAgJ2xhYmVsU3R5bGUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2xhYmVsLXN0eWxlJyxdIH0sXSxcbiAgICAgICAgJ3Jvb3RFbGVtJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3Jvb3RFbGVtZW50JywgeyBzdGF0aWM6IGZhbHNlIH0sXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0Zvcm07XG59KE1ic2NCYXNlKSk7XG52YXIgTWJzY1RleHRhcmVhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1RleHRhcmVhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NUZXh0YXJlYShpbml0aWFsRWxlbSwgX2Zvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfY29udHJvbCwgem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgX2Zvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfY29udHJvbCwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2lucHV0U2VydmljZSA9IF9pbnB1dFNlcnZpY2U7XG4gICAgICAgIF9pbnB1dFNlcnZpY2UuaW5wdXQgPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjVGV4dGFyZWEucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGV4dEFyZWEodGhpcy5faW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBNYnNjVGV4dGFyZWEuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy10ZXh0YXJlYScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY29udHJvbC1uZycgfSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICAgICAgPGxhYmVsIFxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1lcnJdPVxcXCJlcnJvclxcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtaW5wdXQtYm94XT1cXFwiaW5wdXRTdHlsZSA9PSAnYm94J1xcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtaW5wdXQtb3V0bGluZV09XFxcImlucHV0U3R5bGUgPT0gJ291dGxpbmUnXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1zdGFja2VkXT1cXFwibGFiZWxTdHlsZSA9PSAnc3RhY2tlZCdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLWlubGluZV09XFxcImxhYmVsU3R5bGUgPT0gJ2lubGluZSdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLWZsb2F0aW5nXT1cXFwibGFiZWxTdHlsZSA9PSAnZmxvYXRpbmcnXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1ic2MtaW5wdXQtd3JhcFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSAjaW5pdEVsZW1lbnQgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiIFsobmdNb2RlbCldPVxcXCJpbm5lclZhbHVlXFxcIiAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucm93c109XFxcInJvd3NcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci53cmFwXT1cXFwid3JhcFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1pbmxlbmd0aF09XFxcIm1pbmxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1heGxlbmd0aF09XFxcIm1heGxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmF1dG9jb21wbGV0ZV09XFxcImF1dG9jb21wbGV0ZVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvY2FwaXRhbGl6ZV09XFxcImF1dG9jYXBpdGFsaXplXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2NvcnJlY3RdPVxcXCJhdXRvY29ycmVjdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnNwZWxsY2hlY2tdPVxcXCJzcGVsbGNoZWNrXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2ZvY3VzXT1cXFwiYXV0b2ZvY3VzXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbl09XFxcImljb24gPyBpY29uIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi1hbGlnbl09XFxcImljb25BbGlnbiA/IGljb25BbGlnbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seV09XFxcIl9yZWFkb25seVxcXCI+PC90ZXh0YXJlYT5cXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcImVycm9yICYmIGVycm9yTWVzc2FnZVxcXCIgY2xhc3M9XFxcIm1ic2MtZXJyLW1zZ1xcXCI+e3tlcnJvck1lc3NhZ2V9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICBcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0lucHV0U2VydmljZV1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUZXh0YXJlYS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUZXh0YXJlYS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ3Jvd3MnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3dyYXAnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjVGV4dGFyZWE7XG59KE1ic2NJbnB1dEJhc2UpKTtcbnZhciBNYnNjRHJvcGRvd24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjRHJvcGRvd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0Ryb3Bkb3duKGhvc3RFbGVtLCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgY29udHJvbCwgem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbSwgZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9pbnB1dFNlcnZpY2UgPSBfaW5wdXRTZXJ2aWNlO1xuICAgICAgICBfaW5wdXRTZXJ2aWNlLmlucHV0ID0gX3RoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NEcm9wZG93bi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UuX3NldFRleHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjRHJvcGRvd24ucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2VsZWN0KHRoaXMuX2luaXRFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5pbnN0YW5jZS5fc2V0VGV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1ic2NEcm9wZG93bi5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciB0aGF0XzEgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdF8xLmluc3RhbmNlLl9zZXRUZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0Ryb3Bkb3duLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZHJvcGRvd24nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgICAgIDxsYWJlbCBcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtZXJyXT1cXFwiZXJyb3JcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWlucHV0LWJveF09XFxcImlucHV0U3R5bGUgPT0gJ2JveCdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWlucHV0LW91dGxpbmVdPVxcXCJpbnB1dFN0eWxlID09ICdvdXRsaW5lJ1xcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtc3RhY2tlZF09XFxcImxhYmVsU3R5bGUgPT0gJ3N0YWNrZWQnXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1pbmxpbmVdPVxcXCJsYWJlbFN0eWxlID09ICdpbmxpbmUnXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1mbG9hdGluZ109XFxcImxhYmVsU3R5bGUgPT0gJ2Zsb2F0aW5nJ1xcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAge3tsYWJlbH19XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1ic2MtaW5wdXQtd3JhcFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzZWxlY3QgI2luaXRFbGVtZW50XFxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cXFwiaW5uZXJWYWx1ZVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbl09XFxcImljb24gPyBpY29uIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi1hbGlnbl09XFxcImljb25BbGlnbiA/IGljb25BbGlnbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIChibHVyKT1cXFwib25Ub3VjaCgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJlcnJvciAmJiBlcnJvck1lc3NhZ2VcXFwiIGNsYXNzPVxcXCJtYnNjLWVyci1tc2dcXFwiPnt7ZXJyb3JNZXNzYWdlfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NJbnB1dFNlcnZpY2VdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRHJvcGRvd24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRHJvcGRvd24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdsYWJlbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpbnB1dFN0eWxlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpbnB1dC1zdHlsZScsXSB9LF0sXG4gICAgICAgICdsYWJlbFN0eWxlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydsYWJlbC1zdHlsZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0Ryb3Bkb3duO1xufShNYnNjRm9ybVZhbHVlQmFzZSkpO1xudmFyIE1ic2NCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjQnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NCdXR0b24oaG9zdEVsZW0sIGZvcm1TZXJ2aWNlLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtLCBmb3JtU2VydmljZSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2ZsYXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2Jsb2NrID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9vdXRsaW5lID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9jbGFzc2VzT2JqID0ge307XG4gICAgICAgIF90aGlzLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0J1dHRvbi5wcm90b3R5cGUsIFwiY3NzQ2xhc3Nlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jbGFzc2VzT2JqKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NsYXNzZXNPYmpba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGFzc2VzT2JqWydtYnNjLWJ0bi1mbGF0J10gPSB0aGlzLl9mbGF0O1xuICAgICAgICAgICAgdGhpcy5fY2xhc3Nlc09ialsnbWJzYy1idG4tYmxvY2snXSA9IHRoaXMuX2Jsb2NrO1xuICAgICAgICAgICAgdGhpcy5fY2xhc3Nlc09ialsnbWJzYy1idG4tb3V0bGluZSddID0gdGhpcy5fb3V0bGluZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3NlcyA9IHRoaXMuY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc0NsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xhc3Nlc09ialtjc3NDbGFzc2VzW2ldXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNPYmpbJ21ic2MtYnRuLScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlc09iajtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NCdXR0b24ucHJvdG90eXBlLCBcImZsYXRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYXQgPSBlbXB0eU9yVHJ1ZSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0J1dHRvbi5wcm90b3R5cGUsIFwiYmxvY2tcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrID0gZW1wdHlPclRydWUodmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NCdXR0b24ucHJvdG90eXBlLCBcIm91dGxpbmVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX291dGxpbmUgPSBlbXB0eU9yVHJ1ZSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjQnV0dG9uLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5faW5oZXJpdGVkT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEJ1dHRvbih0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1ic2NCdXR0b24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1idXR0b24nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxidXR0b24gI2luaXRFbGVtZW50IFxcbiAgICAgICAgICAgIFt0eXBlXT1cXFwidHlwZVxcXCJcXG4gICAgICAgICAgICBbbmdDbGFzc109XFxcImNzc0NsYXNzZXNcXFwiXFxuICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uXT1cXFwiaWNvbiA/IGljb24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIj5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQnV0dG9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnY2xhc3Nlcyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnY2xhc3MnLF0gfSxdLFxuICAgICAgICAndHlwZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZmxhdCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnYmxvY2snOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ291dGxpbmUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjQnV0dG9uO1xufShNYnNjRm9ybUJhc2UpKTtcbnZhciBNYnNjQ2hlY2tib3ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjQ2hlY2tib3gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0NoZWNrYm94KGhvc3RFbGVtLCBjZHIsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBjb250cm9sLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtLCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgY29udHJvbCwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2RyID0gY2RyO1xuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ2hlY2tib3gucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLWNoZWNrYm94LScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtZXJyJ10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQ2xhc3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NDaGVja2JveC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDaGVja0JveCh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1ic2NDaGVja2JveC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH07XG4gICAgTWJzY0NoZWNrYm94LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGxhYmVsIFtuZ0NsYXNzXT1cXFwiY29sb3JDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGlucHV0ICNpbml0RWxlbWVudCBcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwiY2hlY2tib3hcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1sYWJlbC1zdHlsZV09XFxcImxhYmVsU3R5bGVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaW5wdXQtc3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cXFwiaW5uZXJWYWx1ZVxcXCJcXG4gICAgICAgICAgICAgICAgKGJsdXIpPVxcXCJvblRvdWNoKCRldmVudClcXFwiIC8+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJlcnJvciAmJiBlcnJvck1lc3NhZ2VcXFwiIGNsYXNzPVxcXCJtYnNjLWVyci1tc2dcXFwiPnt7ZXJyb3JNZXNzYWdlfX08L3NwYW4+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICBcIixcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NDaGVja2JveC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjQ2hlY2tib3gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW5wdXRTdHlsZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaW5wdXQtc3R5bGUnLF0gfSxdLFxuICAgICAgICAnbGFiZWxTdHlsZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbGFiZWwtc3R5bGUnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NDaGVja2JveDtcbn0oTWJzY0Zvcm1WYWx1ZUJhc2UpKTtcbnZhciBNYnNjU3dpdGNoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1N3aXRjaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU3dpdGNoKGhvc3RFbGVtLCB6b25lLCBfZm9ybVNlcnZpY2UsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW0sIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9mb3JtU2VydmljZSA9IF9mb3JtU2VydmljZTtcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU3dpdGNoLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLXN3aXRjaC0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLWVyciddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjU3dpdGNoLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZS5nZXRWYWwoKSAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1N3aXRjaC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMgPSB0aGlzLl9mb3JtU2VydmljZSA/IHRoaXMuX2Zvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1N3aXRjaC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTd2l0Y2godGhpcy5faW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU3dpdGNoLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc3dpdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnQgXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNoZWNrYm94XFxcIlxcbiAgICAgICAgICAgICAgICBkYXRhLXJvbGU9XFxcInN3aXRjaFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWlucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIChibHVyKT1cXFwib25Ub3VjaCgkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU3dpdGNoLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NTd2l0Y2gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydvcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWyd2YWx1ZUNoYW5nZScsXSB9LF0sXG4gICAgICAgICdfaW5pdEVsZW0nOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5pdEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjU3dpdGNoO1xufShNYnNjQ29udHJvbEJhc2UpKTtcbnZhciBNYnNjU3RlcHBlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NTdGVwcGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTdGVwcGVyKGhvc3RFbGVtZW50LCB6b25lLCBfZm9ybVNlcnZpY2UsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9mb3JtU2VydmljZSA9IF9mb3JtU2VydmljZTtcbiAgICAgICAgX3RoaXMubWluID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2NvbG9yQ2xhc3MgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWRvbmx5ID0gZW1wdHlPclRydWUodmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJjb2xvckNsYXNzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2NvbG9yQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY29sb3JDbGFzc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JDbGFzc1snbWJzYy1zdGVwcGVyLScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JDbGFzcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1N0ZXBwZXIucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU3RlcHBlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMgPSB0aGlzLl9mb3JtU2VydmljZSA/IHRoaXMuX2Zvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1N0ZXBwZXIucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU3RlcHBlcih0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NTdGVwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc3RlcHBlcicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY29udHJvbC1uZycgfSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cXFwiY29sb3JDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnRcXG4gICAgICAgICAgICAgICAgZGF0YS1yb2xlPVxcXCJzdGVwcGVyXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIubWluXT1cXFwibWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5tYXhdPVxcXCJtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLnN0ZXBdPVxcXCJzdGVwICE9PSB1bmRlZmluZWQgPyBzdGVwIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS12YWxdPVxcXCJ2YWwgPyB2YWwgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWxhYmVsLXN0eWxlXT1cXFwibGFiZWxTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pbnB1dC1zdHlsZV09XFxcImlucHV0U3R5bGVcXFwiXFxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBcXG4gICAgICAgICAgICAgICAgW3JlYWRvbmx5XT1cXFwiX3JlYWRvbmx5XFxcIi8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU3RlcHBlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU3RlcHBlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ3JlYWRvbmx5JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydvcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21heCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc3RlcCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnY29sb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWyd2YWx1ZUNoYW5nZScsXSB9LF0sXG4gICAgICAgICdfaW5pdEVsZW0nOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnaW5pdEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjU3RlcHBlcjtcbn0oTWJzY0NvbnRyb2xCYXNlKSk7XG52YXIgTWJzY1Byb2dyZXNzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Byb2dyZXNzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NQcm9ncmVzcyhob3N0RWxlbWVudCwgem9uZSwgX2Zvcm1TZXJ2aWNlLCBjb250cm9sKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCB6b25lLCBjb250cm9sLCBudWxsLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZm9ybVNlcnZpY2UgPSBfZm9ybVNlcnZpY2U7XG4gICAgICAgIF90aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaWNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaWNvbkFsaWduID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy52YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcImRhdGFTdGVwTGFiZWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLnN0ZXBMYWJlbHMpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBMYWJlbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwiY29sb3JDbGFzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jb2xvckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yQ2xhc3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtcHJvZ3Jlc3MtJyArIHRoaXMuY29sb3JdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbmhlcml0ZWRPcHRpb25zID0gdGhpcy5fZm9ybVNlcnZpY2UgPyB0aGlzLl9mb3JtU2VydmljZS5vcHRpb25zIDoge307XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBQcm9ncmVzcyh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NQcm9ncmVzcy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXByb2dyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8cHJvZ3Jlc3MgI2luaXRFbGVtZW50XFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtc3RlcC1sYWJlbHNdPVxcXCJkYXRhU3RlcExhYmVsc1xcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uXT1cXFwiaWNvbiA/IGljb24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb24tYWxpZ25dPVxcXCJpY29uQWxpZ24gPyBpY29uQWxpZ24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWxhYmVsLXN0eWxlXT1cXFwibGFiZWxTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pbnB1dC1zdHlsZV09XFxcImlucHV0U3R5bGVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm1heF09XFxcIm1heCAhPT0gdW5kZWZpbmVkID8gbWF4IDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS12YWxdPVxcXCJ2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgIDwvcHJvZ3Jlc3M+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICBcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NQcm9ncmVzcy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjUHJvZ3Jlc3MucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydvcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ljb24nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICd2YWwnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGVwTGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydzdGVwLWxhYmVscycsXSB9LF0sXG4gICAgICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnX2luaXRFbGVtJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2luaXRFbGVtZW50JywgeyBzdGF0aWM6IGZhbHNlIH0sXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1Byb2dyZXNzO1xufShNYnNjQ29udHJvbEJhc2UpKTtcbnZhciBncm91cE5hbWUgPSAxO1xudmFyIE1ic2NSYWRpb1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NSYWRpb1NlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbHVlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX25hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lID0gJ21ic2MtcmFkaW8tZ3JvdXAtJyArIChncm91cE5hbWUrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJtdWx0aVNlbGVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpU2VsZWN0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aVNlbGVjdCA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NSYWRpb1NlcnZpY2UucHJvdG90eXBlLm9uVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVPYnNlcnZhYmxlO1xuICAgIH07XG4gICAgTWJzY1JhZGlvU2VydmljZS5wcm90b3R5cGUuY2hhbmdlVmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICB0aGlzLl92YWx1ZU9ic2VydmFibGUubmV4dCh2KTtcbiAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJnZXRMYXN0VmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXN0VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NSYWRpb1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBNYnNjUmFkaW9TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NSYWRpb1NlcnZpY2U7XG59KCkpO1xudmFyIE1ic2NSYWRpb0dyb3VwQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NSYWRpb0dyb3VwQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjUmFkaW9Hcm91cEJhc2UoaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfcmFkaW9TZXJ2aWNlLCBjb250cm9sLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgY29udHJvbCwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3JhZGlvU2VydmljZSA9IF9yYWRpb1NlcnZpY2U7XG4gICAgICAgIF90aGlzLnZhbHVlT2JzZXJ2ZXIgPSBfdGhpcy5fcmFkaW9TZXJ2aWNlLm9uVmFsdWVDaGFuZ2VkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBfdGhpcy5pbm5lclZhbHVlID0gdjtcbiAgICAgICAgICAgIF90aGlzLm9uVG91Y2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9yYWRpb1NlcnZpY2UuY2hhbmdlVmFsdWUodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHYpO1xuICAgIH07XG4gICAgTWJzY1JhZGlvR3JvdXBCYXNlLnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnVuc3Vic2NyaWJlKHRoaXMudmFsdWVPYnNlcnZlcik7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1yZy1iXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjUmFkaW9Hcm91cEJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSYWRpb1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1JhZGlvR3JvdXBCYXNlO1xufShNYnNjRm9ybVZhbHVlQmFzZSkpO1xudmFyIE1ic2NSYWRpb0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1JhZGlvR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1JhZGlvR3JvdXAoaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCByYWRpb1NlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgcmFkaW9TZXJ2aWNlLCBjb250cm9sLCB6b25lKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYnNjUmFkaW9Hcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXJhZGlvLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjUmFkaW9TZXJ2aWNlXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1JhZGlvR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSYWRpb1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY1JhZGlvR3JvdXA7XG59KE1ic2NSYWRpb0dyb3VwQmFzZSkpO1xudmFyIE1ic2NSYWRpbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NSYWRpbywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjUmFkaW8oaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfcmFkaW9TZXJ2aWNlLCB6b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3JhZGlvU2VydmljZSA9IF9yYWRpb1NlcnZpY2U7XG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XG4gICAgICAgIHZhciB2ID0gX3RoaXMuX3JhZGlvU2VydmljZS5nZXRMYXN0VmFsdWU7XG4gICAgICAgIGlmICh2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5tb2RlbFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy52YWx1ZU9ic2VydmVyID0gX3RoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgX3RoaXMubW9kZWxWYWx1ZSA9IHY7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW8ucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09IHRoaXMubW9kZWxWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYWRpby5wcm90b3R5cGUsIFwiY29sb3JDbGFzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jb2xvckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yQ2xhc3Nba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtcmFkaW8tJyArIHRoaXMuY29sb3JdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JDbGFzc1snbWJzYy1lcnInXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JDbGFzcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1JhZGlvLnByb3RvdHlwZS5jbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgTWJzY1JhZGlvLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5faW5oZXJpdGVkT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJhZGlvKHRoaXMuX2luaXRFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgTWJzY1JhZGlvLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLl9yYWRpb1NlcnZpY2UubmFtZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IHRoaXMuX3JhZGlvU2VydmljZS5jb2xvcjtcbiAgICB9O1xuICAgIE1ic2NSYWRpby5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnVuc3Vic2NyaWJlKHRoaXMudmFsdWVPYnNlcnZlcik7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NSYWRpby5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXJhZGlvJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnQgXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcInJhZGlvXFxcIiBcXG4gICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiIFxcbiAgICAgICAgICAgICAgICBbYXR0ci52YWx1ZV09XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICBbdmFsdWVdPVxcXCJ2YWx1ZVxcXCIgXFxuICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIChjbGljayk9XFxcImNsaWNrZWQoJGV2ZW50KVxcXCIgLz5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcImVycm9yICYmIGVycm9yTWVzc2FnZVxcXCIgY2xhc3M9XFxcIm1ic2MtZXJyLW1zZ1xcXCI+e3tlcnJvck1lc3NhZ2V9fTwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjUmFkaW8uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSYWRpb1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgTWJzY1JhZGlvLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjUmFkaW87XG59KE1ic2NGb3JtQmFzZSkpO1xudmFyIE1ic2NTZWdtZW50ZWRHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NTZWdtZW50ZWRHcm91cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2VnbWVudGVkR3JvdXAoaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCByYWRpb1NlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCByYWRpb1NlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdCA9ICdzaW5nbGUnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2VnbWVudGVkR3JvdXAucHJvdG90eXBlLCBcIm11bHRpU2VsZWN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3QgPT0gJ211bHRpcGxlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1NlZ21lbnRlZEdyb3VwLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yYWRpb1NlcnZpY2UubXVsdGlTZWxlY3QgPSB0aGlzLm11bHRpU2VsZWN0O1xuICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1NlZ21lbnRlZEdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2VnbWVudGVkLWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWJzYy1zZWdtZW50ZWQgbWJzYy1zZWdtZW50ZWQtZ3JvdXAgbWJzYy1uby10b3VjaFxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjUmFkaW9TZXJ2aWNlXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1NlZ21lbnRlZEdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjUmFkaW9TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgTWJzY1NlZ21lbnRlZEdyb3VwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnc2VsZWN0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1NlZ21lbnRlZEdyb3VwO1xufShNYnNjUmFkaW9Hcm91cEJhc2UpKTtcbnZhciBNYnNjU2VnbWVudGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1NlZ21lbnRlZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2VnbWVudGVkKGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX3JhZGlvU2VydmljZSwgem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbWVudCwgZm9ybVNlcnZpY2UsIHpvbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9yYWRpb1NlcnZpY2UgPSBfcmFkaW9TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5jaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB2YXIgdiA9IF90aGlzLl9yYWRpb1NlcnZpY2UuZ2V0TGFzdFZhbHVlO1xuICAgICAgICBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMubW9kZWxWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudmFsdWVPYnNlcnZlciA9IF90aGlzLl9yYWRpb1NlcnZpY2Uub25WYWx1ZUNoYW5nZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIF90aGlzLm1vZGVsVmFsdWUgPSB2O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxWYWx1ZSAmJiB0aGlzLm1vZGVsVmFsdWUuaW5jbHVkZXModGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT0gdGhpcy5tb2RlbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjU2VnbWVudGVkLnByb3RvdHlwZS5jbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QgJiYgdGhpcy5jaGVja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KCEoISF0aGlzLmNoZWNrZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZWxWYWx1ZS5pbmNsdWRlcyh0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubW9kZWxWYWx1ZS5pbmRleE9mKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsVmFsdWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbFZhbHVlLnB1c2godGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5jaGFuZ2VWYWx1ZSh0aGlzLm1vZGVsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUsIFwiY3NzQ2xhc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbCA9ICdtYnNjLXNlZ21lbnRlZC1pdGVtJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY2wgKz0gJyBtYnNjLXNlZ21lbnRlZC0nICsgdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTZWdtZW50ZWRJdGVtKHRoaXMuX2luaXRFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5fcmFkaW9TZXJ2aWNlLm5hbWU7XG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3QgPSB0aGlzLl9yYWRpb1NlcnZpY2UubXVsdGlTZWxlY3Q7XG4gICAgICAgIHRoaXMuY29sb3IgPSB0aGlzLl9yYWRpb1NlcnZpY2UuY29sb3I7XG4gICAgfTtcbiAgICBNYnNjU2VnbWVudGVkLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLm9uVmFsdWVDaGFuZ2VkKCkudW5zdWJzY3JpYmUodGhpcy52YWx1ZU9ic2VydmVyKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1NlZ21lbnRlZC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXNlZ21lbnRlZCcsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1tjbGFzc10nOiAnY3NzQ2xhc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJtYnNjLXNlZ21lbnRlZC1pdGVtLXJlYWR5XFxcIj5cXG4gICAgICAgICAgICA8aW5wdXQgI2luaXRFbGVtZW50IFxcbiAgICAgICAgICAgICAgICBkYXRhLXJvbGU9XFxcInNlZ21lbnRlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3R5cGVdPVxcXCJtdWx0aVNlbGVjdCA/ICdjaGVja2JveCcgOiAncmFkaW8nXFxcIiBcXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cXFwidmFsdWVcXFwiIFxcbiAgICAgICAgICAgICAgICBbY2hlY2tlZF09XFxcImlzQ2hlY2tlZFxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIiBcXG4gICAgICAgICAgICAgICAgW2F0dHIudmFsdWVdPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uXT1cXFwiaWNvbiA/IGljb24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJjbGlja2VkKCRldmVudClcXFwiIC8+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiaWNvblxcXCIgY2xhc3M9XFxcInt7J21ic2MtaWMgbWJzYy1pYy0nICsgaWNvbiB9fVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCJcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTZWdtZW50ZWQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSYWRpb1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgTWJzY1NlZ21lbnRlZC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2ljb24nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjaGVja2VkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjaGVja2VkQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjU2VnbWVudGVkO1xufShNYnNjRm9ybUJhc2UpKTtcbnZhciBNYnNjU2xpZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1NsaWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2xpZGVyKGhvc3RFbGVtZW50LCBfZm9ybVNlcnZpY2UsIHpvbmUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9mb3JtU2VydmljZSA9IF9mb3JtU2VydmljZTtcbiAgICAgICAgX3RoaXMuX2R1bW15ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5fbmVlZHNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiaXNNdWx0aVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWYWx1ZSBpbnN0YW5jZW9mIEFycmF5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiZHVtbXlBcnJheVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kdW1teSB8fCAodGhpcy5pc011bHRpICYmIHRoaXMuX2xhc3RWYWx1ZSAmJiB0aGlzLl9sYXN0VmFsdWUubGVuZ3RoICYmIHRoaXMuX2R1bW15Lmxlbmd0aCAhPT0gdGhpcy5fbGFzdFZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kdW1teSA9IEFycmF5KHRoaXMuaXNNdWx0aSA/IHRoaXMuX2xhc3RWYWx1ZS5sZW5ndGggOiAxKS5maWxsKDApLm1hcChmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHVtbXk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJkYXRhU3RlcExhYmVsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5zdGVwTGFiZWxzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwTGFiZWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTbGlkZXIucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLXNsaWRlci0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQ2xhc3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NTbGlkZXIucHJvdG90eXBlLnJlSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDaGFuZ2UoaW5wdXQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2xpZGVyKHRoaXMuaW5wdXRFbGVtZW50cy5maXJzdC5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1ic2NTbGlkZXIucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdjtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGkgJiYgKCFpbm5lclZhbHVlIHx8IGlubmVyVmFsdWUubGVuZ3RoICE9IHYubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZUluaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2Uuc2V0VmFsKF90aGlzLl9sYXN0VmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gKHRoaXMuaXNNdWx0aSAmJiAhZGVlcEVxdWFsc0FycmF5KGlubmVyVmFsdWUsIHYpKSB8fCAoIXRoaXMuaXNNdWx0aSAmJiBpbm5lclZhbHVlICE9PSB2KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU2xpZGVyLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5oZXJpdGVkT3B0aW9ucyA9IHRoaXMuX2Zvcm1TZXJ2aWNlID8gdGhpcy5fZm9ybVNlcnZpY2Uub3B0aW9ucyA6IHt9O1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNYnNjU2xpZGVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlKGlucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5faW5oZXJpdGVkT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFNsaWRlcih0aGlzLmlucHV0RWxlbWVudHMuZmlyc3QubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5pdGlhbFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU2xpZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2xpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8aW5wdXQgI2lucHV0RWxlbWVudHMgKm5nRm9yPVxcXCJsZXQgdiBvZiBkdW1teUFycmF5XFxcIiBcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwicmFuZ2VcXFwiXFxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci52YWx1ZV09XFxcImR1bW15QXJyYXkubGVuZ3RoID4gMSAmJiBpbml0aWFsVmFsdWUgPyBpbml0aWFsVmFsdWVbdl06IGluaXRpYWxWYWx1ZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1zdGVwLWxhYmVsc109XFxcImRhdGFTdGVwTGFiZWxzXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRlbXBsYXRlXT1cXFwidmFsdWVUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS10b29sdGlwXT1cXFwidG9vbHRpcCA/ICd0cnVlJyA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaGlnaGxpZ2h0XT1cXFwiaGlnaGxpZ2h0XFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWxpdmVdPVxcXCJsaXZlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb25dPVxcXCJpY29uID8gaWNvbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtdmFsXT1cXFwidmFsID8gdmFsIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1sYWJlbC1zdHlsZV09XFxcImxhYmVsU3R5bGVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaW5wdXQtc3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIubWF4XT1cXFwibWF4ICE9PSB1bmRlZmluZWQgPyBtYXggOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5taW5dPVxcXCJtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLnN0ZXBdPVxcXCJzdGVwICE9PSB1bmRlZmluZWQgPyBzdGVwIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgKGJsdXIpPVxcXCJvblRvdWNoKCRldmVudClcXFwiIC8+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICBcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1NsaWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2xpZGVyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0b29sdGlwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdoaWdobGlnaHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2xpdmUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbHVlVGVtcGxhdGUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ3ZhbHVlLXRlbXBsYXRlJyxdIH0sXSxcbiAgICAgICAgJ2ljb24nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3ZhbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0ZXAnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGVwTGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydzdGVwLWxhYmVscycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICAnY29sb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWyd2YWx1ZUNoYW5nZScsXSB9LF0sXG4gICAgICAgICdpbnB1dEVsZW1lbnRzJzogW3sgdHlwZTogVmlld0NoaWxkcmVuLCBhcmdzOiBbJ2lucHV0RWxlbWVudHMnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTbGlkZXI7XG59KE1ic2NDb250cm9sQmFzZSkpO1xudmFyIE1ic2NSYXRpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjUmF0aW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NSYXRpbmcoaG9zdEVsZW0sIHpvbmUsIGZvcm1TZXJ2aWNlLCBjb250cm9sKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtLCB6b25lLCBjb250cm9sLCBudWxsLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mb3JtU2VydmljZSA9IGZvcm1TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudmFsID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYXRpbmcucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWFkb25seSA9IGVtcHR5T3JUcnVlKHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYXRpbmcucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLXJhdGluZy0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQ2xhc3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NSYXRpbmcucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlLmdldFZhbCgpICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjUmF0aW5nLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5oZXJpdGVkT3B0aW9ucyA9IHRoaXMuZm9ybVNlcnZpY2UgPyB0aGlzLmZvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1JhdGluZy5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSYXRpbmcodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYXRpbmcuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1yYXRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhdGluZ1xcXCIgZGF0YS1yb2xlPVxcXCJyYXRpbmdcXFwiIFxcbiAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgIFthdHRyLm1pbl09XFxcIm1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogbnVsbFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5tYXhdPVxcXCJtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgW2F0dHIuc3RlcF09XFxcInN0ZXAgIT09IHVuZGVmaW5lZCA/IHN0ZXAgOiBudWxsXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtdmFsXT1cXFwidmFsID8gdmFsIDogbnVsbFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRlbXBsYXRlXT1cXFwidGVtcGxhdGUgPyB0ZW1wbGF0ZSA6IG51bGxcXFwiXFxuICAgICAgICAgICAgW2F0dHIuZGF0YS1lbXB0eV09XFxcImVtcHR5XFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtZmlsbGVkXT1cXFwiZmlsbGVkXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtaW5wdXQtc3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIlxcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFtyZWFkb25seV09XFxcIl9yZWFkb25seVxcXCJcXG4gICAgICAgICAgICAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCIgLz5cXG4gICAgPC9sYWJlbD5cIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1JhdGluZy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjUmF0aW5nLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWluJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0ZXAnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Rpc2FibGVkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlbXB0eSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZmlsbGVkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdyZWFkb25seSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0ZW1wbGF0ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWyd2YWx1ZUNoYW5nZScsXSB9LF0sXG4gICAgICAgICdjb2xvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NSYXRpbmc7XG59KE1ic2NDb250cm9sQmFzZSkpO1xudmFyIE1ic2NGb3JtR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NGb3JtR3JvdXAoaW5pdGlhbEVsZW0pIHtcbiAgICAgICAgdGhpcy5pbml0aWFsRWxlbSA9IGluaXRpYWxFbGVtO1xuICAgICAgICB0aGlzLmNvbGxhcHNpYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gaW5pdGlhbEVsZW07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRm9ybUdyb3VwLnByb3RvdHlwZSwgXCJvcGVuXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZW4gIT0gdiAmJiB0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY0Zvcm1Hcm91cC5wcm90b3R5cGUuZW1wdHlPclRydWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gZW1wdHlPclRydWUodik7XG4gICAgfTtcbiAgICBNYnNjRm9ybUdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IENvbGxhcHNpYmxlQmFzZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgeyBpc09wZW46IHRoaXMuX29wZW4gIT09IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjRm9ybUdyb3VwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjRm9ybUdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZm9ybS1ncm91cCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWJzYy1mb3JtLWdyb3VwLWluc2V0XSc6ICdlbXB0eU9yVHJ1ZShpbnNldCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWZvcm0tZ3JvdXBdJzogJyFlbXB0eU9yVHJ1ZShpbnNldCknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J11cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NGb3JtR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NGb3JtR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjb2xsYXBzaWJsZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3Blbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW5zZXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRm9ybUdyb3VwO1xufSgpKTtcbnZhciBNYnNjRm9ybUdyb3VwVGl0bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NGb3JtR3JvdXBUaXRsZSgpIHtcbiAgICB9XG4gICAgTWJzY0Zvcm1Hcm91cFRpdGxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZm9ybS1ncm91cC10aXRsZScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWJzYy1mb3JtLWdyb3VwLXRpdGxlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRm9ybUdyb3VwVGl0bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0Zvcm1Hcm91cFRpdGxlO1xufSgpKTtcbnZhciBNYnNjRm9ybUdyb3VwQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0Zvcm1Hcm91cENvbnRlbnQoKSB7XG4gICAgfVxuICAgIE1ic2NGb3JtR3JvdXBDb250ZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZm9ybS1ncm91cC1jb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWZvcm0tZ3JvdXAtY29udGVudF0nOiAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2s7IH0nXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Zvcm1Hcm91cENvbnRlbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0Zvcm1Hcm91cENvbnRlbnQ7XG59KCkpO1xudmFyIE1ic2NBY2NvcmRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NBY2NvcmRpb24oKSB7XG4gICAgfVxuICAgIE1ic2NBY2NvcmRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1hY2NvcmRpb24nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1ic2MtYWNjb3JkaW9uXSc6ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjQWNjb3JkaW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NBY2NvcmRpb247XG59KCkpO1xudmFyIGNvbXAkMyA9IFtcbiAgICBNYnNjRm9ybSxcbiAgICBNYnNjVGV4dGFyZWEsXG4gICAgTWJzY0Ryb3Bkb3duLFxuICAgIE1ic2NCdXR0b24sXG4gICAgTWJzY0NoZWNrYm94LFxuICAgIE1ic2NTd2l0Y2gsXG4gICAgTWJzY1N0ZXBwZXIsXG4gICAgTWJzY1Byb2dyZXNzLFxuICAgIE1ic2NSYWRpb0dyb3VwLFxuICAgIE1ic2NSYWRpb0dyb3VwQmFzZSxcbiAgICBNYnNjUmFkaW8sXG4gICAgTWJzY1NlZ21lbnRlZEdyb3VwLFxuICAgIE1ic2NTZWdtZW50ZWQsXG4gICAgTWJzY1NsaWRlcixcbiAgICBNYnNjUmF0aW5nLFxuICAgIE1ic2NGb3JtR3JvdXAsXG4gICAgTWJzY0Zvcm1Hcm91cFRpdGxlLFxuICAgIE1ic2NGb3JtR3JvdXBDb250ZW50LFxuICAgIE1ic2NBY2NvcmRpb25cbl07XG52YXIgTWJzY0Zvcm1zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjRm9ybXNNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbRm9ybXNNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWJzY0Jhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogY29tcCQzLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbY29tcCQzLCBNYnNjSW5wdXRNb2R1bGUsIE1ic2NJbnB1dF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjRm9ybXNNb2R1bGU7XG59KCkpO1xuXG52YXIgZGVmYXVsdHMkNSA9IHtcbiAgaW52YWxpZDogW10sXG4gIHNob3dJbnB1dDogdHJ1ZSxcbiAgaW5wdXRDbGFzczogJycsXG4gIGl0ZW1TZWxlY3RvcjogJ2xpJ1xufTtcbnZhciBMaXN0ID0gZnVuY3Rpb24gTGlzdChpbnN0KSB7XG4gIHZhciBjdXJyTGV2ZWwsXG4gICAgICBpbnB1dCxcbiAgICAgIHByZXZlbnQsXG4gICAgICB3LFxuICAgICAgb3JpZyA9IGV4dGVuZCQxKHt9LCBpbnN0LnNldHRpbmdzKSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWZhdWx0cyQ1LCBvcmlnKSxcbiAgICAgIGxheW91dCA9IHMubGF5b3V0IHx8ICgvdG9wfGJvdHRvbS8udGVzdChzLmRpc3BsYXkpID8gJ2xpcXVpZCcgOiAnJyksXG4gICAgICBpc0xpcXVpZCA9IGxheW91dCA9PSAnbGlxdWlkJyxcbiAgICAgIG9yaWdSZWFkT25seSA9IHMucmVhZG9ubHksXG4gICAgICBlbG0gPSAkJDEodGhpcyksXG4gICAgICBpZCA9IHRoaXMuaWQgKyAnX2R1bW15JyxcbiAgICAgIGx2bCA9IDAsXG4gICAgICBjdXJyV2hlZWxWZWN0b3IgPSBbXSxcbiAgICAgIHdhID0gcy53aGVlbEFycmF5IHx8IGNyZWF0ZVdoZWVsQXJyYXkoZWxtKSxcbiAgICAgIGZ3diA9IGZpcnN0V2hlZWxWZWN0b3Iod2EpO1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoKHRyZWUsIGwpIHtcbiAgICB2YXIgaTtcbiAgICBsdmwgPSBsID4gbHZsID8gbCA6IGx2bDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXS5jaGlsZHJlbikge1xuICAgICAgICBnZXREZXB0aCh0cmVlW2ldLmNoaWxkcmVuLCBsICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgaW52YWxpZCBpdGVtcyBvbiB0aGUgd2hlZWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkdyAtIHRoZSBqUXVlcnkgbW9iaXNjcm9sbCBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5yV2hlZWxzIC0gdGhlIG51bWJlciBvZiB0aGUgY3VycmVudCB3aGVlbHNcbiAgICogQHBhcmFtIHtBcnJheX0gd2hBcnJheSAtIFRoZSB3aGVlbCBhcnJheSBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHdoZWVsIHRyZWVcbiAgICogQHBhcmFtIHtBcnJheX0gd2hWZWN0b3IgLSB0aGUgd2hlZWwgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQga2V5c1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldERpc2FibGVkKG5yV2hlZWxzLCB3aEFycmF5LCB3aFZlY3Rvcikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgZGlzYWJsZWQgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgbnJXaGVlbHMpIHtcbiAgICAgIGRpc2FibGVkW2ldID0gZ2V0SW52YWxpZEtleXMod2hWZWN0b3IsIGksIHdoQXJyYXkpO1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW52YWxpZCBrZXlzIG9mIG9uZSB3aGVlbCBhcyBhbiBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSB3aFZlY3RvciAtIHRoZSB3aGVlbCB2ZWN0b3IgdXNlZCB0byBzZWFyY2ggZm9yIHRoZSB3aGVlbCBpbiB0aGUgd2hlZWwgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgdGhlIHdoZWVsIGluIHRoZSB3aGVlbCB2ZWN0b3IsIHRoYXQgd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICogQHBhcmFtIHtBcnJheX0gd2hBcnJheSAtIHRoZSB3aGVlbCBhcnJheSB3ZSBhcmUgc2VhcmNoaW5nIGluXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIGxpc3Qgb2YgaW52YWxpZCBrZXlzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW52YWxpZEtleXMod2hWZWN0b3IsIGluZGV4LCB3aEFycmF5KSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuLFxuICAgICAgICB3aE9iakEgPSB3aEFycmF5LFxuICAgICAgICBpbnZhbGlkcyA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgdmFyIGlpID0gd2hWZWN0b3JbaV07XG5cbiAgICAgIGZvciAobiBpbiB3aE9iakEpIHtcbiAgICAgICAgaWYgKHdoT2JqQVtuXS5rZXkgPT0gaWkpIHtcbiAgICAgICAgICB3aE9iakEgPSB3aE9iakFbbl0uY2hpbGRyZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCB3aE9iakEubGVuZ3RoKSB7XG4gICAgICBpZiAod2hPYmpBW2ldLmludmFsaWQpIHtcbiAgICAgICAgaW52YWxpZHMucHVzaCh3aE9iakFbaV0ua2V5KTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBpbnZhbGlkcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJvb2xlYW4gdmVjdG9yIHdpdGggdHJ1ZSB2YWx1ZXMgKGV4Y2VwdCBvbmUpIHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIHJlYWRvbmx5IHZlY3RvclxuICAgKiBuIC0gdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXG4gICAqIGkgLSB0aGUgaW5kZXggb2YgdGhlIHZhbHVlIHRoYXQncyBnb2luZyB0byBiZSBmYWxzZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJPVmVjdG9yKG4sIGkpIHtcbiAgICB2YXIgYSA9IFtdO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGFbLS1uXSA9IHRydWU7XG4gICAgfVxuXG4gICAgYVtpXSA9IGZhbHNlO1xuICAgIHJldHVybiBhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSB3aGVlbCBhcnJheSBmcm9tIHRoZSB2ZWN0b3IgcHJvdmlkZWRcbiAgICogd3YgLSB3aGVlbCB2ZWN0b3IgY29udGFpbmluZyB0aGUgdmFsdWVzIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkIG9uIHRoZSB3aGVlbHNcbiAgICogbCAtIHRoZSBsZW5ndGggb2YgdGhlIHdoZWVsIGFycmF5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVXaGVlbHNGcm9tVmVjdG9yKHd2LCBsLCBpbmRleCkge1xuICAgIHZhciBuZXh0TGV2ZWwsXG4gICAgICAgIGosXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBoYXNDaGlsZHJlbiA9IHRydWUsXG4gICAgICAgIHcgPSBbW11dLFxuICAgICAgICB3dE9iakEgPSB3YTtcblxuICAgIGlmIChsKSB7XG4gICAgICAvLyBpZiBsZW5ndGggaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIGdlbmVyYXRlIHRoYXQgbWFueSB3aGVlbHMgKGV2ZW4gaWYgdGhleSBhcmUgZW1wdHkpXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGlmIChpc0xpcXVpZCkge1xuICAgICAgICAgIHdbMF1bal0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3W2pdID0gW3t9XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChoYXNDaGlsZHJlbikge1xuICAgICAgaWYgKGlzTGlxdWlkKSB7XG4gICAgICAgIHdbMF1baV0gPSBnZXRXaGVlbEZyb21PYmpBKHd0T2JqQSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3W2ldID0gW2dldFdoZWVsRnJvbU9iakEod3RPYmpBLCBpKV07XG4gICAgICB9XG5cbiAgICAgIGogPSAwO1xuICAgICAgbmV4dExldmVsID0gbnVsbDtcblxuICAgICAgd2hpbGUgKGogPCB3dE9iakEubGVuZ3RoICYmICFuZXh0TGV2ZWwpIHtcbiAgICAgICAgaWYgKHd0T2JqQVtqXS5rZXkgPT0gd3ZbaV0gJiYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaSA8PSBpbmRleCB8fCBpbmRleCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIG5leHRMZXZlbCA9IHd0T2JqQVtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGorKztcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgbmV4dExldmVsID0gZ2V0Rmlyc3RWYWxpZEl0ZW1PYmpPckluZCh3dE9iakEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dExldmVsICYmIG5leHRMZXZlbC5jaGlsZHJlbikge1xuICAgICAgICB3dE9iakEgPSBuZXh0TGV2ZWwuY2hpbGRyZW47XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkIFdoZWVsIE5vZGUgT2JqZWN0IG9yIGl0cyBpbmRleCBmcm9tIGEgV2hlZWwgTm9kZSBPYmplY3QgQXJyYXlcbiAgICogZ2V0SW5kIC0gaWYgaXQgaXMgdHJ1ZSB0aGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgZ29pbmcgdG8gYmUgdGhlIGluZGV4LCBvdGhlcndpc2UgdGhlIG9iamVjdCBpdHNlbGZcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRGaXJzdFZhbGlkSXRlbU9iak9ySW5kKHd0T2JqQSwgZ2V0SW5kKSB7XG4gICAgaWYgKCF3dE9iakEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG9iajtcblxuICAgIHdoaWxlIChpIDwgd3RPYmpBLmxlbmd0aCkge1xuICAgICAgaWYgKCEob2JqID0gd3RPYmpBW2krK10pLmludmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEluZCA/IGkgLSAxIDogb2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdoZWVsRnJvbU9iakEob2JqQSwgaSkge1xuICAgIHZhciB3aGVlbCA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWw6IHMubGFiZWxzICYmIHMubGFiZWxzW2ldID8gcy5sYWJlbHNbaV0gOiBpXG4gICAgfSxcbiAgICAgICAgaiA9IDA7XG5cbiAgICB3aGlsZSAoaiA8IG9iakEubGVuZ3RoKSB7XG4gICAgICB3aGVlbC5kYXRhLnB1c2goe1xuICAgICAgICB2YWx1ZTogb2JqQVtqXS5rZXksXG4gICAgICAgIGRpc3BsYXk6IG9iakFbal0udmFsdWVcbiAgICAgIH0pO1xuICAgICAgaisrO1xuICAgIH1cblxuICAgIHJldHVybiB3aGVlbDtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIGxhc3QgaSBudW1iZXIgb2Ygd2hlZWxzXG4gICAqIGkgLSB0aGUgbGFzdCBudW1iZXIgb2Ygd2hlZWxzIHRoYXQgaGFzIHRvIGJlIGhpZGRlblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhpZGVXaGVlbHMoaSkge1xuICAgIGlmIChpbnN0Ll9pc1Zpc2libGUpIHtcbiAgICAgICQkMSgnLm1ic2Mtc2Mtd2hsLXcnLCBpbnN0Ll9tYXJrdXApLmNzcygnZGlzcGxheScsICcnKS5zbGljZShpKS5oaWRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGZpcnN0IHdoZWVsIHZlY3RvciBmcm9tIHRoZSB3aGVlbHRyZWVcbiAgICogd3QgLSB0aGUgd2hlZWwgdHJlZSBvYmplY3RcbiAgICogdXNlcyB0aGUgbHZsIGdsb2JhbCB2YXJpYWJsZSB0byBkZXRlcm1pbmUgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmlyc3RXaGVlbFZlY3Rvcih3YSkge1xuICAgIHZhciB0ID0gW10sXG4gICAgICAgIG5kT2JqQSA9IHdhLFxuICAgICAgICBvYmosXG4gICAgICAgIG9rID0gdHJ1ZSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAob2spIHtcbiAgICAgIG9iaiA9IGdldEZpcnN0VmFsaWRJdGVtT2JqT3JJbmQobmRPYmpBKTtcbiAgICAgIHRbaSsrXSA9IG9iai5rZXk7XG4gICAgICBvayA9IG9iai5jaGlsZHJlbjtcblxuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIG5kT2JqQSA9IG9rO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsZXZlbCBvZiBhIHdoZWVsIHZlY3RvciBhbmQgdGhlIG5ldyB3aGVlbCB2ZWN0b3IsIGRlcGVuZGluZyBvbiBjdXJyZW50IHdoZWVsIHZlY3RvciBhbmQgdGhlIGluZGV4IG9mIHRoZSBjaGFuZ2VkIHdoZWVsXG4gICAqIHd2IC0gY3VycmVudCB3aGVlbCB2ZWN0b3JcbiAgICogaW5kZXggLSBpbmRleCBvZiB0aGUgY2hhbmdlZCB3aGVlbFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNhbGNMZXZlbE9mVmVjdG9yMih3diwgaW5kZXgpIHtcbiAgICB2YXIgY2hpbGRJZHgsXG4gICAgICAgIGNoaWxkTmFtZSxcbiAgICAgICAgaSxcbiAgICAgICAgbGV2ZWwgPSAwLFxuICAgICAgICBuZE9iakEgPSB3YSxcbiAgICAgICAgbmV4dCA9IHRydWUsXG4gICAgICAgIHQgPSBbXTtcblxuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAod3ZbbGV2ZWxdICE9PSB1bmRlZmluZWQgJiYgbGV2ZWwgPD0gaW5kZXgpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGNoaWxkTmFtZSA9IHd2W2xldmVsXTtcbiAgICAgICAgY2hpbGRJZHggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuZE9iakEubGVuZ3RoICYmIGNoaWxkSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobmRPYmpBW2ldLmtleSA9PSB3dltsZXZlbF0gJiYgIW5kT2JqQVtpXS5pbnZhbGlkKSB7XG4gICAgICAgICAgICBjaGlsZElkeCA9IGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZElkeCA9IGdldEZpcnN0VmFsaWRJdGVtT2JqT3JJbmQobmRPYmpBLCB0cnVlKTtcbiAgICAgICAgY2hpbGROYW1lID0gbmRPYmpBW2NoaWxkSWR4XSAmJiBuZE9iakFbY2hpbGRJZHhdLmtleTtcbiAgICAgIH1cblxuICAgICAgdFtsZXZlbF0gPSBjaGlsZE5hbWU7XG4gICAgICBsZXZlbCsrO1xuICAgICAgbmV4dCA9IG5kT2JqQVtjaGlsZElkeF0gPyBuZE9iakFbY2hpbGRJZHhdLmNoaWxkcmVuIDogZmFsc2U7XG4gICAgICBuZE9iakEgPSBuZE9iakFbY2hpbGRJZHhdICYmIG5kT2JqQVtjaGlsZElkeF0uY2hpbGRyZW47XG4gICAgfSAvLyByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgbGV2ZWwgYW5kIHRoZSB3aGVlbCB2ZWN0b3IgYXMgYW4gb2JqZWN0XG5cblxuICAgIHJldHVybiB7XG4gICAgICBsdmw6IGxldmVsLFxuICAgICAgblZlY3RvcjogdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXaGVlbEFycmF5KHVsKSB7XG4gICAgdmFyIHdoZWVsQXJyYXkgPSBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB1bC5sZW5ndGggPiAxID8gdWwgOiB1bC5jaGlsZHJlbihzLml0ZW1TZWxlY3Rvcik7XG4gICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciB0aGF0ID0gJCQxKHRoaXMpLFxuICAgICAgICAgIGMgPSB0aGF0LmNsb25lKCk7XG4gICAgICBjLmNoaWxkcmVuKCd1bCxvbCcpLnJlbW92ZSgpO1xuICAgICAgYy5jaGlsZHJlbihzLml0ZW1TZWxlY3RvcikucmVtb3ZlKCk7XG4gICAgICB2YXIgdiA9IGluc3QuX3Byb2Nlc3NNYXJrdXAgPyBpbnN0Ll9wcm9jZXNzTWFya3VwKGMpIDogYy5odG1sKCkucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyksXG4gICAgICAgICAgaW52ID0gdGhhdC5hdHRyKCdkYXRhLWludmFsaWQnKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICB3aGVlbE9iaiA9IHtcbiAgICAgICAga2V5OiB0aGF0LmF0dHIoJ2RhdGEtdmFsJykgPT09IHVuZGVmaW5lZCB8fCB0aGF0LmF0dHIoJ2RhdGEtdmFsJykgPT09IG51bGwgPyBpbmRleCA6IHRoYXQuYXR0cignZGF0YS12YWwnKSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIGludmFsaWQ6IGludixcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICAgIH0sXG4gICAgICAgICAgbmVzdCA9IHMuaXRlbVNlbGVjdG9yID09PSAnbGknID8gdGhhdC5jaGlsZHJlbigndWwsb2wnKSA6IHRoYXQuY2hpbGRyZW4ocy5pdGVtU2VsZWN0b3IpO1xuXG4gICAgICBpZiAobmVzdC5sZW5ndGgpIHtcbiAgICAgICAgd2hlZWxPYmouY2hpbGRyZW4gPSBjcmVhdGVXaGVlbEFycmF5KG5lc3QpO1xuICAgICAgfVxuXG4gICAgICB3aGVlbEFycmF5LnB1c2god2hlZWxPYmopO1xuICAgIH0pO1xuICAgIHJldHVybiB3aGVlbEFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlV2hlZWxzKHZhbHVlcywgaW5kZXgsIG8pIHtcbiAgICB2YXIgaixcbiAgICAgICAgaSA9IChpbmRleCB8fCAwKSArIDEsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgdyA9IHt9LFxuICAgICAgICB3aGVlbHMgPSB7fTtcbiAgICB3ID0gZ2VuZXJhdGVXaGVlbHNGcm9tVmVjdG9yKHZhbHVlcywgbnVsbCwgaW5kZXgpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgaW5zdC5fdGVtcFdoZWVsQXJyYXlbal0gPSB2YWx1ZXNbal0gPSBvLm5WZWN0b3Jbal0gfHwgMDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IG8ubHZsKSB7XG4gICAgICB3aGVlbHNbaV0gPSBpc0xpcXVpZCA/IHdbMF1baV0gOiB3W2ldWzBdO1xuICAgICAgYXJncy5wdXNoKGkrKyk7XG4gICAgfVxuXG4gICAgaGlkZVdoZWVscyhvLmx2bCk7XG4gICAgY3VycldoZWVsVmVjdG9yID0gdmFsdWVzLnNsaWNlKDApO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgIGluc3QuY2hhbmdlV2hlZWwod2hlZWxzKTtcbiAgICB9XG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIGRlcHRoIG9mIHRoZSB0cmVlXG5cblxuICBnZXREZXB0aCh3YSwgMSk7XG4gIHcgPSBnZW5lcmF0ZVdoZWVsc0Zyb21WZWN0b3IoZnd2LCBsdmwpOyAvLyBSZW1vdmUgaW5wdXQgaWYgZXhpc3RzXG5cbiAgJCQxKCcjJyArIGlkKS5yZW1vdmUoKTtcblxuICBpZiAocy5pbnB1dCkge1xuICAgIGlucHV0ID0gJCQxKHMuaW5wdXQpO1xuICB9IGVsc2UgaWYgKHMuc2hvd0lucHV0KSB7XG4gICAgaW5wdXQgPSAkJDEoJzxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiJyArIGlkICsgJ1wiIHZhbHVlPVwiXCIgY2xhc3M9XCInICsgcy5pbnB1dENsYXNzICsgJ1wiIHBsYWNlaG9sZGVyPVwiJyArIChzLnBsYWNlaG9sZGVyIHx8ICcnKSArICdcIiByZWFkb25seSAvPicpLmluc2VydEJlZm9yZShlbG0pO1xuICB9XG5cbiAgaWYgKGlucHV0KSB7XG4gICAgaW5zdC5hdHRhY2hTaG93KGlucHV0KTtcbiAgfVxuXG4gIGlmICghcy53aGVlbEFycmF5KSB7XG4gICAgZWxtLmhpZGUoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlZWxzOiB3LFxuICAgIGFuY2hvcjogaW5wdXQsXG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgaGVhZGVyVGV4dDogZmFsc2UsXG4gICAgc2V0T25UYXA6IGx2bCA9PSAxLFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICBpZiAoY3VyckxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VyckxldmVsID0gY2FsY0xldmVsT2ZWZWN0b3IyKGQsIGQubGVuZ3RoKS5sdmw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkLnNsaWNlKDAsIGN1cnJMZXZlbCkuam9pbignICcpO1xuICAgIH0sXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gKHZhbHVlICsgJycpLnNwbGl0KCcgJykgOiAocy5kZWZhdWx0VmFsdWUgfHwgZnd2KS5zbGljZSgwKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlU2hvdzogZnVuY3Rpb24gb25CZWZvcmVTaG93KCkge1xuICAgICAgdmFyIHQgPSBpbnN0LmdldEFycmF5VmFsKHRydWUpO1xuICAgICAgY3VycldoZWVsVmVjdG9yID0gdC5zbGljZSgwKTtcbiAgICAgIHMud2hlZWxzID0gZ2VuZXJhdGVXaGVlbHNGcm9tVmVjdG9yKHQsIGx2bCwgbHZsKTtcbiAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25XaGVlbEdlc3R1cmVTdGFydDogZnVuY3Rpb24gb25XaGVlbEdlc3R1cmVTdGFydChldikge1xuICAgICAgcy5yZWFkb25seSA9IGNyZWF0ZVJPVmVjdG9yKGx2bCwgZXYuaW5kZXgpO1xuICAgIH0sXG4gICAgb25XaGVlbEFuaW1hdGlvbkVuZDogZnVuY3Rpb24gb25XaGVlbEFuaW1hdGlvbkVuZChldikge1xuICAgICAgdmFyIGluZGV4ID0gZXYuaW5kZXgsXG4gICAgICAgICAgdmFsdWVzID0gaW5zdC5nZXRBcnJheVZhbCh0cnVlKSxcbiAgICAgICAgICBvID0gY2FsY0xldmVsT2ZWZWN0b3IyKHZhbHVlcywgaW5kZXgpO1xuICAgICAgY3VyckxldmVsID0gby5sdmw7XG4gICAgICBzLnJlYWRvbmx5ID0gb3JpZ1JlYWRPbmx5O1xuXG4gICAgICBpZiAodmFsdWVzW2luZGV4XSAhPSBjdXJyV2hlZWxWZWN0b3JbaW5kZXhdKSB7XG4gICAgICAgIGNoYW5nZVdoZWVscyh2YWx1ZXMsIGluZGV4LCBvKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRmlsbDogZnVuY3Rpb24gb25GaWxsKGV2KSB7XG4gICAgICBjdXJyTGV2ZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpbnB1dC52YWwoZXYudmFsdWVUZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgaW5kZXggPSBkYXRhLmluZGV4LFxuICAgICAgICAgIG8gPSBjYWxjTGV2ZWxPZlZlY3RvcjIodmFsdWVzLCB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgIGN1cnJMZXZlbCA9IG8ubHZsO1xuXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoaWRlV2hlZWxzKG8ubHZsKTtcblxuICAgICAgICBpZiAoIXByZXZlbnQpIHtcbiAgICAgICAgICBjaGFuZ2VXaGVlbHModmFsdWVzLCBpbmRleCwgbyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGdldERpc2FibGVkKGN1cnJMZXZlbCwgd2EsIHZhbHVlcylcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAkJDEoJyMnICsgaWQpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBlbG0uc2hvdygpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBJbWFnZVNjcm9sbGVyID0gU2Nyb2xsZXI7XG5cbnByZXNldHMuaW1hZ2UgPSBmdW5jdGlvbiAoaW5zdCkge1xuICBpZiAoaW5zdC5zZXR0aW5ncy5lbmhhbmNlKSB7XG4gICAgaW5zdC5fcHJvY2Vzc01hcmt1cCA9IGZ1bmN0aW9uIChsaSkge1xuICAgICAgdmFyIGhhc0ljb24gPSBsaS5hdHRyKCdkYXRhLWljb24nKTtcbiAgICAgIGxpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICB2ID0gJCQxKHYpO1xuXG4gICAgICAgIGlmICh2LmlzKCdpbWcnKSkge1xuICAgICAgICAgICQkMSgnPGRpdiBjbGFzcz1cIm1ic2MtaW1nLWNcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcih2KS5hcHBlbmQodi5hZGRDbGFzcygnbWJzYy1pbWcnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi5pcygncCcpKSB7XG4gICAgICAgICAgdi5hZGRDbGFzcygnbWJzYy1pbWctdHh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzSWNvbikge1xuICAgICAgICBsaS5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLScgKyBoYXNJY29uICsgJ1wiPjwvZGl2Jyk7XG4gICAgICB9XG5cbiAgICAgIGxpLmh0bWwoJzxkaXYgY2xhc3M9XCJtYnNjLWltZy13XCI+JyArIGxpLmh0bWwoKSArICc8L2Rpdj4nKTtcbiAgICAgIHJldHVybiBsaS5odG1sKCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBMaXN0LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgTWJzY0ltYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0ltYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NJbWFnZShpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5lbmhhbmNlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NJbWFnZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NJbWFnZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5fZWxlbWVudFJlZiAmJiB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LmdldElucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZ2V0SW5wdXRFbGVtZW50KCkudGhlbihmdW5jdGlvbiAoaW5wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVPcHRpb25zKHsgaW5wdXQ6IGlucCB9LCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICdpbWFnZScsIGlucHV0OiB0YXJnZXQgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgSW1hZ2VTY3JvbGxlcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0ltYWdlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY0ltYWdlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWltYWdlXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NJbWFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NJbWFnZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZW5oYW5jZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW5wdXRDbGFzcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW52YWxpZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2hvd0lucHV0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd3aGVlbEFycmF5JzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLWRhdGEnLF0gfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3RhcmdldCc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy10YXJnZXQnLF0gfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtaW1hZ2UnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtaW1hZ2VDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NJbWFnZTtcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xudmFyIE1ic2NJbWFnZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NJbWFnZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGxpc3RTZXJ2aWNlLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlzdFNlcnZpY2UgPSBsaXN0U2VydmljZTtcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLmxhYmVsID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIF90aGlzLnNob3dJbnB1dCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pbmxpbmVPcHRpb25zT2JqID0ge1xuICAgICAgICAgICAgaXRlbVNlbGVjdG9yOiAnbWJzYy1pbWFnZS1pdGVtJyxcbiAgICAgICAgICAgIHNob3dJbnB1dDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1XcmFwcGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLml0ZW1XcmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRSZW1vdmVIYW5kbGVyID0gdGhpcy5saXN0U2VydmljZS5vbkFkZFJlbW92ZSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2Uub3B0aW9uKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gJCQxKCdtYnNjLWlucHV0JywgdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KVswXTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXRDb250cm9sLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3RTZXJ2aWNlLm9uQWRkUmVtb3ZlKCkudW5zdWJzY3JpYmUodGhpcy5hZGRSZW1vdmVIYW5kbGVyKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY0ltYWdlQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bWJzYy1pbnB1dCAqbmdJZj1cXFwiIWlubGluZSB8fCBzaG93SW5wdXRcXFwiIFxcbiAgICAgICAgW25hbWVdPVxcXCJuYW1lXFxcIiBcXG4gICAgICAgIFt0aGVtZV09XFxcInRoZW1lXFxcIiBcXG4gICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBcXG4gICAgICAgIFtlcnJvcl09XFxcImVycm9yXFxcIiBcXG4gICAgICAgIFtlcnJvck1lc3NhZ2VdPVxcXCJlcnJvck1lc3NhZ2VcXFwiIFxcbiAgICAgICAgW2ljb25dPVxcXCJpbnB1dEljb25cXFwiIFxcbiAgICAgICAgW2ljb24tYWxpZ25dPVxcXCJpY29uQWxpZ25cXFwiXFxuICAgICAgICBbcGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlclxcXCJcXG4gICAgICAgIFtjb250cm9sTmddPVxcXCJmYWxzZVxcXCI+e3tsYWJlbH19XFxuICAgICAgICA8L21ic2MtaW5wdXQ+XFxuICAgICAgICA8c3BhbiAjaXRlbVdyYXBwZXI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cIixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0xpc3RTZXJ2aWNlXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0ltYWdlQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NMaXN0U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjSW1hZ2VDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3doZWVsQXJyYXknOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2RhdGEnLF0gfSxdLFxuICAgICAgICAnbGFiZWwnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpdGVtV3JhcHBlcic6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydpdGVtV3JhcHBlcicsIHsgc3RhdGljOiBmYWxzZSB9LF0gfSxdLFxuICAgICAgICAnc2hvd0lucHV0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0ltYWdlQ29tcG9uZW50O1xufShNYnNjSW1hZ2UpKTtcbnZhciBNYnNjSW1hZ2VJdGVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2VJdGVtKGxpc3RTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubGlzdFNlcnZpY2UgPSBsaXN0U2VydmljZTtcbiAgICB9XG4gICAgTWJzY0ltYWdlSXRlbS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3RTZXJ2aWNlLm5vdGlmeUFkZFJlbW92ZSh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NJbWFnZUl0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpc3RTZXJ2aWNlLm5vdGlmeUFkZFJlbW92ZSh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NJbWFnZUl0ZW0uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1pbWFnZS1pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtdmFsXSc6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pY29uXSc6ICdpY29uJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjSW1hZ2VJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IE1ic2NMaXN0U2VydmljZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NJbWFnZUl0ZW0ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaWNvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NJbWFnZUl0ZW07XG59KCkpO1xudmFyIE1ic2NJbWFnZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY0ltYWdlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjSW1hZ2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0ltYWdlLCBNYnNjSW1hZ2VDb21wb25lbnQsIE1ic2NJbWFnZUl0ZW1dLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY0ltYWdlLCBNYnNjSW1hZ2VDb21wb25lbnQsIE1ic2NJbWFnZUl0ZW1dXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjSW1hZ2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY0ltYWdlTW9kdWxlO1xufSgpKTtcblxudmFyIE1lYXN1cmVtZW50ID0gU2Nyb2xsZXI7XG52YXIgZGVmYXVsdHMkNiA9IHtcbiAgYmF0Y2g6IDUwLFxuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBkZWZhdWx0VW5pdDogJycsXG4gIHVuaXRzOiBudWxsLFxuICB1bml0TmFtZXM6IG51bGwsXG4gIGludmFsaWQ6IFtdLFxuICBzaWduOiBmYWxzZSxcbiAgc3RlcDogMC4wNSxcbiAgc2NhbGU6IDIsXG4gIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgc2lnblRleHQ6ICcmbmJzcDsnLFxuICB3aG9sZVRleHQ6ICdXaG9sZScsXG4gIGZyYWN0aW9uVGV4dDogJ0ZyYWN0aW9uJyxcbiAgdW5pdFRleHQ6ICdVbml0J1xufTtcblxucHJlc2V0cy5tZWFzdXJlbWVudCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJDYsIG9yaWcpLFxuICAgICAgd2hlZWwgPSB7fSxcbiAgICAgIHcgPSBbW11dLFxuICAgICAgd2hvbGVJbnZhbGlkcyA9IHt9LFxuICAgICAgd2hvbGVXaGVlbCA9IHt9LFxuICAgICAgZnJhY3Rpb25XaGVlbCA9IHt9LFxuICAgICAgZnJhY3Rpb25zID0gW10sXG4gICAgICB1c2VTaWduID0gcy5zaWduLFxuICAgICAgdXNlVW5pdHMgPSBzLnVuaXRzICYmIHMudW5pdHMubGVuZ3RoLFxuICAgICAgYmFzZVVuaXQgPSB1c2VVbml0cyA/IHMuZGVmYXVsdFVuaXQgfHwgcy51bml0c1swXSA6ICcnLFxuICAgICAgdW5pdHMgPSBbXSxcbiAgICAgIHVzZUZyYWN0ID0gcy5zdGVwIDwgMSxcbiAgICAgIHdob2xlU3RlcCA9IHMuc3RlcCA+IDEgPyBzLnN0ZXAgOiAxLFxuICAgICAgZnJhY3RMZW5ndGggPSB1c2VGcmFjdCA/IE1hdGgubWF4KHMuc2NhbGUsIChzLnN0ZXAgKyAnJykuc3BsaXQoJy4nKVsxXS5sZW5ndGgpIDogMSxcbiAgICAgIG9uZSA9IE1hdGgucG93KDEwLCBmcmFjdExlbmd0aCksXG4gICAgICBzdGVwcyA9IE1hdGgucm91bmQodXNlRnJhY3QgPyBzLnN0ZXAgKiBvbmUgOiBzLnN0ZXApLFxuICAgICAgZnJhY3ROcixcbiAgICAgIHJlYWxWYWx1ZSxcbiAgICAgIG9sZFVuaXQsXG4gICAgICBpZHhGcmFjdCxcbiAgICAgIGlkeFdob2xlLFxuICAgICAgaWR4VW5pdCxcbiAgICAgIG1pblZhbCxcbiAgICAgIG1heFZhbCxcbiAgICAgIG1pbldob2xlLFxuICAgICAgbWF4V2hvbGUsXG4gICAgICBtaW5GcmFjdCxcbiAgICAgIG1heEZyYWN0LFxuICAgICAgd2hvbGVPZmZzZXQgPSAwLFxuICAgICAgZnJhY3RPZmZzZXQgPSAwLFxuICAgICAgdixcbiAgICAgIGosXG4gICAgICBpID0gMDtcblxuICBmdW5jdGlvbiBnZXRXaG9sZShrKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbldob2xlLCBNYXRoLm1pbihtYXhXaG9sZSwgdXNlRnJhY3QgPyBrIDwgMCA/IE1hdGguY2VpbChrKSA6IE1hdGguZmxvb3IoaykgOiBzdGVwKE1hdGgucm91bmQoayAtIHdob2xlT2Zmc2V0KSwgc3RlcHMpICsgd2hvbGVPZmZzZXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZyYWN0KGspIHtcbiAgICByZXR1cm4gdXNlRnJhY3QgPyBzdGVwKChNYXRoLmFicyhrKSAtIE1hdGguYWJzKGdldFdob2xlKGspKSkgKiBvbmUgLSBmcmFjdE9mZnNldCwgc3RlcHMpICsgZnJhY3RPZmZzZXQgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFydHModikge1xuICAgIHZhciB3aG9sZSA9IGdldFdob2xlKHYpLFxuICAgICAgICBmcmFjdCA9IGdldEZyYWN0KHYpLFxuICAgICAgICBzaWduID0gdiA8IDAgPyAnLScgOiAnKyc7XG5cbiAgICBpZiAoZnJhY3QgPj0gb25lKSB7XG4gICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgd2hvbGUtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdob2xlKys7XG4gICAgICB9XG5cbiAgICAgIGZyYWN0ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NpZ24sIHdob2xlLCBmcmFjdF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXROcihkKSB7XG4gICAgdmFyIHdob2xlID0gK2RbaWR4V2hvbGVdLFxuICAgICAgICBmcmFjdCA9IHVzZUZyYWN0ID8gZFtpZHhGcmFjdF0gLyBvbmUgKiAod2hvbGUgPCAwID8gLTEgOiAxKSA6IDA7XG4gICAgcmV0dXJuICh1c2VTaWduICYmIGRbMF0gPT0gJy0nID8gLTEgOiAxKSAqICh3aG9sZSArIGZyYWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAodiwgc3QpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2IC8gc3QpICogc3Q7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0KHYsIHUxLCB1Mikge1xuICAgIGlmICh1MSA9PT0gdTIgfHwgIXMuY29udmVydCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMuY29udmVydC5jYWxsKHRoaXMsIHYsIHUxLCB1Mik7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRNaW5NYXgodW5pdCkge1xuICAgIHZhciBtaW52LCBtYXh2O1xuICAgIG1pblZhbCA9IGNvbnZlcnQocy5taW4sIGJhc2VVbml0LCB1bml0KTtcbiAgICBtYXhWYWwgPSBjb252ZXJ0KHMubWF4LCBiYXNlVW5pdCwgdW5pdCk7XG5cbiAgICBpZiAodXNlRnJhY3QpIHtcbiAgICAgIG1pbldob2xlID0gbWluVmFsIDwgMCA/IE1hdGguY2VpbChtaW5WYWwpIDogTWF0aC5mbG9vcihtaW5WYWwpO1xuICAgICAgbWF4V2hvbGUgPSBtYXhWYWwgPCAwID8gTWF0aC5jZWlsKG1heFZhbCkgOiBNYXRoLmZsb29yKG1heFZhbCk7XG4gICAgICBtaW5GcmFjdCA9IGdldEZyYWN0KG1pblZhbCk7XG4gICAgICBtYXhGcmFjdCA9IGdldEZyYWN0KG1heFZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbldob2xlID0gTWF0aC5yb3VuZChtaW5WYWwpO1xuICAgICAgbWF4V2hvbGUgPSBNYXRoLnJvdW5kKG1heFZhbCk7XG4gICAgICBtYXhXaG9sZSA9IG1pbldob2xlICsgTWF0aC5mbG9vcigobWF4V2hvbGUgLSBtaW5XaG9sZSkgLyBzdGVwcykgKiBzdGVwcztcbiAgICAgIHdob2xlT2Zmc2V0ID0gbWluV2hvbGUgJSBzdGVwcztcbiAgICB9XG5cbiAgICBtaW52ID0gbWluV2hvbGU7XG4gICAgbWF4diA9IG1heFdob2xlO1xuXG4gICAgaWYgKHVzZVNpZ24pIHtcbiAgICAgIG1heHYgPSBNYXRoLmFicyhtaW52KSA+IE1hdGguYWJzKG1heHYpID8gTWF0aC5hYnMobWludikgOiBNYXRoLmFicyhtYXh2KTtcbiAgICAgIG1pbnYgPSBtaW52IDwgMCA/IDAgOiBtaW52O1xuICAgIH1cblxuICAgIHdob2xlV2hlZWwubWluID0gbWludiA8IDAgPyBNYXRoLmNlaWwobWludiAvIHdob2xlU3RlcCkgOiBNYXRoLmZsb29yKG1pbnYgLyB3aG9sZVN0ZXApO1xuICAgIHdob2xlV2hlZWwubWF4ID0gbWF4diA8IDAgPyBNYXRoLmNlaWwobWF4diAvIHdob2xlU3RlcCkgOiBNYXRoLmZsb29yKG1heHYgLyB3aG9sZVN0ZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KGQpIHtcbiAgICByZXR1cm4gZ2V0TnIoZCkudG9GaXhlZCh1c2VGcmFjdCA/IGZyYWN0TGVuZ3RoIDogMCkgKyAodXNlVW5pdHMgPyAnICcgKyB1bml0c1tkW2lkeFVuaXRdXSA6ICcnKTtcbiAgfSAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICAvLyBGb3JjZSBwYXJzZSBpZiB2YWx1ZSBpcyBwYXNzZWQgYXMgYW4gYXJyYXlcbiAgICBpbnN0Ll9zZXRWYWwoJCQxLmlzQXJyYXkodmFsKSA/IGZvcm1hdCh2YWwpIDogdmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpO1xuICB9OyAvLyAtLS1cbiAgLy8gSW5pdHNcbiAgLy8gZ2VuZXJhdGUgYXJyYXkgZnJvbSB1bml0TmFtZXNcblxuXG4gIGlmIChzLnVuaXRzKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHMudW5pdHMubGVuZ3RoOyArK2opIHtcbiAgICAgIHYgPSBzLnVuaXRzW2pdO1xuICAgICAgdW5pdHMucHVzaChzLnVuaXROYW1lcyA/IHMudW5pdE5hbWVzW3ZdIHx8IHYgOiB2KTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgc2lnbiBpcyBuZWVkZWRcblxuXG4gIGlmICh1c2VTaWduKSB7XG4gICAgdXNlU2lnbiA9IGZhbHNlO1xuXG4gICAgaWYgKHVzZVVuaXRzKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcy51bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoY29udmVydChzLm1pbiwgYmFzZVVuaXQsIHMudW5pdHNbal0pIDwgMCkge1xuICAgICAgICAgIHVzZVNpZ24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZVNpZ24gPSBzLm1pbiA8IDA7XG4gICAgfVxuICB9IC8vIFNpZ24gd2hlZWwgKGlmIGVuYWJsZWQpXG5cblxuICBpZiAodXNlU2lnbikge1xuICAgIHdbMF0ucHVzaCh7XG4gICAgICBkYXRhOiBbJy0nLCAnKyddLFxuICAgICAgbGFiZWw6IHMuc2lnblRleHRcbiAgICB9KTtcbiAgICBpKys7XG4gIH0gLy8gV2hvbGUgd2hlZWwgKGxhdGVyIGdlbmVyYXRlZClcblxuXG4gIHdob2xlV2hlZWwgPSB7XG4gICAgbGFiZWw6IHMud2hvbGVUZXh0LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoaSkge1xuICAgICAgcmV0dXJuIG1pbldob2xlICUgd2hvbGVTdGVwICsgaSAqIHdob2xlU3RlcDtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiBnZXRJbmRleChpKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoaSAtIG1pbldob2xlICUgd2hvbGVTdGVwKSAvIHdob2xlU3RlcCk7XG4gICAgfVxuICB9O1xuICB3WzBdLnB1c2god2hvbGVXaGVlbCk7XG4gIGlkeFdob2xlID0gaSsrO1xuICBzZXRNaW5NYXgoYmFzZVVuaXQpOyAvLyBGcmFjdGlvbiB3aGVlbFxuXG4gIGlmICh1c2VGcmFjdCkge1xuICAgIHdbMF0ucHVzaChmcmFjdGlvbldoZWVsKTtcbiAgICBmcmFjdGlvbldoZWVsLmRhdGEgPSBbXTtcbiAgICBmcmFjdGlvbldoZWVsLmxhYmVsID0gcy5mcmFjdGlvblRleHQ7XG5cbiAgICBmb3IgKGogPSBmcmFjdE9mZnNldDsgaiA8IG9uZTsgaiArPSBzdGVwcykge1xuICAgICAgZnJhY3Rpb25zLnB1c2goaik7XG4gICAgICBmcmFjdGlvbldoZWVsLmRhdGEucHVzaCh7XG4gICAgICAgIHZhbHVlOiBqLFxuICAgICAgICBkaXNwbGF5OiBzLmRlY2ltYWxTZXBhcmF0b3IgKyBwYWQoaiwgZnJhY3RMZW5ndGgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZHhGcmFjdCA9IGkrKztcbiAgICBmcmFjdE5yID0gTWF0aC5jZWlsKDEwMCAvIHN0ZXBzKTtcblxuICAgIGlmIChzLmludmFsaWQgJiYgcy5pbnZhbGlkLmxlbmd0aCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHdob2xlIGludmFsaWRzXG4gICAgICAkJDEuZWFjaChzLmludmFsaWQsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIHZhciB3ID0gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayArMCBhbmQgLTAgc2VwcGFyYXRlbHlcbiAgICAgICAgICB3ID0gdiA8PSAwID8gLTAuMDAxIDogMC4wMDE7XG4gICAgICAgIH1cblxuICAgICAgICB3aG9sZUludmFsaWRzW3ddID0gKHdob2xlSW52YWxpZHNbd10gfHwgMCkgKyAxO1xuXG4gICAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgICAgdyA9IDAuMDAxO1xuICAgICAgICAgIHdob2xlSW52YWxpZHNbd10gPSAod2hvbGVJbnZhbGlkc1t3XSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJCQxLmVhY2god2hvbGVJbnZhbGlkcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgaWYgKHYgPCBmcmFjdE5yKSB7XG4gICAgICAgICAgZGVsZXRlIHdob2xlSW52YWxpZHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hvbGVJbnZhbGlkc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBVbml0IHdoZWVsXG5cblxuICBpZiAodXNlVW5pdHMpIHtcbiAgICB3aGVlbCA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWw6IHMudW5pdFRleHQsXG4gICAgICBjc3NDbGFzczogJ21ic2MtbXNyLXdobC11bml0JyxcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcy51bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgd2hlZWwuZGF0YS5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGosXG4gICAgICAgIGRpc3BsYXk6IHVuaXRzW2pdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3WzBdLnB1c2god2hlZWwpO1xuICB9XG5cbiAgaWR4VW5pdCA9IGk7XG4gIHJldHVybiB7XG4gICAgd2hlZWxzOiB3LFxuICAgIG1pbldpZHRoOiB1c2VTaWduICYmIHVzZUZyYWN0ID8gNzAgOiA4MCxcbiAgICBzaG93TGFiZWw6IGZhbHNlLFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXQsXG4gICAgY29tcENsYXNzOiAnbWJzYy1tc3IgbWJzYy1zYycsXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICB2YXIgdnYgPSAodHlwZW9mIHYgPT09ICdudW1iZXInID8gdiArICcnIDogdikgfHwgcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgZCA9ICh2diArICcnKS5zcGxpdCgnICcpLFxuICAgICAgICAgIHZhbCA9ICtkWzBdLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIHVuaXQgPSAnJztcblxuICAgICAgaWYgKHVzZVVuaXRzKSB7XG4gICAgICAgIHVuaXQgPSAkJDEuaW5BcnJheShkWzFdLCB1bml0cyk7XG4gICAgICAgIHVuaXQgPSB1bml0ID09IC0xID8gJCQxLmluQXJyYXkoYmFzZVVuaXQsIHMudW5pdHMpIDogdW5pdDtcbiAgICAgICAgdW5pdCA9IHVuaXQgPT0gLTEgPyAwIDogdW5pdDtcbiAgICAgIH1cblxuICAgICAgb2xkVW5pdCA9IHVzZVVuaXRzID8gcy51bml0c1t1bml0XSA6ICcnO1xuICAgICAgc2V0TWluTWF4KG9sZFVuaXQpO1xuICAgICAgdmFsID0gaXNOYU4odmFsKSA/IDAgOiB2YWw7XG4gICAgICB2YWwgPSBjb25zdHJhaW4odmFsLCBtaW5WYWwsIG1heFZhbCk7XG4gICAgICBwYXJ0cyA9IGdldFBhcnRzKHZhbCk7XG4gICAgICBwYXJ0c1sxXSA9IGNvbnN0cmFpbihwYXJ0c1sxXSwgbWluV2hvbGUsIG1heFdob2xlKTtcbiAgICAgIHJlYWxWYWx1ZSA9IHZhbDtcblxuICAgICAgaWYgKHVzZVNpZ24pIHtcbiAgICAgICAgcmV0WzBdID0gcGFydHNbMF07XG4gICAgICAgIHBhcnRzWzFdID0gTWF0aC5hYnMocGFydHNbMV0pO1xuICAgICAgfVxuXG4gICAgICByZXRbaWR4V2hvbGVdID0gcGFydHNbMV07XG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICByZXRbaWR4RnJhY3RdID0gcGFydHNbMl07XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VVbml0cykge1xuICAgICAgICByZXRbaWR4VW5pdF0gPSB1bml0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgcmVhbFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBtaW51cyxcbiAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICB3aG9sZSxcbiAgICAgICAgICBpcGFydHMsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB2YWx1ZXMgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZGlyID0gZGF0YS5kaXJlY3Rpb24sXG4gICAgICAgICAgZGlzID0ge30sXG4gICAgICAgICAgZGlzYWJsZWQgPSBbXSxcbiAgICAgICAgICB3aGVlbHMgPSB7fSxcbiAgICAgICAgICBuZXdVbml0ID0gdXNlVW5pdHMgPyBzLnVuaXRzW3ZhbHVlc1tpZHhVbml0XV0gOiAnJzsgLy8gU2lnbiBjaGFuZ2VkXG5cbiAgICAgIGlmICh1c2VTaWduICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJlYWxWYWx1ZSA9IE1hdGguYWJzKHJlYWxWYWx1ZSkgKiAodmFsdWVzWzBdID09ICctJyA/IC0xIDogMSk7XG4gICAgICB9IC8vIFNldCByZWFsIHZhbHVlIGlmIG51bWJlcnMgY2hhbmdlZFxuXG5cbiAgICAgIGlmIChpbmRleCA9PT0gaWR4V2hvbGUgfHwgaW5kZXggPT09IGlkeEZyYWN0ICYmIHVzZUZyYWN0IHx8IHJlYWxWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVhbFZhbHVlID0gZ2V0TnIodmFsdWVzKTtcbiAgICAgICAgb2xkVW5pdCA9IG5ld1VuaXQ7XG4gICAgICB9IC8vIENvbnZlcnQgdmFsdWUgaWYgdW5pdCBjaGFuZ2VkXG5cblxuICAgICAgaWYgKHVzZVVuaXRzICYmIGluZGV4ID09PSBpZHhVbml0ICYmIG9sZFVuaXQgIT09IG5ld1VuaXQgfHwgaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRNaW5NYXgobmV3VW5pdCk7XG4gICAgICAgIHJlYWxWYWx1ZSA9IGNvbnZlcnQocmVhbFZhbHVlLCBvbGRVbml0LCBuZXdVbml0KTtcbiAgICAgICAgb2xkVW5pdCA9IG5ld1VuaXQ7XG4gICAgICAgIHBhcnRzID0gZ2V0UGFydHMocmVhbFZhbHVlKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vd2hvbGVXaGVlbC5fcmVmcmVzaCgpO1xuICAgICAgICAgIHdoZWVsc1tpZHhXaG9sZV0gPSB3aG9sZVdoZWVsO1xuICAgICAgICAgIGluc3QuY2hhbmdlV2hlZWwod2hlZWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VTaWduKSB7XG4gICAgICAgICAgdmFsdWVzWzBdID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGlzYWJsZSBpbnZhbGlkIHZhbHVlc1xuXG5cbiAgICAgIGRpc2FibGVkW2lkeFdob2xlXSA9IFtdO1xuXG4gICAgICBpZiAodXNlU2lnbikge1xuICAgICAgICAvLyBEaXNhYmxlICsvLSBzaWduc1xuICAgICAgICBkaXNhYmxlZFswXSA9IFtdO1xuXG4gICAgICAgIGlmIChtaW5WYWwgPiAwKSB7XG4gICAgICAgICAgZGlzYWJsZWRbMF0ucHVzaCgnLScpO1xuICAgICAgICAgIHZhbHVlc1swXSA9ICcrJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhWYWwgPCAwKSB7XG4gICAgICAgICAgZGlzYWJsZWRbMF0ucHVzaCgnKycpO1xuICAgICAgICAgIHZhbHVlc1swXSA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZyb20gPSBNYXRoLmFicyh2YWx1ZXNbMF0gPT0gJy0nID8gbWluV2hvbGUgOiBtYXhXaG9sZSk7XG5cbiAgICAgICAgZm9yIChpID0gZnJvbSArIHdob2xlU3RlcDsgaSA8IGZyb20gKyAyMCAqIHdob2xlU3RlcDsgaSArPSB3aG9sZVN0ZXApIHtcbiAgICAgICAgICBkaXNhYmxlZFtpZHhXaG9sZV0ucHVzaChpKTtcbiAgICAgICAgICBkaXNbaV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWxWYWx1ZSA9IGNvbnN0cmFpbihyZWFsVmFsdWUsIG1pblZhbCwgbWF4VmFsKTtcbiAgICAgIHBhcnRzID0gZ2V0UGFydHMocmVhbFZhbHVlKTtcbiAgICAgIHdob2xlID0gdXNlU2lnbiA/IE1hdGguYWJzKHBhcnRzWzFdKSA6IHBhcnRzWzFdO1xuICAgICAgbWludXMgPSB1c2VTaWduID8gdmFsdWVzWzBdID09ICctJyA6IHJlYWxWYWx1ZSA8IDA7XG4gICAgICB2YWx1ZXNbaWR4V2hvbGVdID0gd2hvbGU7XG5cbiAgICAgIGlmIChtaW51cykge1xuICAgICAgICAvLyBOZWVkIHRoaXMgZm9yIDBcbiAgICAgICAgcGFydHNbMF0gPSAnLSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICB2YWx1ZXNbaWR4RnJhY3RdID0gcGFydHNbMl07XG4gICAgICB9IC8vIERpc2FibGUgaW52YWxpZCB2YWx1ZXMgb24gd2hvbGUgd2hlZWxcblxuXG4gICAgICAkJDEuZWFjaCh1c2VGcmFjdCA/IHdob2xlSW52YWxpZHMgOiBzLmludmFsaWQsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIC8vIGRpc2FibGUgd2hvbGUgdXNlciB2YWx1ZXNcbiAgICAgICAgaWYgKHVzZVNpZ24gJiYgbWludXMpIHtcbiAgICAgICAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5hYnModik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gc3RlcChjb252ZXJ0KHYsIGJhc2VVbml0LCBuZXdVbml0KSwgdXNlRnJhY3QgPyAxIDogc3RlcHMpO1xuICAgICAgICBkaXNbdl0gPSB0cnVlO1xuICAgICAgICBkaXNhYmxlZFtpZHhXaG9sZV0ucHVzaCh2KTtcbiAgICAgIH0pOyAvLyBGaW5kIG5lYXJlc3QgdmFsaWQgd2hvbGUgdmFsdWVcblxuICAgICAgdmFsdWVzW2lkeFdob2xlXSA9IGluc3QuZ2V0VmFsaWRWYWx1ZShpZHhXaG9sZSwgd2hvbGUsIGRpciwgZGlzKTtcbiAgICAgIHBhcnRzWzFdID0gdmFsdWVzW2lkeFdob2xlXSAqICh1c2VTaWduICYmIG1pbnVzID8gLTEgOiAxKTsgLy8gVmFsaWRhdGUgZnJhY3Rpb24gd2hlZWwgdmFsdWVzXG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICBkaXNhYmxlZFtpZHhGcmFjdF0gPSBbXTsgLy8gV2UgbmVlZCB0byBtYWtlIGRpZmZlcmVuY2UgYmV0d2VlbiArMCBhbmQgLTAsIHNvIHdlIGNvbXBhcmUgdGhlIHN0cmluZ3MgaW5zdGVhZCBvZiBudW1iZXJzXG5cbiAgICAgICAgdmFyIHAxID0gdXNlU2lnbiA/IHZhbHVlc1swXSArIHZhbHVlc1sxXSA6IChyZWFsVmFsdWUgPCAwID8gJy0nIDogJysnKSArIE1hdGguYWJzKHBhcnRzWzFdKSxcbiAgICAgICAgICAgIHAyID0gKG1pblZhbCA8IDAgPyAnLScgOiAnKycpICsgTWF0aC5hYnMobWluV2hvbGUpLFxuICAgICAgICAgICAgcDMgPSAobWF4VmFsIDwgMCA/ICctJyA6ICcrJykgKyBNYXRoLmFicyhtYXhXaG9sZSk7IC8vIERpc2FibGUgb3V0IG9mIHJhbmdlIGZyYWN0aW9uIHZhbHVlc1xuXG4gICAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgICAkJDEoZnJhY3Rpb25zKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgICBpZiAobWludXMgPyB2ID4gbWluRnJhY3QgOiB2IDwgbWluRnJhY3QpIHtcbiAgICAgICAgICAgICAgZGlzYWJsZWRbaWR4RnJhY3RdLnB1c2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocDEgPT09IHAzKSB7XG4gICAgICAgICAgJCQxKGZyYWN0aW9ucykuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgICAgaWYgKG1pbnVzID8gdiA8IG1heEZyYWN0IDogdiA+IG1heEZyYWN0KSB7XG4gICAgICAgICAgICAgIGRpc2FibGVkW2lkeEZyYWN0XS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIERpc2FibGUgaW52YWxpZCBmcmFjdGlvbiB2YWx1ZXNcblxuXG4gICAgICAgICQkMS5lYWNoKHMuaW52YWxpZCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBpcGFydHMgPSBnZXRQYXJ0cyhjb252ZXJ0KHYsIGJhc2VVbml0LCBuZXdVbml0KSk7IC8vIFNpZ24gYW5kIHdob2xlIHBhcnQgbWF0Y2hlc1xuXG4gICAgICAgICAgaWYgKChwYXJ0c1swXSA9PT0gaXBhcnRzWzBdIHx8IHBhcnRzWzFdID09PSAwICYmIGlwYXJ0c1sxXSA9PT0gMCAmJiBpcGFydHNbMl0gPT09IDApICYmIHBhcnRzWzFdID09PSBpcGFydHNbMV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkW2lkeEZyYWN0XS5wdXNoKGlwYXJ0c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICB2YWxpZDogdmFsdWVzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBkZWZhdWx0cyQ3ID0ge1xuICBtaW46IC0yMCxcbiAgbWF4OiA0MCxcbiAgZGVmYXVsdFVuaXQ6ICdjJyxcbiAgdW5pdHM6IFsnYycsICdrJywgJ2YnLCAnciddLFxuICB1bml0TmFtZXM6IHtcbiAgICBjOiAnwrBDJyxcbiAgICBrOiAnSycsXG4gICAgZjogJ8KwRicsXG4gICAgcjogJ8KwUidcbiAgfVxufSxcbiAgICBjb2JqID0ge1xuICBjMms6IGZ1bmN0aW9uIGMyayhjKSB7XG4gICAgcmV0dXJuIGMgKyAyNzMuMTU7XG4gIH0sXG4gIGMyZjogZnVuY3Rpb24gYzJmKGMpIHtcbiAgICByZXR1cm4gYyAqIDkgLyA1ICsgMzI7XG4gIH0sXG4gIGMycjogZnVuY3Rpb24gYzJyKGMpIHtcbiAgICByZXR1cm4gKGMgKyAyNzMuMTUpICogOSAvIDU7XG4gIH0sXG4gIGsyYzogZnVuY3Rpb24gazJjKGspIHtcbiAgICByZXR1cm4gayAtIDI3My4xNTtcbiAgfSxcbiAgazJmOiBmdW5jdGlvbiBrMmYoaykge1xuICAgIHJldHVybiBrICogOSAvIDUgLSA0NTkuNjc7XG4gIH0sXG4gIGsycjogZnVuY3Rpb24gazJyKGspIHtcbiAgICByZXR1cm4gayAqIDkgLyA1O1xuICB9LFxuICBmMmM6IGZ1bmN0aW9uIGYyYyhmKSB7XG4gICAgcmV0dXJuIChmIC0gMzIpICogNSAvIDk7XG4gIH0sXG4gIGYyazogZnVuY3Rpb24gZjJrKGYpIHtcbiAgICByZXR1cm4gKGYgKyA0NTkuNjcpICogNSAvIDk7XG4gIH0sXG4gIGYycjogZnVuY3Rpb24gZjJyKGYpIHtcbiAgICByZXR1cm4gZiArIDQ1OS42NztcbiAgfSxcbiAgcjJjOiBmdW5jdGlvbiByMmMocikge1xuICAgIHJldHVybiAociAtIDQ5MS42NykgKiA1IC8gOTtcbiAgfSxcbiAgcjJrOiBmdW5jdGlvbiByMmsocikge1xuICAgIHJldHVybiByICogNSAvIDk7XG4gIH0sXG4gIHIyZjogZnVuY3Rpb24gcjJmKHIpIHtcbiAgICByZXR1cm4gciAtIDQ1OS42NztcbiAgfVxufTtcblxucHJlc2V0cy50ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRlZmF1bHRzJDcsIGluc3Quc2V0dGluZ3MpO1xuICBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBzLCB7XG4gICAgc2lnbjogdHJ1ZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gY29ialt1bml0MSArICcyJyArIHVuaXQyXSh2YWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcmVzZXRzLm1lYXN1cmVtZW50LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgZGVmYXVsdHMkOCA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrbScsXG4gIHVuaXRzOiBbJ20nLCAna20nLCAnaW4nLCAnZnQnLCAneWQnLCAnbWknXVxufSxcbiAgICBjb2JqJDEgPSB7XG4gIG1tOiAwLjAwMSxcbiAgY206IDAuMDEsXG4gIGRtOiAwLjEsXG4gIG06IDEsXG4gIGRhbTogMTAsXG4gIGhtOiAxMDAsXG4gIGttOiAxMDAwLFxuICAnaW4nOiAwLjAyNTQsXG4gIGZ0OiAwLjMwNDgsXG4gIHlkOiAwLjkxNDQsXG4gIGNoOiAyMC4xMTY4LFxuICBmdXI6IDIwMS4xNjgsXG4gIG1pOiAxNjA5LjM0NCxcbiAgbGVhOiA0ODI4LjAzMlxufTtcblxucHJlc2V0cy5kaXN0YW5jZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRlZmF1bHRzJDgsIGluc3Quc2V0dGluZ3MpO1xuICBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBzLCB7XG4gICAgc2lnbjogZmFsc2UsXG4gICAgY29udmVydDogZnVuY3Rpb24gY29udmVydCh2YWwsIHVuaXQxLCB1bml0Mikge1xuICAgICAgcmV0dXJuIHZhbCAqIGNvYmokMVt1bml0MV0gLyBjb2JqJDFbdW5pdDJdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcmVzZXRzLm1lYXN1cmVtZW50LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgZGVmYXVsdHMkOSA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrcGgnLFxuICB1bml0czogWydrcGgnLCAnbXBoJywgJ21wcycsICdmcHMnLCAna25vdCddLFxuICB1bml0TmFtZXM6IHtcbiAgICBrcGg6ICdrbS9oJyxcbiAgICBtcGg6ICdtaS9oJyxcbiAgICBtcHM6ICdtL3MnLFxuICAgIGZwczogJ2Z0L3MnLFxuICAgIGtub3Q6ICdrbm90J1xuICB9XG59LFxuICAgIGNvYmokMiA9IHtcbiAga3BoOiAxLFxuICBtcGg6IDEuNjA5MzQsXG4gIG1wczogMy42LFxuICBmcHM6IDEuMDk3MjgsXG4gIGtub3Q6IDEuODUyXG59O1xuXG5wcmVzZXRzLnNwZWVkID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIHMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMkOSwgaW5zdC5zZXR0aW5ncyk7XG4gIGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHMsIHtcbiAgICBzaWduOiBmYWxzZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gdmFsICogY29iaiQyW3VuaXQxXSAvIGNvYmokMlt1bml0Ml07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByZXNldHMubWVhc3VyZW1lbnQuY2FsbCh0aGlzLCBpbnN0KTtcbn07XG5cbnZhciBkZWZhdWx0cyRhID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBkZWZhdWx0VW5pdDogJ04nLFxuICB1bml0czogWydOJywgJ2twJywgJ2xiZicsICdwZGwnXVxufSxcbiAgICBjb2JqJDMgPSB7XG4gIE46IDEsXG4gIGtwOiA5LjgwNjY1LFxuICBsYmY6IDQuNDQ4MjIyLFxuICBwZGw6IDAuMTM4MjU1XG59O1xuXG5wcmVzZXRzLmZvcmNlID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIHMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMkYSwgaW5zdC5zZXR0aW5ncyk7XG4gIGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHMsIHtcbiAgICBzaWduOiBmYWxzZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gdmFsICogY29iaiQzW3VuaXQxXSAvIGNvYmokM1t1bml0Ml07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByZXNldHMubWVhc3VyZW1lbnQuY2FsbCh0aGlzLCBpbnN0KTtcbn07XG5cbnZhciBkZWZhdWx0cyRiID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrZycsXG4gIHVuaXRzOiBbJ2cnLCAna2cnLCAnb3onLCAnbGInXSxcbiAgdW5pdE5hbWVzOiB7XG4gICAgdGxvbmc6ICd0IChsb25nKScsXG4gICAgdHNob3J0OiAndCAoc2hvcnQpJ1xuICB9XG59LFxuICAgIGNvYmokNCA9IHtcbiAgbWc6IDAuMDAxLFxuICBjZzogMC4wMSxcbiAgZGc6IDAuMSxcbiAgZzogMSxcbiAgZGFnOiAxMCxcbiAgaGc6IDEwMCxcbiAga2c6IDEwMDAsXG4gIHQ6IDEwMDAwMDAsXG4gIGRyYzogMS43NzE4NDUyLFxuICBvejogMjguMzQ5NSxcbiAgbGI6IDQ1My41OTIzNyxcbiAgc3Q6IDYzNTAuMjkzMTgsXG4gIHF0cjogMTI3MDAuNTg2MzYsXG4gIGN3dDogNTA4MDIuMzQ1NDQsXG4gIHRsb25nOiAxMDE2MDQ2LjkwODgsXG4gIHRzaG9ydDogOTA3MTg0Ljc0XG59O1xuXG5wcmVzZXRzLm1hc3MgPSBmdW5jdGlvbiAoaW5zdCkge1xuICB2YXIgcyA9IGV4dGVuZCQxKHt9LCBkZWZhdWx0cyRiLCBpbnN0LnNldHRpbmdzKTtcbiAgZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgcywge1xuICAgIHNpZ246IGZhbHNlLFxuICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQodmFsLCB1bml0MSwgdW5pdDIpIHtcbiAgICAgIHJldHVybiB2YWwgKiBjb2JqJDRbdW5pdDFdIC8gY29iaiQ0W3VuaXQyXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJlc2V0cy5tZWFzdXJlbWVudC5jYWxsKHRoaXMsIGluc3QpO1xufTtcblxudmFyIE1ic2NNZWFzdXJlbWVudEJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTWVhc3VyZW1lbnRCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NNZWFzdXJlbWVudEJhc2UoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ21lYXN1cmVtZW50JztcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xuICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiB0aGlzLnByZXNldCB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTY3JvbGxlcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY01lYXN1cmVtZW50QmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1tLWJdJyB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NNZWFzdXJlbWVudEJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY01lYXN1cmVtZW50QmFzZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ21heCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWluJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWNpbWFsU2VwYXJhdG9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWZhdWx0VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ludmFsaWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NjYWxlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGVwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWZhdWx0VW5pdCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndW5pdE5hbWVzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd1bml0cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnd2hvbGVUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdmcmFjdGlvblRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NpZ25UZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1tZWFzdXJlbWVudCcsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1tZWFzdXJlbWVudENoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY01lYXN1cmVtZW50QmFzZTtcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xudmFyIE1ic2NNZWFzdXJlbWVudENoaWxkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY01lYXN1cmVtZW50Q2hpbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY01lYXN1cmVtZW50Q2hpbGQoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICB9XG4gICAgTWJzY01lYXN1cmVtZW50Q2hpbGQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtbS1jXScgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTWVhc3VyZW1lbnRDaGlsZC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NNZWFzdXJlbWVudENoaWxkLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnY29udmVydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NNZWFzdXJlbWVudENoaWxkO1xufShNYnNjTWVhc3VyZW1lbnRCYXNlKSk7XG52YXIgTWJzY01lYXN1cmVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY01lYXN1cmVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NNZWFzdXJlbWVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYnNjTWVhc3VyZW1lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtbWVhc3VyZW1lbnRdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY01lYXN1cmVtZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY01lYXN1cmVtZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnY29udmVydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTWVhc3VyZW1lbnQ7XG59KE1ic2NNZWFzdXJlbWVudEJhc2UpKTtcbnZhciBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY01lYXN1cmVtZW50Q29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1tZWFzdXJlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQ7XG59KE1ic2NNZWFzdXJlbWVudCkpO1xudmFyIE1ic2NUZW1wZXJhdHVyZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NUZW1wZXJhdHVyZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjVGVtcGVyYXR1cmUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ3RlbXBlcmF0dXJlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1RlbXBlcmF0dXJlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1RlbXBlcmF0dXJlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXRlbXBlcmF0dXJlXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUZW1wZXJhdHVyZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUZW1wZXJhdHVyZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy10ZW1wZXJhdHVyZScsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy10ZW1wZXJhdHVyZUNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1RlbXBlcmF0dXJlO1xufShNYnNjTWVhc3VyZW1lbnRDaGlsZCkpO1xudmFyIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudDtcbn0oTWJzY1RlbXBlcmF0dXJlKSk7XG52YXIgTWJzY0Rpc3RhbmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0Rpc3RhbmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NEaXN0YW5jZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnZGlzdGFuY2UnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRGlzdGFuY2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjRGlzdGFuY2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtZGlzdGFuY2VdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Rpc3RhbmNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY0Rpc3RhbmNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLWRpc3RhbmNlJyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydtYnNjLWRpc3RhbmNlQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRGlzdGFuY2U7XG59KE1ic2NNZWFzdXJlbWVudEJhc2UpKTtcbnZhciBNYnNjRGlzdGFuY2VDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjRGlzdGFuY2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0Rpc3RhbmNlQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY0Rpc3RhbmNlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjRGlzdGFuY2VDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1kaXN0YW5jZScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0Rpc3RhbmNlQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NEaXN0YW5jZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjRGlzdGFuY2VDb21wb25lbnQ7XG59KE1ic2NEaXN0YW5jZSkpO1xudmFyIE1ic2NTcGVlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NTcGVlZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU3BlZWQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ3NwZWVkJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NwZWVkLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1NwZWVkLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXNwZWVkXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTcGVlZC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NTcGVlZC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1zcGVlZCcsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1zcGVlZENoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1NwZWVkO1xufShNYnNjTWVhc3VyZW1lbnRCYXNlKSk7XG52YXIgTWJzY1NwZWVkQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1NwZWVkQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTcGVlZENvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NTcGVlZENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY1NwZWVkQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc3BlZWQnLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTcGVlZENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU3BlZWRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1NwZWVkQ29tcG9uZW50O1xufShNYnNjU3BlZWQpKTtcbnZhciBNYnNjRm9yY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjRm9yY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY0ZvcmNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLnByZXNldCA9ICdmb3JjZSc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NGb3JjZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NGb3JjZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1mb3JjZV0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRm9yY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjRm9yY2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtZm9yY2UnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtZm9yY2VDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NGb3JjZTtcbn0oTWJzY01lYXN1cmVtZW50QmFzZSkpO1xudmFyIE1ic2NGb3JjZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NGb3JjZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjRm9yY2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjRm9yY2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NGb3JjZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWZvcmNlJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjRm9yY2VDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY0ZvcmNlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NGb3JjZUNvbXBvbmVudDtcbn0oTWJzY0ZvcmNlKSk7XG52YXIgTWJzY01hc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTWFzcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTWFzcyhpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnbWFzcyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NNYXNzLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY01hc3MuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtbWFzc10nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTWFzcy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NNYXNzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW1hc3MnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtbWFzc0NoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY01hc3M7XG59KE1ic2NNZWFzdXJlbWVudEJhc2UpKTtcbnZhciBNYnNjTWFzc0NvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NNYXNzQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NNYXNzQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY01hc3NDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NNYXNzQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtbWFzcycsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY01hc3NDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY01hc3NDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY01hc3NDb21wb25lbnQ7XG59KE1ic2NNYXNzKSk7XG52YXIgY29tcCQ0ID0gW1xuICAgIE1ic2NNZWFzdXJlbWVudCxcbiAgICBNYnNjTWVhc3VyZW1lbnRCYXNlLFxuICAgIE1ic2NNZWFzdXJlbWVudENoaWxkLFxuICAgIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudCxcbiAgICBNYnNjVGVtcGVyYXR1cmUsXG4gICAgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LFxuICAgIE1ic2NEaXN0YW5jZSxcbiAgICBNYnNjRGlzdGFuY2VDb21wb25lbnQsXG4gICAgTWJzY1NwZWVkLFxuICAgIE1ic2NTcGVlZENvbXBvbmVudCxcbiAgICBNYnNjRm9yY2UsXG4gICAgTWJzY0ZvcmNlQ29tcG9uZW50LFxuICAgIE1ic2NNYXNzLFxuICAgIE1ic2NNYXNzQ29tcG9uZW50XG5dO1xudmFyIE1ic2NNZWFzdXJlbWVudE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY01lYXN1cmVtZW50TW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjTWVhc3VyZW1lbnRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBjb21wJDQsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IGNvbXAkNFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY01lYXN1cmVtZW50TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NNZWFzdXJlbWVudE1vZHVsZTtcbn0oKSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGd1aWQkMSA9IDE7XG52YXIgU2Nyb2xsVmlldyA9IGZ1bmN0aW9uIFNjcm9sbFZpZXcoZWxtLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJGFjdGl2ZUl0ZW0sXG4gICAgICAkY29udCxcbiAgICAgICRjdHgsXG4gICAgICAkd25kLFxuICAgICAgY29udFdpZHRoLFxuICAgICAgaXRlbVdpZHRoLFxuICAgICAgaXNDbGljayxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgb2xkV2lkdGgsXG4gICAgICBwb3NEZWJvdW5jZSxcbiAgICAgIHJ0bCxcbiAgICAgIHNjcm9sbFZpZXcsXG4gICAgICBzbmFwLFxuICAgICAgcyxcbiAgICAgIHRvdGFsV2lkdGgsXG4gICAgICB0b3VjaGVkLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIGNzc0NsYXNzZXMgPSB7fSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgJGVsbSA9ICQkMShlbG0pO1xuXG4gIGZ1bmN0aW9uIG9uUmVzaXplKGV2KSB7XG4gICAgY2xlYXJUaW1lb3V0KHBvc0RlYm91bmNlKTtcbiAgICBwb3NEZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2l6ZSghZXYgfHwgZXYudHlwZSAhPT0gJ2xvYWQnKTtcbiAgICB9LCAyMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICBpZiAoaXNDbGljayAmJiB0aGlzLnBhcmVudE5vZGUgPT09IGVsbSkge1xuICAgICAgb25JdGVtVGFwKCQkMSh0aGlzKSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25JdGVtVGFwKCRpdGVtLCB0b2dnbGUsIGFuaW1UaW1lKSB7XG4gICAgaWYgKCEkaXRlbS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbVRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5pbVRpbWUgPSAxMDAwO1xuICAgIH1cblxuICAgIHRvZ2dsZSA9IHRoYXQuX29uSXRlbVRhcCgkaXRlbSwgdG9nZ2xlKTtcbiAgICAkYWN0aXZlSXRlbSA9ICRpdGVtO1xuXG4gICAgaWYgKCRpdGVtLnBhcmVudCgpWzBdID09IGVsbSkge1xuICAgICAgdmFyIGJsID0gJGl0ZW0ub2Zmc2V0KCkubGVmdCxcbiAgICAgICAgICBicCA9ICRpdGVtWzBdLm9mZnNldExlZnQsXG4gICAgICAgICAgYncgPSAkaXRlbVswXS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBjbCA9ICRjb250Lm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgIGlmIChydGwpIHtcbiAgICAgICAgYnAgPSB0b3RhbFdpZHRoIC0gYnAgLSBidztcbiAgICAgIH0gLy8gU2Nyb2xsIGl0ZW0gdG8gdmlld1xuXG5cbiAgICAgIGlmIChzLnZhcmlhbnQgPT0gJ2EnKSB7XG4gICAgICAgIGlmIChibCA8IGNsKSB7XG4gICAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGwocnRsID8gYnAgKyBidyAtIGNvbnRXaWR0aCA6IC1icCwgYW5pbVRpbWUsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGJsICsgYncgPiBjbCArIGNvbnRXaWR0aCkge1xuICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsKHJ0bCA/IGJwIDogY29udFdpZHRoIC0gYnAgLSBidywgYW5pbVRpbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTY3JvbGwgaXRlbSB0byBjZW50ZXJcbiAgICAgICAgc2Nyb2xsVmlldy5zY3JvbGwoKGNvbnRXaWR0aCAvIDIgLSBicCAtIGJ3IC8gMikgKiAocnRsID8gLTEgOiAxKSwgYW5pbVRpbWUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2dnbGUgJiYgISRpdGVtLmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykpIHtcbiAgICAgIC8vIFRyaWdnZXIgdGFwIGV2ZW50XG4gICAgICB0cmlnZ2VyKCdvbkl0ZW1UYXAnLCB7XG4gICAgICAgIHRhcmdldDogJGl0ZW1bMF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRNYXJrdXAoKSB7XG4gICAgdmFyICRmaXJzdEl0ZW0sIHByb3BzO1xuXG4gICAgdGhhdC5faW5pdE1hcmt1cCgkY29udCk7XG5cbiAgICAkZWxtLmZpbmQoJy5tYnNjLXJpcHBsZScpLnJlbW92ZSgpO1xuICAgIHRoYXQuXyRpdGVtcyA9ICRlbG0uY2hpbGRyZW4oKTtcblxuICAgIHRoYXQuXyRpdGVtcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgY3NzQ2xhc3MsXG4gICAgICAgICAgJGl0ZW0gPSAkJDEodGhpcyksXG4gICAgICAgICAgcmVmID0gJGl0ZW0uYXR0cignZGF0YS1yZWYnKTtcblxuICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgcmVmID0gZ3VpZCQxKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICRmaXJzdEl0ZW0gPSAkaXRlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEkYWN0aXZlSXRlbSkge1xuICAgICAgICAkYWN0aXZlSXRlbSA9IHRoYXQuX2dldEFjdGl2ZUl0ZW0oJGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IHRoYXQuX2dldEl0ZW1Qcm9wcygkaXRlbSkgfHwge307XG4gICAgICBjc3NDbGFzcyA9ICdtYnNjLXNjdi1pdGVtIG1ic2MtYnRuLWUgJyArIChwcm9wcy5jc3NDbGFzcyB8fCAnJyk7XG4gICAgICAkaXRlbS5hdHRyKCdkYXRhLXJlZicsIHJlZikucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlc1tyZWZdKS5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgICBjc3NDbGFzc2VzW3JlZl0gPSBjc3NDbGFzcztcbiAgICAgICRpdGVtLmFwcGVuZCh0aGF0Ll9nZXRUZXh0KG1vYmlzY3JvbGwsIDAuMikpO1xuICAgIH0pO1xuXG4gICAgaWYgKCEkYWN0aXZlSXRlbSkge1xuICAgICAgJGFjdGl2ZUl0ZW0gPSAkZmlyc3RJdGVtO1xuICAgIH1cblxuICAgIHRoYXQuX21hcmt1cFJlYWR5KCRjb250KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemUoY2hlY2ssIG5vU2Nyb2xsKSB7XG4gICAgdmFyIHcgPSBzLml0ZW1XaWR0aCxcbiAgICAgICAgbGF5b3V0ID0gcy5sYXlvdXQ7XG4gICAgdGhhdC5jb250V2lkdGggPSBjb250V2lkdGggPSAkY29udC53aWR0aCgpO1xuXG4gICAgaWYgKHRoYXQuX2NoZWNrUmVzcCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrICYmIG9sZFdpZHRoID09PSBjb250V2lkdGggfHwgIWNvbnRXaWR0aCkge1xuICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgY29udGFpbmVyIHdpZHRoIGhhcyBub3QgY2hhbmdlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9sZFdpZHRoID0gY29udFdpZHRoO1xuXG4gICAgaWYgKGlzTnVtZXJpYyhsYXlvdXQpKSB7XG4gICAgICBpdGVtV2lkdGggPSBjb250V2lkdGggPyBjb250V2lkdGggLyBsYXlvdXQgOiB3O1xuXG4gICAgICBpZiAoaXRlbVdpZHRoIDwgdykge1xuICAgICAgICBsYXlvdXQgPSAnbGlxdWlkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodykge1xuICAgICAgaWYgKGxheW91dCA9PSAnbGlxdWlkJykge1xuICAgICAgICAvLyBUaGUgc3BlY2lmaWVkIGl0ZW1XaWR0aCB3aWxsIGJlIGhhbmRsZWQgYXMgbWluIHdpZHRoXG4gICAgICAgIGl0ZW1XaWR0aCA9IGNvbnRXaWR0aCA/IGNvbnRXaWR0aCAvIE1hdGgubWluKE1hdGguZmxvb3IoY29udFdpZHRoIC8gdyksIHRoYXQuXyRpdGVtcy5sZW5ndGgpIDogdztcbiAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09ICdmaXhlZCcpIHtcbiAgICAgICAgLy8gRml4ZWQgd2lkdGhcbiAgICAgICAgaXRlbVdpZHRoID0gdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGF0Ll9zaXplKGNvbnRXaWR0aCwgaXRlbVdpZHRoKTtcblxuICAgIGlmIChpdGVtV2lkdGgpIHtcbiAgICAgICRlbG0uY2hpbGRyZW4oKS5jc3MoJ3dpZHRoJywgaXRlbVdpZHRoICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgdGhhdC50b3RhbFdpZHRoID0gdG90YWxXaWR0aCA9IGVsbS5vZmZzZXRXaWR0aDtcbiAgICBleHRlbmQkMShzY3JvbGxWaWV3LnNldHRpbmdzLCB7XG4gICAgICBjb250U2l6ZTogY29udFdpZHRoLFxuICAgICAgbWF4U25hcFNjcm9sbDogcy5wYWdpbmcgPyAxIDogZmFsc2UsXG4gICAgICBtYXhTY3JvbGw6IDAsXG4gICAgICBtaW5TY3JvbGw6IHRvdGFsV2lkdGggPiBjb250V2lkdGggPyBjb250V2lkdGggLSB0b3RhbFdpZHRoIDogMCxcbiAgICAgIHNuYXA6IHMucGFnaW5nID8gY29udFdpZHRoIDogc25hcCA/IGl0ZW1XaWR0aCB8fCAnLm1ic2Mtc2N2LWl0ZW0nIDogZmFsc2UsXG4gICAgICBlbGFzdGljOiB0b3RhbFdpZHRoID4gY29udFdpZHRoID8gaXRlbVdpZHRoIHx8IGNvbnRXaWR0aCA6IGZhbHNlXG4gICAgfSk7IC8vIFBhc3MgbmV3IHZhbHVlcyB0byBzY3JvbGx2aWV3XG5cbiAgICBzY3JvbGxWaWV3LnJlZnJlc2gobm9TY3JvbGwpOyAvLyBNYWtlIHN1cmUgdGhlIGFjdGl2ZSBpdGVtIHJlbWFpbnMgdmlzaWJsZVxuXG4gICAgaWYgKCRhY3RpdmVJdGVtKSB7XG4gICAgICBvbkl0ZW1UYXAoJGFjdGl2ZUl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICgkaXRlbSwgdG9nZ2xlLCBhbmltVGltZSkge1xuICAgIG9uSXRlbVRhcCh0aGF0Ll9nZXRJdGVtKCRpdGVtKSwgdG9nZ2xlLCBhbmltVGltZSk7XG4gIH07XG5cbiAgdGhhdC5uZXh0ID0gZnVuY3Rpb24gKHRvZ2dsZSkge1xuICAgIGlmICgkYWN0aXZlSXRlbSkge1xuICAgICAgdmFyICRuZXh0ID0gJGFjdGl2ZUl0ZW0ubmV4dCgpO1xuXG4gICAgICBpZiAoJG5leHQubGVuZ3RoKSB7XG4gICAgICAgICRhY3RpdmVJdGVtID0gJG5leHQ7XG4gICAgICAgIG9uSXRlbVRhcCgkYWN0aXZlSXRlbSwgdG9nZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhhdC5wcmV2ID0gZnVuY3Rpb24gKHRvZ2dsZSkge1xuICAgIGlmICgkYWN0aXZlSXRlbSkge1xuICAgICAgdmFyICRwcmV2ID0gJGFjdGl2ZUl0ZW0ucHJldigpO1xuXG4gICAgICBpZiAoJHByZXYubGVuZ3RoKSB7XG4gICAgICAgICRhY3RpdmVJdGVtID0gJHByZXY7XG4gICAgICAgIG9uSXRlbVRhcCgkYWN0aXZlSXRlbSwgdG9nZ2xlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZXMgc2l6ZXMuXG4gICAqL1xuXG5cbiAgdGhhdC5yZWZyZXNoID0gdGhhdC5wb3NpdGlvbiA9IGZ1bmN0aW9uIChub1Njcm9sbCkge1xuICAgIGluaXRNYXJrdXAoKTtcbiAgICBzaXplKGZhbHNlLCBub1Njcm9sbCk7XG4gIH07XG4gIC8qKlxuICAgKiBJbml0aWFsaXphdGlvbi5cbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250Q2xhc3M7XG4gICAgJGN0eCA9ICQkMShzLmNvbnRleHQpO1xuICAgICR3bmQgPSAkJDEocy5jb250ZXh0ID09ICdib2R5JyA/IHdpbmRvdyA6IHMuY29udGV4dCk7XG5cbiAgICB0aGF0Ll9faW5pdCgpO1xuICAgIC8qXG4gICAgcnRsID0gcy5ydGw7XG4gICAgc25hcCA9IChzLml0ZW1XaWR0aCAmJiBzLmxheW91dCAhPSAnZml4ZWQnICYmIHMuc25hcCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBzLnNuYXA7XG4gICAgY29udENsYXNzID0gJ21ic2Mtc2N2LWMgbWJzYy1uby10b3VjaCcgKyAnIG1ic2MtJyArIHMudGhlbWUgKyAnICcgK1xuICAgICAgICAocy5jc3NDbGFzcyB8fCAnJykgKyAnICcgK1xuICAgICAgICAocy53cmFwcGVyQ2xhc3MgfHwgJycpICtcbiAgICAgICAgKHMuYmFzZVRoZW1lID8gJyBtYnNjLScgKyBzLmJhc2VUaGVtZSA6ICcnKSArXG4gICAgICAgIChydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKSArXG4gICAgICAgIChzLml0ZW1XaWR0aCA/ICcgbWJzYy1zY3YtaGFzdycgOiAnJykgK1xuICAgICAgICAocy5jb250ZXh0ID09ICdib2R5JyA/ICcnIDogJyBtYnNjLXNjdi1jdHgnKSArICcgJyArXG4gICAgICAgICh0aGF0Ll9nZXRDb250Q2xhc3MoKSB8fCAnJyk7XG4gICAgICAgICovXG4gICAgLy8gLS0tIFJFTU9URSBUUklBTCBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgICBydGwgPSB0aGF0LnJlbW90ZS5tZW51c3RyaXAucnRsU2V0dGluZztcbiAgICBzbmFwID0gdGhhdC5yZW1vdGUubWVudXN0cmlwLnNuYXBTZXR0aW5nO1xuICAgIGNvbnRDbGFzcyA9IHRoYXQucmVtb3RlLm1lbnVzdHJpcC5jb250Q2xhc3MgKyAodGhhdC5fZ2V0Q29udENsYXNzKCkgfHwgJycpOyAvLyAtLS0gUkVNT1RFIFRSSUFMIENPREUgRU5EIC0tLVxuXG4gICAgaWYgKCEkY29udCkge1xuICAgICAgJGNvbnQgPSAkJDEoJzxkaXYgY2xhc3M9XCInICsgY29udENsYXNzICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLXNjdi1zY1wiPjwvZGl2PjwvZGl2PicpLm9uKCdjbGljaycsICcubWJzYy1zY3YtaXRlbScsIG9uQ2xpY2spLmluc2VydEFmdGVyKCRlbG0pO1xuICAgICAgJGNvbnQuZmluZCgnLm1ic2Mtc2N2LXNjJykuYXBwZW5kKCRlbG0pOyAvLyBXaGVuIGltYWdlcyBhcmUgbG9hZGVkLCBzaXplIG1pZ3RoIGNoYW5nZVxuXG4gICAgICAkY29udC5maW5kKCdpbWcnKS5vbignbG9hZCcsIG9uUmVzaXplKTtcbiAgICAgICR3bmQub24oJ29yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIG9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIoJGNvbnRbMF0sIG9uUmVzaXplLCBzLnpvbmUpO1xuICAgICAgc2Nyb2xsVmlldyA9IG5ldyBTY3JvbGxWaWV3QmFzZSgkY29udFswXSwge1xuICAgICAgICBheGlzOiAnWCcsXG4gICAgICAgIGNvbnRTaXplOiAwLFxuICAgICAgICBtYXhTY3JvbGw6IDAsXG4gICAgICAgIG1heFNuYXBTY3JvbGw6IDEsXG4gICAgICAgIG1pblNjcm9sbDogMCxcbiAgICAgICAgc25hcDogMSxcbiAgICAgICAgZWxhc3RpYzogMSxcbiAgICAgICAgcnRsOiBydGwsXG4gICAgICAgIG1vdXNld2hlZWw6IHMubW91c2V3aGVlbCxcbiAgICAgICAgdGhyZXNob2xkWDogcy50aHJlc2hvbGQsXG4gICAgICAgIHN0b3BQcm9wOiBzLnN0b3BQcm9wLFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgICAgICAgaWYgKGV2LmRvbUV2ZW50LnR5cGUgPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICBpc0NsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghdG91Y2hlZCkge1xuICAgICAgICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJGN0eC5maW5kKCcubWJzYy1uby10b3VjaCcpLnJlbW92ZUNsYXNzKCdtYnNjLW5vLXRvdWNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkJ0blRhcDogZnVuY3Rpb24gb25CdG5UYXAoZXYpIHtcbiAgICAgICAgICBpc0NsaWNrID0gdHJ1ZTsgLy8gVHJpZ2dlciBjbGljayBhbmQgYWN0aXZhdGUgdGFyZ2V0LCBpZiBpdCdzIGEgZm9ybSBjb250cm9sXG5cbiAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBldi5kb21FdmVudCxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gZG9tRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgaWYgKGRvbUV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgcy50YXApIHtcbiAgICAgICAgICAgIGFjdGl2YXRlQ29udHJvbCh0YXJnZXQsIGdldENvbnRyb2xUeXBlKCQkMSh0YXJnZXQpKSwgZG9tRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIG9uR2VzdHVyZVN0YXJ0KGV2KSB7XG4gICAgICAgICAgdHJpZ2dlcignb25HZXN0dXJlU3RhcnQnLCBldik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uR2VzdHVyZUVuZDogZnVuY3Rpb24gb25HZXN0dXJlRW5kKGV2KSB7XG4gICAgICAgICAgdHJpZ2dlcignb25HZXN0dXJlRW5kJywgZXYpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uTW92ZScsIGV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogZnVuY3Rpb24gb25BbmltYXRpb25TdGFydChldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uQW5pbWF0aW9uU3RhcnQnLCBldik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiBmdW5jdGlvbiBvbkFuaW1hdGlvbkVuZChldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uQW5pbWF0aW9uRW5kJywgZXYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGNvbnQuYXR0cignY2xhc3MnLCBjb250Q2xhc3MpOyAvLyBSZW1vdmUgcmlwcGxlIGV2ZW50cyAoaWYgdGhlbWUgY2hhbmdlZClcblxuICAgICAgaWYgKGVsbS5fX21ic2NSaXBwbGVPZmYpIHtcbiAgICAgICAgZWxtLl9fbWJzY1JpcHBsZU9mZigpO1xuICAgICAgfVxuICAgIH0gLy8gUHJlcGFyZSBtYXJrdXBcblxuXG4gICAgJGVsbS5jc3MoJ2Rpc3BsYXknLCAnJykuYWRkQ2xhc3MoJ21ic2Mtc2N2JykucmVtb3ZlQ2xhc3MoJ21ic2MtY2xvYWsnKTtcbiAgICBpbml0TWFya3VwKCk7XG4gICAgdHJpZ2dlcignb25NYXJrdXBSZWFkeScsIHtcbiAgICAgIHRhcmdldDogJGNvbnRbMF1cbiAgICB9KTtcbiAgICBzaXplKCk7XG4gIH07XG5cbiAgdGhhdC5fc2l6ZSA9IG5vb3A7XG4gIHRoYXQuX2luaXRNYXJrdXAgPSBub29wO1xuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IG5vb3A7XG4gIHRoYXQuX2dldENvbnRDbGFzcyA9IG5vb3A7XG4gIHRoYXQuX2dldEl0ZW1Qcm9wcyA9IG5vb3A7XG4gIHRoYXQuX2dldEFjdGl2ZUl0ZW0gPSBub29wO1xuICB0aGF0Ll9faW5pdCA9IG5vb3A7XG4gIHRoYXQuX19kZXN0cm95ID0gbm9vcDtcbiAgLyoqXG4gICAqIERlc3Ryb3lcbiAgICovXG5cbiAgdGhhdC5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGF0Ll9fZGVzdHJveSgpO1xuXG4gICAgJHduZC5vZmYoJ29yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLXNjdicpLmluc2VydEFmdGVyKCRjb250KS5maW5kKCcubWJzYy1zY3YtaXRlbScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRpdGVtID0gJCQxKHRoaXMpO1xuICAgICAgJGl0ZW0ud2lkdGgoJycpLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXNbJGl0ZW0uYXR0cignZGF0YS1yZWYnKV0pO1xuICAgIH0pO1xuICAgICRjb250LnJlbW92ZSgpO1xuICAgIHNjcm9sbFZpZXcuZGVzdHJveSgpO1xuICAgIG9ic2VydmVyLmRldGFjaCgpO1xuICB9O1xuXG4gIHRoYXQuX2dldEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGl0ZW0gPSB0aGF0Ll8kaXRlbXMuZmlsdGVyKCdbZGF0YS1pZD1cIicgKyBpdGVtICsgJ1wiXScpO1xuICAgIH1cblxuICAgIHJldHVybiAkJDEoaXRlbSk7XG4gIH07XG5cbiAgdGhhdC5fb25JdGVtVGFwID0gZnVuY3Rpb24gKCRpdGVtLCB0b2dnbGUpIHtcbiAgICBpZiAodG9nZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0b2dnbGU7XG4gIH07IC8vIC0tLVxuICAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gIHRyaWdnZXIgPSB0aGF0LnRyaWdnZXI7XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07IC8vIERlZmF1bHRzXG5cblNjcm9sbFZpZXcucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdzY3JvbGx2aWV3JyxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX3Jlc3BvbnNpdmU6IHRydWUsXG4gIF9kZWZhdWx0czoge1xuICAgIHRhcDogaGFzR2hvc3RDbGljayxcbiAgICBzdG9wUHJvcDogZmFsc2UsXG4gICAgY29udGV4dDogJ2JvZHknLFxuICAgIGxheW91dDogJ2xpcXVpZCdcbiAgfVxufTtcbmNsYXNzZXMuU2Nyb2xsVmlldyA9IFNjcm9sbFZpZXc7XG5cbnZhciBOYXZpZ2F0aW9uQmFzZSA9IGZ1bmN0aW9uIE5hdmlnYXRpb25CYXNlKGVsbSwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRjdHgsXG4gICAgICBkaXNwbGF5LFxuICAgICAgbXVsdGlwbGUsXG4gICAgICBzZWxlY3QsXG4gICAgICBzZWxlY3RlZENsYXNzLFxuICAgICAgcyxcbiAgICAgICRlbG0gPSAkJDEoZWxtKSxcbiAgICAgIHRoYXQgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVBhZ2VQYWRkaW5nKCkge1xuICAgIGlmIChkaXNwbGF5ICYmIGRpc3BsYXkgIT0gJ2lubGluZScpIHtcbiAgICAgICRjdHguZmluZCgnLm1ic2MtcGFnZScpLmNzcygncGFkZGluZy0nICsgZGlzcGxheSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEl0ZW0oJGl0ZW0pIHtcbiAgICAkaXRlbS5hZGRDbGFzcyhzZWxlY3RlZENsYXNzKS5hdHRyKCdkYXRhLXNlbGVjdGVkJywgJ3RydWUnKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2VsZWN0SXRlbSgkaXRlbSkge1xuICAgICRpdGVtLnJlbW92ZUNsYXNzKHNlbGVjdGVkQ2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtc2VsZWN0ZWQnKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBTY3JvbGxWaWV3LmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5zZWxlY3QgPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICBkZXNlbGVjdEl0ZW0odGhhdC5fJGl0ZW1zLmZpbHRlcignLm1ic2MtbXMtaXRlbS1zZWwnKSk7XG4gICAgfVxuXG4gICAgc2VsZWN0SXRlbSh0aGF0Ll9nZXRJdGVtKCRpdGVtKSk7XG4gIH07XG5cbiAgdGhhdC5kZXNlbGVjdCA9IGZ1bmN0aW9uICgkaXRlbSkge1xuICAgIGRlc2VsZWN0SXRlbSh0aGF0Ll9nZXRJdGVtKCRpdGVtKSk7XG4gIH07XG5cbiAgdGhhdC5lbmFibGUgPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICB0aGF0Ll9nZXRJdGVtKCRpdGVtKS5yZW1vdmVDbGFzcygnbWJzYy1kaXNhYmxlZCcpLnJlbW92ZUF0dHIoJ2RhdGEtZGlzYWJsZWQnKS5yZW1vdmVBdHRyKCdhcmlhLWRpc2FibGVkJyk7XG4gIH07XG5cbiAgdGhhdC5kaXNhYmxlID0gZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgdGhhdC5fZ2V0SXRlbSgkaXRlbSkuYWRkQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKS5hdHRyKCdkYXRhLWRpc2FibGVkJywgJ3RydWUnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgfTtcblxuICB0aGF0LnNldEJhZGdlID0gZnVuY3Rpb24gKCRpdGVtLCBjb250ZW50KSB7XG4gICAgdmFyICRiYWRnZTtcbiAgICAkaXRlbSA9IHRoYXQuX2dldEl0ZW0oJGl0ZW0pLmF0dHIoJ2RhdGEtYmFkZ2UnLCBjb250ZW50KTtcbiAgICAkYmFkZ2UgPSAkJDEoJy5tYnNjLW1zLWJhZGdlJywgJGl0ZW0pO1xuXG4gICAgaWYgKCRiYWRnZS5sZW5ndGgpIHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICRiYWRnZS5odG1sKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGJhZGdlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudCkge1xuICAgICAgJGl0ZW0uYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2MtbXMtYmFkZ2VcIj4nICsgY29udGVudCArICc8L3NwYW4+Jyk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX21hcmt1cFJlYWR5ID0gZnVuY3Rpb24gKCRjb250KSB7XG4gICAgaWYgKHRoYXQuX2hhc0ljb25zKSB7XG4gICAgICAkY29udC5hZGRDbGFzcygnbWJzYy1tcy1pY29ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkY29udC5yZW1vdmVDbGFzcygnbWJzYy1tcy1pY29ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGF0Ll9oYXNUZXh0KSB7XG4gICAgICAkY29udC5hZGRDbGFzcygnbWJzYy1tcy10eHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2MtbXMtdHh0Jyk7XG4gICAgfVxuXG4gICAgdGhhdC5fX21hcmt1cFJlYWR5KCRjb250KTtcbiAgfTtcblxuICB0aGF0Ll9zaXplID0gZnVuY3Rpb24gKGNvbnRXaWR0aCwgaXRlbVdpZHRoKSB7XG4gICAgdGhhdC5fX3NpemUoY29udFdpZHRoLCBpdGVtV2lkdGgpOyAvLyBBZGQgc3BhY2UgdG8gcGFnZXMgd2l0aGluIGNvbnRleHRcblxuXG4gICAgaWYgKGRpc3BsYXkgIT0gJ2lubGluZScpIHtcbiAgICAgICRjdHguZmluZCgnLm1ic2MtcGFnZScpLmNzcygncGFkZGluZy0nICsgZGlzcGxheSwgZWxtLm9mZnNldEhlaWdodCArICdweCcpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9vbkl0ZW1UYXAgPSBmdW5jdGlvbiAoJGl0ZW0sIHRvZ2dsZSkge1xuICAgIGlmICh0aGF0Ll9fb25JdGVtVGFwKCRpdGVtLCB0b2dnbGUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0b2dnbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdG9nZ2xlID0gIW11bHRpcGxlO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3QgJiYgdG9nZ2xlICYmICEkaXRlbS5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKCRpdGVtLmF0dHIoJ2RhdGEtc2VsZWN0ZWQnKSA9PSAndHJ1ZScpIHtcbiAgICAgICAgICBkZXNlbGVjdEl0ZW0oJGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdEl0ZW0oJGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNlbGVjdEl0ZW0odGhhdC5fJGl0ZW1zLmZpbHRlcignLm1ic2MtbXMtaXRlbS1zZWwnKSk7XG4gICAgICAgIHNlbGVjdEl0ZW0oJGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2dnbGU7XG4gIH07XG5cbiAgdGhhdC5fZ2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uICgkaXRlbSkge1xuICAgIHZhciBzZWxlY3RlZCA9ICRpdGVtLmF0dHIoJ2RhdGEtc2VsZWN0ZWQnKSA9PSAndHJ1ZSc7XG5cbiAgICBpZiAoc2VsZWN0ICYmICFtdWx0aXBsZSAmJiBzZWxlY3RlZCkge1xuICAgICAgcmV0dXJuICRpdGVtO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9nZXRJdGVtUHJvcHMgPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSAkaXRlbS5hdHRyKCdkYXRhLXNlbGVjdGVkJykgPT0gJ3RydWUnLFxuICAgICAgICBkaXNhYmxlZCA9ICRpdGVtLmF0dHIoJ2RhdGEtZGlzYWJsZWQnKSA9PSAndHJ1ZScsXG4gICAgICAgIGljb24gPSAkaXRlbS5hdHRyKCdkYXRhLWljb24nKSxcbiAgICAgICAgYmFkZ2UgPSAkaXRlbS5hdHRyKCdkYXRhLWJhZGdlJyk7XG4gICAgJGl0ZW0uYXR0cignZGF0YS1yb2xlJywgJ2J1dHRvbicpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBzZWxlY3RlZCA/ICd0cnVlJyA6ICdmYWxzZScpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZScpLmZpbmQoJy5tYnNjLW1zLWJhZGdlJykucmVtb3ZlKCk7XG5cbiAgICBpZiAoYmFkZ2UpIHtcbiAgICAgICRpdGVtLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLW1zLWJhZGdlXCI+JyArIGJhZGdlICsgJzwvc3Bhbj4nKTtcbiAgICB9XG5cbiAgICBpZiAoaWNvbikge1xuICAgICAgdGhhdC5faGFzSWNvbnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICgkaXRlbS50ZXh0KCkpIHtcbiAgICAgIHRoYXQuX2hhc1RleHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjc3NDbGFzczogJ21ic2MtbXMtaXRlbSAnICsgKHMuaXRlbUNsYXNzIHx8ICcnKSArICcgJyArIChzZWxlY3RlZCA/IHNlbGVjdGVkQ2xhc3MgOiAnJykgKyAoZGlzYWJsZWQgPyAnIG1ic2MtZGlzYWJsZWQgJyArIChzLmRpc2FibGVkQ2xhc3MgfHwgJycpIDogJycpICsgKGljb24gPyAnIG1ic2MtbXMtaWMgbWJzYy1pYyBtYnNjLWljLScgKyBpY29uIDogJycpXG4gICAgfTtcbiAgfTtcblxuICB0aGF0Ll9nZXRDb250Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcgbWJzYy1tcy1jIG1ic2MtbXMtJyArIHMudmFyaWFudCArICcgbWJzYy1tcy0nICsgZGlzcGxheSArIChzZWxlY3QgPyAnJyA6ICcgbWJzYy1tcy1ub3NlbCcpICsgKHRoYXQuX19nZXRDb250Q2xhc3MoKSB8fCAnJyk7XG4gIH07XG5cbiAgdGhhdC5fX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5fX19pbml0KCk7XG5cbiAgICAkY3R4ID0gJCQxKHMuY29udGV4dCk7IC8vIFJlbW92ZSBvbGQgcGFkZGluZyBmcm9tIG1ic2MtcGFnZVxuICAgIC8vIGlmIGRpc3BsYXkgY2hhbmdlZCBkeW5hbWljYWxseVxuXG4gICAgcmVtb3ZlUGFnZVBhZGRpbmcoKTtcbiAgICBkaXNwbGF5ID0gcy5kaXNwbGF5O1xuICAgIG11bHRpcGxlID0gcy5zZWxlY3QgPT0gJ211bHRpcGxlJztcbiAgICBzZWxlY3QgPSBzLnNlbGVjdCAhPSAnb2ZmJztcbiAgICBzZWxlY3RlZENsYXNzID0gJyBtYnNjLW1zLWl0ZW0tc2VsICcgKyAocy5hY3RpdmVDbGFzcyB8fCAnJyk7XG4gICAgJGVsbS5hZGRDbGFzcygnbWJzYy1tcyBtYnNjLW1zLWJhc2UgJyArIChzLmdyb3VwQ2xhc3MgfHwgJycpKTtcbiAgfTtcblxuICB0aGF0Ll9fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLW1zIG1ic2MtbXMtYmFzZSAnICsgKHMuZ3JvdXBDbGFzcyB8fCAnJykpO1xuICAgIHJlbW92ZVBhZ2VQYWRkaW5nKCk7XG5cbiAgICB0aGF0Ll9fX2Rlc3Ryb3koKTtcbiAgfTtcblxuICB0aGF0Ll9fb25JdGVtVGFwID0gbm9vcDtcbiAgdGhhdC5fX2dldENvbnRDbGFzcyA9IG5vb3A7XG4gIHRoYXQuX19tYXJrdXBSZWFkeSA9IG5vb3A7XG4gIHRoYXQuX19zaXplID0gbm9vcDtcbiAgdGhhdC5fX19pbml0ID0gbm9vcDtcbiAgdGhhdC5fX19kZXN0cm95ID0gbm9vcDsgLy8gLS0tXG4gIC8vIENvbnN0cnVjdG9yXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07IC8vIERlZmF1bHRzXG5cbk5hdmlnYXRpb25CYXNlLnByb3RvdHlwZSA9IHtcbiAgX2RlZmF1bHRzOiBleHRlbmQkMSh7fSwgU2Nyb2xsVmlldy5wcm90b3R5cGUuX2RlZmF1bHRzKVxufTtcblxudmFyIE5hdmlnYXRpb24gPSBmdW5jdGlvbiBOYXZpZ2F0aW9uKGVsbSwgc2V0dGluZ3MpIHtcbiAgdmFyICRlbG0gPSAkJDEoZWxtKSxcbiAgICAgICRtZW51LFxuICAgICAgJHBvcHVwLFxuICAgICAgbWVudUNsYXNzLFxuICAgICAgcyxcbiAgICAgIHBvcHVwLFxuICAgICAgaXNMaXN0ID0gJGVsbS5pcygndWwsb2wnKSxcbiAgICAgIHRoYXQgPSB0aGlzOyAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuICBOYXZpZ2F0aW9uQmFzZS5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQuX2luaXRNYXJrdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCRtZW51KSB7XG4gICAgICAkbWVudS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoJHBvcHVwKSB7XG4gICAgICAkZWxtLmFwcGVuZCgkcG9wdXAuY2hpbGRyZW4oKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19zaXplID0gZnVuY3Rpb24gKGNvbnRXaWR0aCwgaXRlbVdpZHRoKSB7XG4gICAgdmFyIHNob3dNb3JlLFxuICAgICAgICBzaG93TW9yZVdpZHRoID0gaXRlbVdpZHRoIHx8IDcyLFxuICAgICAgICBpdGVtc05yID0gdGhhdC5fJGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgaXRlbXNXaWR0aCA9IDA7XG4gICAgcG9wdXAuaGlkZSgpOyAvLyBzaG93IG1vcmUgbWVudVxuXG4gICAgaWYgKHMudHlwZSA9PSAnYm90dG9tJykge1xuICAgICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1zY3YtbGlxJyk7IC8vLmVtcHR5KCk7IC8vIGVtcHR5IGxpc3RcblxuICAgICAgJG1lbnUucmVtb3ZlKCk7XG5cbiAgICAgIHRoYXQuXyRpdGVtcy5yZW1vdmUoKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciAkaXRlbSA9ICQkMSh0aGlzKTtcbiAgICAgICAgJGVsbS5hcHBlbmQoJGl0ZW0pO1xuICAgICAgICBpdGVtc1dpZHRoICs9IGl0ZW1XaWR0aCB8fCB0aGlzLm9mZnNldFdpZHRoIHx8IDA7IC8vIGlmIG5leHQgaXRlbSBkb2Vzbid0IGZpdCwgYWRkIHRvIHNob3cgbW9yZSBtZW51XG5cbiAgICAgICAgaWYgKE1hdGgucm91bmQoaXRlbXNXaWR0aCArIChpIDwgaXRlbXNOciAtIDEgPyBzaG93TW9yZVdpZHRoIDogMCkpID4gY29udFdpZHRoKSB7XG4gICAgICAgICAgc2hvd01vcmUgPSB0cnVlO1xuICAgICAgICAgICRwb3B1cC5hcHBlbmQoJGl0ZW0uY3NzKCd3aWR0aCcsICcnKS5hZGRDbGFzcygnbWJzYy1mci1idG4tZScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICRtZW51LmF0dHIoJ2NsYXNzJywgbWVudUNsYXNzICsgKHMubW9yZUljb24gPyAnIG1ic2MtbWVudS1pdGVtLWljIG1ic2MtbXMtaWMgbWJzYy1pYyBtYnNjLWljLScgKyBzLm1vcmVJY29uIDogJycpKS5odG1sKHRoYXQuX2hhc0ljb25zICYmIHRoYXQuX2hhc1RleHQgPyBzLm1vcmVUZXh0IDogJycpOyAvLyBhZGQgc2hvdyBtb3JlIGl0ZW0gaWYgbmVlZGVkXG5cbiAgICAgIGlmIChzaG93TW9yZSkge1xuICAgICAgICAkZWxtLmFwcGVuZCgkbWVudSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMubGF5b3V0ID09ICdsaXF1aWQnKSB7XG4gICAgICAkZWxtLmFkZENsYXNzKCdtYnNjLXNjdi1saXEnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fX29uSXRlbVRhcCA9IGZ1bmN0aW9uICgkaXRlbSkge1xuICAgIGlmICgkaXRlbS5oYXNDbGFzcygnbWJzYy1tZW51LWl0ZW0nKSAmJiB0aGF0LnRyaWdnZXIoJ29uTWVudVNob3cnLCB7XG4gICAgICB0YXJnZXQ6ICRpdGVtWzBdLFxuICAgICAgbWVudTogcG9wdXBcbiAgICB9KSAhPT0gZmFsc2UpIHtcbiAgICAgIHBvcHVwLnNob3coZmFsc2UsIHRydWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9fZ2V0Q29udENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzLnR5cGUgPT0gJ2hhbWJ1cmdlcicgPyAnIG1ic2MtbXMtaGFtYnVyZ2VyJyA6ICcnO1xuICB9O1xuXG4gIHRoYXQuX19tYXJrdXBSZWFkeSA9IGZ1bmN0aW9uICgkY29udCkge1xuICAgIGlmIChzLnR5cGUgPT0gJ2hhbWJ1cmdlcicpIHtcbiAgICAgICRwb3B1cC5hcHBlbmQodGhhdC5fJGl0ZW1zLmFkZENsYXNzKCdtYnNjLWZyLWJ0bi1lJykpO1xuICAgICAgJG1lbnUuYXR0cignY2xhc3MnLCBtZW51Q2xhc3MgKyAocy5tZW51SWNvbiA/ICcgbWJzYy1tZW51LWl0ZW0taWMgbWJzYy1tcy1pYyBtYnNjLWljIG1ic2MtaWMtJyArIHMubWVudUljb24gOiAnJykpLmh0bWwocy5tZW51VGV4dCB8fCAnJyk7XG4gICAgICAkZWxtLmFwcGVuZCgkbWVudSk7XG5cbiAgICAgIGlmICghcy5tZW51VGV4dCB8fCAhcy5tZW51SWNvbikge1xuICAgICAgICAkY29udC5yZW1vdmVDbGFzcygnbWJzYy1tcy1pY29ucycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXMubWVudVRleHQpIHtcbiAgICAgICAgJGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2MtbXMtdHh0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY29udC5hZGRDbGFzcygnbWJzYy1tcy10eHQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkdGFyZ2V0O1xuXG4gICAgaWYgKHMudHlwZSA9PSAndGFiJykge1xuICAgICAgcy5kaXNwbGF5ID0gcy5kaXNwbGF5IHx8ICd0b3AnO1xuICAgICAgcy52YXJpYW50ID0gcy52YXJpYW50IHx8ICdiJztcbiAgICB9IGVsc2UgaWYgKHMudHlwZSA9PSAnYm90dG9tJykge1xuICAgICAgcy5kaXNwbGF5ID0gcy5kaXNwbGF5IHx8ICdib3R0b20nO1xuICAgICAgcy52YXJpYW50ID0gcy52YXJpYW50IHx8ICdhJztcbiAgICB9IGVsc2UgaWYgKHMudHlwZSA9PSAnaGFtYnVyZ2VyJykge1xuICAgICAgcy5kaXNwbGF5ID0gcy5kaXNwbGF5IHx8ICdpbmxpbmUnO1xuICAgICAgcy52YXJpYW50ID0gcy52YXJpYW50IHx8ICdhJztcbiAgICB9XG5cbiAgICBtZW51Q2xhc3MgPSAnbWJzYy1zY3YtaXRlbSBtYnNjLW1zLWl0ZW0gbWJzYy1idG4tZSBtYnNjLW1lbnUtaXRlbSAnICsgKHMuaXRlbUNsYXNzIHx8ICcnKTtcblxuICAgIGlmICghJG1lbnUpIHtcbiAgICAgICRtZW51ID0gJCQxKGlzTGlzdCA/ICc8bGk+PC9saT4nIDogJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAkcG9wdXAgPSAkJDEoaXNMaXN0ID8gJzx1bD48L3VsPicgOiAnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWJzYy1zY3YgbWJzYy1tcycpO1xuICAgIH1cblxuICAgIHBvcHVwID0gbmV3IFBvcHVwKCRwb3B1cFswXSwge1xuICAgICAgZGlzcGxheTogJ2J1YmJsZScsXG4gICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgIGxhbmc6IHMubGFuZyxcbiAgICAgIGNvbnRleHQ6IHMuY29udGV4dCxcbiAgICAgIGJ1dHRvbnM6IFtdLFxuICAgICAgYW5jaG9yOiAkbWVudSxcbiAgICAgIG9uQmVmb3JlU2hvdzogZnVuY3Rpb24gb25CZWZvcmVTaG93KGV2ZW50LCBpbnN0KSB7XG4gICAgICAgICR0YXJnZXQgPSBudWxsO1xuICAgICAgICBpbnN0LnNldHRpbmdzLmNzc0NsYXNzID0gJ21ic2Mtd2RnIG1ic2MtbXMtYSBtYnNjLW1zLW1vcmUnICsgKHRoYXQuX2hhc1RleHQgPyAnJyA6ICcgbWJzYy1tcy1tb3JlLWljb25zJyk7XG4gICAgICB9LFxuICAgICAgb25CZWZvcmVDbG9zZTogZnVuY3Rpb24gb25CZWZvcmVDbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcignb25NZW51SGlkZScsIHtcbiAgICAgICAgICB0YXJnZXQ6ICR0YXJnZXQgJiYgJHRhcmdldFswXSxcbiAgICAgICAgICBtZW51OiBwb3B1cFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2ZW50LCBpbnN0KSB7XG4gICAgICAgIHRoYXQudGFwKGluc3QuX21hcmt1cC5maW5kKCcubWJzYy1mci1jJyksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICR0YXJnZXQgPSAkJDEoZXYudGFyZ2V0KS5jbG9zZXN0KCcubWJzYy1tcy1pdGVtJyk7XG5cbiAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgdGhhdC5uYXZpZ2F0ZSgkdGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgIHBvcHVwLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoYXQuX19fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3B1cC5kZXN0cm95KCk7XG4gICAgJGVsbS5hcHBlbmQodGhhdC5fJGl0ZW1zKTtcbiAgICAkbWVudS5yZW1vdmUoKTtcbiAgfTsgLy8gLS0tXG4gIC8vIENvbnN0cnVjdG9yXG5cblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdGhhdC5pbml0KCk7XG59OyAvLyBEZWZhdWx0c1xuXG5OYXZpZ2F0aW9uLnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnbmF2aWdhdGlvbicsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9yZXNwb25zaXZlOiB0cnVlLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBOYXZpZ2F0aW9uQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgdHlwZTogJ2JvdHRvbScsXG4gICAgbW9yZVRleHQ6ICdNb3JlJyxcbiAgICBtb3JlSWNvbjogJ21hdGVyaWFsLW1vcmUtaG9yaXonLFxuICAgIG1lbnVJY29uOiAnbWF0ZXJpYWwtbWVudSdcbiAgfSlcbn07XG5jbGFzc2VzLk5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uO1xuXG52YXIgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UoKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuX2FkZFJlbW92ZU9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmluc3QgPSBudWxsO1xuICAgIH1cbiAgICBNYnNjTm90aWZ5SXRlbVNlcnZpY2UucHJvdG90eXBlLm5vdGlmeUluc3RhbmNlUmVhZHkgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5pbnN0ID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlT2JzZXJ2YWJsZS5uZXh0KGluc3RhbmNlKTtcbiAgICB9O1xuICAgIE1ic2NOb3RpZnlJdGVtU2VydmljZS5wcm90b3R5cGUubm90aWZ5QWRkUmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fYWRkUmVtb3ZlT2JzZXJ2YWJsZS5uZXh0KGl0ZW0pO1xuICAgIH07XG4gICAgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLnByb3RvdHlwZS5vbkluc3RhbmNlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZU9ic2VydmFibGU7XG4gICAgfTtcbiAgICBNYnNjTm90aWZ5SXRlbVNlcnZpY2UucHJvdG90eXBlLm9uQWRkUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUmVtb3ZlT2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIE1ic2NOb3RpZnlJdGVtU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIE1ic2NOb3RpZnlJdGVtU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjTm90aWZ5SXRlbVNlcnZpY2U7XG59KCkpO1xudmFyIE1ic2NTY3JvbGxJdGVtQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbEl0ZW1CYXNlKG5vdGlmeUl0ZW1TZXJ2aWNlLCBfZWxlbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlID0gbm90aWZ5SXRlbVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX2VsZW0gPSBfZWxlbTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VPYnNlcnZlciA9IHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25JbnN0YW5jZVJlYWR5KCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgX3RoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm90aWZ5SXRlbVNlcnZpY2UuaW5zdCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBub3RpZnlJdGVtU2VydmljZS5pbnN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2Nyb2xsSXRlbUJhc2UucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NTY3JvbGxJdGVtQmFzZS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm5vdGlmeUFkZFJlbW92ZSh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NTY3JvbGxJdGVtQmFzZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25JbnN0YW5jZVJlYWR5KCkudW5zdWJzY3JpYmUodGhpcy5pbnN0YW5jZU9ic2VydmVyKTtcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlBZGRSZW1vdmUodGhpcyk7XG4gICAgfTtcbiAgICBNYnNjU2Nyb2xsSXRlbUJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2Mtc2ktYicgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsSXRlbUJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2Nyb2xsSXRlbUJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxJdGVtQmFzZTtcbn0oKSk7XG52YXIgTWJzY1Njcm9sbFZpZXdCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbFZpZXdCYXNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3QmFzZShpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlID0gbm90aWZ5SXRlbVNlcnZpY2U7XG4gICAgICAgIF90aGlzLm9uSXRlbVRhcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25NYXJrdXBSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25BbmltYXRpb25TdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25BbmltYXRpb25FbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uTW92ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25HZXN0dXJlU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uR2VzdHVyZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjU2Nyb2xsVmlld0Jhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2Mtcy1iJyB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTY3JvbGxWaWV3QmFzZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2Nyb2xsVmlld0Jhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjb250ZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpdGVtV2lkdGgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2xheW91dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbW91c2V3aGVlbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc25hcCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAndGhyZXNob2xkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwYWdpbmcnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uSXRlbVRhcCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbk1hcmt1cFJlYWR5JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQW5pbWF0aW9uU3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25BbmltYXRpb25FbmQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25Nb3ZlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uR2VzdHVyZVN0YXJ0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uR2VzdHVyZUVuZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1Njcm9sbFZpZXdCYXNlO1xufShNYnNjQmFzZSkpO1xudmFyIE1ic2NTY3JvbGxWaWV3QmFzZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY0Jhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjU2Nyb2xsSXRlbUJhc2UsIE1ic2NTY3JvbGxWaWV3QmFzZV0sXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlO1xufSgpKTtcblxudmFyIE1ic2NOYXZJdGVtQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOYXZJdGVtQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTmF2SXRlbUJhc2Uobm90aWZ5SXRlbVNlcnZpY2UsIGVsZW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm90aWZ5SXRlbVNlcnZpY2UsIGVsZW0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTmF2SXRlbUJhc2UucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5kaXNhYmxlKHRoaXMuX2VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5lbmFibGUodGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTmF2SXRlbUJhc2UucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZWxlY3QodGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRlc2VsZWN0KHRoaXMuX2VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjTmF2SXRlbUJhc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAhdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLl9zZWxlY3RlZCk7XG4gICAgfTtcbiAgICBNYnNjTmF2SXRlbUJhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW21ic2MtbmktYicgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTmF2SXRlbUJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTmF2SXRlbUJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpY29uJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkaXNhYmxlZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2VsZWN0ZWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NlbGVjdGVkQ2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTmF2SXRlbUJhc2U7XG59KE1ic2NTY3JvbGxJdGVtQmFzZSkpO1xudmFyIE1ic2NOYXZpZ2F0aW9uQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOYXZpZ2F0aW9uQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTmF2aWdhdGlvbkJhc2UoaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1ic2NOYXZpZ2F0aW9uQmFzZS5wcm90b3R5cGUudGFwSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3QgfHwgKGluc3QgJiYgaW5zdC5zZXR0aW5ncy5zZWxlY3QpO1xuICAgICAgICBzd2l0Y2ggKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbXVsdGlwbGUnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaXRlbS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2dldEl0ZW0oZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV2ZW50Lmluc3QgPSBpbnN0O1xuICAgICAgICB0aGlzLm9uSXRlbVRhcC5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIE1ic2NOYXZpZ2F0aW9uQmFzZS5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAobmF0aXZlRWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmF0aXZlRWxlbWVudCA9PT0gbmF0aXZlRWw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWJzY05hdmlnYXRpb25CYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1ttYnNjLW4tYicgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTmF2aWdhdGlvbkJhc2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgIF07IH07XG4gICAgTWJzY05hdmlnYXRpb25CYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnZGlzcGxheSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICdpdGVtcyc6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW01ic2NOYXZJdGVtQmFzZSxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTmF2aWdhdGlvbkJhc2U7XG59KE1ic2NTY3JvbGxWaWV3QmFzZSkpO1xudmFyIE1ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjTmF2aWdhdGlvbkJhc2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY05hdmlnYXRpb25CYXNlLCBNYnNjTmF2SXRlbUJhc2VdLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBNYnNjTmF2SXRlbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOYXZJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NOYXZJdGVtKG5vdGlmeUl0ZW1TZXJ2aWNlLCBlbGVtLCBpbmosIHJvdXRlclRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBlbGVtKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmogPSBpbmo7XG4gICAgICAgIF90aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zID0geyBleGFjdDogZmFsc2UgfTtcbiAgICAgICAgX3RoaXMuaW5zdE9ic2VydmVyID0gbm90aWZ5SXRlbVNlcnZpY2Uub25JbnN0YW5jZVJlYWR5KCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmluaXRpYWxCYWRnZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldEJhZGdlKF90aGlzLm5hdGl2ZUVsZW1lbnQsIF90aGlzLmluaXRpYWxCYWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm91dGVyVG9rZW4pIHtcbiAgICAgICAgICAgIF90aGlzLmluamVjdGVkUm91dGVyID0gcm91dGVyVG9rZW47XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZWRSb3V0ZSA9IF90aGlzLmluai5nZXQoX3RoaXMuaW5qZWN0ZWRSb3V0ZXIucm91dGVyU3RhdGUucm9vdC5fX3Byb3RvX18uY29uc3RydWN0b3IsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5pbmplY3RlZFJvdXRlcikge1xuICAgICAgICAgICAgX3RoaXMuaW5qZWN0ZWRSb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuZGVib3VuY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWJvdW5jZUhhbmRsZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tTZWxlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY05hdkl0ZW0ucHJvdG90eXBlLCBcImJhZGdlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmFkZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldEJhZGdlKHRoaXMubmF0aXZlRWxlbWVudCwgYmFkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsQmFkZ2UgPSBiYWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY05hdkl0ZW0ucHJvdG90eXBlLmNoZWNrU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluamVjdGVkUm91dGVyICYmIHRoaXMucm91dGVyTGluayAhPT0gbnVsbCAmJiB0aGlzLnJvdXRlckxpbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0gQXJyYXkuaXNBcnJheSh0aGlzLnJvdXRlckxpbmspID8gdGhpcy5yb3V0ZXJMaW5rIDogW3RoaXMucm91dGVyTGlua107XG4gICAgICAgICAgICB2YXIgdXJsVHJlZSA9IHRoaXMuaW5qZWN0ZWRSb3V0ZXIuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgeyByZWxhdGl2ZVRvOiB0aGlzLmFjdGl2YXRlZFJvdXRlIH0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5pbmplY3RlZFJvdXRlci5pc0FjdGl2ZSh1cmxUcmVlLCB0aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zLmV4YWN0KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2VsZWN0KHRoaXMuX2VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5kZXNlbGVjdCh0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY05hdkl0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnVuc3Vic2NyaWJlKHRoaXMuaW5zdE9ic2VydmVyKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY05hdkl0ZW0uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1uYXYtaXRlbScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWljb25dJzogJ2ljb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pZF0nOiAnaWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOYXZJdGVtLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IE1ic2NOb3RpZnlJdGVtU2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSb3V0ZXJUb2tlbiwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTmF2SXRlbS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2JhZGdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdyb3V0ZXJMaW5rJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdyb3V0ZXJMaW5rQWN0aXZlT3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NOYXZJdGVtO1xufShNYnNjTmF2SXRlbUJhc2UpKTtcbnZhciBNYnNjTmF2ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY05hdiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTmF2KGluaXRpYWxFbGVtLCB6b25lLCBub3RpZnlJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5zZWxlY3QgPSAnc2luZ2xlJztcbiAgICAgICAgX3RoaXMub25NZW51SGlkZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25NZW51U2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTmF2LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9uSXRlbVRhcCA9IHRoaXMudGFwSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgb25JdGVtVGFwVXNlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMub25JdGVtVGFwO1xuICAgICAgICBpZiAob25JdGVtVGFwVXNlcikge1xuICAgICAgICAgICAgb25JdGVtVGFwID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGFwSGFuZGxlcihldmVudCwgaW5zdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uSXRlbVRhcFVzZXIoZXZlbnQsIGluc3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgdHlwZTogdGhpcy50eXBlIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB7IG9uSXRlbVRhcDogb25JdGVtVGFwIH0pO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IE5hdmlnYXRpb24odGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlJbnN0YW5jZVJlYWR5KHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmFkZFJlbW92ZU9ic2VydmVyID0gdGhpcy5ub3RpZnlJdGVtU2VydmljZS5vbkFkZFJlbW92ZSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1ic2NOYXYucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkudW5zdWJzY3JpYmUodGhpcy5hZGRSZW1vdmVPYnNlcnZlcik7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NOYXYuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1uYXYnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTm90aWZ5SXRlbVNlcnZpY2VdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTmF2LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NOb3RpZnlJdGVtU2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY05hdi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ21vcmVUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtb3JlSWNvbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWVudVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21lbnVJY29uJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvbk1lbnVIaWRlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uTWVudVNob3cnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnaXRlbXMnOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtNYnNjTmF2SXRlbSxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTmF2O1xufShNYnNjTmF2aWdhdGlvbkJhc2UpKTtcbnZhciBNYnNjQm90dG9tTmF2ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY0JvdHRvbU5hdiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjQm90dG9tTmF2KGluaXRpYWxFbGVtLCB6b25lLCBuYXZJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbmF2SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnYm90dG9tJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjQm90dG9tTmF2LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtYm90dG9tLW5hdicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NOb3RpZnlJdGVtU2VydmljZV0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NCb3R0b21OYXYuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gTWJzY0JvdHRvbU5hdjtcbn0oTWJzY05hdikpO1xudmFyIE1ic2NIYW1idXJnZXJOYXYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjSGFtYnVyZ2VyTmF2LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NIYW1idXJnZXJOYXYoaW5pdGlhbEVsZW0sIHpvbmUsIG5hdkl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBuYXZJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdoYW1idXJnZXInO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NIYW1idXJnZXJOYXYuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1oYW1idXJnZXItbmF2JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jbG9haycgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0hhbWJ1cmdlck5hdi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBNYnNjSGFtYnVyZ2VyTmF2O1xufShNYnNjTmF2KSk7XG52YXIgTWJzY1RhYk5hdiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NUYWJOYXYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1RhYk5hdihpbml0aWFsRWxlbSwgem9uZSwgbmF2SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5hdkl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ3RhYic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY1RhYk5hdi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRhYi1uYXYnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTm90aWZ5SXRlbVNlcnZpY2VdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjVGFiTmF2LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NOb3RpZnlJdGVtU2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1ic2NUYWJOYXY7XG59KE1ic2NOYXYpKTtcbnZhciBjb21wcyA9IFtcbiAgICBNYnNjTmF2SXRlbSxcbiAgICBNYnNjTmF2LFxuICAgIE1ic2NCb3R0b21OYXYsXG4gICAgTWJzY0hhbWJ1cmdlck5hdixcbiAgICBNYnNjVGFiTmF2XG5dO1xudmFyIE1ic2NOYXZpZ2F0aW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjTmF2aWdhdGlvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY05hdmlnYXRpb25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYnNjTmF2aWdhdGlvbk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWJzY1JvdXRlclRva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogY29uZmlnLmFuZ3VsYXJSb3V0ZXJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWJzY05hdmlnYXRpb25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBjb21wcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogY29tcHNcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOYXZpZ2F0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NOYXZpZ2F0aW9uTW9kdWxlO1xufSgpKTtcblxudmFyIE51bWJlclNjcm9sbGVyID0gTWVhc3VyZW1lbnQ7XG5wcmVzZXRzLm51bWJlciA9IHByZXNldHMubWVhc3VyZW1lbnQ7XG5cbnZhciBNYnNjTnVtYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTnVtYmVyKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjTnVtYmVyLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY051bWJlci5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICdudW1iZXInIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IE51bWJlclNjcm9sbGVyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjTnVtYmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bWJlcl0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTnVtYmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY051bWJlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2RlY2ltYWxTZXBhcmF0b3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW52YWxpZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NjYWxlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGVwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd3aG9sZVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ZyYWN0aW9uVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2lnblRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1udW1iZXInLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtbnVtYmVyQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTnVtYmVyO1xufShNYnNjU2Nyb2xsZXJCYXNlKSk7XG52YXIgTWJzY051bWJlckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOdW1iZXJDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bWJlckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NOdW1iZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1iZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOdW1iZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY051bWJlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTnVtYmVyQ29tcG9uZW50O1xufShNYnNjTnVtYmVyKSk7XG52YXIgTWJzY051bWJlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY051bWJlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY051bWJlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjTnVtYmVyLCBNYnNjTnVtYmVyQ29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01ic2NOdW1iZXIsIE1ic2NOdW1iZXJDb21wb25lbnRdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTnVtYmVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NOdW1iZXJNb2R1bGU7XG59KCkpO1xuXG52YXIgcHJlc2V0cyQxID0ge307XG52YXIgTnVtcGFkID0gZnVuY3Rpb24gTnVtcGFkKGVsLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJG1hcmt1cCxcbiAgICAgIGRlbGV0ZUJ0bixcbiAgICAgIGRpc2FibGVkQ2xhc3MsXG4gICAgICBwaCxcbiAgICAgIHBvcyxcbiAgICAgIHMsXG4gICAgICBtYXNrLFxuICAgICAgc1gsXG4gICAgICBzWSxcbiAgICAgIGVYLFxuICAgICAgZVksXG4gICAgICBkaWZmWCxcbiAgICAgIGRpZmZZLFxuICAgICAgYWN0aW9uLFxuICAgICAgaW50ZXJ2YWwsXG4gICAgICB0ZW1wVmFsdWVBcnJheSxcbiAgICAgIHRlbXBUb3RhbCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICB0b3RhbCxcbiAgICAgIHZhbHVlQXJyYXksXG4gICAgICAkZWxtID0gJCQxKGVsKSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgdGVtcEFjdGlvbnMgPSBbXSxcbiAgICAgIHRlbXBWYXJpYWJsZXMgPSB7fSxcbiAgICAgIHZhcmlhYmxlcyA9IHt9LFxuICAgICAgY3VzdG9tS2V5cyA9IHt9LFxuICAgICAgbnVtZXJpY0tleXMgPSB7XG4gICAgNDg6IDAsXG4gICAgNDk6IDEsXG4gICAgNTA6IDIsXG4gICAgNTE6IDMsXG4gICAgNTI6IDQsXG4gICAgNTM6IDUsXG4gICAgNTQ6IDYsXG4gICAgNTU6IDcsXG4gICAgNTY6IDgsXG4gICAgNTc6IDksXG4gICAgOTY6IDAsXG4gICAgOTc6IDEsXG4gICAgOTg6IDIsXG4gICAgOTk6IDMsXG4gICAgMTAwOiA0LFxuICAgIDEwMTogNSxcbiAgICAxMDI6IDYsXG4gICAgMTAzOiA3LFxuICAgIDEwNDogOCxcbiAgICAxMDU6IDlcbiAgfTtcblxuICBmdW5jdGlvbiBkaXNwbGF5KG1hbnVhbCkge1xuICAgIC8vIFZhbGlkYXRlXG4gICAgdmFyIGksXG4gICAgICAgIHJldCA9IHMudmFsaWRhdGUuY2FsbChlbCwge1xuICAgICAgdmFsdWVzOiB0ZW1wVmFsdWVBcnJheS5zbGljZSgwKSxcbiAgICAgIHZhcmlhYmxlczogdGVtcFZhcmlhYmxlc1xuICAgIH0sIHRoYXQpIHx8IFtdLFxuICAgICAgICBkaXNhYmxlZCA9IHJldCAmJiByZXQuZGlzYWJsZWQgfHwgW107XG4gICAgdGhhdC5faXNWYWxpZCA9IHJldC5pbnZhbGlkID8gZmFsc2UgOiB0cnVlOyAvLyBHZW5lcmF0ZSBmb3JtYXR0ZWQgdmFsdWVcblxuICAgIHRoYXQuX3RlbXBWYWx1ZSA9IHMuZm9ybWF0VmFsdWUuY2FsbChlbCwgdGVtcFZhbHVlQXJyYXkuc2xpY2UoMCksIHRlbXBWYXJpYWJsZXMsIHRoYXQpO1xuICAgIHBvcyA9IHRlbXBWYWx1ZUFycmF5Lmxlbmd0aDtcbiAgICB0ZW1wVG90YWwgPSByZXQubGVuZ3RoIHx8IHRvdGFsO1xuXG4gICAgaWYgKHRoYXQuX2lzVmlzaWJsZSAmJiBtb2Jpc2Nyb2xsLkVtdGpDKSB7XG4gICAgICAvLyBGaWxsIHRlbXBsYXRlIHdpdGggbnVtYmVyc1xuICAgICAgJCQxKCcubWJzYy1ucC1waCcsICRtYXJrdXApLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgJCQxKHRoaXMpLmh0bWwocy5maWxsID09ICdsdHInID8gaSA+PSBwb3MgPyBwaCA6IG1hc2sgfHwgdGVtcFZhbHVlQXJyYXlbaV0gOiBpID49IHRvdGFsIC0gdGVtcFRvdGFsID8gaSArIHBvcyA8IHRvdGFsID8gcGggOiBtYXNrIHx8IHRlbXBWYWx1ZUFycmF5W2kgKyBwb3MgLSB0b3RhbF0gOiAnJyk7XG4gICAgICB9KTsgLy8gRmlsbCB2YXJpYWJsZSBwbGFjZWhvbGRlcnNcblxuICAgICAgJCQxKCcubWJzYy1ucC1jcGgnLCAkbWFya3VwKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCQxKHRoaXMpLmh0bWwodGVtcFZhcmlhYmxlc1skJDEodGhpcykuYXR0cignZGF0YS12YXInKV0gfHwgJCQxKHRoaXMpLmF0dHIoJ2RhdGEtcGgnKSk7XG4gICAgICB9KTsgLy8gRGlzYWJsZSBhbGwgbnVtZXJpYyBidXR0b25zIGlmIHRlbXBsYXRlIGlzIGZ1bGxcblxuICAgICAgaWYgKHBvcyA9PT0gdG90YWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIERpc2FibGUgaW52YWxpZCBidXR0b25zXG5cblxuICAgICAgJCQxKCcubWJzYy1ucC1idG4nLCAkbWFya3VwKS5yZW1vdmVDbGFzcyhkaXNhYmxlZENsYXNzKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRpc2FibGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICQkMSgnLm1ic2MtbnAtYnRuW2RhdGEtdmFsPVwiJyArIGRpc2FibGVkW2ldICsgJ1wiXScsICRtYXJrdXApLmFkZENsYXNzKGRpc2FibGVkQ2xhc3MpO1xuICAgICAgfSAvLyBEaXNhYmxlIHNldCBidXR0b25cblxuXG4gICAgICBpZiAodGhhdC5faXNWYWxpZCkge1xuICAgICAgICAkJDEoJy5tYnNjLWZyLWJ0bi1zIC5tYnNjLWZyLWJ0bicsICRtYXJrdXApLnJlbW92ZUNsYXNzKGRpc2FibGVkQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQxKCcubWJzYy1mci1idG4tcyAubWJzYy1mci1idG4nLCAkbWFya3VwKS5hZGRDbGFzcyhkaXNhYmxlZENsYXNzKTtcbiAgICAgIH0gLy8gRmlsbCBpbnB1dCBpZiBpbiBsaXZlIG1vZGVcblxuXG4gICAgICBpZiAodGhhdC5saXZlKSB7XG4gICAgICAgIHRoYXQuX2hhc1ZhbHVlID0gbWFudWFsIHx8IHRoYXQuX2hhc1ZhbHVlO1xuICAgICAgICBmaWxsVmFsdWUobWFudWFsLCBmYWxzZSwgbWFudWFsKTtcblxuICAgICAgICBpZiAobWFudWFsKSB7XG4gICAgICAgICAgdHJpZ2dlcignb25TZXQnLCB7XG4gICAgICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX3ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsVmFsdWUoZmlsbCwgZGlzcCwgY2hhbmdlLCB0ZW1wKSB7XG4gICAgaWYgKGRpc3ApIHtcbiAgICAgIGRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRlbXApIHtcbiAgICAgIHZhbHVlQXJyYXkgPSB0ZW1wVmFsdWVBcnJheS5zbGljZSgwKTtcbiAgICAgIHZhcmlhYmxlcyA9IGV4dGVuZCQxKHt9LCB0ZW1wVmFyaWFibGVzKTtcbiAgICAgIGFjdGlvbnMgPSB0ZW1wQWN0aW9ucy5zbGljZSgwKTtcbiAgICAgIHRoYXQuX3ZhbHVlID0gdGhhdC5faGFzVmFsdWUgPyB0aGF0Ll90ZW1wVmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBpZiAodGhhdC5faXNJbnB1dCkge1xuICAgICAgICAkZWxtLnZhbCh0aGF0Ll9oYXNWYWx1ZSAmJiB0aGF0Ll9pc1ZhbGlkID8gdGhhdC5fdmFsdWUgOiAnJyk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXIoJ29uRmlsbCcsIHtcbiAgICAgICAgdmFsdWVUZXh0OiB0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnLFxuICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IHRydWU7XG4gICAgICAgICRlbG0udHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFZhbHVlcyh2YWx1ZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdmFycyxcbiAgICAgICAgdmFsID0gdmFsdWVzIHx8IFtdLFxuICAgICAgICByZXQgPSBbXTtcbiAgICB0ZW1wQWN0aW9ucyA9IFtdO1xuICAgIHRlbXBWYXJpYWJsZXMgPSB7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vaWYgKGlzTmFOKHBhcnNlSW50KHZhbFtpXSkpKSB7XG4gICAgICBpZiAoLzovLnRlc3QodmFsW2ldKSkge1xuICAgICAgICB2YXJzID0gdmFsW2ldLnNwbGl0KCc6Jyk7XG4gICAgICAgIHRlbXBWYXJpYWJsZXNbdmFyc1swXV0gPSB2YXJzWzFdO1xuICAgICAgICB0ZW1wQWN0aW9ucy5wdXNoKHZhcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2godmFsW2ldKTtcbiAgICAgICAgdGVtcEFjdGlvbnMucHVzaCgnZGlnaXQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlcklucHV0KGJ0biwgZXYpIHtcbiAgICB0cmlnZ2VyKCdvbklucHV0Jywge1xuICAgICAgZG9tRXZlbnQ6IGV2LFxuICAgICAgdGFyZ2V0OiBidG4sXG4gICAgICB2YWx1ZXM6IHRlbXBWYWx1ZUFycmF5LnNsaWNlKDApLFxuICAgICAgdmFsdWVUZXh0OiB0aGF0Ll90ZW1wVmFsdWUsXG4gICAgICB2YXJpYWJsZXM6IHRlbXBWYXJpYWJsZXNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEtleXMoa2V5cywgcG9zKSB7XG4gICAgaWYgKGtleXMpIHtcbiAgICAgIGtleXMgPSAkJDEuaXNBcnJheShrZXlzKSA/IGtleXMgOiBba2V5c107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjdXN0b21LZXlzW2tleV0gPSBwb3M7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk51bWJlclRhcChidG4sIHZhbCwgZXYpIHtcbiAgICBpZiAoIXBvcyAmJiAhdmFsICYmICFzLmFsbG93TGVhZGluZ1plcm8gfHwgYnRuLmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykgfHwgYnRuLmhhc0NsYXNzKCdtYnNjLW5wLWJ0bi1lbXB0eScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcyA8IHRvdGFsICYmIG1vYmlzY3JvbGwuRW10akMpIHtcbiAgICAgIHRlbXBBY3Rpb25zLnB1c2goJ2RpZ2l0Jyk7XG4gICAgICB0ZW1wVmFsdWVBcnJheS5wdXNoKHZhbCk7XG4gICAgICBkaXNwbGF5KHRydWUpO1xuICAgICAgdHJpZ2dlcklucHV0KGJ0blswXSwgZXYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ3VzdG9tVGFwKGJ0biwgZXYpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdixcbiAgICAgICAgdmFsID0gYnRuLmF0dHIoJ2RhdGEtdmFsJyksXG4gICAgICAgIHRyYWNrID0gYnRuLmF0dHIoJ2RhdGEtdHJhY2snKSAhPT0gJ2ZhbHNlJyxcbiAgICAgICAgdmFyaWFibGUgPSBidG4uYXR0cignZGF0YS12YXInKTtcblxuICAgIGlmICghYnRuLmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykpIHtcbiAgICAgIGlmICh2YXJpYWJsZSkge1xuICAgICAgICB2ID0gdmFyaWFibGUuc3BsaXQoJzonKTtcblxuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICB0ZW1wQWN0aW9ucy5wdXNoKHZbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcFZhcmlhYmxlc1t2WzBdXSA9IHZbMl0gPT09IHVuZGVmaW5lZCA/IHZbMV0gOiB0ZW1wVmFyaWFibGVzW3ZbMF1dID09IHZbMV0gPyB2WzJdIDogdlsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbC5sZW5ndGggKyBwb3MgPD0gdGVtcFRvdGFsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2ID0gaXNOdW1lcmljKHZhbFtpXSkgPyArdmFsW2ldIDogdmFsW2ldO1xuXG4gICAgICAgICAgaWYgKHMuYWxsb3dMZWFkaW5nWmVybyB8fCBwb3MgfHwgdikge1xuICAgICAgICAgICAgdGVtcEFjdGlvbnMucHVzaCgnZGlnaXQnKTtcbiAgICAgICAgICAgIHRlbXBWYWx1ZUFycmF5LnB1c2godik7XG4gICAgICAgICAgICBwb3MgPSB0ZW1wVmFsdWVBcnJheS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpc3BsYXkodHJ1ZSk7XG4gICAgICB0cmlnZ2VySW5wdXQoYnRuWzBdLCBldik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EZWxldGVUYXAoZXYpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgb2xkLFxuICAgICAgICBhY3QgPSB0ZW1wQWN0aW9ucy5wb3AoKTtcblxuICAgIGlmIChwb3MgfHwgYWN0ICE9PSAnZGlnaXQnKSB7XG4gICAgICBpZiAoYWN0ICE9PSAnZGlnaXQnICYmIHRlbXBWYXJpYWJsZXNbYWN0XSkge1xuICAgICAgICBkZWxldGUgdGVtcFZhcmlhYmxlc1thY3RdO1xuICAgICAgICBvbGQgPSB0ZW1wQWN0aW9ucy5zbGljZSgwKTtcbiAgICAgICAgdGVtcEFjdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9sZFtpXSAhPT0gYWN0KSB7XG4gICAgICAgICAgICB0ZW1wQWN0aW9ucy5wdXNoKG9sZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wVmFsdWVBcnJheS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZGlzcGxheSh0cnVlKTtcbiAgICAgIHRyaWdnZXJJbnB1dChkZWxldGVCdG4sIGV2KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydERlbGV0ZShldikge1xuICAgIGFjdGlvbiA9IHRydWU7XG4gICAgc1ggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICBzWSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIGNsZWFyVGltZW91dChpbnRlcnZhbCk7XG4gICAgb25EZWxldGVUYXAoZXYpO1xuICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgb25EZWxldGVUYXAoZXYpO1xuICAgIH0sIDE1MCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wRGVsZXRlKCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIGFjdGlvbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdGFydChldikge1xuICAgIGlmICh0ZXN0VG91Y2goZXYsIHRoaXMpKSB7XG4gICAgICBpZiAoZXYudHlwZSA9PSAna2V5ZG93bicgJiYgZXYua2V5Q29kZSAhPSAzMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0RGVsZXRlKGV2KTtcblxuICAgICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vbignbW91c2V1cCcsIG9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdmUoZXYpIHtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBlWCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgZVkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIGRpZmZYID0gZVggLSBzWDtcbiAgICAgIGRpZmZZID0gZVkgLSBzWTtcblxuICAgICAgaWYgKE1hdGguYWJzKGRpZmZYKSA+IDcgfHwgTWF0aC5hYnMoZGlmZlkpID4gNykge1xuICAgICAgICBzdG9wRGVsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoZXYpIHtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcERlbGV0ZSgpO1xuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2V1cCcpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vZmYoJ21vdXNlbW92ZScsIG9uTW92ZSkub2ZmKCdtb3VzZXVwJywgb25FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEZyYW1lLmNhbGwodGhpcywgZWwsIHNldHRpbmdzLCB0cnVlKTsgLy8gUHVibGljIGZ1bmN0aW9uc1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZVxuICAgKi9cblxuICB0aGF0LnNldFZhbCA9IHRoYXQuX3NldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCkge1xuICAgIHRoYXQuX2hhc1ZhbHVlID0gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gJyc7XG4gICAgdGVtcFZhbHVlQXJyYXkgPSBsb2FkVmFsdWVzKCQkMS5pc0FycmF5KHZhbCkgPyB2YWwuc2xpY2UoMCkgOiBzLnBhcnNlVmFsdWUuY2FsbChlbCwgdmFsLCB0aGF0KSk7XG4gICAgZmlsbFZhbHVlKGZpbGwsIHRydWUsIGNoYW5nZSA9PT0gdW5kZWZpbmVkID8gZmlsbCA6IGNoYW5nZSwgdGVtcCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZVxuICAgKi9cblxuXG4gIHRoYXQuZ2V0VmFsID0gdGhhdC5fZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICByZXR1cm4gdGhhdC5faGFzVmFsdWUgfHwgdGVtcCA/IHRoYXRbdGVtcCA/ICdfdGVtcFZhbHVlJyA6ICdfdmFsdWUnXSA6IG51bGw7XG4gIH07XG4gIC8qXG4gICAqIFNldHMgdGhlIHZhbHVlIChwYXNzZWQgYXMgYW4gYXJyYXkpXG4gICAqL1xuXG5cbiAgdGhhdC5zZXRBcnJheVZhbCA9IHRoYXQuc2V0VmFsO1xuICAvKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB3aGVlbCB2YWx1ZXMgYXMgYW4gYXJyYXlcbiAgICovXG5cbiAgdGhhdC5nZXRBcnJheVZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIHRlbXAgPyB0ZW1wVmFsdWVBcnJheS5zbGljZSgwKSA6IHRoYXQuX2hhc1ZhbHVlID8gdmFsdWVBcnJheS5zbGljZSgwKSA6IG51bGw7XG4gIH07IC8vIFByb3RlY3RlZCBvdmVycmlkZXNcblxuXG4gIHRoYXQuX3JlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9ICRlbG0udmFsKCkgfHwgJyc7XG5cbiAgICBpZiAodiAhPT0gJycpIHtcbiAgICAgIHRoYXQuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobWFzaykge1xuICAgICAgdGVtcFZhcmlhYmxlcyA9IHt9O1xuICAgICAgdGVtcEFjdGlvbnMgPSBbXTtcbiAgICAgIHRlbXBWYWx1ZUFycmF5ID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBWYXJpYWJsZXMgPSB0aGF0Ll9oYXNWYWx1ZSA/IHZhcmlhYmxlcyA6IHt9O1xuICAgICAgdGVtcEFjdGlvbnMgPSB0aGF0Ll9oYXNWYWx1ZSA/IGFjdGlvbnMgOiBbXTtcbiAgICAgIHRlbXBWYWx1ZUFycmF5ID0gdGhhdC5faGFzVmFsdWUgJiYgdmFsdWVBcnJheSA/IHZhbHVlQXJyYXkuc2xpY2UoMCkgOiBsb2FkVmFsdWVzKHMucGFyc2VWYWx1ZS5jYWxsKGVsLCB2LCB0aGF0KSk7XG4gICAgICBmaWxsVmFsdWUoZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9maWxsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5faGFzVmFsdWUgPSB0cnVlO1xuICAgIGZpbGxWYWx1ZSh0cnVlLCBmYWxzZSwgdHJ1ZSk7XG4gIH07XG5cbiAgdGhhdC5fZ2VuZXJhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICB2LFxuICAgICAgICBrID0gMSxcbiAgICAgICAgbGVmdEtleSA9IHMubGVmdEtleSxcbiAgICAgICAgcmlnaHRLZXkgPSBzLnJpZ2h0S2V5LFxuICAgICAgICB0ZW1wbGF0ZSA9ICcnLFxuICAgICAgICBodG1sID0gJyc7IC8vIERpc3BsYXlcblxuICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLW5wLWhkclwiPjxkaXYgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGFyaWEtbGFiZWw9XCInICsgcy5kZWxldGVUZXh0ICsgJ1wiIGNsYXNzPVwibWJzYy1ucC1kZWwgbWJzYy1mci1idG4tZSBtYnNjLWljIG1ic2MtaWMtJyArIHMuZGVsZXRlSWNvbiArICdcIj48L2Rpdj48ZGl2IGNsYXNzPVwibWJzYy1ucC1kc3BcIj4nOyAvLyBQcm9jZXNzIHRlbXBsYXRlXG5cbiAgICB0ZW1wbGF0ZSA9IHMudGVtcGxhdGUucmVwbGFjZSgvZC9nLCAnPHNwYW4gY2xhc3M9XCJtYnNjLW5wLXBoXCI+JyArIHBoICsgJzwvc3Bhbj4nKS5yZXBsYWNlKC8mIzEwMDsvZywgJ2QnKTsgLy8gR2VuZXJhdGUgdGhlIHRlbXBsYXRlIGZvciBjdXN0b20gYnV0dG9uc1xuXG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC97KFthLXpBLVowLTldKik6PyhbYS16QS1aMC05XFwtX10qKX0vZywgJzxzcGFuIGNsYXNzPVwibWJzYy1ucC1jcGhcIiBkYXRhLXZhcj1cIiQxXCIgZGF0YS1waD1cIiQyXCI+JDI8L3NwYW4+Jyk7XG4gICAgaHRtbCArPSB0ZW1wbGF0ZTtcbiAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nOyAvLyBEaWdpdCBidXR0b25zXG5cbiAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1ucC10YmwtYyBtYnNjLXctcFwiPjxkaXYgY2xhc3M9XCJtYnNjLW5wLXRibFwiPic7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1ucC1yb3dcIj4nO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIHYgPSBrO1xuXG4gICAgICAgIGlmIChrID09IDEwIHx8IGsgPT0gMTIpIHtcbiAgICAgICAgICB2ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PSAxMSkge1xuICAgICAgICAgIHYgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYgPT09ICcnKSB7XG4gICAgICAgICAgaWYgKGsgPT0gMTAgJiYgbGVmdEtleSkge1xuICAgICAgICAgICAgYWRkS2V5cyhsZWZ0S2V5LmtleXMsICdsZWZ0Jyk7XG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cIm1ic2MtbnAtYnRuIG1ic2MtbnAtYnRuLWN1c3RvbSBtYnNjLW5wLWJ0bi1jdXN0b20tbGVmdCBtYnNjLWZyLWJ0bi1lXCIgJyArIChsZWZ0S2V5LnZhcmlhYmxlID8gJ2RhdGEtdmFyPVwiJyArIGxlZnRLZXkudmFyaWFibGUgKyAnXCInIDogJycpICsgJyBkYXRhLXZhbD1cIicgKyAobGVmdEtleS52YWx1ZSB8fCAnJykgKyAnXCIgJyArIChsZWZ0S2V5LnRyYWNrICE9PSB1bmRlZmluZWQgPyAnIGRhdGEtdHJhY2s9XCInICsgbGVmdEtleS50cmFjayArICdcIicgOiAnJykgKyAnPicgKyBsZWZ0S2V5LnRleHQgKyAnPC9kaXY+JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGsgPT0gMTIgJiYgcy5yaWdodEtleSkge1xuICAgICAgICAgICAgYWRkS2V5cyhyaWdodEtleS5rZXlzLCAncmlnaHQnKTtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGNsYXNzPVwibWJzYy1ucC1idG4gbWJzYy1ucC1idG4tY3VzdG9tIG1ic2MtbnAtYnRuLWN1c3RvbS1yaWdodCBtYnNjLWZyLWJ0bi1lXCIgJyArIChyaWdodEtleS52YXJpYWJsZSA/ICdkYXRhLXZhcj1cIicgKyByaWdodEtleS52YXJpYWJsZSArICdcIicgOiAnJykgKyAnIGRhdGEtdmFsPVwiJyArIChyaWdodEtleS52YWx1ZSB8fCAnJykgKyAnXCIgJyArIChyaWdodEtleS50cmFjayAhPT0gdW5kZWZpbmVkID8gJyBkYXRhLXRyYWNrPVwiJyArIHJpZ2h0S2V5LnRyYWNrICsgJ1wiJyA6ICcnKSArICcgPicgKyByaWdodEtleS50ZXh0ICsgJzwvZGl2Pic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLW5wLWJ0biBtYnNjLW5wLWJ0bi1lbXB0eVwiPjwvZGl2Pic7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGh0bWwgKz0gJzxkaXYgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwibWJzYy1ucC1idG4gbWJzYy1mci1idG4tZVwiIGRhdGEtdmFsPVwiJyArIHYgKyAnXCI+JyArIHYgKyB0aGF0Ll9nZXRUZXh0KG1vYmlzY3JvbGwsIDAuMikgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGsrKztcbiAgICAgIH1cblxuICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICB9XG5cbiAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuXG4gIHRoYXQuX21hcmt1cFJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICRtYXJrdXAgPSB0aGF0Ll9tYXJrdXA7XG4gICAgZGlzcGxheSgpO1xuICB9O1xuXG4gIHRoYXQuX2F0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uICgkbSkge1xuICAgICRtLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgYnRuLFxuICAgICAgICAgIGtleSA9IGV2LmtleUNvZGU7XG5cbiAgICAgIGlmIChjdXN0b21LZXlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidG4gPSAkJDEoJy5tYnNjLW5wLWJ0bi1jdXN0b20tJyArIGN1c3RvbUtleXNba2V5XSwgJG0pO1xuXG4gICAgICAgIGlmIChidG4ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGJ0bi5hdHRyKCdkYXRhLXZhcicpID09PSAnc2lnbjotOicpIHtcbiAgICAgICAgICAgIHRlbXBWYXJpYWJsZXMuc2lnbiA9IGtleSA9PT0gMTA3IHx8IGtleSA9PT0gMTg3ID8gJy0nIDogJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb25DdXN0b21UYXAoYnRuLCBldik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpY0tleXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uTnVtYmVyVGFwKCQkMSgnLm1ic2MtbnAtYnRuW2RhdGEtdmFsPVwiJyArIG51bWVyaWNLZXlzW2tleV0gKyAnXCJdJywgJG0pLCBudW1lcmljS2V5c1trZXldLCBldik7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PSA4KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uRGVsZXRlVGFwKGV2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGF0LnRhcCgkJDEoJy5tYnNjLW5wLWJ0bicsICRtKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgYnRuID0gJCQxKHRoaXMpO1xuXG4gICAgICBpZiAoYnRuLmhhc0NsYXNzKCdtYnNjLW5wLWJ0bi1jdXN0b20nKSkge1xuICAgICAgICBvbkN1c3RvbVRhcChidG4sIGV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTnVtYmVyVGFwKGJ0biwgK2J0bi5hdHRyKCdkYXRhLXZhbCcpLCBldik7XG4gICAgICB9XG4gICAgfSwgZmFsc2UsIDMwLCB0cnVlKTtcbiAgICBkZWxldGVCdG4gPSAkJDEoJy5tYnNjLW5wLWRlbCcsICRtKVswXTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgbGlzdGVuKGRlbGV0ZUJ0biwgJ2tleWRvd24nLCBvblN0YXJ0KTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgbGlzdGVuKGRlbGV0ZUJ0biwgJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgbGlzdGVuKGRlbGV0ZUJ0biwgJ3RvdWNoZW5kJywgb25FbmQpO1xuICAgIGxpc3RlbihkZWxldGVCdG4sICdtb3VzZXVwJywgb25FbmQpO1xuICAgIGxpc3RlbihkZWxldGVCdG4sICdrZXl1cCcsIG9uRW5kKTtcbiAgfTtcblxuICB0aGF0Ll9faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBzLnRlbXBsYXRlID0gcy50ZW1wbGF0ZS5yZXBsYWNlKC9cXFxcZC8sICcmIzEwMDsnKTtcbiAgICBwaCA9IHMucGxhY2Vob2xkZXI7XG4gICAgdG90YWwgPSAocy50ZW1wbGF0ZS5tYXRjaCgvZC9nKSB8fCBbXSkubGVuZ3RoO1xuICAgIGRpc2FibGVkQ2xhc3MgPSAnbWJzYy1kaXNhYmxlZCAnICsgKHMuZGlzYWJsZWRDbGFzcyB8fCAnJyk7XG4gICAgbWFzayA9IHMubWFzaztcbiAgICB0cmlnZ2VyID0gdGhhdC50cmlnZ2VyO1xuXG4gICAgaWYgKG1hc2sgJiYgJGVsbS5pcygnaW5wdXQnKSkge1xuICAgICAgJGVsbS5hdHRyKCd0eXBlJywgJ3Bhc3N3b3JkJyk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2luZGV4T2YgPSBmdW5jdGlvbiAoY29udCwgdikge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChjb250W2ldLnRvU3RyaW5nKCkgPT09IHYudG9TdHJpbmcoKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07IC8vIENvbnN0cnVjdG9yXG5cblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTsgLy8gRXh0ZW5kIGRlZmF1bHRzXG5cbk51bXBhZC5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9yZXNwb25zaXZlOiB0cnVlLFxuICBfY2xhc3M6ICdudW1wYWQnLFxuICBfcHJlc2V0czogcHJlc2V0cyQxLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBGcmFtZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgdGVtcGxhdGU6ICdkZC5kZCcsXG4gICAgcGxhY2Vob2xkZXI6ICcwJyxcbiAgICBkZWxldGVJY29uOiAnYmFja3NwYWNlJyxcbiAgICBhbGxvd0xlYWRpbmdaZXJvOiBmYWxzZSxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICBmaWxsOiAncnRsJyxcbiAgICBjb21wQ2xhc3M6ICdtYnNjLW5wJyxcbiAgICAvLyBMb2NhbGl6YXRpb25cbiAgICBkZWxldGVUZXh0OiAnRGVsZXRlJyxcbiAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG4gICAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnLCcsXG4gICAgLy8gQHRvZG9cbiAgICAvLyAtLS1cbiAgICAvL2ZpbGxGdWxsVGVtcGxhdGU6IHRydWUsXG4gICAgLy8gLS0tXG4gICAgdmFsaWRhdGU6IG5vb3AsXG4gICAgcGFyc2VWYWx1ZTogbm9vcCxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHZhcmlhYmxlcywgaW5zdCkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaiA9IDEsXG4gICAgICAgICAgcyA9IGluc3Quc2V0dGluZ3MsXG4gICAgICAgICAgcGggPSBzLnBsYWNlaG9sZGVyLFxuICAgICAgICAgIHRlbXBsYXRlID0gcy50ZW1wbGF0ZSxcbiAgICAgICAgICB2YWx1ZUxlbiA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB0ZW1wTGVuID0gdGVtcGxhdGUubGVuZ3RoLFxuICAgICAgICAgIHJlcyA9ICcnO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcExlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVt0ZW1wTGVuIC0gaSAtIDFdID09ICdkJykge1xuICAgICAgICAgIGlmIChqIDw9IHZhbHVlTGVuKSB7XG4gICAgICAgICAgICByZXMgPSB2YWx1ZVt2YWx1ZUxlbiAtIGpdICsgcmVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwaCArIHJlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gdGVtcGxhdGVbdGVtcExlbiAtIGkgLSAxXSArIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkJDEuZWFjaCh2YXJpYWJsZXMsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIHJlcyA9IHJlcy5yZXBsYWNlKCd7JyArIGkgKyAnfScsIHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJCQxKCc8ZGl2PicgKyByZXMgKyAnPC9kaXY+JykudGV4dCgpO1xuICAgIH1cbiAgfSlcbn07XG5jbGFzc2VzLk51bXBhZCA9IE51bXBhZDtcbm1vYmlzY3JvbGwudGhlbWVzLm51bXBhZCA9IG1vYmlzY3JvbGwudGhlbWVzLmZyYW1lOyAvLyBEZWNpbWFsIHByZXNldFxuLy8gLS0tXG5cbnZhciBkZWNpbWFsRGVmYXVsdHMgPSB7XG4gIGVudHJ5TW9kZTogJ3RlbXBsYXRlJyxcbiAgbWluOiAwLFxuICBtYXg6IDk5Ljk5LFxuICBtYXhTY2FsZTogNCxcbiAgcHJlZml4OiAnJyxcbiAgc3VmZml4OiAnJyxcbiAgcmV0dXJuQWZmaXg6IGZhbHNlXG59O1xuXG5wcmVzZXRzJDEuZGVjaW1hbCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgY29uZGl0aW9uYWxEZWZhdWx0cyA9IHtcbiAgICBzY2FsZTogb3JpZy5lbnRyeU1vZGUgPT0gJ2ZyZWVmb3JtJyA/IHVuZGVmaW5lZCA6IDJcbiAgfSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWNpbWFsRGVmYXVsdHMsIGNvbmRpdGlvbmFsRGVmYXVsdHMsIG9yaWcpLFxuICAgICAgc2NhbGUgPSBzLnNjYWxlLFxuICAgICAgbWluID0gK3MubWluLnRvRml4ZWQoc2NhbGUpLFxuICAgICAgbWF4ID0gK3MubWF4LnRvRml4ZWQoc2NhbGUpLFxuICAgICAgbmVnYXRpdmVOdW0gPSBtaW4gPCAwLFxuICAgICAgdGhvdXNhbmRSZWdleCA9IG5ldyBSZWdFeHAocy50aG91c2FuZHNTZXBhcmF0b3IsICdnJyksXG4gICAgICBtYXhJbnRMZW5ndGggPSAoTWF0aC5mbG9vcihNYXRoLm1heChtYXgsIE1hdGguYWJzKG1pbikpKSArICcnKS5sZW5ndGggKyAxLFxuICAgICAgZnJlZUVudHJ5ID0gcy5lbnRyeU1vZGUgPT0gJ2ZyZWVmb3JtJztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBmcm9tIHRoZSBkaWdpdHNcbiAgICogQHBhcmFtIHtBcnJheX0gZGlnaXRBcnJheVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTmVnYXRpdmVcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0TnVtYmVyKGRpZ2l0QXJyYXksIGlzTmVnYXRpdmUpIHtcbiAgICBpZiAoIWRpZ2l0QXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gK2RpZ2l0QXJyYXkubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gKGkgPT09IDAgJiYgdiA9PT0gJy4nID8gJzAnIDogJycpICsgdjtcbiAgICB9KS5qb2luKCcnKTsgLy8gaW4gdGhlIGNhc2Ugb2YgTk9UIHRoZSBmcmVlRW50cnkgbW9kZSwgdGhlIGRlY2ltYWwgcG9pbnQgd29udCBiZSBwYXJ0IG9mIHRoZSBkaWdpdHMgYXJyYXlcbiAgICAvLyBpbiB0aGF0IGNhc2UgdGhlIHZhbHVlIHdpbGwgbmVlZCB0byBiZSBhZGp1c3RlZCB0byB0aGUgcmlnaHQgc2NhbGVcblxuICAgIGlmICghZnJlZUVudHJ5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjYWxlOyBpKyspIHtcbiAgICAgICAgcmV0IC89IDEwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpc05lZ2F0aXZlID8gcmV0ICogLTEgOiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCB2YWx1ZSBmcm9tIHRoZSBhcnJheSBvZiBkaWdpdHNcbiAgICogQHBhcmFtIHtBcnJheX0gZGlnaXRBcnJheVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZChkaWdpdEFycmF5LCBmb3JJbnB1dCkge1xuICAgIHZhciBudW1iZXJTdHIgPSAnJztcblxuICAgIGlmIChmcmVlRW50cnkgJiYgKHNjYWxlID09PSB1bmRlZmluZWQgfHwgIWZvcklucHV0KSkge1xuICAgICAgaWYgKGRpZ2l0QXJyYXlbMF0gPT09ICcuJykge1xuICAgICAgICAvLyBhZGQgbWlzc2luZyBsZWFkaW5nIHplcm8gd2hlbiBvbmx5IHRoZSBkZWNpbWFsIHBvaW50IGlzIHByZXNzZWRcbiAgICAgICAgbnVtYmVyU3RyICs9ICcwJztcbiAgICAgIH1cblxuICAgICAgbnVtYmVyU3RyICs9IGRpZ2l0QXJyYXkuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuciA9IGdldE51bWJlcihkaWdpdEFycmF5KTtcblxuICAgICAgaWYgKGZvcklucHV0ICYmIGZyZWVFbnRyeSkge1xuICAgICAgICBudW1iZXJTdHIgPSBuciA9PT0gbnVsbCA/ICcnIDogbnIudG9GaXhlZChzY2FsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1iZXJTdHIgPSAobnIgPT09IG51bGwgPyAwIDogbnIpLnRvRml4ZWQoc2NhbGUpO1xuICAgICAgfVxuICAgIH0gLy8gc3BsaXQgdGhlIHZhbHVlIGJ5IHRoZSBkZWNpbWFsIHNlcGFyYXRvciB0byBhZGQgdGhvdXNhbmQgc2VwYXJhdG9ycyB0byB0aGUgaW50ZWdlciBwYXJ0XG5cblxuICAgIHZhciBwYXJ0cyA9IG51bWJlclN0ci5zcGxpdCgnLicpLFxuICAgICAgICBpbnRlZ2VyID0gcGFydHNbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgcy50aG91c2FuZHNTZXBhcmF0b3IpLFxuICAgICAgICBkZWMgPSBwYXJ0c1sxXSA/IHMuZGVjaW1hbFNlcGFyYXRvciArIHBhcnRzWzFdIDogJyc7IC8vIHdoZW4gZGVjaW1hbCBzZXBhcmF0b3IgYWxzbyBuZWVkZWQgd2hlbiB0aGVyZSBpcyBubyBkZWNpbWFsIHBhcnQgaW4gZnJlZSBlbnRyeSBtb2RlXG4gICAgLy8gYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGFsc28gdXNlZCBmb3IgdGhlIGRpc3BsYXllZCBudW1iZXIgb24gdGhlIG51bXBhZCwgbm90IG9ubHkgZm9yIHRoZSBpbnB1dFxuXG4gICAgaWYgKHBhcnRzWzFdICE9PSB1bmRlZmluZWQgJiYgIXBhcnRzWzFdLmxlbmd0aCAmJiBmcmVlRW50cnkpIHtcbiAgICAgIGRlYyA9IHMuZGVjaW1hbFNlcGFyYXRvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZWdlciArIGRlYztcbiAgfSAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXApIHtcbiAgICBpZiAodmFsIHx8IHZhbCA9PT0gMCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9ICt2YWwucmVwbGFjZShzLnRob3VzYW5kc1NlcGFyYXRvciwgJycpLnJlcGxhY2Uocy5kZWNpbWFsU2VwYXJhdG9yLCAnLicpO1xuICAgICAgfVxuXG4gICAgICB2YWwgPSBjb25zdHJhaW4odmFsLCBtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3QuX3NldFZhbCh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCk7XG4gIH07XG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHZhciB2YWwgPSBpbnN0Ll9nZXRWYWwodGVtcCksXG4gICAgICAgIHZhbE5yID0gKHZhbCArICcnKS5yZXBsYWNlKHRob3VzYW5kUmVnZXgsICcnKS5yZXBsYWNlKHMuZGVjaW1hbFNlcGFyYXRvciwgJy4nKTtcblxuICAgIHJldHVybiBpc051bWVyaWModmFsTnIpID8gK3ZhbE5yIDogdmFsO1xuICB9OyAvLyAtLS1cblxuXG4gIHZhciBudW1iZXJUZW1wbGF0ZSA9IEFycmF5KG1heEludExlbmd0aCkuam9pbignZCcpOyAvLyBpbiB0aGUgY2FzZSBvZiBmcmVlRW50cnksIHRoZSBkZWNpbWFsIHBvaW50IHNob3VsZCBub3QgYmUgcGFydCBvZiB0aGUgdGVtcGxhdGVcblxuICBpZiAoZnJlZUVudHJ5KSB7XG4gICAgaWYgKHNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICsyIGluZGV4IHJlcXVpcmVkOlxuICAgICAgLy8gLSAxIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgLy8gLSAxIGZvciB0aGUgam9pbiBtZXRob2QsIHNpbmNlIHRoZSBcImRcInMgd2lsbCBiZSB0aGUgc2VwYXJhdG9ycyAoYW5kIHRoZXJlJ3Mgb25lIHNlcGFyYXRvciBsZXNzIHRoYW4gdmFsdWUpXG4gICAgICBudW1iZXJUZW1wbGF0ZSArPSBzY2FsZSA/IEFycmF5KHNjYWxlICsgMikuam9pbignZCcpIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlclRlbXBsYXRlICs9IEFycmF5KHMubWF4U2NhbGUgKyAyKS5qb2luKCdkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICsxIHJlcXVpcmVkIGZvciB0aGUgam9pbiBtZXRob2QsIHNpbmNlIHRoZSBcImRcInMgd2lsbCBiZSB0aGUgc2VwYXJhdG9ycyAoYW5kIHRoZXJlJ3Mgb25lIHNlcGFyYXRvciBsZXNzIHRoYW4gdmFsdWUpXG4gICAgbnVtYmVyVGVtcGxhdGUgKz0gc2NhbGUgPyAnLicgKyBBcnJheShzY2FsZSArIDEpLmpvaW4oJ2QnKSA6ICcnO1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlID0gKG5lZ2F0aXZlTnVtID8gJ3tzaWdufScgOiAnJykgKyBzLnByZWZpeC5yZXBsYWNlKC9kL2csICdcXFxcZCcpICsgbnVtYmVyVGVtcGxhdGUgKyBzLnN1ZmZpeC5yZXBsYWNlKC9kL2csICdcXFxcZCcpO1xuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBsZWZ0S2V5OiBuZWdhdGl2ZU51bSA/IHtcbiAgICAgIHRleHQ6ICctLysnLFxuICAgICAgdmFyaWFibGU6ICdzaWduOi06JyxcbiAgICAgIHRyYWNrOiBmYWxzZSxcbiAgICAgIGtleXM6IFsxMDcsIDEwOSwgMTg3LCAxODldXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICByaWdodEtleTogZnJlZUVudHJ5ID8ge1xuICAgICAgdGV4dDogcy5kZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgdmFsdWU6ICcuJyxcbiAgICAgIGtleXM6IFsxMTAsIDE5MF1cbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIGFsbG93TGVhZGluZ1plcm86IGZyZWVFbnRyeSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICBmaXhTY2FsZSA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IHMubWF4U2NhbGU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICBpZiAoK3ZhbHVlID09PSAwKSB7XG4gICAgICAgIGlmIChmcmVlRW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodikge1xuICAgICAgICB2ID0gKHYgKyAnJykucmVwbGFjZSh0aG91c2FuZFJlZ2V4LCAnJykucmVwbGFjZShzLmRlY2ltYWxTZXBhcmF0b3IsICcuJyk7XG4gICAgICAgIG0gPSB2Lm1hdGNoKC9cXGQrXFwuP1xcZCovZyk7XG5cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBtID0gKCttWzBdKS50b0ZpeGVkKGZpeFNjYWxlKTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobVtpXSAhPSAnLicpIHtcbiAgICAgICAgICAgICAgaWYgKCttW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goK21baV0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBsZWFkaW5nIDBzXG4gICAgICAgICAgICAgICAgLy8gaW4gZnJlZUVudHJ5IG1vZGUsIHplcm9zIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IGFyZSBvbmx5IG5lY2Vzc2FyeSBpZiB0aGVyZSBhcmUgb3RoZXIgbm9uemVybyBkaWdpdHMgYWZ0ZXIgdGhlbVxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlIDEwLjAwMDEgLSBkZWNpbWFsIHplcm9zIGFyZSByZXF1aXJlZCA9PiAxMC4wMDAxID0+IFsxLCAwLCAuLCAwLCAwLCAwLCAxXVxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlIDEwLjEwMDAgLSBkZWNpbWFsIHplcm9zIGFyZSBub3QgcmVxdWlyZWQgPT4gMTAuMSA9PiBbMSwgMCwgLiwgMV1cbiAgICAgICAgICAgICAgICB2YXIgZGVjSW5kZXggPSBtLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9uWmVybyA9IG0ubGVuZ3RoID4gaSArIDEgJiYgbS5zdWJzdHJpbmcoaSArIDEpLm1hdGNoKC9bMS05XSsvKTtcblxuICAgICAgICAgICAgICAgIGlmICghZnJlZUVudHJ5IHx8IGkgPCBkZWNJbmRleCB8fCBub25aZXJvKSB7XG4gICAgICAgICAgICAgICAgICByZXQucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJlZUVudHJ5KSB7XG4gICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZyZWVFbnRyeSwgdGhlIGRlY2ltYWwgcG9pbnQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGlucHV0IGRpZ2l0c1xuICAgICAgICAgICAgICByZXQucHVzaCgnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkZWNpbWFsSW5kZXggPSBtLmluZGV4T2YoJy4nKTsgLy8gaWYgdGhlcmUgYXJlIG5vIGRpZ2l0cyBhZnRlciB0aGUgcG9pbnQgcmVtb3ZlIHRoZSBwb2ludFxuXG4gICAgICAgICAgaWYgKHJldC5pbmRleE9mKCcuJykgPj0gMCAmJiAobS5sZW5ndGggPD0gZGVjaW1hbEluZGV4ICsgMSB8fCAhbS5zdWJzdHJpbmcoZGVjaW1hbEluZGV4ICsgMSkubWF0Y2goL1sxLTldKy8pKSkge1xuICAgICAgICAgICAgcmV0LnNwbGljZShyZXQuaW5kZXhPZignLicpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAvLyBtYWtlIHRoZSBzaWduIHRoZSBsYXN0IHRoaW5nIHRvIG1hbmlwdWxhdGVcbiAgICAgICAgcmV0LnVuc2hpZnQoJ3NpZ246JyArICctJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIHZhcmlhYmxlcykge1xuICAgICAgdmFyIHYgPSBnZXRGb3JtYXR0ZWQodmFsdWUsIHRydWUpLFxuICAgICAgICAgIG5yID0gZ2V0TnVtYmVyKHZhbHVlLCB2YXJpYWJsZXMgJiYgdmFyaWFibGVzLnNpZ24gPT0gJy0nKTtcbiAgICAgIHJldHVybiAobnIgPCAwID8gJy0nIDogJycpICsgKHMucmV0dXJuQWZmaXggPyBzLnByZWZpeCArIHYgKyBzLnN1ZmZpeCA6IHYpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGRpZ2l0cyA9IGRhdGEudmFsdWVzLFxuICAgICAgICAgIHYgPSBnZXRGb3JtYXR0ZWQoZGlnaXRzKSxcbiAgICAgICAgICBuciA9IGdldE51bWJlcihkaWdpdHMsIGRhdGEudmFyaWFibGVzICYmIGRhdGEudmFyaWFibGVzLnNpZ24gPT0gJy0nKSxcbiAgICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICAgIGludmFsaWQgPSBuciA+IG1heCB8fCBuciA8IG1pbiB8fCAocy5pbnZhbGlkID8gaW5zdC5faW5kZXhPZihzLmludmFsaWQsIG5yKSAhPSAtMSA6IGZhbHNlKTtcblxuICAgICAgaWYgKCFkaWdpdHMubGVuZ3RoICYmICFzLmFsbG93TGVhZGluZ1plcm8gJiYgIWZyZWVFbnRyeSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlnaXRzLmxlbmd0aCA+PSBtYXhJbnRMZW5ndGggfHwgZGlnaXRzLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJlZUVudHJ5KSB7XG4gICAgICAgIGlmIChkaWdpdHMubGVuZ3RoID09IDEgJiYgZGlnaXRzWzBdID09PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWdpdHMubGVuZ3RoIHx8IGRpZ2l0c1tkaWdpdHMubGVuZ3RoIC0gMV0gPT0gJy4nKSB7XG4gICAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICAgIH0gLy8gT25seSBhbGxvdyBtYXggbWF4U2NhbGUgZGVjaW1hbCB2YWx1ZXNcblxuXG4gICAgICAgIHZhciBzY2EgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiBzLm1heFNjYWxlOyAvLyA+PSBtZWFuaW5nOiBzdGFydGluZyB6ZXJvIGRpZ2l0IG1heSBiZSBtaXNzaW5nLCB0aGF0J3Mgd2h5XG5cbiAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPj0gc2NhICsgMSAmJiBkaWdpdHNbZGlnaXRzLmxlbmd0aCAtIHNjYSAtIDFdID09ICcuJykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gOTsgaSsrKSB7XG4gICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBEaXNwbGF5IHRoZSBmb3JtYXR0ZWQgdmFsdWVcblxuXG4gICAgICBpZiAoaW5zdC5pc1Zpc2libGUoKSkge1xuICAgICAgICAkJDEoJy5tYnNjLW5wLWRzcCcsIGluc3QuX21hcmt1cCkuaHRtbCgoZGF0YS52YXJpYWJsZXMuc2lnbiB8fCAnJykgKyBzLnByZWZpeCArIHYgKyBzLnN1ZmZpeCB8fCAnJm5ic3A7Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgaW52YWxpZDogaW52YWxpZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvLyAtLS1cbi8vIFRpbWVzcGFuIHByZXNldFxuLy8gLS0tXG5cblxuZnVuY3Rpb24gZ2V0U2Vjb25kcyh2YWx1ZSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBtID0gMSxcbiAgICAgIHJldCA9IDA7XG5cbiAgd2hpbGUgKHZhbHVlLmxlbmd0aCkge1xuICAgIGlmIChpID4gMykge1xuICAgICAgbSA9IDYwICogNjA7XG4gICAgfSBlbHNlIGlmIChpID4gMSkge1xuICAgICAgbSA9IDYwO1xuICAgIH1cblxuICAgIHJldCA9IHJldCArIHZhbHVlLnBvcCgpICogbSAqIChpICUgMiA/IDEwIDogMSk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxudmFyIHBhcnRzID0gWydoJywgJ20nLCAncyddLFxuICAgIHRpbWVzcGFuRGVmYXVsdHMgPSB7XG4gIG1pbjogMCxcbiAgbWF4OiAzNjI0MzksXG4gIC8vOTkgKiA2MCAqIDYwICsgOTkgKiA2MCArIDk5XG4gIGRlZmF1bHRWYWx1ZTogMCxcbiAgaG91clRleHRTaG9ydDogJ2gnLFxuICBtaW51dGVUZXh0U2hvcnQ6ICdtJyxcbiAgc2VjVGV4dFNob3J0OiAncydcbn07XG5cbnByZXNldHMkMS50aW1lc3BhbiA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHRpbWVzcGFuRGVmYXVsdHMsIG9yaWcpLFxuICAgICAgbGFiZWxzID0ge1xuICAgIGg6IHMuaG91clRleHRTaG9ydC5yZXBsYWNlKC9kL2csICdcXFxcZCcpLFxuICAgIG06IHMubWludXRlVGV4dFNob3J0LnJlcGxhY2UoL2QvZywgJ1xcXFxkJyksXG4gICAgczogcy5zZWNUZXh0U2hvcnQucmVwbGFjZSgvZC9nLCAnXFxcXGQnKVxuICB9LFxuICAgICAgdGVtcGxhdGUgPSAnZDxzcGFuIGNsYXNzPVwibWJzYy1ucC1zdXAgbWJzYy1ucC10aW1lXCI+JyArIGxhYmVscy5zICsgJzwvc3Bhbj4nO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFRpbWUoc2Vjb25kcykge1xuICAgIHZhciBwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgbSA9IDYwICogNjA7XG4gICAgJCQxKHBhcnRzKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICBwID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gbSk7XG4gICAgICBzZWNvbmRzIC09IHAgKiBtO1xuICAgICAgbSAvPSA2MDtcblxuICAgICAgaWYgKHAgPiAwIHx8IHYgPT0gJ3MnICYmICFyZXQpIHtcbiAgICAgICAgcmV0ID0gcmV0ICsgKHJldCA/ICcgJyA6ICcnKSArIHAgKyBsYWJlbHNbdl07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChzLm1heCA+IDkpIHtcbiAgICB0ZW1wbGF0ZSA9ICdkJyArIHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHMubWF4ID4gOTkpIHtcbiAgICB0ZW1wbGF0ZSA9ICc8c3BhbiBjbGFzcz1cIm1ic2MtbnAtdHMtbVwiPicgKyAocy5tYXggPiA2MzkgPyAnZCcgOiAnJykgKyAnZDwvc3Bhbj48c3BhbiBjbGFzcz1cIm1ic2MtbnAtc3VwIG1ic2MtbnAtdGltZVwiPicgKyBsYWJlbHMubSArICc8L3NwYW4+JyArIHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHMubWF4ID4gNjAzOSkge1xuICAgIHRlbXBsYXRlID0gJzxzcGFuIGNsYXNzPVwibWJzYy1ucC10cy1oXCI+JyArIChzLm1heCA+IDM4NDM5ID8gJ2QnIDogJycpICsgJ2Q8L3NwYW4+PHNwYW4gY2xhc3M9XCJtYnNjLW5wLXN1cCBtYnNjLW5wLXRpbWVcIj4nICsgbGFiZWxzLmggKyAnPC9zcGFuPicgKyB0ZW1wbGF0ZTtcbiAgfSAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXApIHtcbiAgICBpZiAoaXNOdW1lcmljKHZhbCkpIHtcbiAgICAgIHZhbCA9IGZvcm1hdFRpbWUodmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdC5fc2V0VmFsKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wKTtcbiAgfTtcblxuICBpbnN0LmdldFZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBnZXRTZWNvbmRzKGluc3QuZ2V0QXJyYXlWYWwodGVtcCkpIDogbnVsbDtcbiAgfTsgLy8gLS0tXG5cblxuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgcCxcbiAgICAgICAgICB2diA9IHZhbHVlIHx8IGZvcm1hdFRpbWUocy5kZWZhdWx0VmFsdWUpLFxuICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICBpZiAodnYpIHtcbiAgICAgICAgJCQxKHBhcnRzKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgcCA9IG5ldyBSZWdFeHAoJyhcXFxcZCspJyArIGxhYmVsc1t2XSwgJ2dpJykuZXhlYyh2dik7XG5cbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcCA9ICtwWzFdO1xuXG4gICAgICAgICAgICBpZiAocCA+IDkpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihwIC8gMTApKTtcbiAgICAgICAgICAgICAgcmV0LnB1c2gocCAlIDEwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbGVhZGluZyAwc1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHAgfHwgcmV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGxlYWRpbmcgMHNcbiAgICAgICAgICAgICAgICByZXQucHVzaChwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0LnB1c2goMCk7XG4gICAgICAgICAgICByZXQucHVzaCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VGltZShnZXRTZWNvbmRzKHZhbHVlKSk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgdiA9IGdldFNlY29uZHModmFsdWUuc2xpY2UoMCkpLFxuICAgICAgICAgIGRpc2FibGVkID0gW107XG5cbiAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgaW52YWxpZDogdiA+IHMubWF4IHx8IHYgPCBzLm1pbiB8fCAocy5pbnZhbGlkID8gaW5zdC5faW5kZXhPZihzLmludmFsaWQsICt2KSAhPSAtMSA6IGZhbHNlKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvLyAtLS1cbi8vIFRpbWUgcHJlc2V0XG4vLyAtLS1cblxuXG52YXIgdGltZURlZmF1bHRzID0ge1xuICB0aW1lRm9ybWF0OiAnaGg6aWkgQScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgcG1UZXh0OiAncG0nXG59O1xuXG5wcmVzZXRzJDEudGltZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHRpbWVEZWZhdWx0cywgb3JpZyksXG4gICAgICB0aW1lRm9ybWF0ID0gcy50aW1lRm9ybWF0LnNwbGl0KCc6JyksXG4gICAgICBpc0FtUE0gPSBzLnRpbWVGb3JtYXQubWF0Y2goL2EvaSksXG4gICAgICBhbSA9IGlzQW1QTSA/IGlzQW1QTVswXSA9PSAnYScgPyBzLmFtVGV4dCA6IHMuYW1UZXh0LnRvVXBwZXJDYXNlKCkgOiAnJyxcbiAgICAgIHBtID0gaXNBbVBNID8gaXNBbVBNWzBdID09ICdhJyA/IHMucG1UZXh0IDogcy5wbVRleHQudG9VcHBlckNhc2UoKSA6ICcnLFxuICAgICAgbCA9IDAsXG4gICAgICBtaW5IID0gcy5taW4gPyAnJyArIHMubWluLmdldEhvdXJzKCkgOiAnJyxcbiAgICAgIG1heEggPSBzLm1heCA/ICcnICsgcy5tYXguZ2V0SG91cnMoKSA6ICcnLFxuICAgICAgbWluTSA9IHMubWluID8gJycgKyAocy5taW4uZ2V0TWludXRlcygpIDwgMTAgPyAnMCcgKyBzLm1pbi5nZXRNaW51dGVzKCkgOiBzLm1pbi5nZXRNaW51dGVzKCkpIDogJycsXG4gICAgICBtYXhNID0gcy5tYXggPyAnJyArIChzLm1heC5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIHMubWF4LmdldE1pbnV0ZXMoKSA6IHMubWF4LmdldE1pbnV0ZXMoKSkgOiAnJyxcbiAgICAgIG1pblMgPSBzLm1pbiA/ICcnICsgKHMubWluLmdldFNlY29uZHMoKSA8IDEwID8gJzAnICsgcy5taW4uZ2V0U2Vjb25kcygpIDogcy5taW4uZ2V0U2Vjb25kcygpKSA6ICcnLFxuICAgICAgbWF4UyA9IHMubWF4ID8gJycgKyAocy5tYXguZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyBzLm1heC5nZXRTZWNvbmRzKCkgOiBzLm1heC5nZXRTZWNvbmRzKCkpIDogJyc7XG5cbiAgaWYgKHMubWluKSB7XG4gICAgcy5taW4uc2V0RnVsbFllYXIoMjAxNCwgNywgMjApO1xuICB9XG5cbiAgaWYgKHMubWF4KSB7XG4gICAgcy5tYXguc2V0RnVsbFllYXIoMjAxNCwgNywgMjApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkVGltZSh2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHJldCA9ICcnO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXQgKz0gdmFsdWVbaV0gKyAoaSAlIDIgPT0gKHZhbHVlLmxlbmd0aCAlIDIgPT0gMSA/IDAgOiAxKSAmJiBpICE9IHZhbHVlLmxlbmd0aCAtIDEgPyAnOicgOiAnJyk7XG4gICAgfVxuXG4gICAgJCQxLmVhY2godmFyaWFibGVzLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgcmV0ICs9ICcgJyArIHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVCdXR0b25zKHZhbHVlKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlzTWluSCxcbiAgICAgICAgaXNNYXhILFxuICAgICAgICBpc01pbk0sXG4gICAgICAgIGlzTWF4TSxcbiAgICAgICAgaW52SCxcbiAgICAgICAgaW52TSxcbiAgICAgICAgaW52UyxcbiAgICAgICAgaG91cixcbiAgICAgICAgbWludXRlcyxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICBkaWdpdE5yID0gMiAqIHRpbWVGb3JtYXQubGVuZ3RoO1xuICAgIGwgPSBkaWdpdE5yO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIGlmIChpc0FtUE0pIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICAgICAgZGlzYWJsZWQucHVzaChzLmxlZnRLZXkudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBkaXNhYmxlZC5wdXNoKHMucmlnaHRLZXkudmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghaXNBbVBNICYmIChkaWdpdE5yIC0gbGVuZ3RoIDwgMiB8fCB2YWx1ZVswXSAhPSAxICYmICh2YWx1ZVswXSA+IDIgfHwgdmFsdWVbMV0gPiAzKSAmJiBkaWdpdE5yIC0gbGVuZ3RoIDw9IDIpKSB7XG4gICAgICBkaXNhYmxlZC5wdXNoKCczMCcpO1xuICAgICAgZGlzYWJsZWQucHVzaCgnMDAnKTtcbiAgICB9XG5cbiAgICBpZiAoKGlzQW1QTSA/IHZhbHVlWzBdID4gMSB8fCB2YWx1ZVsxXSA+IDIgOiB2YWx1ZVswXSAhPSAxICYmICh2YWx1ZVswXSA+IDIgfHwgdmFsdWVbMV0gPiAzKSkgJiYgdmFsdWVbMF0pIHtcbiAgICAgIC8vIGlmIHRoZSBob3VyIG51bWJlciBpcyBub3QgYSB0d28gZGlnaXQgbnVtYmVyXG4gICAgICB2YWx1ZS51bnNoaWZ0KDApO1xuICAgICAgbCA9IGRpZ2l0TnIgLSAxO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT0gbCB8fCBsZW5ndGggPT09IGRpZ2l0TnIgLSAxICYmIHZhbHVlWzJdID4gNSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PSAxICYmIGlzQW1QTSAmJiB2YWx1ZVswXSA9PSAxIHx8ICFpc0FtUE0gJiYgdmFsdWVbMF0gPT0gMiAmJiB2YWx1ZVsxXSA+IDMgJiYgbGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICBmb3IgKGkgPSA2OyBpIDw9IDk7ICsraSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdXIgPSB2YWx1ZVsxXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVswXSArIHZhbHVlWzFdIDogJyc7XG4gICAgbWludXRlcyA9ICttYXhNID09ICsodmFsdWVbM10gIT09IHVuZGVmaW5lZCA/ICcnICsgdmFsdWVbMl0gKyB2YWx1ZVszXSA6ICcnKTtcblxuICAgIGlmIChzLmludmFsaWQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmludmFsaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW52SCA9IHMuaW52YWxpZFtpXS5nZXRIb3VycygpO1xuICAgICAgICBpbnZNID0gcy5pbnZhbGlkW2ldLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgaW52UyA9IHMuaW52YWxpZFtpXS5nZXRTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKGludkggPT0gK2hvdXIpIHtcbiAgICAgICAgICBpZiAodGltZUZvcm1hdC5sZW5ndGggPT0gMiAmJiAoaW52TSA8IDEwID8gMCA6ICsoJycgKyBpbnZNKVswXSkgPT0gK3ZhbHVlWzJdKSB7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGludmFsaWQgbWludXRlc1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpbnZNIDwgMTAgPyBpbnZNIDogKygnJyArIGludk0pWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGludlMgPCAxMCA/IDAgOiArKCcnICsgaW52UylbMF0pID09ICt2YWx1ZVs0XSkge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnZhbGlkIHNlY1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpbnZTIDwgMTAgPyBpbnZTIDogKygnJyArIGludlMpWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzLm1pbiB8fCBzLm1heCkge1xuICAgICAgaXNNaW5IID0gK21pbkggPT0gK2hvdXI7XG4gICAgICBpc01heEggPSArbWF4SCA9PSAraG91cjtcbiAgICAgIGlzTWF4TSA9IGlzTWF4SCAmJiBtaW51dGVzO1xuICAgICAgaXNNaW5NID0gaXNNaW5IICYmIG1pbnV0ZXM7XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gaXNBbVBNID8gMiA6IG1pbkggPiAxOSA/IG1pbkhbMF0gOiAzOyBpIDw9IChtaW5IWzBdID09IDEgPyA5IDogbWluSFswXSAtIDEpOyArK2kpIHtcbiAgICAgICAgICAvLyBkaXNhYmxlcyB2YWx1ZXMgbG93ZXIgdGhhbiBtaW4gYW5kIGxldmVzIHRoZSAxLDIgYnV0dG9uc1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluSCA+PSAxMCkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG5cbiAgICAgICAgICBpZiAobWluSFswXSA9PSAyKSB7XG4gICAgICAgICAgICAvL2lmIDJ4IGhvdXIgaXMgbWluXG4gICAgICAgICAgICBmb3IgKGkgPSAzOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhIICYmIG1heEggPCAxMCB8fCBtaW5IICYmIG1pbkggPj0gMTApIHtcbiAgICAgICAgICAvL2Rpc2FibGVzIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgICAgIGZvciAoaSA9IG1heEggJiYgbWF4SCA8IDEwID8gK21heEhbMF0gKyAxIDogMDsgaSA8IChtaW5IICYmIG1pbkggPj0gMTAgPyBtaW5IWzBdIDogMTApOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICBpZiAodmFsdWVbMF0gPT09IDApIHtcbiAgICAgICAgICAvLyBkaXNhYmxlIG1pbiB2YWx1ZXMgaWYgMjRoIGZvcm1hdCwgYW5kIHN0YXJ0cyB3aXRoIDBcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluSFswXTsgKytpKSB7XG4gICAgICAgICAgICAvL2tpdmV2ZSBtaW5IWzBdID09IDEgPyA5IDpcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbkggJiYgdmFsdWVbMF0gIT09IDAgJiYgKGlzQW1QTSA/IHZhbHVlWzBdID09IDEgOiB2YWx1ZVswXSA9PSAyKSkge1xuICAgICAgICAgIC8vIGRvbid0IGFsbG93IGxvd2VyIHZhbHVlcyBlbnRlcmVkLCBleC4gMjo1NlxuICAgICAgICAgIGZvciAoaSA9IGlzQW1QTSA/IDMgOiA0OyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVbMF0gPT0gbWluSFswXSkge1xuICAgICAgICAgIC8vIGlzIG1pbiB2YWx1ZVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5IWzFdOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlWzBdID09IG1heEhbMF0gJiYgIWlzQW1QTSkge1xuICAgICAgICAgIC8vIGlzIG1heCB2YWx1ZVxuICAgICAgICAgIGZvciAoaSA9ICttYXhIWzFdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gMiAmJiAoaXNNaW5IIHx8IGlzTWF4SCkpIHtcbiAgICAgICAgZm9yIChpID0gaXNNYXhIID8gK21heE1bMF0gKyAxIDogMDsgaSA8IChpc01pbkggPyArbWluTVswXSA6IDEwKTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IDMgJiYgKGlzTWF4SCAmJiB2YWx1ZVsyXSA9PSBtYXhNWzBdIHx8IGlzTWluSCAmJiB2YWx1ZVsyXSA9PSBtaW5NWzBdKSkge1xuICAgICAgICBmb3IgKGkgPSBpc01heEggJiYgdmFsdWVbMl0gPT0gbWF4TVswXSA/ICttYXhNWzFdICsgMSA6IDA7IGkgPCAoaXNNaW5IICYmIHZhbHVlWzJdID09IG1pbk1bMF0gPyArbWluTVsxXSA6IDEwKTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IDQgJiYgKGlzTWluTSB8fCBpc01heE0pKSB7XG4gICAgICAgIGZvciAoaSA9IGlzTWF4TSA/ICttYXhTWzBdICsgMSA6IDA7IGkgPCAoaXNNaW5NID8gK21pblNbMF0gOiAxMCk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA9PSA1ICYmIChpc01pbk0gJiYgdmFsdWVbNF0gPT0gbWluU1swXSB8fCBpc01heE0gJiYgdmFsdWVbNF0gPT0gbWF4U1swXSkpIHtcbiAgICAgICAgZm9yIChpID0gaXNNYXhNICYmIHZhbHVlWzRdID09IG1heFNbMF0gPyArbWF4U1sxXSArIDEgOiAwOyBpIDwgKGlzTWluTSAmJiB2YWx1ZVs0XSA9PSBtaW5TWzBdID8gK21pblNbMV0gOiAxMCk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBsYWNlaG9sZGVyOiAnLScsXG4gICAgYWxsb3dMZWFkaW5nWmVybzogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogKHRpbWVGb3JtYXQubGVuZ3RoID09IDMgPyAnZGQ6ZGQ6ZGQnIDogdGltZUZvcm1hdC5sZW5ndGggPT0gMiA/ICdkZDpkZCcgOiAnZGQnKSArIChpc0FtUE0gPyAnPHNwYW4gY2xhc3M9XCJtYnNjLW5wLXN1cFwiPnthbXBtOi0tfTwvc3Bhbj4nIDogJycpLFxuICAgIGxlZnRLZXk6IGlzQW1QTSA/IHtcbiAgICAgIHRleHQ6IGFtLFxuICAgICAgdmFyaWFibGU6ICdhbXBtOicgKyBhbSxcbiAgICAgIHZhbHVlOiAnMDAnXG4gICAgfSA6IHtcbiAgICAgIHRleHQ6ICc6MDAnLFxuICAgICAgdmFsdWU6ICcwMCdcbiAgICB9LFxuICAgIHJpZ2h0S2V5OiBpc0FtUE0gPyB7XG4gICAgICB0ZXh0OiBwbSxcbiAgICAgIHZhcmlhYmxlOiAnYW1wbTonICsgcG0sXG4gICAgICB2YWx1ZTogJzAwJ1xuICAgIH0gOiB7XG4gICAgICB0ZXh0OiAnOjMwJyxcbiAgICAgIHZhbHVlOiAnMzAnXG4gICAgfSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgaWYgKHYpIHtcbiAgICAgICAgdiA9IHYgKyAnJztcbiAgICAgICAgbSA9IHYubWF0Y2goL1xcZC9nKTtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXQucHVzaCgrbVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQW1QTSkge1xuICAgICAgICAgIHJldC5wdXNoKCdhbXBtOicgKyAodi5tYXRjaChuZXcgUmVnRXhwKHMucG1UZXh0LCAnZ2knKSkgPyBwbSA6IGFtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVGltZSh2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICB2YXJpYWJsZXMgPSBkYXRhLnZhcmlhYmxlcyxcbiAgICAgICAgICBmb3JtYXR0ZWRUaW1lID0gZ2V0Rm9ybWF0dGVkVGltZSh2YWx1ZSwgdmFyaWFibGVzKSxcbiAgICAgICAgICBkID0gdmFsdWUubGVuZ3RoID49IDMgPyBuZXcgRGF0ZSgyMDE0LCA3LCAyMCwgJycgKyB2YWx1ZVswXSArICh2YWx1ZS5sZW5ndGggJSAyID09PSAwID8gdmFsdWVbMV0gOiAnJyksICcnICsgdmFsdWVbdmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IDIgOiAxXSArIHZhbHVlW3ZhbHVlLmxlbmd0aCAlIDIgPT09IDAgPyAzIDogMl0pIDogJyc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZUJ1dHRvbnModmFsdWUpLFxuICAgICAgICBsZW5ndGg6IGwsXG4gICAgICAgIGludmFsaWQ6IChpc0FtUE0gPyAhbmV3IFJlZ0V4cCgnXigwP1sxLTldfDFbMDEyXSkoOlswLTVdXFxcXGQpPyg6WzAtNV1bMC05XSknICsgJyAoPzonICsgcy5hbVRleHQgKyAnfCcgKyBzLnBtVGV4dCArICcpJCcsICdpJykudGVzdChmb3JtYXR0ZWRUaW1lKSA6ICEvXihbMC0xXT9bMC05XXwyWzAtNF0pOihbMC01XVswLTldKSg6WzAtNV1bMC05XSk/JC8udGVzdChmb3JtYXR0ZWRUaW1lKSkgfHwgKHMuaW52YWxpZCA/IGluc3QuX2luZGV4T2Yocy5pbnZhbGlkLCBkKSAhPSAtMSA6IGZhbHNlKSB8fCAhKChzLm1pbiA/IHMubWluIDw9IGQgOiB0cnVlKSAmJiAocy5tYXggPyBkIDw9IHMubWF4IDogdHJ1ZSkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIERhdGUgcHJlc2V0XG4vLyAtLS1cblxuXG52YXIgZGF0ZURlZmF1bHRzID0ge1xuICBkYXRlT3JkZXI6ICdtZHknLFxuICBkYXRlRm9ybWF0OiAnbW0vZGQveXknLFxuICBkZWxpbWl0ZXI6ICcvJ1xufTtcblxucHJlc2V0cyQxLmRhdGUgPSBmdW5jdGlvbiAoaW5zdCkge1xuICB2YXIgeWksXG4gICAgICBtaSxcbiAgICAgIGRpLFxuICAgICAgaSxcbiAgICAgIGluZGV4QXJyYXkgPSBbXSxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgZGF0ZVRpbWVEZWZhdWx0cywgZGF0ZURlZmF1bHRzLCBvcmlnKSxcbiAgICAgIHRlbXBsID0gcy5kYXRlT3JkZXIsXG4gICAgICBtaW5NID0gcy5taW4gPyAnJyArIChzLmdldE1vbnRoKHMubWluKSArIDEpIDogMCxcbiAgICAgIG1heE0gPSBzLm1heCA/ICcnICsgKHMuZ2V0TW9udGgocy5tYXgpICsgMSkgOiAwLFxuICAgICAgbWluRCA9IHMubWluID8gJycgKyBzLmdldERheShzLm1pbikgOiAwLFxuICAgICAgbWF4RCA9IHMubWF4ID8gJycgKyBzLmdldERheShzLm1heCkgOiAwLFxuICAgICAgbWluWSA9IHMubWluID8gJycgKyBzLmdldFllYXIocy5taW4pIDogMCxcbiAgICAgIG1heFkgPSBzLm1heCA/ICcnICsgcy5nZXRZZWFyKHMubWF4KSA6IDA7XG4gIHRlbXBsID0gdGVtcGwucmVwbGFjZSgveSsvZ2ksICd5eXl5Jyk7XG4gIHRlbXBsID0gdGVtcGwucmVwbGFjZSgvbSsvZ2ksICdtbScpO1xuICB0ZW1wbCA9IHRlbXBsLnJlcGxhY2UoL2QrL2dpLCAnZGQnKTtcbiAgeWkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ1knKTtcbiAgbWkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ00nKTtcbiAgZGkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0QnKTtcbiAgdGVtcGwgPSAnJztcbiAgaW5kZXhBcnJheS5wdXNoKHtcbiAgICB2YWw6IHlpLFxuICAgIG46ICd5eXl5J1xuICB9LCB7XG4gICAgdmFsOiBtaSxcbiAgICBuOiAnbW0nXG4gIH0sIHtcbiAgICB2YWw6IGRpLFxuICAgIG46ICdkZCdcbiAgfSk7XG4gIGluZGV4QXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnZhbCAtIGIudmFsO1xuICB9KTtcbiAgJCQxLmVhY2goaW5kZXhBcnJheSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICB0ZW1wbCArPSB2Lm47XG4gIH0pO1xuICB5aSA9IHRlbXBsLmluZGV4T2YoJ3knKTtcbiAgbWkgPSB0ZW1wbC5pbmRleE9mKCdtJyk7XG4gIGRpID0gdGVtcGwuaW5kZXhPZignZCcpO1xuICB0ZW1wbCA9ICcnO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB0ZW1wbCArPSAnZCc7XG5cbiAgICBpZiAoaSArIDEgPT0geWkgfHwgaSArIDEgPT0gbWkgfHwgaSArIDEgPT0gZGkpIHtcbiAgICAgIHRlbXBsICs9IHMuZGVsaW1pdGVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzbGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucyh2YWx1ZSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBpbnZZLFxuICAgICAgICBpbnZNLFxuICAgICAgICBpbnZELFxuICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICB5ZWFyID0gdmFsdWVbeWkgKyAzXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVt5aV0gKyB2YWx1ZVt5aSArIDFdICsgdmFsdWVbeWkgKyAyXSArIHZhbHVlW3lpICsgM10gOiAnJyxcbiAgICAgICAgbW9udGggPSB2YWx1ZVttaSArIDFdICE9PSB1bmRlZmluZWQgPyAnJyArIHZhbHVlW21pXSArIHZhbHVlW21pICsgMV0gOiAnJyxcbiAgICAgICAgZGF5ID0gdmFsdWVbZGkgKyAxXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVtkaV0gKyB2YWx1ZVtkaSArIDFdIDogJycsXG4gICAgICAgIG1heERheSA9ICcnICsgcy5nZXRNYXhEYXlPZk1vbnRoKHllYXIgfHwgMjAxMiwgbW9udGggLSAxIHx8IDApLFxuICAgICAgICAvLyBVc2UgYSBsZWFwIHllYXIgaWYgbm8geWVhciBwcmVzZW50IHRvIGFsbG93IGRheSAyOSB0byBiZSBlbmV0ZXJlZFxuICAgIGlzTWluID0gbWluWSA9PT0geWVhciAmJiArbWluTSA9PT0gK21vbnRoLFxuICAgICAgICBpc01heCA9IG1heFkgPT09IHllYXIgJiYgK21heE0gPT09ICttb250aDtcblxuICAgIGlmIChzLmludmFsaWQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmludmFsaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW52WSA9IHMuZ2V0WWVhcihzLmludmFsaWRbaV0pO1xuICAgICAgICBpbnZNID0gcy5nZXRNb250aChzLmludmFsaWRbaV0pO1xuICAgICAgICBpbnZEID0gcy5nZXREYXkocy5pbnZhbGlkW2ldKTtcblxuICAgICAgICBpZiAoaW52WSA9PSAreWVhciAmJiBpbnZNICsgMSA9PSArbW9udGgpIHtcbiAgICAgICAgICAvL2Rpc2FibGUgdGhlIGl2YWxpZCBkYXlcbiAgICAgICAgICBpZiAoKGludkQgPCAxMCA/IDAgOiArKCcnICsgaW52RClbMF0pID09ICt2YWx1ZVtkaV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaW52RCA8IDEwID8gaW52RCA6ICsoJycgKyBpbnZEKVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52TSArIDEgPT0gK21vbnRoICYmIGludkQgPT0gK2RheSkge1xuICAgICAgICAgIC8vZGlzYWJsZSBpbnZhbGlkIHllYXJcbiAgICAgICAgICBpZiAoKCcnICsgaW52WSkuc3Vic3RyaW5nKDAsIDMpID09ICcnICsgdmFsdWVbeWldICsgdmFsdWVbeWkgKyAxXSArIHZhbHVlW3lpICsgMl0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goKCcnICsgaW52WSlbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludlkgPT0gK3llYXIgJiYgaW52RCA9PSArZGF5KSB7XG4gICAgICAgICAgLy9kaXNhYmxlIHRoZSBpdmFsaWQgbW9udGhcbiAgICAgICAgICBpZiAoKGludk0gPCAxMCA/IDAgOiArKCcnICsgKGludk0gKyAxKSlbMF0pID09ICt2YWx1ZVttaV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaW52TSA8IDEwID8gaW52TSA6ICsoJycgKyAoaW52TSArIDEpKVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIG1vbnRoIGNoZWNrXG5cblxuICAgIGlmIChkYXkgPT0gJzMxJyAmJiAodmFsdWUubGVuZ3RoID09IG1pIHx8IHZhbHVlLmxlbmd0aCA9PSBtaSArIDEpKSB7XG4gICAgICAvLyBkaXNhYmxlIDMwIGRheSBtb250aHNcbiAgICAgIGlmICh2YWx1ZVttaV0gIT0gMSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKDIsIDQsIDYsIDksIDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2FibGVkLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRheSA9PSAnMzAnICYmIHZhbHVlW21pXSA9PT0gMCAmJiB2YWx1ZS5sZW5ndGggPD0gbWkgKyAxKSB7XG4gICAgICAvLyBkaXNhYmxlIGZlYnJ1YXJ5XG4gICAgICBkaXNhYmxlZC5wdXNoKDIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gbWkpIHtcbiAgICAgIC8vIGJlZm9yZSBtb250aCdzIGZpcnN0IGRpZ2l0IHNldCwgZGlzYWJsZSB2YWx1ZXMgb3V0c2lkZSBtaW4vbWF4XG4gICAgICBmb3IgKGkgPSBtYXhZID09PSB5ZWFyICYmICttYXhNIDwgMTAgPyAxIDogMjsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pblkgPT09IHllYXIgJiYgK21pbk0gPj0gMTApIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID09IG1pICsgMSkge1xuICAgICAgLy8gYmVmb3JlIG1vbnRoJ3Mgc2Vjb25kIGRpZ2l0IHNldFxuICAgICAgaWYgKHZhbHVlW21pXSA9PSAxKSB7XG4gICAgICAgIC8vIGlmIHR3byBkaWdpdCBtb250aCBudW1iZXJcbiAgICAgICAgZm9yIChpID0gbWF4WSA9PT0geWVhciA/ICttYXhNWzFdICsgMSA6IDM7IGkgPD0gOTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5ZID09IHllYXIpIHtcbiAgICAgICAgICAvLyBpZiBtaW4geWVhciBkaWFibGUgbG93ZXIgdmFsdWVzXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8ICttaW5NWzFdOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZVttaV0gPT09IDApIHtcbiAgICAgICAgLy9pZiBtb250aCBudW1iZXIgc3RhcnRzIHdpdGggMFxuICAgICAgICBkaXNhYmxlZC5wdXNoKDApO1xuXG4gICAgICAgIGlmIChtYXhZID09PSB5ZWFyIHx8IG1pblkgPT09IHllYXIpIHtcbiAgICAgICAgICAvLyBpZiBtaW4vbWF4IGRpYWJsZSBsb3dlci9ncmVhdGVyIHZhbHVlc1xuICAgICAgICAgIGZvciAoaSA9IG1heFkgPT09IHllYXIgPyArZGF5ID4gK21heEQgPyArbWF4TSA6ICttYXhNICsgMSA6IDA7IGkgPD0gKG1pblkgPT09IHllYXIgPyArZGF5IDwgK21pbkQgPyArbWluTSAtIDEgOiArbWluTSAtIDEgOiA5KTsgKytpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZGF5IGNoZWNrXG5cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gZGkpIHtcbiAgICAgIC8vIGJlZm9yZSBkYXkgZmlyc3QgZGlnaXQgc2V0XG4gICAgICBmb3IgKGkgPSBpc01heCA/ICgrbWF4RCA+IDEwID8gK21heERbMF0gOiAwKSArIDEgOiArbWF4RGF5WzBdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWluKSB7XG4gICAgICAgIC8vIGlmIGlzIG1pbiB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGxvd2VyIHZhbHVlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgKCttaW5EIDwgMTAgPyAwIDogbWluRFswXSk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID09IGRpICsgMSkge1xuICAgICAgLy8gYmVmb3JlIGRheSBzZWNvbmQgZGlnaXQgc2V0XG4gICAgICBpZiAodmFsdWVbZGldID49IDMgfHwgbW9udGggPT0gJzAyJykge1xuICAgICAgICAvL2Rpc2FibGUgZ3JlYXRlciB2YWx1ZXMgdGhhbiB0aGUgbWF4RGF5J3Mgc2Vjb25kIGRpZ2l0XG4gICAgICAgIGZvciAoaSA9ICttYXhEYXlbMV0gKyAxOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWF4ICYmICttYXhEWzBdID09IHZhbHVlW2RpXSkge1xuICAgICAgICAvL2lmIG1heCB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGdyZWF0ZXIgdmFsdWVzXG4gICAgICAgIGZvciAoaSA9ICttYXhEWzFdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01pbiAmJiBtaW5EWzBdID09IHZhbHVlW2RpXSkge1xuICAgICAgICAvL2lmIG1pbiB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGxvd2VyIHZhbHVlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgK21pbkRbMV07ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlW2RpXSA9PT0gMCkge1xuICAgICAgICAvLyBpZiBtb250aCBmaXJzdCBkaWdpdCAwXG4gICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG5cbiAgICAgICAgaWYgKGlzTWF4IHx8IGlzTWluKSB7XG4gICAgICAgICAgLy8gZGlzYWJsZSBncmVhdGVyL2xvd2VyIHZhbGllcyBpZiBtaW4gb3IgbWF4XG4gICAgICAgICAgZm9yIChpID0gaXNNYXggPyArbWF4RCArIDEgOiAxOyBpIDw9IChpc01pbiA/ICttaW5EIC0gMSA6IDkpOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyB5ZWFyIGNoZWNrXG5cblxuICAgIGlmICh2YWx1ZVt5aSArIDJdICE9PSB1bmRlZmluZWQgJiYgbW9udGggPT0gJzAyJyAmJiBkYXkgPT0gJzI5Jykge1xuICAgICAgLy8gaWYgMjl0aCBhbmQgZmVicnVhcnkgdGhhbiBqdXN0IGxlYXAgeWVhcnMgYWxsb3dlZFxuICAgICAgZm9yIChqID0gKygnJyArIHZhbHVlW3lpXSArIHZhbHVlW3lpICsgMV0gKyB2YWx1ZVt5aSArIDJdICsgMCk7IGogPD0gKygnJyArIHZhbHVlW3lpXSArIHZhbHVlW3lpICsgMV0gKyB2YWx1ZVt5aSArIDJdICsgOSk7ICsraikge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKCFpc2xlYXBZZWFyKGopID8gaiAlIDEwIDogJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0geWkpIHtcbiAgICAgIC8vIGJlZm9yZSB5ZWFyJ3MgZmlyc3QgZGlnaXQgc2V0XG4gICAgICBpZiAocy5taW4pIHtcbiAgICAgICAgLy8gZGlzYWJsZSBsb3dlciB2YWx1ZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8ICttaW5ZWzBdOyArK2kpIHtcbiAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzLm1heCkge1xuICAgICAgICAvL2Rpc2FibGUgZ3JlYXRlciB2YWx1ZXNcbiAgICAgICAgZm9yIChpID0gK21heFlbMF0gKyAxOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICB9XG5cbiAgICBpZiAocy5taW4gfHwgcy5tYXgpIHtcbiAgICAgIGZvciAoaiA9IDE7IGogPCA0OyArK2opIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSB5aSArIGopIHtcbiAgICAgICAgICAvLyBiZWZvcmUgeWVhcidzIGktdGggZGlnaXQgc2V0XG4gICAgICAgICAgaWYgKHZhbHVlW3lpICsgaiAtIDFdID09ICttaW5ZW2ogLSAxXSAmJiAoaiA9PSAzID8gdmFsdWVbeWkgKyBqIC0gMl0gPT0gK21pbllbaiAtIDJdIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCArbWluWVtqXSArIChqID09IDMgJiYgdmFsdWVbbWkgKyAxXSAmJiArbWluTSA+ICttb250aCA/IDEgOiAwKTsgKytpKSB7XG4gICAgICAgICAgICAgIC8vaWYgbW9udGggbGVzcyB0aGFuIG1pbi1tb250aCB0aGFuIGRvZXNuJ3QgYWxsb3cgbWluWWVhclxuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZVt5aSArIGogLSAxXSA9PSArbWF4WVtqIC0gMV0gJiYgKGogPT0gMyA/IHZhbHVlW3lpICsgaiAtIDJdID09ICttYXhZW2ogLSAyXSA6IHRydWUpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSArbWF4WVtqXSArIChqID09IDMgJiYgK21heE0gPCArbW9udGggPyAwIDogMSk7IGkgPD0gOTsgKytpKSB7XG4gICAgICAgICAgICAgIC8vaWYgbW9udGggZ3JlYXRlciB0aGFuIG1heC1tb250aCB0aGFuIGRvZXNuJ3QgYWxsb3cgbWF4WWVhclxuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCsoJycgKyB2YWx1ZVt5aV0gKyB2YWx1ZVt5aSArIDFdICsgdmFsdWVbeWkgKyAyXSArIHZhbHVlW3lpICsgM10pLCArKCcnICsgdmFsdWVbbWldICsgdmFsdWVbbWkgKyAxXSkgLSAxLCArKCcnICsgdmFsdWVbZGldICsgdmFsdWVbZGkgKyAxXSkpO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0LmdldFZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBjYWxjRGF0ZShpbnN0LmdldEFycmF5VmFsKHRlbXApKSA6IG51bGw7XG4gIH07IC8vIC0tLVxuXG5cbiAgcmV0dXJuIHtcbiAgICBwbGFjZWhvbGRlcjogJy0nLFxuICAgIGZpbGw6ICdsdHInLFxuICAgIGFsbG93TGVhZGluZ1plcm86IHRydWUsXG4gICAgdGVtcGxhdGU6IHRlbXBsLFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBkID0gcGFyc2VEYXRlKHMuZGF0ZUZvcm1hdCwgdiwgcyk7XG5cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKC9tL2kudGVzdChpbmRleEFycmF5W2ldLm4pKSB7XG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KCgocy5nZXRNb250aChkKSA8IDkgPyAnMCcgOiAnJykgKyAocy5nZXRNb250aChkKSArIDEpKS5zcGxpdCgnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL2QvaS50ZXN0KGluZGV4QXJyYXlbaV0ubikpIHtcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoKChzLmdldERheShkKSA8IDEwID8gJzAnIDogJycpICsgcy5nZXREYXkoZCkpLnNwbGl0KCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoKHMuZ2V0WWVhcihkKSArICcnKS5zcGxpdCgnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGNhbGNEYXRlKHZhbHVlKSwgcyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgZCA9IGNhbGNEYXRlKHZhbHVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlQnV0dG9ucyh2YWx1ZSksXG4gICAgICAgIGludmFsaWQ6ICEoZCAhPSAnSW52YWxpZCBEYXRlJyAmJiAocy5taW4gPyBzLm1pbiA8PSBkIDogdHJ1ZSkgJiYgKHMubWF4ID8gZCA8PSBzLm1heCA6IHRydWUpKSB8fCAocy5pbnZhbGlkID8gaW5zdC5faW5kZXhPZihzLmludmFsaWQsIGQpICE9IC0xIDogZmFsc2UpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIC0tLVxuXG52YXIgTWJzY051bXBhZEJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkQmFzZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkQmFzZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5vblNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25JbnB1dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkQmFzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbWJzYy1uLWJdJyB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOdW1wYWRCYXNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZEJhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdhbGxvd0xlYWRpbmdaZXJvJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWxldGVJY29uJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdmaWxsJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdsZWZ0S2V5JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXNrJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlckNoYXInOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2NoYXItcGxhY2Vob2xkZXInLF0gfSxdLFxuICAgICAgICAncmlnaHRLZXknOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3RlbXBsYXRlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd2YWxpZGF0ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25TZXQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25DbGVhcic6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbklucHV0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ2NhbmNlbFRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NsZWFyVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2V0VGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NOdW1wYWRCYXNlO1xufShNYnNjRnJhbWVCYXNlKSk7XG52YXIgTWJzY051bXBhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NOdW1wYWQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NOdW1wYWQucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgIGlmIChpbm5lclZhbHVlICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjTnVtcGFkLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogdGhpcy5wcmVzZXQgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgTnVtcGFkKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjTnVtcGFkLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bXBhZF0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTnVtcGFkLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1udW1wYWQnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtbnVtcGFkQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTnVtcGFkO1xufShNYnNjTnVtcGFkQmFzZSkpO1xudmFyIE1ic2NOdW1wYWRDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NOdW1wYWRDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjTnVtcGFkQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtbnVtcGFkJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTnVtcGFkQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NOdW1wYWRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY051bXBhZENvbXBvbmVudDtcbn0oTWJzY051bXBhZCkpO1xudmFyIE1ic2NOdW1wYWREZWNpbWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZERlY2ltYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERlY2ltYWwoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2RlY2ltYWwnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtcGFkRGVjaW1hbC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSB8fCB2ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY051bXBhZERlY2ltYWwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtbnVtcGFkLWRlY2ltYWxdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZERlY2ltYWwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTnVtcGFkRGVjaW1hbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW51bXBhZC1kZWNpbWFsJyxdIH0sXSxcbiAgICAgICAgJ2RlY2ltYWxTZXBhcmF0b3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZW50cnlNb2RlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpbnZhbGlkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzY2FsZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4U2NhbGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwcmVmaXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3JldHVybkFmZml4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdWZmaXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Rob3VzYW5kc1NlcGFyYXRvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydtYnNjLW51bXBhZC1kZWNpbWFsQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTnVtcGFkRGVjaW1hbDtcbn0oTWJzY051bXBhZCkpO1xudmFyIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkRGVjaW1hbENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQtZGVjaW1hbCcsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQ7XG59KE1ic2NOdW1wYWREZWNpbWFsKSk7XG52YXIgTWJzY051bXBhZERhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkRGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkRGF0ZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSB8fCB2ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY051bXBhZERhdGUucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgIGlmICgoaW5uZXJWYWx1ZSAmJiAhdikgfHxcbiAgICAgICAgICAgICAgICAoIWlubmVyVmFsdWUgJiYgdikgfHxcbiAgICAgICAgICAgICAgICAoaW5uZXJWYWx1ZSAmJiB2ICYmIGlubmVyVmFsdWUuZ2V0VGltZSgpICE9PSB2LmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NOdW1wYWREYXRlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ2RhdGUnIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IE51bXBhZCh0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY051bXBhZERhdGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtbnVtcGFkLWRhdGVdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZERhdGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTnVtcGFkRGF0ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW51bXBhZC1kYXRlJyxdIH0sXSxcbiAgICAgICAgJ2RhdGVGb3JtYXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RhdGVPcmRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGVsaW1pdGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkZWZhdWx0VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ludmFsaWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pbic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtbnVtcGFkLWRhdGVDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NOdW1wYWREYXRlO1xufShNYnNjTnVtcGFkQmFzZSkpO1xudmFyIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZERhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERhdGVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY051bXBhZERhdGVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQtZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZERhdGVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZERhdGVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY051bXBhZERhdGVDb21wb25lbnQ7XG59KE1ic2NOdW1wYWREYXRlKSk7XG52YXIgTWJzY051bXBhZFRpbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkVGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkVGltZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtcGFkVGltZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSB8fCB2ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY051bXBhZFRpbWUucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgIGlmIChpbm5lclZhbHVlICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjTnVtcGFkVGltZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICd0aW1lJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBOdW1wYWQodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbml0aWFsVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NOdW1wYWRUaW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bXBhZC10aW1lXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOdW1wYWRUaW1lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZFRpbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1udW1wYWQtdGltZScsXSB9LF0sXG4gICAgICAgICdkZWZhdWx0VmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ludmFsaWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21heCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWluJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0aW1lRm9ybWF0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2MtbnVtcGFkLXRpbWVDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NOdW1wYWRUaW1lO1xufShNYnNjTnVtcGFkQmFzZSkpO1xudmFyIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZFRpbWVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZFRpbWVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkVGltZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY051bXBhZFRpbWVDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQtdGltZScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZFRpbWVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZFRpbWVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY051bXBhZFRpbWVDb21wb25lbnQ7XG59KE1ic2NOdW1wYWRUaW1lKSk7XG52YXIgTWJzY051bXBhZFRpbWVzcGFuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZFRpbWVzcGFuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NOdW1wYWRUaW1lc3Bhbihpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5wcmVzZXQgPSAndGltZXNwYW4nO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgfHwgdiAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NOdW1wYWRUaW1lc3Bhbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1udW1wYWQtdGltZXNwYW5dJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZFRpbWVzcGFuLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY051bXBhZFRpbWVzcGFuLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtbnVtcGFkLXRpbWVzcGFuJyxdIH0sXSxcbiAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW52YWxpZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWluJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtYXgnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1udW1wYWQtdGltZXNwYW5DaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NOdW1wYWRUaW1lc3Bhbjtcbn0oTWJzY051bXBhZCkpO1xudmFyIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLW51bXBhZC10aW1lc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQ7XG59KE1ic2NOdW1wYWRUaW1lc3BhbikpO1xudmFyIGNvbXBzJDEgPSBbXG4gICAgTWJzY051bXBhZCxcbiAgICBNYnNjTnVtcGFkQmFzZSxcbiAgICBNYnNjTnVtcGFkQ29tcG9uZW50LFxuICAgIE1ic2NOdW1wYWREZWNpbWFsLFxuICAgIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50LFxuICAgIE1ic2NOdW1wYWREYXRlLFxuICAgIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LFxuICAgIE1ic2NOdW1wYWRUaW1lLFxuICAgIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50LFxuICAgIE1ic2NOdW1wYWRUaW1lc3BhbixcbiAgICBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnRcbl07XG52YXIgTWJzY051bXBhZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY051bXBhZE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY051bXBhZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjRnJhbWVCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXBzJDEsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IGNvbXBzJDFcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOdW1wYWRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY051bXBhZE1vZHVsZTtcbn0oKSk7XG5cbnZhciBPcHRpb25saXN0ID0gZnVuY3Rpb24gT3B0aW9ubGlzdChlbG0sIHNldHRpbmdzKSB7XG4gIHZhciB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgTmF2aWdhdGlvbkJhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcbiAgLyoqXG4gICAqIE9wdGlvbmxpc3QgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuXG4gIHRoYXQuX19faW5pdCA9IGZ1bmN0aW9uICgpIHt9OyAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgdGhhdC5pbml0KCk7XG59OyAvLyBEZWZhdWx0c1xuXG5PcHRpb25saXN0LnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnb3B0aW9ubGlzdCcsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9yZXNwb25zaXZlOiB0cnVlLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBOYXZpZ2F0aW9uQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgc2VsZWN0OiAnbXVsdGlwbGUnLFxuICAgIHZhcmlhbnQ6ICdhJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lJ1xuICB9KVxufTtcbmNsYXNzZXMuT3B0aW9ubGlzdCA9IE9wdGlvbmxpc3Q7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5vcHRpb25saXN0ID0gbW9iaXNjcm9sbC50aGVtZXMubmF2aWdhdGlvbjtcblxudmFyIE1ic2NPcHRpb25JdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY09wdGlvbkl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY09wdGlvbkl0ZW0obm90aWZ5SXRlbVNlcnZpY2UsIF9lbGVtKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBub3RpZnlJdGVtU2VydmljZSwgX2VsZW0pIHx8IHRoaXM7XG4gICAgfVxuICAgIE1ic2NPcHRpb25JdGVtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtb3B0aW9uLWl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pY29uXSc6ICdpY29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWRdJzogJ2lkJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjT3B0aW9uSXRlbS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBNYnNjT3B0aW9uSXRlbTtcbn0oTWJzY05hdkl0ZW1CYXNlKSk7XG52YXIgTWJzY09wdGlvbmxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjT3B0aW9ubGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjT3B0aW9ubGlzdChpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjT3B0aW9ubGlzdC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbkl0ZW1UYXAgPSB0aGlzLnRhcEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIG9uSXRlbVRhcFVzZXIgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm9uSXRlbVRhcDtcbiAgICAgICAgaWYgKG9uSXRlbVRhcFVzZXIpIHtcbiAgICAgICAgICAgIG9uSXRlbVRhcCA9IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRhcEhhbmRsZXIoZXZlbnQsIGluc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkl0ZW1UYXBVc2VyKGV2ZW50LCBpbnN0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHsgb25JdGVtVGFwOiBvbkl0ZW1UYXAgfSk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgT3B0aW9ubGlzdCh0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm5vdGlmeUluc3RhbmNlUmVhZHkodGhpcy5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYWRkUmVtb3ZlT2JzZXJ2ZXIgPSB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWJzY09wdGlvbmxpc3QucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkudW5zdWJzY3JpYmUodGhpcy5hZGRSZW1vdmVPYnNlcnZlcik7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1ic2NPcHRpb25saXN0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtb3B0aW9ubGlzdCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NOb3RpZnlJdGVtU2VydmljZV0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NPcHRpb25saXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NOb3RpZnlJdGVtU2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY09wdGlvbmxpc3QucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdzZWxlY3QnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2l0ZW1zJzogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTWJzY09wdGlvbkl0ZW0sXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY09wdGlvbmxpc3Q7XG59KE1ic2NOYXZpZ2F0aW9uQmFzZSkpO1xudmFyIE1ic2NPcHRpb25saXN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjT3B0aW9ubGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY09wdGlvbmxpc3RNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW01ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NPcHRpb25JdGVtLCBNYnNjT3B0aW9ubGlzdF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjT3B0aW9uSXRlbSwgTWJzY09wdGlvbmxpc3RdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjT3B0aW9ubGlzdE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjT3B0aW9ubGlzdE1vZHVsZTtcbn0oKSk7XG5cbi8vIC0tLVxuXG52YXIgUGFnZSA9IGZ1bmN0aW9uIFBhZ2UoZWwsIHNldHRpbmdzKSB7XG4gIHZhciBjc3NDbGFzcyA9ICcnLFxuICAgICAgJGVsbSA9ICQkMShlbCksXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgIHMgPSB0aGF0LnNldHRpbmdzOyAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuICBCYXNlLmNhbGwodGhpcywgZWwsIHNldHRpbmdzLCB0cnVlKTtcbiAgLyoqXG4gICAqIFBhZ2UgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHMuY29udGV4dCxcbiAgICAgICAgJGN0eCA9ICQkMShjdHgpLFxuICAgICAgICAkdG9wTWVudSA9ICRjdHguZmluZCgnLm1ic2MtbXMtdG9wIC5tYnNjLW1zJyksXG4gICAgICAgICRib3R0b21NZW51ID0gJGN0eC5maW5kKCcubWJzYy1tcy1ib3R0b20gLm1ic2MtbXMnKSxcbiAgICAgICAgY3NzID0ge307XG5cbiAgICBpZiAoY3R4ID09ICdib2R5Jykge1xuICAgICAgJCQxKCdib2R5LGh0bWwnKS5hZGRDbGFzcygnbWJzYy1wYWdlLWN0eCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkY3R4LmFkZENsYXNzKCdtYnNjLXBhZ2UtY3R4Jyk7XG4gICAgfVxuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICAkZWxtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoJHRvcE1lbnUubGVuZ3RoKSB7XG4gICAgICBjc3MucGFkZGluZ1RvcCA9ICR0b3BNZW51WzBdLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoJGJvdHRvbU1lbnUubGVuZ3RoKSB7XG4gICAgICBjc3MucGFkZGluZ0JvdHRvbSA9ICRib3R0b21NZW51WzBdLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBjc3NDbGFzcyA9ICdtYnNjLXBhZ2UgbWJzYy0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKTtcbiAgICAkZWxtLmFkZENsYXNzKGNzc0NsYXNzKS5yZW1vdmVDbGFzcygnbWJzYy1jbG9haycpLmNzcyhjc3MpO1xuICB9O1xuICAvKipcbiAgICogRGVzdHJveXMgdGhlIG1vYmlzY3JvbGwgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgdGhhdC5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgfTsgLy8gQ29uc3RydWN0b3JcblxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuICB0aGF0LmluaXQoKTtcbn07IC8vIEV4dGVuZCBkZWZhdWx0c1xuXG5QYWdlLnByb3RvdHlwZSA9IHtcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2NsYXNzOiAncGFnZScsXG4gIF9kZWZhdWx0czoge1xuICAgIGNvbnRleHQ6ICdib2R5J1xuICB9XG59O1xuY2xhc3Nlcy5QYWdlID0gUGFnZTtcbm1vYmlzY3JvbGwudGhlbWVzLnBhZ2UubW9iaXNjcm9sbCA9IHt9OyAvLyAtLS1cbi8vIFBhZ2UgZW5kXG4vLyBJbml0IG1ic2MtcGFnZSBlbGVtZW50cyBvbiBwYWdlIGxvYWQgb3Igd2hlbiBtYnNjLWVuaGFuY2UgZXZlbnQgaXMgdHJpZ2dlcmVzXG5cbmF1dG9Jbml0KCdbbWJzYy1wYWdlXScsIFBhZ2UpO1xuXG52YXIgTWJzY1BhZ2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjUGFnZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjUGFnZShob3N0RWxlbWVudCwgb3B0aW9uc1NlcnZpY2UsIHpvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIHpvbmUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnNTZXJ2aWNlID0gb3B0aW9uc1NlcnZpY2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY1BhZ2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9uc09iaiA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMub3B0aW9uc1NlcnZpY2Uub3B0aW9ucyA9IG9wdGlvbnNPYmo7XG4gICAgfTtcbiAgICBNYnNjUGFnZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBQYWdlKHRoaXMuaW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBNYnNjUGFnZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXBhZ2UnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgI2luaXRFbGVtZW50PjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjT3B0aW9uc1NlcnZpY2VdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjUGFnZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjUGFnZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NvbnRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2luaXRFbGVtJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2luaXRFbGVtZW50JywgeyBzdGF0aWM6IGZhbHNlIH0sXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1BhZ2U7XG59KE1ic2NCYXNlKSk7XG52YXIgTWJzY05vdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NOb3RlKGluaXRpYWxFbGVtKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbEVsZW0gPSBpbml0aWFsRWxlbTtcbiAgICAgICAgdGhpcy5jb2xvciA9ICdwcmltYXJ5JztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NOb3RlLnByb3RvdHlwZSwgXCJjbGFzc05hbWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21ic2Mtbm90ZSBtYnNjLW5vdGUtJyArIHRoaXMuY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NOb3RlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtbm90ZScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3NdJzogJ2NsYXNzTmFtZXMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J11cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NOb3RlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjTm90ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2NvbG9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY05vdGU7XG59KCkpO1xudmFyIE1ic2NBdmF0YXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NBdmF0YXIoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIE1ic2NBdmF0YXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1hdmF0YXInLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxpbWcgY2xhc3M9XCJtYnNjLWF2YXRhclwiIFtzcmNdPVwic3JjXCIgW2FsdF09XCJhbHRcIiBbZHJhZ2dhYmxlXT1cImRyYWdnYWJsZVwiIC8+J1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY0F2YXRhci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIE1ic2NBdmF0YXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdkcmFnZ2FibGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3NyYyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnYWx0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY0F2YXRhcjtcbn0oKSk7XG52YXIgTWJzY1BhZ2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NQYWdlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjUGFnZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWJzY0Jhc2VNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjUGFnZSwgTWJzY05vdGUsIE1ic2NBdmF0YXJdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY1BhZ2UsIE1ic2NOb3RlLCBNYnNjQXZhdGFyXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1BhZ2VNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY1BhZ2VNb2R1bGU7XG59KCkpO1xuXG52YXIgTWJzY1BvcHVwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1BvcHVwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NQb3B1cChpbml0aWFsRWxlbSwgb3B0aW9uU2VydmljZSwgem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLm9uQmVmb3JlQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQmVmb3JlU2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25DYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uRGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25GaWxsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbk1hcmt1cFJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblBvc2l0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vblNob3cgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uU2V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NQb3B1cC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldElubGluZUV2ZW50cygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgUG9wdXAodGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIE1ic2NQb3B1cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXBvcHVwJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjUG9wdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NQb3B1cC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ29wdGlvbnMnLF0gfSxdLFxuICAgICAgICAnYW5jaG9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdhbmltYXRlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdidXR0b25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdjbG9zZU9uT3ZlcmxheVRhcCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnY29udGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Rpc3BsYXknOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ZvY3VzT25DbG9zZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZm9jdXNUcmFwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdoZWFkZXJUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzaG93T25Gb2N1cyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnc2hvd09uVGFwJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0b3VjaFVpJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdva1RleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NhbmNlbFRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uQmVmb3JlQ2xvc2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25CZWZvcmVTaG93JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQ2FuY2VsJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQ2xvc2UnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25EZXN0cm95JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uRmlsbCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbk1hcmt1cFJlYWR5JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uUG9zaXRpb24nOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25TaG93JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uU2V0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjUG9wdXA7XG59KE1ic2NCYXNlKSk7XG52YXIgTWJzY1dpZGdldCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1dpZGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYnNjV2lkZ2V0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtd2lkZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjV2lkZ2V0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NXaWRnZXQ7XG59KE1ic2NQb3B1cCkpO1xudmFyIE1ic2NQb3B1cE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1BvcHVwTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjUG9wdXBNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW01ic2NCYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1BvcHVwLCBNYnNjV2lkZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01ic2NQb3B1cCwgTWJzY1dpZGdldF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NQb3B1cE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjUG9wdXBNb2R1bGU7XG59KCkpO1xuXG52YXIgUmFuZ2VQaWNrZXIgPSBTY3JvbGxlcjtcbnZhciBkZWZhdWx0cyRjID0ge1xuICBhdXRvQ29ycmVjdDogdHJ1ZSxcbiAgc2hvd1NlbGVjdG9yOiB0cnVlLFxuICBtaW5SYW5nZTogMSxcbiAgcmFuZ2VUYXA6IHRydWVcbn07XG5cbnByZXNldHMucmFuZ2UgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcml2YXRlIGZ1bmN0aW9uc1xuICAvLyAtLS1cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGQsIHJlZikge1xuICAgIGlmIChkKSB7XG4gICAgICBkLnNldEZ1bGxZZWFyKHJlZi5nZXRGdWxsWWVhcigpKTtcbiAgICAgIGQuc2V0TW9udGgocmVmLmdldE1vbnRoKCkpO1xuICAgICAgZC5zZXREYXRlKHJlZi5nZXREYXRlKCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWUoZGF0ZSwgaXNFbmQpIHtcbiAgICB2YXIgbyA9IGluc3QuX29yZGVyLFxuICAgICAgICBkID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAoby5oID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGQuc2V0SG91cnMoaXNFbmQgPyAyMyA6IDApO1xuICAgIH1cblxuICAgIGlmIChvLmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZC5zZXRNaW51dGVzKGlzRW5kID8gNTkgOiAwKTtcbiAgICB9XG5cbiAgICBpZiAoby5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGQuc2V0U2Vjb25kcyhpc0VuZCA/IDU5IDogMCk7XG4gICAgfVxuXG4gICAgZC5zZXRNaWxsaXNlY29uZHMoaXNFbmQgPyA5OTkgOiAwKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUlucHV0cyhjaGFuZ2UpIHtcbiAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGUgPSB0ZW1wU3RhcnREYXRlO1xuICAgIGluc3QuX2VuZERhdGUgPSBlbmREYXRlID0gdGVtcEVuZERhdGU7XG5cbiAgICBpZiAocy5zdGFydElucHV0KSB7XG4gICAgICAkJDEocy5zdGFydElucHV0KS52YWwoaW5zdC5zdGFydFZhbCk7XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgJCQxKHMuc3RhcnRJbnB1dCkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMuZW5kSW5wdXQpIHtcbiAgICAgICQkMShzLmVuZElucHV0KS52YWwoaW5zdC5lbmRWYWwpO1xuXG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICQkMShzLmVuZElucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGREYXlzKGQsIGRheXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpICsgZGF5cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1JhbmdlU2l6ZShjdXJyKSB7XG4gICAgaWYgKGhhc1RpbWUpIHtcbiAgICAgIC8vIENoZWNrIGV4YWN0IHRpbWVzIGluIG1pbGxpc2Vjb25kcyBmb3IgbWluIGFuZCBtYXggcmFuZ2VzXG4gICAgICBpZiAodGVtcEVuZERhdGUgLSB0ZW1wU3RhcnREYXRlID4gcy5tYXhSYW5nZSAtIDEpIHtcbiAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICB0ZW1wU3RhcnREYXRlID0gbmV3IERhdGUoTWF0aC5tYXgobWluRGF0ZSwgdGVtcEVuZERhdGUgLSBzLm1heFJhbmdlICsgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBFbmREYXRlID0gbmV3IERhdGUoTWF0aC5taW4obWF4RGF0ZSwgK3RlbXBTdGFydERhdGUgKyBzLm1heFJhbmdlIC0gMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZW1wRW5kRGF0ZSAtIHRlbXBTdGFydERhdGUgPCBzLm1pblJhbmdlIC0gMSkge1xuICAgICAgICBpZiAoY3Vycikge1xuICAgICAgICAgIHRlbXBTdGFydERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heChtaW5EYXRlLCB0ZW1wRW5kRGF0ZSAtIHMubWluUmFuZ2UgKyAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcEVuZERhdGUgPSBuZXcgRGF0ZShNYXRoLm1pbihtYXhEYXRlLCArdGVtcFN0YXJ0RGF0ZSArIHMubWluUmFuZ2UgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV29yayB3aXRoIGRheXMgb25seSwgbm90IG1pbGxpc2Vjb25kcy4gVGhpcyB3YXkgZGF5bGlnaHQgc2F2aW5nIHRpbWVzIGFyZSBoYW5kbGVkXG4gICAgICBpZiAoTWF0aC5jZWlsKCh0ZW1wRW5kRGF0ZSAtIHRlbXBTdGFydERhdGUpIC8gb25lRGF5KSA+IG1heERheXMpIHtcbiAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICB0ZW1wU3RhcnREYXRlID0gbm9ybWFsaXplVGltZShNYXRoLm1heChtaW5EYXRlLCBhZGREYXlzKHRlbXBFbmREYXRlLCAxIC0gbWF4RGF5cykpLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcEVuZERhdGUgPSBub3JtYWxpemVUaW1lKE1hdGgubWluKG1heERhdGUsIGFkZERheXModGVtcFN0YXJ0RGF0ZSwgbWF4RGF5cyAtIDEpKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguY2VpbCgodGVtcEVuZERhdGUgLSB0ZW1wU3RhcnREYXRlKSAvIG9uZURheSkgPCBtaW5EYXlzKSB7XG4gICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgdGVtcFN0YXJ0RGF0ZSA9IG5vcm1hbGl6ZVRpbWUoTWF0aC5tYXgobWluRGF0ZSwgYWRkRGF5cyh0ZW1wRW5kRGF0ZSwgMSAtIG1pbkRheXMpKSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBFbmREYXRlID0gbm9ybWFsaXplVGltZShNYXRoLm1pbihtYXhEYXRlLCBhZGREYXlzKHRlbXBTdGFydERhdGUsIG1pbkRheXMgLSAxKSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUoZGF0ZXMsIHVpKSB7XG4gICAgdmFyIHJldCA9IHRydWU7XG5cbiAgICBpZiAoZGF0ZXMgJiYgdGVtcFN0YXJ0RGF0ZSAmJiB0ZW1wRW5kRGF0ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGlzIDIgdGltZXMsIGJlY2F1c2UgdGhlXG4gICAgICAvLyBjb3JyZWN0ZWQgcmFuZ2UgaXMgY29uc3RyYWluZWQgYnkgbWluL21heCBkYXRlc1xuICAgICAgY2hlY2tSYW5nZVNpemUoY3Vycik7XG4gICAgICBjaGVja1JhbmdlU2l6ZSghY3Vycik7XG4gICAgfVxuXG4gICAgaWYgKCF0ZW1wU3RhcnREYXRlIHx8ICF0ZW1wRW5kRGF0ZSkge1xuICAgICAgcmV0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHVpKSB7XG4gICAgICBoaWdobGlnaHREYXlzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNEYXlOcigpIHtcbiAgICByZXR1cm4gdGVtcFN0YXJ0RGF0ZSAmJiB0ZW1wRW5kRGF0ZSA/IE1hdGgubWF4KDEsIE1hdGgucm91bmQoKG5ldyBEYXRlKHRlbXBFbmREYXRlKS5zZXRIb3VycygwLCAwLCAwLCAwKSAtIG5ldyBEYXRlKHRlbXBTdGFydERhdGUpLnNldEhvdXJzKDAsIDAsIDAsIDApKSAvIDg2NDAwMDAwKSArIDEpIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdFRhYih0YWIpIHtcbiAgICB0YWIuYWRkQ2xhc3Moc2VsZWN0ZWRDbGFzcykuYXR0cignYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZVRhYigpIHtcbiAgICBpZiAoc2hvd1NlbGVjdG9yICYmIGN0eCkge1xuICAgICAgJCQxKCcubWJzYy1yYW5nZS1idG4nLCBjdHgpLnJlbW92ZUNsYXNzKHNlbGVjdGVkQ2xhc3MpLnJlbW92ZUF0dHIoJ2FyaWEtY2hlY2tlZCcpO1xuICAgICAgc2VsZWN0VGFiKCQkMSgnLm1ic2MtcmFuZ2UtYnRuJywgY3R4KS5lcShjdXJyKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0RGF5cygpIHtcbiAgICB2YXIgc3RhcnQsXG4gICAgICAgIHN0YXJ0VCxcbiAgICAgICAgZW5kLFxuICAgICAgICBlbmRULFxuICAgICAgICBobCxcbiAgICAgICAgbnIgPSAwLFxuICAgICAgICBzdGFydENsYXNzID0gYXV0b0NoYW5nZSB8fCAhY3VyciA/ICcgbWJzYy1jYWwtZGF5LWhsIG1ic2MtY2FsLXNlbC1zdGFydCcgOiAnIG1ic2MtY2FsLXNlbC1zdGFydCcsXG4gICAgICAgIGVuZENsYXNzID0gYXV0b0NoYW5nZSB8fCBjdXJyID8gJyBtYnNjLWNhbC1kYXktaGwgbWJzYy1jYWwtc2VsLWVuZCcgOiAnIG1ic2MtY2FsLXNlbC1lbmQnO1xuICAgIGluc3Quc3RhcnRWYWwgPSB0ZW1wU3RhcnREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIHRlbXBTdGFydERhdGUsIHMpIDogJyc7XG4gICAgaW5zdC5lbmRWYWwgPSB0ZW1wRW5kRGF0ZSA/IGZvcm1hdERhdGUoZm9ybWF0LCB0ZW1wRW5kRGF0ZSwgcykgOiAnJztcblxuICAgIGlmIChjdHgpIHtcbiAgICAgICQkMSgnLm1ic2MtcmFuZ2UtYnRuLXYtc3RhcnQnLCBjdHgpLmh0bWwoaW5zdC5zdGFydFZhbCB8fCAnJm5ic3A7Jyk7XG4gICAgICAkJDEoJy5tYnNjLXJhbmdlLWJ0bi12LWVuZCcsIGN0eCkuaHRtbChpbnN0LmVuZFZhbCB8fCAnJm5ic3A7Jyk7IC8vIEhpZ2hsaWdodCBkYXRlc1xuXG4gICAgICBzdGFydCA9IHRlbXBTdGFydERhdGUgPyBuZXcgRGF0ZSh0ZW1wU3RhcnREYXRlKSA6IG51bGw7XG4gICAgICBlbmQgPSB0ZW1wRW5kRGF0ZSA/IG5ldyBEYXRlKHRlbXBFbmREYXRlKSA6IG51bGw7XG5cbiAgICAgIGlmICghc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmQgJiYgc3RhcnQpIHtcbiAgICAgICAgZW5kID0gbmV3IERhdGUoc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBobCA9IGN1cnIgPyBlbmQgOiBzdGFydDtcbiAgICAgICQkMSgnLm1ic2MtY2FsLWRheS1waWNrZXIgLm1ic2MtY2FsLWRheS1obCcsIGN0eCkucmVtb3ZlQ2xhc3MoaGlnaGxpZ2h0Q2xhc3MpO1xuICAgICAgJCQxKCcubWJzYy1jYWwtZGF5LXBpY2tlciAubWJzYy1zZWxlY3RlZCcsIGN0eCkucmVtb3ZlQ2xhc3MoJ21ic2MtY2FsLXNlbC1zdGFydCBtYnNjLWNhbC1zZWwtZW5kICcgKyBzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG5cbiAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgc3RhcnRUID0gc3RhcnQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIGVuZFQgPSBlbmQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgd2hpbGUgKGVuZCA+PSBzdGFydCAmJiBuciA8IDEyNikge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgaGwuZ2V0RnVsbFllYXIoKSArICctJyArIChobC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBobC5nZXREYXRlKCkgKyAnXCJdJywgY3R4KS5hZGRDbGFzcyhzZWxlY3RlZENsYXNzICsgJyAnICsgKGhsLmdldFRpbWUoKSA9PT0gc3RhcnRUID8gc3RhcnRDbGFzcyA6ICcnKSArIChobC5nZXRUaW1lKCkgPT09IGVuZFQgPyBlbmRDbGFzcyA6ICcnKSkuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgICAgaGwuc2V0RGF0ZShobC5nZXREYXRlKCkgKyAoY3VyciA/IC0xIDogMSkpO1xuICAgICAgICAgIGhsLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIG5yKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUaW1lSW5mbyhkLCBlbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogZCA/IGQuZ2V0SG91cnMoKSA6IGVuZCA/IDIzIDogMCxcbiAgICAgIGk6IGQgPyBkLmdldE1pbnV0ZXMoKSA6IGVuZCA/IDU5IDogMCxcbiAgICAgIHM6IGQgPyBkLmdldFNlY29uZHMoKSA6IGVuZCA/IDU5IDogMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZURhdGVzKCkge1xuICAgIGlmICh0ZW1wU3RhcnREYXRlKSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgIGluc3Quc2V0RGF0ZSh0ZW1wU3RhcnREYXRlLCBmYWxzZSwgMCwgdHJ1ZSk7XG4gICAgICB0ZW1wU3RhcnREYXRlID0gaW5zdC5nZXREYXRlKHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0ZW1wRW5kRGF0ZSkge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgICBpbnN0LnNldERhdGUodGVtcEVuZERhdGUsIGZhbHNlLCAwLCB0cnVlKTtcbiAgICAgIHRlbXBFbmREYXRlID0gaW5zdC5nZXREYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQnRuQ2xpY2soZXYpIHtcbiAgICBpZiAodGVzdFRvdWNoKGV2LCB0aGlzKSkge1xuICAgICAgaW5zdC5fc2hvd0RheVBpY2tlcigpO1xuXG4gICAgICBpbnN0LnNldEFjdGl2ZURhdGUoJCQxKHRoaXMpLmF0dHIoJ2RhdGEtc2VsZWN0JykpO1xuICAgIH1cbiAgfSAvLyAtLS1cblxuXG4gIHZhciBiYXNlLFxuICAgICAgY3R4LFxuICAgICAgZGF5Q2hhbmdlLFxuICAgICAgZm9ybWF0LFxuICAgICAgaGFzVGltZSxcbiAgICAgIGluaXQsXG4gICAgICBtYXhEYXRlLFxuICAgICAgbWluRGF0ZSxcbiAgICAgIHNldCxcbiAgICAgIHRlbXBTdGFydERhdGUsXG4gICAgICB0ZW1wU3RhcnRUaW1lLFxuICAgICAgdGVtcEVuZERhdGUsXG4gICAgICB0ZW1wRW5kVGltZSxcbiAgICAgIHRpbWVPbmx5LFxuICAgICAgc2hvd1NlbGVjdG9yLFxuICAgICAgc3RhcnREYXRlID0gaW5zdC5fc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZSA9IGluc3QuX2VuZERhdGUsXG4gICAgICBjdXJyID0gMCxcbiAgICAgIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJGMsIG9yaWcpLFxuICAgICAgc3RhcnRBbmNob3IgPSBzLmFuY2hvcixcbiAgICAgIGF1dG9DaGFuZ2UgPSBzLnJhbmdlVGFwLFxuICAgICAgb25lRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgIG1pbkRheXMgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwocy5taW5SYW5nZSAvIG9uZURheSkpLFxuICAgICAgbWF4RGF5cyA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChzLm1heFJhbmdlIC8gb25lRGF5KSksXG4gICAgICBkaXNhYmxlZENsYXNzID0gJ21ic2MtZGlzYWJsZWQgJyArIChzLmRpc2FibGVkQ2xhc3MgfHwgJycpLFxuICAgICAgc2VsZWN0ZWRDbGFzcyA9ICdtYnNjLXNlbGVjdGVkICcgKyAocy5zZWxlY3RlZENsYXNzIHx8ICcnKSxcbiAgICAgIGhpZ2hsaWdodENsYXNzID0gJ21ic2MtY2FsLWRheS1obCcsXG4gICAgICBkZWYgPSBzLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCA/IFtdIDogcy5kZWZhdWx0VmFsdWUgfHwgW25ldyBEYXRlKG5vdy5zZXRIb3VycygwLCAwLCAwLCAwKSksIG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKSArIDYsIDIzLCA1OSwgNTksIDk5OSldO1xuXG4gIGlmIChhdXRvQ2hhbmdlKSB7XG4gICAgcy50YWJzID0gdHJ1ZTtcbiAgfVxuXG4gIGJhc2UgPSBDYWxlbmRhckJhc2UuY2FsbCh0aGlzLCBpbnN0KTtcbiAgZm9ybWF0ID0gaW5zdC5fZm9ybWF0O1xuICBoYXNUaW1lID0gL3RpbWUvaS50ZXN0KHMuY29udHJvbHMuam9pbignLCcpKTtcbiAgdGltZU9ubHkgPSBzLmNvbnRyb2xzLmpvaW4oJycpID09PSAndGltZSc7XG4gIHNob3dTZWxlY3RvciA9IHMuc2hvd1NlbGVjdG9yO1xuICBtYXhEYXRlID0gcy5tYXggPyBub3JtYWxpemVUaW1lKG1ha2VEYXRlKHMubWF4LCBmb3JtYXQsIHMpLCB0cnVlKSA6IEluZmluaXR5O1xuICBtaW5EYXRlID0gcy5taW4gPyBub3JtYWxpemVUaW1lKG1ha2VEYXRlKHMubWluLCBmb3JtYXQsIHMpLCBmYWxzZSkgOiAtSW5maW5pdHk7XG4gIGRlZlswXSA9IG1ha2VEYXRlKGRlZlswXSwgZm9ybWF0LCBzLCBzLmlzb1BhcnRzKTtcbiAgZGVmWzFdID0gbWFrZURhdGUoZGVmWzFdLCBmb3JtYXQsIHMsIHMuaXNvUGFydHMpO1xuXG4gIGlmIChzLnN0YXJ0SW5wdXQpIHtcbiAgICBpbnN0LmF0dGFjaFNob3coJCQxKHMuc3RhcnRJbnB1dCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnIgPSAwO1xuICAgICAgcy5hbmNob3IgPSBzdGFydEFuY2hvciB8fCAkJDEocy5zdGFydElucHV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzLmVuZElucHV0KSB7XG4gICAgaW5zdC5hdHRhY2hTaG93KCQkMShzLmVuZElucHV0KSwgZnVuY3Rpb24gKCkge1xuICAgICAgY3VyciA9IDE7XG4gICAgICBzLmFuY2hvciA9IHN0YXJ0QW5jaG9yIHx8ICQkMShzLmVuZElucHV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGluc3QuX2dldERheVByb3BzID0gZnVuY3Rpb24gKGQsIHByb3BzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGVtcFN0YXJ0RGF0ZSA/IG5ldyBEYXRlKHRlbXBTdGFydERhdGUuZ2V0RnVsbFllYXIoKSwgdGVtcFN0YXJ0RGF0ZS5nZXRNb250aCgpLCB0ZW1wU3RhcnREYXRlLmdldERhdGUoKSkgOiBudWxsLFxuICAgICAgICBlbmQgPSB0ZW1wRW5kRGF0ZSA/IG5ldyBEYXRlKHRlbXBFbmREYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBFbmREYXRlLmdldE1vbnRoKCksIHRlbXBFbmREYXRlLmdldERhdGUoKSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDogc3RhcnQgJiYgZW5kICYmIGQgPj0gc3RhcnQgJiYgZCA8PSB0ZW1wRW5kRGF0ZSxcbiAgICAgIGNzc0NsYXNzOiBwcm9wcy5jc3NDbGFzcyArICcgJyArICgoYXV0b0NoYW5nZSB8fCAhY3VycikgJiYgc3RhcnQgJiYgc3RhcnQuZ2V0VGltZSgpID09PSBkLmdldFRpbWUoKSB8fCAoYXV0b0NoYW5nZSB8fCBjdXJyKSAmJiBlbmQgJiYgZW5kLmdldFRpbWUoKSA9PT0gZC5nZXRUaW1lKCkgPyBoaWdobGlnaHRDbGFzcyA6ICcnKSArIChzdGFydCAmJiBzdGFydC5nZXRUaW1lKCkgPT09IGQuZ2V0VGltZSgpID8gJyBtYnNjLWNhbC1zZWwtc3RhcnQnIDogJycpICsgKGVuZCAmJiBlbmQuZ2V0VGltZSgpID09PSBkLmdldFRpbWUoKSA/ICcgbWJzYy1jYWwtc2VsLWVuZCcgOiAnJylcbiAgICB9O1xuICB9OyAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsdWVzLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICB2YXIgdiA9IHZhbHVlcyB8fCBbXSxcbiAgICAgICAgZCA9IHZhbHVlcztcbiAgICB0ZW1wU3RhcnREYXRlID0gbWFrZURhdGUodlswXSwgZm9ybWF0LCBzLCBzLmlzb1BhcnRzKTtcbiAgICB0ZW1wRW5kRGF0ZSA9IG1ha2VEYXRlKHZbMV0sIGZvcm1hdCwgcywgcy5pc29QYXJ0cyk7XG4gICAgdmFsaWRhdGVEYXRlcygpO1xuICAgIGluc3Quc3RhcnRWYWwgPSB0ZW1wU3RhcnREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIHRlbXBTdGFydERhdGUsIHMpIDogJyc7XG4gICAgaW5zdC5lbmRWYWwgPSB0ZW1wRW5kRGF0ZSA/IGZvcm1hdERhdGUoZm9ybWF0LCB0ZW1wRW5kRGF0ZSwgcykgOiAnJztcbiAgICBkID0gYmFzZS5wYXJzZVZhbHVlKGN1cnIgPyB0ZW1wRW5kRGF0ZSA6IHRlbXBTdGFydERhdGUsIGluc3QpO1xuXG4gICAgaWYgKCF0ZW1wKSB7XG4gICAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGUgPSB0ZW1wU3RhcnREYXRlO1xuICAgICAgaW5zdC5fZW5kRGF0ZSA9IGVuZERhdGUgPSB0ZW1wRW5kRGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgPSB0cnVlO1xuXG4gICAgaW5zdC5fc2V0VmFsKGQsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSk7XG4gIH07XG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0ZW1wID8gW3JldHVybkRhdGUodGVtcFN0YXJ0RGF0ZSwgcywgZm9ybWF0KSwgcmV0dXJuRGF0ZSh0ZW1wRW5kRGF0ZSwgcywgZm9ybWF0KV0gOiBpbnN0Ll9oYXNWYWx1ZSA/IFtyZXR1cm5EYXRlKHN0YXJ0RGF0ZSwgcywgZm9ybWF0KSwgcmV0dXJuRGF0ZShlbmREYXRlLCBzLCBmb3JtYXQpXSA6IG51bGw7XG4gIH07XG5cbiAgaW5zdC5zZXRBY3RpdmVEYXRlID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgIHZhciBobDsgLy9pZiAoIWF1dG9DaGFuZ2UpIHtcblxuICAgIGN1cnIgPSBhY3RpdmUgPT0gJ3N0YXJ0JyA/IDAgOiAxOyAvL31cblxuICAgIGhsID0gYWN0aXZlID09ICdzdGFydCcgPyB0ZW1wU3RhcnREYXRlIDogdGVtcEVuZERhdGU7XG5cbiAgICBpZiAoaW5zdC5pc1Zpc2libGUoKSkge1xuICAgICAgLy9pZiAoIWF1dG9DaGFuZ2UpIHtcbiAgICAgIHNldEFjdGl2ZVRhYigpO1xuXG4gICAgICBpZiAoIWF1dG9DaGFuZ2UpIHtcbiAgICAgICAgJCQxKCcubWJzYy1jYWwtdGFibGUgLm1ic2MtY2FsLWRheS1obCcsIGN0eCkucmVtb3ZlQ2xhc3MoaGlnaGxpZ2h0Q2xhc3MpO1xuXG4gICAgICAgIGlmIChobCkge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgaGwuZ2V0RnVsbFllYXIoKSArICctJyArIChobC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBobC5nZXREYXRlKCkgKyAnXCJdJywgY3R4KS5hZGRDbGFzcyhoaWdobGlnaHRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhsKSB7XG4gICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICBpbnN0LnNldERhdGUoaGwsIGZhbHNlLCAxMDAwLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5zdC5nZXRWYWx1ZSA9IGluc3QuZ2V0VmFsOyAvLyAtLS1cbiAgLy8gLS0tXG5cbiAgcmV0dXJuIGV4dGVuZCQxKHt9LCBiYXNlLCB7XG4gICAgaGlnaGxpZ2h0OiBmYWxzZSxcbiAgICBvdXRlck1vbnRoQ2hhbmdlOiBmYWxzZSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGFydFZhbCArIChzLmVuZElucHV0ID8gJycgOiBpbnN0LmVuZFZhbCA/ICcgLSAnICsgaW5zdC5lbmRWYWwgOiAnJyk7XG4gICAgfSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHYgPyB2LnNwbGl0KCcgLSAnKSA6IFtdLFxuICAgICAgICAgIHN0YXJ0VmFsID0gcy5zdGFydElucHV0ID8gJCQxKHMuc3RhcnRJbnB1dCkudmFsKCkgOiBwYXJ0c1swXSxcbiAgICAgICAgICBlbmRWYWwgPSBzLmVuZElucHV0ID8gJCQxKHMuZW5kSW5wdXQpLnZhbCgpIDogcGFydHNbMV07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZlsxXTsgLy8gdXNlZCBieSBwYXJzZURhdGVcblxuICAgICAgZW5kRGF0ZSA9IGVuZFZhbCA/IHBhcnNlRGF0ZShmb3JtYXQsIGVuZFZhbCwgcykgOiBkZWZbMV07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZlswXTsgLy8gdXNlZCBieSBwYXJzZURhdGVcblxuICAgICAgc3RhcnREYXRlID0gc3RhcnRWYWwgPyBwYXJzZURhdGUoZm9ybWF0LCBzdGFydFZhbCwgcykgOiBkZWZbMl07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZltjdXJyXTtcbiAgICAgIGluc3Quc3RhcnRWYWwgPSBzdGFydERhdGUgPyBmb3JtYXREYXRlKGZvcm1hdCwgc3RhcnREYXRlLCBzKSA6ICcnO1xuICAgICAgaW5zdC5lbmRWYWwgPSBlbmREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIGVuZERhdGUsIHMpIDogJyc7XG4gICAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICBpbnN0Ll9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIHJldHVybiBiYXNlLnBhcnNlVmFsdWUoY3VyciA/IGVuZERhdGUgOiBzdGFydERhdGUsIGluc3QpO1xuICAgIH0sXG4gICAgb25GaWxsOiBmdW5jdGlvbiBvbkZpbGwoZXYpIHtcbiAgICAgIHVwZGF0ZUlucHV0cyhldi5jaGFuZ2UpO1xuICAgIH0sXG4gICAgb25CZWZvcmVDbG9zZTogZnVuY3Rpb24gb25CZWZvcmVDbG9zZShldikge1xuICAgICAgLy8gRG9uJ3QgYWxsb3cgaW52YWxpZCBzZWxlY3Rpb25cbiAgICAgIGlmIChldi5idXR0b24gPT09ICdzZXQnICYmICF2YWxpZGF0ZSh0cnVlLCB0cnVlKSkge1xuICAgICAgICBpbnN0LnNldEFjdGl2ZURhdGUoY3VyciA/ICdzdGFydCcgOiAnZW5kJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICAgYmFzZS5vbkhpZGUuY2FsbChpbnN0KTtcbiAgICAgIGN1cnIgPSAwO1xuICAgICAgY3R4ID0gbnVsbDtcbiAgICAgIHMuYW5jaG9yID0gc3RhcnRBbmNob3I7XG4gICAgfSxcbiAgICBvbkNsZWFyOiBmdW5jdGlvbiBvbkNsZWFyKCkge1xuICAgICAgaWYgKGF1dG9DaGFuZ2UpIHtcbiAgICAgICAgY3VyciA9IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJlZm9yZVNob3c6IGZ1bmN0aW9uIG9uQmVmb3JlU2hvdygpIHtcbiAgICAgIHRlbXBTdGFydERhdGUgPSBzdGFydERhdGUgfHwgZGVmWzBdO1xuICAgICAgdGVtcEVuZERhdGUgPSBlbmREYXRlIHx8IGRlZlsxXTtcbiAgICAgIHRlbXBTdGFydFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wU3RhcnREYXRlLCAwKTtcbiAgICAgIHRlbXBFbmRUaW1lID0gc2V0VGltZUluZm8odGVtcEVuZERhdGUsIDEpO1xuXG4gICAgICBpZiAocy5jb3VudGVyKSB7XG4gICAgICAgIHMuaGVhZGVyVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbnIgPSBjYWxjRGF5TnIoKTtcbiAgICAgICAgICByZXR1cm4gKG5yID4gMSA/IHMuc2VsZWN0ZWRQbHVyYWxUZXh0IHx8IHMuc2VsZWN0ZWRUZXh0IDogcy5zZWxlY3RlZFRleHQpLnJlcGxhY2UoL3tjb3VudH0vLCBucik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNldCA9IHRydWU7XG4gICAgfSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgICB2YXIgaHRtbDsgLy8gVmFsaWRhdGUgc3RhcnQgZW5kIGVuZCBkYXRlc1xuXG4gICAgICB2YWxpZGF0ZURhdGVzKCk7IC8vIFNldCB0aGUgY3VycmVudCBkYXRlIChzdGFydCBvciBlbmQpXG5cbiAgICAgIGlmIChjdXJyICYmIHRlbXBFbmREYXRlIHx8ICFjdXJyICYmIHRlbXBTdGFydERhdGUpIHtcbiAgICAgICAgaW5pdCA9IHRydWU7XG4gICAgICAgIGluc3Quc2V0RGF0ZShjdXJyID8gdGVtcEVuZERhdGUgOiB0ZW1wU3RhcnREYXRlLCBmYWxzZSwgMCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hsaWdodERheXMoKTsgLy8gQ2FsbCBjYWxiYXNlXG5cbiAgICAgIGJhc2Uub25NYXJrdXBSZWFkeS5jYWxsKHRoaXMsIGV2KTtcbiAgICAgIGN0eCA9ICQkMShldi50YXJnZXQpO1xuICAgICAgY3R4LmFkZENsYXNzKCdtYnNjLXJhbmdlJyk7XG5cbiAgICAgIGlmIChzaG93U2VsZWN0b3IpIHtcbiAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tdFwiIHJvbGU9XCJyYWRpb2dyb3VwXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tYyBtYnNjLXJhbmdlLWJ0bi1zdGFydFwiPjxkaXYgcm9sZT1cInJhZGlvXCIgZGF0YS1zZWxlY3Q9XCJzdGFydFwiIGNsYXNzPVwibWJzYy1mci1idG4tZSBtYnNjLWZyLWJ0bi1uaGwgbWJzYy1yYW5nZS1idG5cIj4nICsgcy5mcm9tVGV4dCArICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tdiBtYnNjLXJhbmdlLWJ0bi12LXN0YXJ0XCI+JyArIChpbnN0LnN0YXJ0VmFsIHx8ICcmbmJzcDsnKSArICc8L2Rpdj48L2Rpdj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLXJhbmdlLWJ0bi1jIG1ic2MtcmFuZ2UtYnRuLWVuZFwiPjxkaXYgcm9sZT1cInJhZGlvXCIgZGF0YS1zZWxlY3Q9XCJlbmRcIiBjbGFzcz1cIm1ic2MtZnItYnRuLWUgbWJzYy1mci1idG4tbmhsIG1ic2MtcmFuZ2UtYnRuXCI+JyArIHMudG9UZXh0ICsgJzxkaXYgY2xhc3M9XCJtYnNjLXJhbmdlLWJ0bi12IG1ic2MtcmFuZ2UtYnRuLXYtZW5kXCI+JyArIChpbnN0LmVuZFZhbCB8fCAnJm5ic3A7JykgKyAnPC9kaXY+PC9kaXY+PC9kaXY+JyArICc8L2Rpdj4nO1xuXG4gICAgICAgIGlmIChzLmhlYWRlclRleHQpIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWhkcicsIGN0eCkuYWZ0ZXIoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5wcmVwZW5kKGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QWN0aXZlVGFiKCk7XG4gICAgICB9XG5cbiAgICAgICQkMSgnLm1ic2MtcmFuZ2UtYnRuJywgY3R4KS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICBsaXN0ZW4oZWwsICd0b3VjaHN0YXJ0Jywgb25CdG5DbGljaywge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3RlbihlbCwgJ2NsaWNrJywgb25CdG5DbGljayk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uRGF5Q2hhbmdlOiBmdW5jdGlvbiBvbkRheUNoYW5nZShkYXkpIHtcbiAgICAgIGRheS5hY3RpdmUgPSBjdXJyID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgZGF5Q2hhbmdlID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uU2V0RGF0ZTogZnVuY3Rpb24gb25TZXREYXRlKGRheSkge1xuICAgICAgdmFyIGQ7XG5cbiAgICAgIGlmICghaW5pdCkge1xuICAgICAgICBkID0gbm9ybWFsaXplVGltZShkYXkuZGF0ZSwgY3Vycik7XG5cbiAgICAgICAgaWYgKCFzZXQgfHwgZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgaWYgKGF1dG9DaGFuZ2UgJiYgZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY3VyciA9PSAxICYmIGQgPCB0ZW1wU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgIGN1cnIgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Vycikge1xuICAgICAgICAgICAgICBkLnNldEhvdXJzKHRlbXBFbmRUaW1lLmgsIHRlbXBFbmRUaW1lLmksIHRlbXBFbmRUaW1lLnMsIDk5OSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkLnNldEhvdXJzKHRlbXBTdGFydFRpbWUuaCwgdGVtcFN0YXJ0VGltZS5pLCB0ZW1wU3RhcnRUaW1lLnMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgICB0ZW1wRW5kRGF0ZSA9IG5ldyBEYXRlKGQpO1xuICAgICAgICAgICAgdGVtcEVuZFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wRW5kRGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBTdGFydERhdGUgPSBuZXcgRGF0ZShkKTtcbiAgICAgICAgICAgIHRlbXBTdGFydFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wU3RhcnREYXRlKTtcbiAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSB0aW1lcyBhcmUgb24gdGhlIHNhbWUgZGF5IGZvciBjb21wYXJpc29uXG5cblxuICAgICAgICAgIGlmICh0aW1lT25seSAmJiBzLmF1dG9Db3JyZWN0KSB7XG4gICAgICAgICAgICBub3JtYWxpemUodGVtcFN0YXJ0RGF0ZSwgZCk7XG4gICAgICAgICAgICBub3JtYWxpemUodGVtcEVuZERhdGUsIGQpO1xuICAgICAgICAgIH0gLy8gU2V0IGVuZCBkYXRlIG9uIHN0YXJ0IHNlbGVjdGlvbiBpZiByYW5nZVRhcCBpcyBlbmFibGVkXG5cblxuICAgICAgICAgIGlmIChhdXRvQ2hhbmdlICYmIGRheUNoYW5nZSAmJiAhY3Vycikge1xuICAgICAgICAgICAgLy90ZW1wRW5kRGF0ZSA9IG5ldyBEYXRlKGQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KSk7XG4gICAgICAgICAgICB0ZW1wRW5kRGF0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lT25seSAmJiAhcy5hdXRvQ29ycmVjdCAmJiB0ZW1wRW5kRGF0ZSA8IHRlbXBTdGFydERhdGUpIHtcbiAgICAgICAgLy8gU2V0IGVuZCB0aW1lIHRvIG5leHQgZGF5XG4gICAgICAgIHRlbXBFbmREYXRlID0gbmV3IERhdGUodGVtcEVuZERhdGUuc2V0RGF0ZSh0ZW1wRW5kRGF0ZS5nZXREYXRlKCkgKyAxKSk7XG4gICAgICB9IC8vIFZhbGlkYXRlIG1pbi9tYXggcmFuZ2VzXG5cblxuICAgICAgaW5zdC5faXNWYWxpZCA9IHZhbGlkYXRlKHNldCB8fCBkYXlDaGFuZ2UgfHwgcy5hdXRvQ29ycmVjdCwgIWluaXQpO1xuICAgICAgZGF5LmFjdGl2ZSA9IGN1cnIgPyAnZW5kJyA6ICdzdGFydCc7IC8vIFRvZ2dsZSBzdGFydC9lbmQgaWYgcmFuZ2VUYXAgaXMgZW5hYmxlZFxuXG4gICAgICBpZiAoIWluaXQgJiYgYXV0b0NoYW5nZSkge1xuICAgICAgICBpZiAoZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgY3VyciA9IGN1cnIgPyAwIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEFjdGl2ZVRhYigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdC5pc1Zpc2libGUoKSkge1xuICAgICAgICAvLyBEaXNhYmxlIHNldCBidXR0b25cbiAgICAgICAgaWYgKGluc3QuX2lzVmFsaWQpIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWJ0bi1zIC5tYnNjLWZyLWJ0bicsIGluc3QuX21hcmt1cCkucmVtb3ZlQ2xhc3MoZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1mci1idG4tcyAubWJzYy1mci1idG4nLCBpbnN0Ll9tYXJrdXApLmFkZENsYXNzKGRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRheUNoYW5nZSA9IGZhbHNlO1xuICAgICAgc2V0ID0gZmFsc2U7XG4gICAgICBpbml0ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblRhYkNoYW5nZTogZnVuY3Rpb24gb25UYWJDaGFuZ2UoZXYpIHtcbiAgICAgIGlmIChldi50YWIgIT0gJ2NhbGVuZGFyJykge1xuICAgICAgICBpbnN0LnNldERhdGUoY3VyciA/IHRlbXBFbmREYXRlIDogdGVtcFN0YXJ0RGF0ZSwgZmFsc2UsIDEwMDAsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZSh0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFJBTkdFX1NVQl9URU1QTEFURSA9IFwiPG1ic2MtaW5wdXRcXG4gICAgW2NvbnRyb2xOZ109XFxcImZhbHNlXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt0aGVtZV09XFxcInRoZW1lXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiXFxuICAgIFtlcnJvcl09XFxcImVycm9yXFxcIiBbZXJyb3JNZXNzYWdlXT1cXFwiZXJyb3JNZXNzYWdlXFxcIiBcXG4gICAgW2ljb25dPVxcXCJpbnB1dEljb25cXFwiIFtpY29uLWFsaWduXT1cXFwiaWNvbkFsaWduXFxcIj5cXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbjwvbWJzYy1pbnB1dD5cIjtcbnZhciBNYnNjUmFuZ2VTdGFydENvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1JhbmdlU3RhcnRDb21wb25lbnQoaG9zdCwgcGFyZW50LCB6b25lLCBjb250cm9sKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgICB0aGlzLnRoZW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMub2xkQWNjZXNzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsU2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGVja0FjY2Vzc29yKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGkgPSAkJDEodGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQpLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICByZXR1cm4gaVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrQWNjZXNzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wudmFsdWVBY2Nlc3NvciAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkQWNjZXNzb3IgPSB0aGlzLmNvbnRyb2wudmFsdWVBY2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgJCQxKHRoaXMuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gX3RoaXMucGFyZW50Lmluc3RhbmNlLmdldFZhbCgpLCB2YWx1ZSA9IGFyciA/IGFycltfdGhpcy5yYW5nZUluZGV4XSA6IHVuZGVmaW5lZCwgY3VycmVudCA9IHVuZGVmaW5lZCwgdmFsdWVUZXh0ID0gX3RoaXMucGFyZW50Lmluc3RhbmNlW190aGlzLnJhbmdlSW5kZXggPT09IDAgPyAnc3RhcnRWYWwnIDogJ2VuZFZhbCddO1xuICAgICAgICAgICAgICAgIGlmIChhcnIgJiYgdmFsdWUgJiYgX3RoaXMuZWxlbWVudC52YWx1ZSAhPT0gdmFsdWVUZXh0ICYmIF90aGlzLnBhcmVudC5lbmFibGVNYW51YWxFZGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkoMiksIG90aGVySW5kZXggPSBfdGhpcy5yYW5nZUluZGV4ID09PSAxID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycltfdGhpcy5yYW5nZUluZGV4XSA9IF90aGlzLmVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycltvdGhlckluZGV4XSA9IGFycltvdGhlckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Lmluc3RhbmNlLnNldFZhbChuZXdBcnIsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2wgJiYgX3RoaXMuY29udHJvbC52YWx1ZSAmJiBfdGhpcy5jb250cm9sLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBfdGhpcy5jb250cm9sLnZhbHVlW190aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmNvbnRyb2wgJiYgX3RoaXMuY29udHJvbC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IF90aGlzLmNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEYXRlRXF1YWwoY3VycmVudCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBY2Nlc3NvcigpO1xuICAgIH07XG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaCA9IGZuO1xuICAgIH07XG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgaWYgKHRoaXMub2xkQWNjZXNzb3IgJiYgdGhpcy5vbGRBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLm9sZEFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgYXJyXzEgPSB0aGlzLnBhcmVudC5pbnN0YW5jZS5nZXRWYWwoKSwgdmFsID0gKGFycl8xICYmIGFycl8xLmxlbmd0aCkgPyBhcnJfMVt0aGlzLnJhbmdlSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFpc0RhdGVFcXVhbCh2LCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJfMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFycl8xID0gYXJyXzEgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGFycl8xW3RoaXMucmFuZ2VJbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbnN0YW5jZS5zZXRWYWwoYXJyXzEsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Lmluc3RhbmNlLnNldFZhbChhcnJfMSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbFNldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcmFuZ2Utc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogUkFOR0VfU1VCX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NSYW5nZUNvbXBvbmVudCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNYnNjUmFuZ2VDb21wb25lbnQ7IH0pLF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGlzYWJsZWQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1JhbmdlU3RhcnRDb21wb25lbnQ7XG59KCkpO1xudmFyIE1ic2NSYW5nZUVuZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NSYW5nZUVuZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjUmFuZ2VFbmRDb21wb25lbnQoZWwsIHBhcmVudCwgem9uZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbCwgcGFyZW50LCB6b25lLCBjb250cm9sKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yYW5nZUluZGV4ID0gMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjUmFuZ2VFbmRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1yYW5nZS1lbmQnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogUkFOR0VfU1VCX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1JhbmdlRW5kQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY1JhbmdlQ29tcG9uZW50LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtmb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ic2NSYW5nZUNvbXBvbmVudDsgfSksXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBNYnNjUmFuZ2VFbmRDb21wb25lbnQ7XG59KE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50KSk7XG52YXIgTWJzY1JhbmdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1JhbmdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NSYW5nZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5vblNldERhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQ2VsbEhvdmVySW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm9uQ2VsbEhvdmVyT3V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkRheUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYW5nZS5wcm90b3R5cGUsIFwiZW5kSW5wdXRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhciBoYXNJbnB1dCA9ICQkMSh2KS5maW5kKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNJbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGhhc0lucHV0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2VuZElucHV0ID0gZWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYW5nZS5wcm90b3R5cGUsIFwic3RhcnRJbnB1dFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0lucHV0ID0gJCQxKHYpLmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gaGFzSW5wdXRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRJbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFuZ2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNYnNjUmFuZ2UucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsc0FycmF5KHYsIHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJvcHRpb25FeHRlbnNpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4dGVybmFsT25DbG9zZSA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMub25DbG9zZTtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbE9uRmlsbCA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMub25GaWxsO1xuICAgICAgICAgICAgdmFyIG9uQ2xvc2VFbWl0dGVyID0gdGhpcy5vbkNsb3NlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvbkZpbGw6IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl93cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub2xkQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbGRBY2Nlc3Nvci53cml0ZVZhbHVlKGV2ZW50LnZhbHVlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsT25GaWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbE9uRmlsbChldmVudCwgaW5zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblRvdWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbE9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsT25DbG9zZShldmVudCwgaW5zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQ2xvc2VFbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5pbnN0ID0gaW5zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2VFbWl0dGVyLmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1JhbmdlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7XG4gICAgICAgICAgICBwcmVzZXQ6ICdyYW5nZScsXG4gICAgICAgICAgICBza2lwU2hvdzogdGhpcy5fd3JhcHBlclxuICAgICAgICB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwge1xuICAgICAgICAgICAgZW5kSW5wdXQ6IHRoaXMuX3dyYXBwZXIgPyB0aGlzLmVuZC5lbGVtZW50IDogdGhpcy5fZW5kSW5wdXQsXG4gICAgICAgICAgICBzdGFydElucHV0OiB0aGlzLl93cmFwcGVyID8gdGhpcy5zdGFydC5lbGVtZW50IDogdGhpcy5fc3RhcnRJbnB1dFxuICAgICAgICB9LCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJhbmdlUGlja2VyKHRoaXMuX3dyYXBwZXIgPyB0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYW5nZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydCB8fCB0aGlzLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NSYW5nZS5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fd3JhcHBlcikge1xuICAgICAgICAgICAgJCQxKHRoaXMuc3RhcnQuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLmluc3RhbmNlLmdldFZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWxzQXJyYXkoX3RoaXMuY29udHJvbC52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkJDEodGhpcy5lbmQuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLmluc3RhbmNlLmdldFZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWxzQXJyYXkoX3RoaXMuY29udHJvbC52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGhhdF8xID0gdGhpcztcbiAgICAgICAgICAgICQkMSh0aGlzLmVsZW1lbnQpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdF8xLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXRfMS5lbGVtZW50LnZhbHVlICE9PSB0aGF0XzEuaW5zdGFuY2UuX3ZhbHVlICYmIHRoYXRfMS5lbmFibGVNYW51YWxFZGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoYXRfMS5lbGVtZW50LnZhbHVlICYmIHRoYXRfMS5lbGVtZW50LnZhbHVlLnNwbGl0KCcgLSAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdF8xLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXRfMS5pbnN0YW5jZS5nZXRWYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0XzEuY29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRfMS5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdF8xLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRfMS5vbkNoYW5nZUVtaXR0ZXIuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjUmFuZ2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtcmFuZ2VdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1JhbmdlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY1JhbmdlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnYXV0b0NvcnJlY3QnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2NvbnRyb2xzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlbmRJbnB1dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4UmFuZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21pblJhbmdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzaG93U2VsZWN0b3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0YXJ0SW5wdXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Zyb21UZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd0b1RleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29uU2V0RGF0ZSc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkNlbGxIb3ZlckluJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uQ2VsbEhvdmVyT3V0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uRGF5Q2hhbmdlJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ3N0YXJ0JzogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTWJzY1JhbmdlU3RhcnRDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9LF0gfSxdLFxuICAgICAgICAnZW5kJzogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTWJzY1JhbmdlRW5kQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSxdIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1yYW5nZScsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy1yYW5nZUNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1JhbmdlO1xufShNYnNjQ2FsQmFzZSkpO1xudmFyIE1ic2NSYW5nZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NSYW5nZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjUmFuZ2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NSYW5nZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtYnNjLXJhbmdlLXN0YXJ0XFxcIj48L25nLWNvbnRlbnQ+XFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cXFwibWJzYy1yYW5nZS1lbmRcXFwiPjwvbmctY29udGVudD5cXG4gICAgPG1ic2MtaW5wdXQgKm5nSWY9XFxcIiFfd3JhcHBlciAmJiAoIWlubGluZSB8fCBzaG93SW5wdXQpXFxcIiBcXG4gICAgICAgIFtjb250cm9sTmddPVxcXCJmYWxzZVxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbdGhlbWVdPVxcXCJ0aGVtZVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtkcm9wZG93bl09XFxcImRyb3Bkb3duXFxcIiBbcGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlclxcXCJcXG4gICAgICAgIFtlcnJvcl09XFxcImVycm9yXFxcIiBbZXJyb3JNZXNzYWdlXT1cXFwiZXJyb3JNZXNzYWdlXFxcIiBcXG4gICAgICAgIFtpY29uXT1cXFwiaW5wdXRJY29uXFxcIiBbaWNvbi1hbGlnbl09XFxcImljb25BbGlnblxcXCI+XFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgIDwvbWJzYy1pbnB1dD5cIixcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NSYW5nZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjUmFuZ2VDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1JhbmdlQ29tcG9uZW50O1xufShNYnNjUmFuZ2UpKTtcbnZhciBNYnNjUmFuZ2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NSYW5nZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY1JhbmdlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NDYWxCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjUmFuZ2VTdGFydENvbXBvbmVudCwgTWJzY1JhbmdlRW5kQ29tcG9uZW50LCBNYnNjUmFuZ2UsIE1ic2NSYW5nZUNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjUmFuZ2VTdGFydENvbXBvbmVudCwgTWJzY1JhbmdlRW5kQ29tcG9uZW50LCBNYnNjUmFuZ2UsIE1ic2NSYW5nZUNvbXBvbmVudF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NSYW5nZU1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjUmFuZ2VNb2R1bGU7XG59KCkpO1xuXG52YXIgTWJzY1Njcm9sbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxlcihpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1Njcm9sbGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1Njcm9sbGVyLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1Njcm9sbGVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2Nyb2xsZXIodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NTY3JvbGxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1zY3JvbGxlcl0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IFZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2Nyb2xsZXIucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtc2Nyb2xsZXInLF0gfSxdLFxuICAgICAgICAnb25DaGFuZ2VFbWl0dGVyJzogW3sgdHlwZTogT3V0cHV0LCBhcmdzOiBbJ21ic2Mtc2Nyb2xsZXJDaGFuZ2UnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlcjtcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xudmFyIE1ic2NTY3JvbGxlckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NTY3JvbGxlckNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXJDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjU2Nyb2xsZXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NTY3JvbGxlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXNjcm9sbGVyJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY1Njcm9sbGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlckNvbXBvbmVudDtcbn0oTWJzY1Njcm9sbGVyKSk7XG52YXIgTWJzY1Njcm9sbGVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NTY3JvbGxlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjU2Nyb2xsZXIsIE1ic2NTY3JvbGxlckNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjU2Nyb2xsZXIsIE1ic2NTY3JvbGxlckNvbXBvbmVudF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTY3JvbGxlck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYnNjU2Nyb2xsZXJNb2R1bGU7XG59KCkpO1xuXG52YXIgTWJzY1Njcm9sbFZpZXcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjU2Nyb2xsVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsVmlldyhpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjU2Nyb2xsVmlldy5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTY3JvbGxWaWV3KHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uubm90aWZ5SW5zdGFuY2VSZWFkeSh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hZGRSZW1vdmVPYnNlcnZlciA9IHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25BZGRSZW1vdmUoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYnNjU2Nyb2xsVmlldy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25BZGRSZW1vdmUoKS51bnN1YnNjcmliZSh0aGlzLmFkZFJlbW92ZU9ic2VydmVyKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1Njcm9sbFZpZXcuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2Mtc2Nyb2xsdmlld10nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTm90aWZ5SXRlbVNlcnZpY2VdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2Nyb2xsVmlldy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NTY3JvbGxWaWV3LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjU2Nyb2xsVmlldztcbn0oTWJzY1Njcm9sbFZpZXdCYXNlKSk7XG52YXIgTWJzY1Njcm9sbFZpZXdJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbFZpZXdJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3SXRlbShpbml0aWFsRWxlbSwgbm90aWZ5SXRlbVNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBpbml0aWFsRWxlbSkgfHwgdGhpcztcbiAgICB9XG4gICAgTWJzY1Njcm9sbFZpZXdJdGVtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXNjcm9sbHZpZXctaXRlbV0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pZF0nOiAnaWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTY3JvbGxWaWV3SXRlbS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NOb3RpZnlJdGVtU2VydmljZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBNYnNjU2Nyb2xsVmlld0l0ZW07XG59KE1ic2NTY3JvbGxJdGVtQmFzZSkpO1xudmFyIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbFZpZXdDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2Nyb2xsdmlldycsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ29wdGlvbnMnLF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50O1xufShNYnNjU2Nyb2xsVmlldykpO1xudmFyIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnQoaW5pdGlhbEVsZW0sIG5vdGlmeUl0ZW1TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgbm90aWZ5SXRlbVNlcnZpY2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXNjcm9sbHZpZXctaXRlbScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWlkXSc6ICdpZCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudDtcbn0oTWJzY1Njcm9sbFZpZXdJdGVtKSk7XG52YXIgTWJzY1Njcm9sbFZpZXdNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3TW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjU2Nyb2xsVmlld01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1Njcm9sbFZpZXcsIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50LCBNYnNjU2Nyb2xsVmlld0l0ZW0sIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjU2Nyb2xsVmlldywgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIE1ic2NTY3JvbGxWaWV3SXRlbSwgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50XVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1Njcm9sbFZpZXdNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY1Njcm9sbFZpZXdNb2R1bGU7XG59KCkpO1xuXG52YXIgU2VsZWN0JDEgPSBTY3JvbGxlcjtcbnZhciBkZWZhdWx0cyRkID0ge1xuICBpbnB1dENsYXNzOiAnJyxcbiAgcnRsOiBmYWxzZSxcbiAgc2hvd0lucHV0OiB0cnVlLFxuICBncm91cExhYmVsOiAnR3JvdXBzJyxcbiAgZGF0YUh0bWw6ICdodG1sJyxcbiAgZGF0YVRleHQ6ICd0ZXh0JyxcbiAgZGF0YVZhbHVlOiAndmFsdWUnLFxuICBkYXRhR3JvdXA6ICdncm91cCcsXG4gIGRhdGFEaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZmlsdGVyUGxhY2Vob2xkZXJUZXh0OiAnVHlwZSB0byBmaWx0ZXInLFxuICBmaWx0ZXJFbXB0eVRleHQ6ICdObyByZXN1bHRzJyxcbiAgZmlsdGVyQ2xlYXJJY29uOiAnbWF0ZXJpYWwtY2xvc2UnXG59O1xuXG5wcmVzZXRzLnNlbGVjdCA9IGZ1bmN0aW9uIChpbnN0LCBzZXR0aW5ncykge1xuICB2YXIgJGlucHV0LFxuICAgICAgZGF0YUFycmF5LFxuICAgICAgZmlsdGVyTGVuZ3RoLFxuICAgICAgZmlsdGVyVGV4dCxcbiAgICAgIGdyb3VwLFxuICAgICAgZ3JvdXBBcnJheSxcbiAgICAgIGdyb3VwV2hlZWwsXG4gICAgICBncm91cHMsXG4gICAgICBncm91cFdoZWVsSWR4LFxuICAgICAgaGFzUmVtb3RlRGF0YSxcbiAgICAgIG9wdGlvbixcbiAgICAgIG9wdGlvbkFycmF5LFxuICAgICAgb3B0aW9uV2hlZWwsXG4gICAgICBvcHRpb25XaGVlbElkeCxcbiAgICAgIHByZXZlbnQsXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyxcbiAgICAgIHNlbGVjdGVkVGV4dHMgPSB7fSxcbiAgICAgIGFuaW1UaW1lID0gMTAwMCxcbiAgICAgIGVsbSA9IHRoaXMsXG4gICAgICAkZWxtID0gJCQxKGVsbSksXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJGQsIG9yaWcpLFxuICAgICAgJGZpbHRlckVtcHR5ID0gJCQxKCc8ZGl2IGNsYXNzPVwibWJzYy1zZWwtZW1wdHlcIj4nICsgcy5maWx0ZXJFbXB0eVRleHQgKyAnPC9kaXY+JyksXG4gICAgICBvcmlnUmVhZE9ubHkgPSBzLnJlYWRvbmx5LFxuICAgICAgb3B0aW9ucyA9IHt9LFxuICAgICAgbGF5b3V0ID0gcy5sYXlvdXQgfHwgKC90b3B8Ym90dG9tfGlubGluZS8udGVzdChzLmRpc3BsYXkpIHx8IHMuZmlsdGVyID8gJ2xpcXVpZCcgOiAnJyksXG4gICAgICBpc0xpcXVpZCA9IGxheW91dCA9PSAnbGlxdWlkJyB8fCAhcy50b3VjaFVpLFxuICAgICAgbXVsdGlwbGUgPSBpc051bWVyaWMocy5zZWxlY3QpID8gcy5zZWxlY3QgOiBzLnNlbGVjdCA9PSAnbXVsdGlwbGUnIHx8ICRlbG0ucHJvcCgnbXVsdGlwbGUnKSxcbiAgICAgIHRhcFNlbGVjdCA9IG11bHRpcGxlIHx8IChzLmZpbHRlciB8fCBzLnRhcFNlbGVjdCA/IDEgOiBmYWxzZSksXG4gICAgICBpZCA9IHRoaXMuaWQgKyAnX2R1bW15JyxcbiAgICAgIGxibCA9ICQkMSgnbGFiZWxbZm9yPVwiJyArIHRoaXMuaWQgKyAnXCJdJykuYXR0cignZm9yJywgaWQpLFxuICAgICAgbGFiZWwgPSBzLmxhYmVsICE9PSB1bmRlZmluZWQgPyBzLmxhYmVsIDogbGJsLmxlbmd0aCA/IGxibC50ZXh0KCkgOiAkZWxtLmF0dHIoJ25hbWUnKSxcbiAgICAgIGdyb3VwU2V0dXAgPSBzLmdyb3VwLFxuICAgICAgaGFzRGF0YSA9ICEhcy5kYXRhLFxuICAgICAgaGFzR3JvdXBzID0gaGFzRGF0YSA/ICEhcy5ncm91cCA6ICQkMSgnb3B0Z3JvdXAnLCAkZWxtKS5sZW5ndGgsXG4gICAgICBoYXNHcm91cFdoZWVsID0gaGFzR3JvdXBzICYmIGdyb3VwU2V0dXAgJiYgZ3JvdXBTZXR1cC5ncm91cFdoZWVsICE9PSBmYWxzZSxcbiAgICAgIGdyb3VwU2VwID0gaGFzR3JvdXBzICYmIGdyb3VwU2V0dXAgJiYgaGFzR3JvdXBXaGVlbCAmJiBncm91cFNldHVwLmNsdXN0ZXJlZCA9PT0gdHJ1ZSxcbiAgICAgIGdyb3VwSGRyID0gaGFzR3JvdXBzICYmICghZ3JvdXBTZXR1cCB8fCBncm91cFNldHVwLmhlYWRlciAhPT0gZmFsc2UgJiYgIWdyb3VwU2VwKSxcbiAgICAgIHZhbHVlcyA9ICRlbG0udmFsKCkgfHwgKG11bHRpcGxlID8gW10gOiBbJyddKSxcbiAgICAgIGludmFsaWQgPSBbXTtcblxuICBmdW5jdGlvbiBwcmVwYXJlRGF0YShmaWx0ZXIpIHtcbiAgICB2YXIgZ3IsXG4gICAgICAgIGh0bWwsXG4gICAgICAgIGxibCxcbiAgICAgICAgb3B0LFxuICAgICAgICB0eHQsXG4gICAgICAgIHZhbCxcbiAgICAgICAgbCA9IDAsXG4gICAgICAgIGMgPSAwLFxuICAgICAgICBncm91cEluZGV4ZXMgPSB7fTtcbiAgICBvcHRpb25zID0ge307XG4gICAgZ3JvdXBzID0ge307XG4gICAgb3B0aW9uQXJyYXkgPSBbXTtcbiAgICBncm91cEFycmF5ID0gW107IC8vIFJlc2V0IGludmFsaWRzXG5cbiAgICBpbnZhbGlkLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgJCQxLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICB0eHQgPSB2W3MuZGF0YVRleHRdICsgJyc7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICAgICAgaHRtbCA9IHZbcy5kYXRhSHRtbF07XG4gICAgICAgIHZhbCA9IHZbcy5kYXRhVmFsdWVdO1xuICAgICAgICBsYmwgPSB2W3MuZGF0YUdyb3VwXTtcbiAgICAgICAgb3B0ID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgICB0ZXh0OiB0eHQsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgY3NzQ2xhc3M6IGdyb3VwSGRyID8gJ21ic2Mtc2VsLWdyLWl0bScgOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zW3ZhbF0gPSBvcHQ7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgbWF0Y2hlc0ZpbHRlcih0eHQsIGZpbHRlcikpIHtcbiAgICAgICAgICBvcHRpb25BcnJheS5wdXNoKG9wdCk7XG5cbiAgICAgICAgICBpZiAoaGFzR3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBJbmRleGVzW2xibF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBnciA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYmwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGMsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZ3JvdXBzW2NdID0gZ3I7XG4gICAgICAgICAgICAgIGdyb3VwSW5kZXhlc1tsYmxdID0gYztcbiAgICAgICAgICAgICAgZ3JvdXBBcnJheS5wdXNoKGdyKTtcbiAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ3IgPSBncm91cHNbZ3JvdXBJbmRleGVzW2xibF1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBTZXApIHtcbiAgICAgICAgICAgICAgb3B0LmluZGV4ID0gZ3Iub3B0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdC5ncm91cCA9IGdyb3VwSW5kZXhlc1tsYmxdO1xuICAgICAgICAgICAgZ3Iub3B0aW9ucy5wdXNoKG9wdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZbcy5kYXRhRGlzYWJsZWRdKSB7XG4gICAgICAgICAgICBpbnZhbGlkLnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzR3JvdXBzKSB7XG4gICAgICAgIHZhciBhZGRHcm91cCA9IHRydWU7XG4gICAgICAgICQkMSgnb3B0Z3JvdXAnLCAkZWxtKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgZ3JvdXBzW2ldID0ge1xuICAgICAgICAgICAgdGV4dDogdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgb3B0aW9uczogW10sXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWRkR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICQkMSgnb3B0aW9uJywgdGhpcykuZWFjaChmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgb3B0ID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgICBpbmRleDogZ3JvdXBTZXAgPyBqIDogbCsrLFxuICAgICAgICAgICAgICBncm91cDogaSxcbiAgICAgICAgICAgICAgY3NzQ2xhc3M6IGdyb3VwSGRyID8gJ21ic2Mtc2VsLWdyLWl0bScgOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wdGlvbnNbdGhpcy52YWx1ZV0gPSBvcHQ7XG5cbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IG1hdGNoZXNGaWx0ZXIodGhpcy50ZXh0LCBmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgIGlmIChhZGRHcm91cCkge1xuICAgICAgICAgICAgICAgIGdyb3VwQXJyYXkucHVzaChncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgIGFkZEdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvcHRpb25BcnJheS5wdXNoKG9wdCk7XG4gICAgICAgICAgICAgIGdyb3Vwc1tpXS5vcHRpb25zLnB1c2gob3B0KTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGludmFsaWQucHVzaCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkMSgnb3B0aW9uJywgJGVsbSkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIG9wdCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9wdGlvbnNbdGhpcy52YWx1ZV0gPSBvcHQ7XG5cbiAgICAgICAgICBpZiAoIWZpbHRlciB8fCBtYXRjaGVzRmlsdGVyKHRoaXMudGV4dCwgZmlsdGVyKSkge1xuICAgICAgICAgICAgb3B0aW9uQXJyYXkucHVzaChvcHQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICBpbnZhbGlkLnB1c2godGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHMuZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBvcHRpb25BcnJheVswXS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwSGRyKSB7XG4gICAgICBvcHRpb25BcnJheSA9IFtdO1xuICAgICAgbCA9IDA7XG4gICAgICAkJDEuZWFjaChncm91cHMsIGZ1bmN0aW9uIChpLCBncikge1xuICAgICAgICBpZiAoZ3Iub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSAnX19ncm91cCcgKyBpO1xuICAgICAgICAgIG9wdCA9IHtcbiAgICAgICAgICAgIHRleHQ6IGdyLnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgZ3JvdXA6IGksXG4gICAgICAgICAgICBpbmRleDogbCsrLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLXNlbC1ncidcbiAgICAgICAgICB9O1xuICAgICAgICAgIG9wdGlvbnNbdmFsXSA9IG9wdDtcbiAgICAgICAgICBvcHRpb25BcnJheS5wdXNoKG9wdCk7XG4gICAgICAgICAgaW52YWxpZC5wdXNoKG9wdC52YWx1ZSk7XG4gICAgICAgICAgJCQxLmVhY2goZ3Iub3B0aW9ucywgZnVuY3Rpb24gKGosIG9wdCkge1xuICAgICAgICAgICAgb3B0LmluZGV4ID0gbCsrO1xuICAgICAgICAgICAgb3B0aW9uQXJyYXkucHVzaChvcHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJGZpbHRlckVtcHR5KSB7XG4gICAgICBpZiAob3B0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICRmaWx0ZXJFbXB0eS5yZW1vdmVDbGFzcygnbWJzYy1zZWwtZW1wdHktdicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGZpbHRlckVtcHR5LmFkZENsYXNzKCdtYnNjLXNlbC1lbXB0eS12Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVmFsdWVzKGRhdGEsIHRhcFNlbGVjdCwgbGFiZWwsIG11bHRpcGxlLCBjc3NDbGFzcykge1xuICAgIHZhciBpLFxuICAgICAgICB2YWx1ZXMgPSBbXTtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IGRhdGFbaV0udmFsdWUsXG4gICAgICAgICAgZGlzcGxheTogZGF0YVtpXS5odG1sIHx8IGRhdGFbaV0udGV4dCxcbiAgICAgICAgICBjc3NDbGFzczogZGF0YVtpXS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgICAgbXVsdGlwbGU6IHRhcFNlbGVjdCAmJiAhbXVsdGlwbGUgPyAxIDogbXVsdGlwbGUsXG4gICAgICBjc3NDbGFzczogKHRhcFNlbGVjdCAmJiAhbXVsdGlwbGUgPyAnbWJzYy1zZWwtb25lJyA6ICcnKSArICcgJyArIGNzc0NsYXNzLFxuICAgICAgZGF0YTogdmFsdWVzLFxuICAgICAgbGFiZWw6IGxhYmVsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkdyb3VwV2hlZWwoKSB7XG4gICAgcmV0dXJuIGdlblZhbHVlcyhncm91cEFycmF5LCB0YXBTZWxlY3QsIHMuZ3JvdXBMYWJlbCwgZmFsc2UsICdtYnNjLXNlbC1nci13aGwnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk9wdFdoZWVsKCkge1xuICAgIHJldHVybiBnZW5WYWx1ZXMoZ3JvdXBTZXAgJiYgZ3JvdXBzW2dyb3VwXSA/IGdyb3Vwc1tncm91cF0ub3B0aW9ucyA6IG9wdGlvbkFycmF5LCB0YXBTZWxlY3QsIGxhYmVsLCBtdWx0aXBsZSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuV2hlZWxzKCkge1xuICAgIHZhciB3ID0gW1tdXTtcblxuICAgIGlmIChoYXNHcm91cFdoZWVsKSB7XG4gICAgICBncm91cFdoZWVsID0gZ2VuR3JvdXBXaGVlbCgpO1xuXG4gICAgICBpZiAoaXNMaXF1aWQpIHtcbiAgICAgICAgd1swXVtncm91cFdoZWVsSWR4XSA9IGdyb3VwV2hlZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3W2dyb3VwV2hlZWxJZHhdID0gW2dyb3VwV2hlZWxdO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbldoZWVsID0gZ2VuT3B0V2hlZWwoKTtcblxuICAgIGlmIChpc0xpcXVpZCkge1xuICAgICAgd1swXVtvcHRpb25XaGVlbElkeF0gPSBvcHRpb25XaGVlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgd1tvcHRpb25XaGVlbElkeF0gPSBbb3B0aW9uV2hlZWxdO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9uKHYpIHtcbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIGlmICh2ICYmIGlzU3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSB2LnNwbGl0KCcsJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkJDEuaXNBcnJheSh2KSkge1xuICAgICAgICB2ID0gdlswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb24gPSB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCB8fCB2ID09PSAnJyA/IGRlZmF1bHRWYWx1ZSA6IHY7XG5cbiAgICBpZiAoIW9wdGlvbnNbb3B0aW9uXSAmJiBvcHRpb25BcnJheSAmJiBvcHRpb25BcnJheS5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbiA9IG9wdGlvbkFycmF5WzBdLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChoYXNHcm91cFdoZWVsKSB7XG4gICAgICBncm91cCA9IG9wdGlvbnNbb3B0aW9uXSA/IG9wdGlvbnNbb3B0aW9uXS5ncm91cCA6IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGV4dChvcHQpIHtcbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0c1tvcHRdIHx8IChvcHRpb25zW29wdF0gPyBvcHRpb25zW29wdF0udGV4dCA6ICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGQsIGluc3QsIGZpbGwpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgb3B0LFxuICAgICAgICBzZWwgPSBbXSxcbiAgICAgICAgc2VsZWN0ZWQgPSBmaWxsID8gaW5zdC5fc2VsZWN0ZWQgOiBpbnN0Ll90ZW1wU2VsZWN0ZWQ7XG5cbiAgICBpZiAodGFwU2VsZWN0KSB7XG4gICAgICBmb3IgKGkgaW4gc2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdKSB7XG4gICAgICAgIHNlbC5wdXNoKGdldFRleHQoaSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgb3B0ID0gZFtvcHRpb25XaGVlbElkeF07XG4gICAgcmV0dXJuIGdldFRleHQob3B0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRmlsbCgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICB2YWwgPSBpbnN0LmdldFZhbCgpLFxuICAgICAgICB0eHQgPSBzLmZvcm1hdFZhbHVlLmNhbGwoZWxtLCBpbnN0LmdldEFycmF5VmFsKCksIGluc3QsIHRydWUpO1xuXG4gICAgaWYgKCEocy5maWx0ZXIgJiYgcy5kaXNwbGF5ID09ICdpbmxpbmUnKSkge1xuICAgICAgJGlucHV0LnZhbCh0eHQpO1xuICAgIH0gLy8gSWYgd2UgaGF2ZSBhIG5hdGl2ZSBzZWxlY3QsIGJ1dCBkYXRhIHdhcyBwYXNzZWQgaW4gc2V0dGluZyxcbiAgICAvLyBjcmVhdGUgYW4gb3B0aW9uIHRhZyB3aXRoIHRoZSBzZWxlY3RlZCB2YWx1ZVxuXG5cbiAgICBpZiAoJGVsbS5pcygnc2VsZWN0JykgJiYgaGFzRGF0YSkge1xuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIHZhbFtpXSArICdcIj4nICsgZ2V0VGV4dCh2YWxbaV0pICsgJzwvb3B0aW9uPic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyAodmFsID09PSBudWxsID8gJycgOiB2YWwpICsgJ1wiPicgKyB0eHQgKyAnPC9vcHRpb24+JztcbiAgICAgIH1cblxuICAgICAgJGVsbS5odG1sKGh0bWwpO1xuICAgIH1cblxuICAgIGlmIChlbG0gIT09ICRpbnB1dFswXSkge1xuICAgICAgLy8gaWYgdGhlIHRhcmdldCBpcyB0aGUgc2FtZSwgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaXRcbiAgICAgICRlbG0udmFsKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlV2hlZWwoKSB7XG4gICAgdmFyIHdoZWVscyA9IHt9O1xuICAgIHdoZWVsc1tvcHRpb25XaGVlbElkeF0gPSBnZW5PcHRXaGVlbCgpO1xuICAgIHByZXZlbnQgPSB0cnVlO1xuICAgIGluc3QuY2hhbmdlV2hlZWwod2hlZWxzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoZXNGaWx0ZXIoc3RyLCBmaWx0ZXIpIHtcbiAgICBmaWx0ZXIgPSBmaWx0ZXIucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgdGhlIHNwZWNpYWwgY2hhcmFjdGVyc1xuXG4gICAgcmV0dXJuIHN0ci5tYXRjaChuZXcgUmVnRXhwKGZpbHRlciwgJ2lnJykpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHMuZGF0YS5kYXRhRmllbGQgPyBkYXRhW3MuZGF0YS5kYXRhRmllbGRdIDogcy5kYXRhLnByb2Nlc3NSZXNwb25zZSA/IHMuZGF0YS5wcm9jZXNzUmVzcG9uc2UoZGF0YSkgOiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVdoZWVscyhmaWx0ZXIpIHtcbiAgICB2YXIgd2hlZWxzID0ge307XG4gICAgcHJlcGFyZURhdGEoZmlsdGVyKTtcbiAgICBnZXRPcHRpb24ob3B0aW9uKTtcbiAgICBzLndoZWVscyA9IGdlbldoZWVscygpO1xuICAgIHdoZWVsc1tvcHRpb25XaGVlbElkeF0gPSBvcHRpb25XaGVlbDtcbiAgICBpbnN0Ll90ZW1wV2hlZWxBcnJheVtvcHRpb25XaGVlbElkeF0gPSBvcHRpb247XG5cbiAgICBpZiAoaGFzR3JvdXBXaGVlbCkge1xuICAgICAgd2hlZWxzW2dyb3VwV2hlZWxJZHhdID0gZ3JvdXBXaGVlbDtcbiAgICAgIGluc3QuX3RlbXBXaGVlbEFycmF5W2dyb3VwV2hlZWxJZHhdID0gZ3JvdXA7XG4gICAgfVxuXG4gICAgaW5zdC5jaGFuZ2VXaGVlbCh3aGVlbHMsIDAsIHRydWUpO1xuICAgIG9uRmlsbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlck9uRmlsdGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGluc3QudHJpZ2dlcignb25GaWx0ZXInLCB7XG4gICAgICBmaWx0ZXJUZXh0OiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZEdyb3VwT3B0aW9ucyh2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzW2dyb3VwV2hlZWxJZHhdICE9IGdyb3VwKSB7XG4gICAgICBncm91cCA9IHZhbHVlc1tncm91cFdoZWVsSWR4XTtcbiAgICAgIG9wdGlvbiA9IGdyb3Vwc1tncm91cF0ub3B0aW9uc1swXS52YWx1ZTtcbiAgICAgIHZhbHVlc1tvcHRpb25XaGVlbElkeF0gPSBvcHRpb247XG5cbiAgICAgIGlmIChncm91cFNlcCkge1xuICAgICAgICBjaGFuZ2VXaGVlbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5zZXRBcnJheVZhbCh2YWx1ZXMsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgYW5pbVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICBpZiAodGFwU2VsZWN0KSB7XG4gICAgICBpZiAodmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkICYmICFtdWx0aXBsZSkge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbCAmJiBpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zcGxpdCgnLCcpO1xuICAgICAgfVxuXG4gICAgICBpbnN0Ll90ZW1wU2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdCh2YWwpO1xuXG4gICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgaW5zdC5fc2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdCh2YWwpO1xuICAgICAgfVxuXG4gICAgICB2YWwgPSB2YWwgPyB2YWxbMF0gOiBudWxsO1xuXG4gICAgICBpZiAoaGFzR3JvdXBXaGVlbCkge1xuICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc1t2YWxdLFxuICAgICAgICAgICAgZ3IgPSBvcHQgJiYgb3B0Lmdyb3VwO1xuICAgICAgICBpbnN0Ll90ZW1wU2VsZWN0ZWRbZ3JvdXBXaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KFtncl0pO1xuXG4gICAgICAgIGlmICghdGVtcCkge1xuICAgICAgICAgIGluc3QuX3NlbGVjdGVkW2dyb3VwV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdChbZ3JdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3NldFZhbCh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSk7XG4gIH07XG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCwgZ3JvdXApIHtcbiAgICB2YXIgdmFsO1xuXG4gICAgaWYgKHRhcFNlbGVjdCkge1xuICAgICAgdmFsID0gb2JqZWN0VG9BcnJheSh0ZW1wID8gaW5zdC5fdGVtcFNlbGVjdGVkW29wdGlvbldoZWVsSWR4XSA6IGluc3QuX3NlbGVjdGVkW29wdGlvbldoZWVsSWR4XSk7XG4gICAgICB2YWwgPSBtdWx0aXBsZSA/IHZhbCA6IHZhbC5sZW5ndGggPyB2YWxbMF0gOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSB0ZW1wID8gaW5zdC5fdGVtcFdoZWVsQXJyYXkgOiBpbnN0Ll9oYXNWYWx1ZSA/IGluc3QuX3doZWVsQXJyYXkgOiBudWxsO1xuICAgICAgdmFsID0gdmFsID8gdmFsW29wdGlvbldoZWVsSWR4XSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11bHRpcGxlID8gdmFsIDogdmFsICE9PSB1bmRlZmluZWQgPyBoYXNHcm91cHMgJiYgZ3JvdXAgPyBbb3B0aW9uc1t2YWxdID8gb3B0aW9uc1t2YWxdLmdyb3VwIDogbnVsbCwgdmFsXSA6IHZhbCA6IG51bGw7XG4gIH07XG5cbiAgaW5zdC5yZWZyZXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbHRlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgZGF0YUFycmF5ID0gZGF0YTtcblxuICAgICAgaWYgKCFoYXNSZW1vdGVEYXRhKSB7XG4gICAgICAgIC8vIFNhdmUgZGF0YSwgb3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IGxvc3Qgb24gYW4gb3B0aW9uIGNhbGwsXG4gICAgICAgIC8vIGFuZCBmaWx0ZXJpbmcgZG9lcyBub3Qgd29yayBhcyB3ZWxsIGFmdGVyIGFzeW5jIGRhdGEgdXBkYXRlXG4gICAgICAgIHMuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkJDEuaXNBcnJheShzLmRhdGEpKSB7XG4gICAgICBkYXRhQXJyYXkgPSBzLmRhdGE7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhICYmIGhhc1JlbW90ZURhdGEgJiYgZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlbG9hZCB0aGUgZGF0YSBmcm9tIHJlbW90ZSBzb3VyY2VcbiAgICAgIGdldEpzb24ocy5kYXRhLnVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZGF0YUFycmF5ID0gZ2V0RGF0YShkYXRhKTtcbiAgICAgICAgcHJlcGFyZVdoZWVscygpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSwgcy5kYXRhLmRhdGFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlcGFyZVdoZWVscyhmaWx0ZXIpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07IC8vIC0tLVxuICAvLyBJbml0c1xuICAvLyAtLS1cblxuXG4gIGlmICghc2V0dGluZ3MuaW52YWxpZCkge1xuICAgIHMuaW52YWxpZCA9IGludmFsaWQ7XG4gIH1cblxuICBpZiAoaGFzR3JvdXBXaGVlbCkge1xuICAgIGdyb3VwV2hlZWxJZHggPSAwO1xuICAgIG9wdGlvbldoZWVsSWR4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICBncm91cFdoZWVsSWR4ID0gLTE7XG4gICAgb3B0aW9uV2hlZWxJZHggPSAwO1xuICB9XG5cbiAgaWYgKHRhcFNlbGVjdCkge1xuICAgIGlmIChtdWx0aXBsZSAmJiAkZWxtLmlzKCdzZWxlY3QnKSkge1xuICAgICAgJGVsbS5wcm9wKCdtdWx0aXBsZScsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMgJiYgaXNTdHJpbmcodmFsdWVzKSkge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgaW5zdC5fc2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdCh2YWx1ZXMpO1xuICB9IC8vIFJlbW92ZSBkdW1teSBlbGVtZW50IGlmIGV4aXN0c1xuXG5cbiAgaWYgKGluc3QuXyRpbnB1dCkge1xuICAgIGluc3QuXyRpbnB1dC5yZW1vdmUoKTtcbiAgfSAvLyBDaGVjayBpZiBtb2Jpc2Nyb2xsIGZvcm0gYWxyZWFkeSBpbml0aWFsaXplZCB0aGlzIHNlbGVjdFxuXG5cbiAgaWYgKCRlbG0ubmV4dCgpLmlzKCcubWJzYy1zZWxlY3QtaW5wdXQnKSkge1xuICAgICRpbnB1dCA9ICRlbG0ubmV4dCgpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMuaW5wdXQpIHtcbiAgICAgICRpbnB1dCA9ICQkMShzLmlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGR1bW15IGlucHV0XG4gICAgICBpZiAocy5maWx0ZXIgJiYgcy5kaXNwbGF5ID09ICdpbmxpbmUnKSB7XG4gICAgICAgIGluc3QuXyRpbnB1dCA9ICQkMSgnPGRpdiBjbGFzcz1cIm1ic2Mtc2VsLWlucHV0LXdyYXBcIj48aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cIm1ic2Mtc2VsZWN0LWlucHV0IG1ic2MtY29udHJvbCAnICsgcy5pbnB1dENsYXNzICsgJ1wiIHJlYWRvbmx5IC8+PC9kaXY+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaW5wdXQgPSAkJDEoJzxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwibWJzYy1zZWxlY3QtaW5wdXQgbWJzYy1jb250cm9sICcgKyBzLmlucHV0Q2xhc3MgKyAnXCIgcmVhZG9ubHkgLz4nKTtcbiAgICAgICAgaW5zdC5fJGlucHV0ID0gJGlucHV0O1xuICAgICAgfVxuXG4gICAgICBpZiAocy5zaG93SW5wdXQpIHtcbiAgICAgICAgaW5zdC5fJGlucHV0Lmluc2VydEFmdGVyKCRlbG0pO1xuXG4gICAgICAgIGlmICghJGlucHV0KSB7XG4gICAgICAgICAgJGlucHV0ID0gaW5zdC5fJGlucHV0LmZpbmQoJyMnICsgaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNob3cgc2Nyb2xsZXIgb24gaW5wdXQgdGFwXG5cblxuICBpbnN0LmF0dGFjaFNob3coJGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJywgcy5wbGFjZWhvbGRlciB8fCAnJykpO1xuXG4gIGlmICgkaW5wdXRbMF0gIT09IGVsbSkge1xuICAgICRlbG0uYWRkQ2xhc3MoJ21ic2Mtc2VsLWhkbicpLmF0dHIoJ3RhYmluZGV4JywgLTEpO1xuXG4gICAgaWYgKCFzLnNob3dJbnB1dCkge1xuICAgICAgJGVsbS5hdHRyKCdkYXRhLWVuaGFuY2UnLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhcFNlbGVjdCAmJiAhKHMucm93cyAlIDIpKSB7XG4gICAgcy5yb3dzID0gcy5yb3dzIC0gMTtcbiAgfVxuXG4gIGlmIChzLmZpbHRlcikge1xuICAgIGZpbHRlckxlbmd0aCA9IHMuZmlsdGVyLm1pbkxlbmd0aCB8fCAwO1xuICB9XG5cbiAgaGFzUmVtb3RlRGF0YSA9IHMuZGF0YSAmJiBzLmRhdGEudXJsO1xuXG4gIGlmIChoYXNSZW1vdGVEYXRhKSB7XG4gICAgaW5zdC5yZWZyZXNoKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhhc0RhdGEpIHtcbiAgICAgIGRhdGFBcnJheSA9IHMuZGF0YTtcbiAgICB9XG5cbiAgICBwcmVwYXJlRGF0YSgpO1xuICAgIGdldE9wdGlvbigkZWxtLnZhbCgpKTtcbiAgfSAvLyAtLS1cblxuXG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgaGVhZGVyVGV4dDogZmFsc2UsXG4gICAgYW5jaG9yOiAkaW5wdXQsXG4gICAgY29tcENsYXNzOiAnbWJzYy1zYyBtYnNjLXNlbCcgKyAodGFwU2VsZWN0ID8gJyBtYnNjLXNlbC1tdWx0aScgOiAnJyksXG4gICAgc2V0T25UYXA6IGhhc0dyb3VwV2hlZWwgPyBbZmFsc2UsIHRydWVdIDogdHJ1ZSxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWUsXG4gICAgdGFwU2VsZWN0OiB0YXBTZWxlY3QsXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWwpIHtcbiAgICAgIGdldE9wdGlvbih2YWwgPT09IHVuZGVmaW5lZCA/ICRlbG0udmFsKCkgOiB2YWwpO1xuICAgICAgcmV0dXJuIGhhc0dyb3VwV2hlZWwgPyBbZ3JvdXAsIG9wdGlvbl0gOiBbb3B0aW9uXTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgaW5kZXggPSBkYXRhLmluZGV4LFxuICAgICAgICAgIGRpc2FibGVkID0gW107XG4gICAgICBkaXNhYmxlZFtvcHRpb25XaGVlbElkeF0gPSBzLmludmFsaWQ7XG5cbiAgICAgIGlmIChncm91cFNlcCAmJiAhcHJldmVudCAmJiBpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoYW5nZVdoZWVsKCk7XG4gICAgICB9XG5cbiAgICAgIHByZXZlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIG9uUmVhZDogb25GaWxsLFxuICAgIG9uRmlsbDogb25GaWxsLFxuICAgIG9uTWFya3VwUmVhZHk6IGZ1bmN0aW9uIG9uTWFya3VwUmVhZHkoZXZlbnQsIGluc3QpIHtcbiAgICAgIGlmIChzLmZpbHRlcikge1xuICAgICAgICB2YXIgJGZpbHRlcklucHV0LFxuICAgICAgICAgICAgZGVib3VuY2UsXG4gICAgICAgICAgICBmaWx0ZXJJbnB1dCxcbiAgICAgICAgICAgICRjb250ID0gJCQxKCcubWJzYy1mci13JywgZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgICRmaWx0ZXJDbGVhciA9ICQkMSgnPHNwYW4gY2xhc3M9XCJtYnNjLXNlbC1maWx0ZXItY2xlYXIgbWJzYy1pYyBtYnNjLWljLScgKyBzLmZpbHRlckNsZWFySWNvbiArICdcIj48L3NwYW4+Jyk7XG5cbiAgICAgICAgaWYgKHMuZGlzcGxheSA9PSAnaW5saW5lJykge1xuICAgICAgICAgICRmaWx0ZXJJbnB1dCA9ICRpbnB1dDtcbiAgICAgICAgICAkaW5wdXQucGFyZW50KCkuZmluZCgnLm1ic2Mtc2VsLWZpbHRlci1jbGVhcicpLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRjb250LmZpbmQoJy5tYnNjLWZyLWMnKS5iZWZvcmUoJzxkaXYgY2xhc3M9XCJtYnNjLWlucHV0IG1ic2Mtc2VsLWZpbHRlci1jb250IG1ic2MtY29udHJvbC13IG1ic2MtJyArIHMudGhlbWUgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpICsgJ1wiPjxzcGFuIGNsYXNzPVwibWJzYy1pbnB1dC13cmFwXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJtYnNjLXNlbC1maWx0ZXItaW5wdXQgbWJzYy1jb250cm9sXCIvPjwvc3Bhbj48L2Rpdj4nKTtcbiAgICAgICAgICAkZmlsdGVySW5wdXQgPSAkY29udC5maW5kKCcubWJzYy1zZWwtZmlsdGVyLWlucHV0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgZmlsdGVySW5wdXQgPSAkZmlsdGVySW5wdXRbMF07XG4gICAgICAgICRmaWx0ZXJJbnB1dC5wcm9wKCdyZWFkb25seScsIGZhbHNlKS5hdHRyKCdwbGFjZWhvbGRlcicsIHMuZmlsdGVyUGxhY2Vob2xkZXJUZXh0KS5wYXJlbnQoKS5hcHBlbmQoJGZpbHRlckNsZWFyKTtcbiAgICAgICAgJGNvbnQuZmluZCgnLm1ic2MtZnItYycpLnByZXBlbmQoJGZpbHRlckVtcHR5KTsgLy8gV2lsbCBmb2N1cyBpbiB0aGUgaW5wdXQgb24gc2hvd1xuXG4gICAgICAgIGluc3QuX2FjdGl2ZUVsbSA9IGZpbHRlcklucHV0O1xuICAgICAgICBpbnN0LnRhcCgkZmlsdGVyQ2xlYXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmaWx0ZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgICBmaWx0ZXJJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgIGluc3QucmVmcmVzaCgpO1xuICAgICAgICAgICRmaWx0ZXJDbGVhci5yZW1vdmVDbGFzcygnbWJzYy1zZWwtZmlsdGVyLXNob3ctY2xlYXInKTtcbiAgICAgICAgICB0cmlnZ2VyT25GaWx0ZXIoJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgJGZpbHRlcklucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgLy8gRW50ZXIgYW5kIEVzY1xuICAgICAgICAgIGlmIChldi5rZXlDb2RlID09IDEzIHx8IGV2LmtleUNvZGUgPT0gMjcpIHtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZmlsdGVySW5wdXQuYmx1cigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZSk7XG5cbiAgICAgICAgICBpZiAoZmlsdGVySW5wdXQudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAkZmlsdGVyQ2xlYXIuYWRkQ2xhc3MoJ21ic2Mtc2VsLWZpbHRlci1zaG93LWNsZWFyJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRmaWx0ZXJDbGVhci5yZW1vdmVDbGFzcygnbWJzYy1zZWwtZmlsdGVyLXNob3ctY2xlYXInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpbHRlclRleHQgPT09IGZpbHRlcklucHV0LnZhbHVlIHx8IHRyaWdnZXJPbkZpbHRlcihmaWx0ZXJJbnB1dC52YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGZpbHRlcklucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyVGV4dC5sZW5ndGggPj0gZmlsdGVyTGVuZ3RoIHx8ICFmaWx0ZXJUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaGFzUmVtb3RlRGF0YSAmJiBzLmRhdGEucmVtb3RlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZ2V0SnNvbihzLmRhdGEudXJsICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpbHRlclRleHQpLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgaW5zdC5yZWZyZXNoKGdldERhdGEoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0sIHMuZGF0YS5kYXRhVHlwZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdC5yZWZyZXNoKHVuZGVmaW5lZCwgZmlsdGVyVGV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQmVmb3JlU2hvdzogZnVuY3Rpb24gb25CZWZvcmVTaG93KCkge1xuICAgICAgaWYgKG11bHRpcGxlICYmIHMuY291bnRlcikge1xuICAgICAgICBzLmhlYWRlclRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgJCQxLmVhY2goaW5zdC5fdGVtcFNlbGVjdGVkW29wdGlvbldoZWVsSWR4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIChsZW5ndGggPiAxID8gcy5zZWxlY3RlZFBsdXJhbFRleHQgfHwgcy5zZWxlY3RlZFRleHQgOiBzLnNlbGVjdGVkVGV4dCkucmVwbGFjZSgve2NvdW50fS8sIGxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGdldE9wdGlvbigkZWxtLnZhbCgpKTtcblxuICAgICAgaWYgKHRhcFNlbGVjdCAmJiBoYXNHcm91cFdoZWVsKSB7XG4gICAgICAgIGluc3QuX3NlbGVjdGVkW2dyb3VwV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdChbZ3JvdXBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMuZmlsdGVyKSB7XG4gICAgICAgIHByZXBhcmVEYXRhKHVuZGVmaW5lZCk7XG4gICAgICB9XG5cbiAgICAgIGluc3Quc2V0dGluZ3Mud2hlZWxzID0gZ2VuV2hlZWxzKCk7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uV2hlZWxHZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIG9uV2hlZWxHZXN0dXJlU3RhcnQoZXYpIHtcbiAgICAgIGlmIChldi5pbmRleCA9PSBncm91cFdoZWVsSWR4KSB7XG4gICAgICAgIHMucmVhZG9ubHkgPSBbZmFsc2UsIHRydWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25XaGVlbEFuaW1hdGlvbkVuZDogZnVuY3Rpb24gb25XaGVlbEFuaW1hdGlvbkVuZChldikge1xuICAgICAgdmFyIHZhbHVlcyA9IGluc3QuZ2V0QXJyYXlWYWwodHJ1ZSk7XG5cbiAgICAgIGlmIChldi5pbmRleCA9PSBncm91cFdoZWVsSWR4KSB7XG4gICAgICAgIHMucmVhZG9ubHkgPSBvcmlnUmVhZE9ubHk7XG5cbiAgICAgICAgaWYgKCF0YXBTZWxlY3QpIHtcbiAgICAgICAgICBsb2FkR3JvdXBPcHRpb25zKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXYuaW5kZXggPT0gb3B0aW9uV2hlZWxJZHggJiYgdmFsdWVzW29wdGlvbldoZWVsSWR4XSAhPSBvcHRpb24pIHtcbiAgICAgICAgb3B0aW9uID0gdmFsdWVzW29wdGlvbldoZWVsSWR4XTtcblxuICAgICAgICBpZiAoaGFzR3JvdXBXaGVlbCAmJiBvcHRpb25zW29wdGlvbl0gJiYgb3B0aW9uc1tvcHRpb25dLmdyb3VwICE9IGdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAgPSBvcHRpb25zW29wdGlvbl0uZ3JvdXA7XG4gICAgICAgICAgdmFsdWVzW2dyb3VwV2hlZWxJZHhdID0gZ3JvdXA7XG4gICAgICAgICAgaW5zdC5fdGVtcFNlbGVjdGVkW2dyb3VwV2hlZWxJZHhdID0gYXJyYXlUb09iamVjdChbZ3JvdXBdKTtcbiAgICAgICAgICBpbnN0LnNldEFycmF5VmFsKHZhbHVlcywgZmFsc2UsIGZhbHNlLCB0cnVlLCBhbmltVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSXRlbVRhcDogZnVuY3Rpb24gb25JdGVtVGFwKGV2KSB7XG4gICAgICB2YXIgdmFsdWVzO1xuXG4gICAgICBpZiAoZXYuaW5kZXggPT0gb3B0aW9uV2hlZWxJZHgpIHtcbiAgICAgICAgc2VsZWN0ZWRUZXh0c1tldi52YWx1ZV0gPSBvcHRpb25zW2V2LnZhbHVlXS50ZXh0O1xuXG4gICAgICAgIGlmICh0YXBTZWxlY3QgJiYgIW11bHRpcGxlICYmIGV2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgaW5zdC5fcHJldkl0ZW1UYXAgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXYuaW5kZXggPT0gZ3JvdXBXaGVlbElkeCAmJiB0YXBTZWxlY3QpIHtcbiAgICAgICAgaWYgKGV2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgaW5zdC5fcHJldkl0ZW1UYXAgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcyA9IGluc3QuZ2V0QXJyYXlWYWwodHJ1ZSk7XG4gICAgICAgIHZhbHVlc1tncm91cFdoZWVsSWR4XSA9IGV2LnZhbHVlO1xuICAgICAgICBsb2FkR3JvdXBPcHRpb25zKHZhbHVlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlKCkge1xuICAgICAgaWYgKGhhc1JlbW90ZURhdGEgJiYgcy5kYXRhLnJlbW90ZUZpbHRlciAmJiBmaWx0ZXJUZXh0KSB7XG4gICAgICAgIGluc3QucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgICAvLyBSZW1vdmUgZHVtbXkgaW5wdXRcbiAgICAgIGlmIChpbnN0Ll8kaW5wdXQpIHtcbiAgICAgICAgaW5zdC5fJGlucHV0LnJlbW92ZSgpO1xuICAgICAgfSAvLyBSZXZlcnQgc2VsZWN0IGF0dHJpYnV0ZXMgYW5kIGNsYXNzZXNcblxuXG4gICAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLXNlbC1oZG4nKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBNYnNjU2VsZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1NlbGVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjU2VsZWN0KGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIF90aGlzLm9uRmlsdGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1NlbGVjdC5wcm90b3R5cGUucmVmcmVzaERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlLnJlZnJlc2gobmV3RGF0YSk7XG4gICAgfTtcbiAgICBNYnNjU2VsZWN0LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycgJiYgdGFyZ2V0Ll9lbGVtZW50UmVmICYmIHRhcmdldC5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Ll9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0VW5kZXIgPSAkJDEoJ2lucHV0JywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRVbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gaW5wdXRVbmRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGVudElucHV0ID0gJCQxKCdpbnB1dCcsIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0ICYmIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lPTi1JTlBVVCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ3NlbGVjdCcsIGlucHV0OiB0YXJnZXQgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2VsZWN0JDEodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1ic2NTZWxlY3QucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGNvbnRlbnRTZWxlY3QgPSAkJDEoJ3NlbGVjdCcsIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChjb250ZW50U2VsZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gY29udGVudFNlbGVjdFswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0RWxlbWVudC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU2VsZWN0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc011bHRpID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zZWxlY3QgJiYgdGhpcy5vcHRpb25zLnNlbGVjdCAhPT0gJ3NpbmdsZSc7XG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5LmRhdGEgPSBbXTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWJzY1NlbGVjdC5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFkZWVwRXF1YWxzQXJyYXkodiwgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IGlubmVyVmFsdWUgIT09IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1NlbGVjdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1zZWxlY3RdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1NlbGVjdC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NTZWxlY3QucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjb3VudGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdkYXRhJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLWRhdGEnLF0gfSxdLFxuICAgICAgICAnZGF0YVRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RhdGFHcm91cCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZGF0YVZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdmaWx0ZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2ZpbHRlclBsYWNlaG9sZGVyVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZmlsdGVyRW1wdHlUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdncm91cCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZ3JvdXBMYWJlbCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW5wdXRDbGFzcyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnaW52YWxpZCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWwnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzZWxlY3QnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3Nob3dJbnB1dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb25GaWx0ZXInOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3RhcmdldCc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy10YXJnZXQnLF0gfSxdLFxuICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtc2VsZWN0JyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydtYnNjLXNlbGVjdENoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1NlbGVjdDtcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xudmFyIE1ic2NTZWxlY3RDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjU2VsZWN0Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NTZWxlY3RDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcbiAgICAgICAgX3RoaXMuZHJvcGRvd24gPSB0cnVlO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgdmFyIHNob3dJbnB1dCA9IHRoaXMuc2hvd0lucHV0IHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNob3dJbnB1dCk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5maWx0ZXIgfHwgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuZmlsdGVyKTtcbiAgICAgICAgICAgIGlmIChzaG93SW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lT3B0aW9uc09iai5zaG93SW5wdXQgPSB0aGlzLnNob3dJbnB1dCA9ICEhZmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjU2VsZWN0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjU2VsZWN0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NTZWxlY3RDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2RhdGEnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Ryb3Bkb3duJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdwbGFjZWhvbGRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIE1ic2NTZWxlY3RDb21wb25lbnQ7XG59KE1ic2NTZWxlY3QpKTtcbnZhciBNYnNjU2VsZWN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYnNjU2VsZWN0TW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjU2VsZWN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NTZWxlY3QsIE1ic2NTZWxlY3RDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY1NlbGVjdCwgTWJzY1NlbGVjdENvbXBvbmVudF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NTZWxlY3RNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY1NlbGVjdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBUaW1lciA9IFNjcm9sbGVyO1xudmFyIGRlZmF1bHRzJGUgPSB7XG4gIGF1dG9zdGFydDogZmFsc2UsXG4gIHN0ZXA6IDEsXG4gIC8vIGluIHNlY29uZHNcbiAgdXNlU2hvcnRMYWJlbHM6IGZhbHNlLFxuICAvLyBMb2NhbGl6YXRpb25cbiAgbGFiZWxzOiBbJ1llYXJzJywgJ01vbnRocycsICdEYXlzJywgJ0hvdXJzJywgJ01pbnV0ZXMnLCAnU2Vjb25kcycsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnWXJzJywgJ010aHMnLCAnRGF5cycsICdIcnMnLCAnTWlucycsICdTZWNzJywgJyddLFxuICBzdGFydFRleHQ6ICdTdGFydCcsXG4gIHN0b3BUZXh0OiAnU3RvcCcsXG4gIHJlc2V0VGV4dDogJ1Jlc2V0JyxcbiAgbGFwVGV4dDogJ0xhcCcsXG4gIGhpZGVUZXh0OiAnSGlkZScsXG4gIG1vZGU6ICdjb3VudGRvd24nXG59O1xuXG5wcmVzZXRzLnRpbWVyID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgZGF0ZSB0byBVVENcbiAgICogQHBhcmFtICAgZCAgIChEYXRlKSAgRGF0ZSB0byBjb252ZXJ0XG4gICAqIEByZXR1cm4gICAgICAoRGF0ZSkgIERhdGUgY29udmVydGVkIHRvIFVUQ1xuICAgKi9cbiAgZnVuY3Rpb24gdG9VdGMoZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDSG91cnMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcGFydHMgb2YgdGhlIHRpbWUgZGlmZmVybmNlXG4gICAqIEBwYXJhbSAgIHRpbWUgICAgKEludGVnZXIpICAgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiAgICAgICAgICAoT2JqZWN0KSAgICBUaW1lIHNwbGl0dGVkIHRvIHRoZSByZXF1aXJlZCBwYXJ0cyAoeWVhcnMsIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UGFydHModGltZSkge1xuICAgIHZhciByZXQgPSB7fTtcblxuICAgIGlmIChkYXRlTW9kZSAmJiBvYmpbbWF4XS5pbmRleCA+IG9iai5kYXlzLmluZGV4KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICB2LFxuICAgICAgICAgIG8sXG4gICAgICAgICAgcHJldixcbiAgICAgICAgICBub3cgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGQyID0gdXAgPyBub3cgOiBvcmlnVGltZSxcbiAgICAgICAgICBkMSA9IHVwID8gb3JpZ1RpbWUgOiBub3c7XG4gICAgICBkMSA9IHRvVXRjKGQxKTtcbiAgICAgIGQyID0gdG9VdGMoZDIpO1xuICAgICAgcmV0LnllYXJzID0gZDIuZ2V0RnVsbFllYXIoKSAtIGQxLmdldEZ1bGxZZWFyKCk7XG4gICAgICByZXQubW9udGhzID0gZDIuZ2V0TW9udGgoKSAtIGQxLmdldE1vbnRoKCk7XG4gICAgICByZXQuZGF5cyA9IGQyLmdldERhdGUoKSAtIGQxLmdldERhdGUoKTtcbiAgICAgIHJldC5ob3VycyA9IGQyLmdldEhvdXJzKCkgLSBkMS5nZXRIb3VycygpO1xuICAgICAgcmV0Lm1pbnV0ZXMgPSBkMi5nZXRNaW51dGVzKCkgLSBkMS5nZXRNaW51dGVzKCk7XG4gICAgICByZXQuc2Vjb25kcyA9IGQyLmdldFNlY29uZHMoKSAtIGQxLmdldFNlY29uZHMoKTtcbiAgICAgIHJldC5mcmFjdCA9IChkMi5nZXRNaWxsaXNlY29uZHMoKSAtIGQxLmdldE1pbGxpc2Vjb25kcygpKSAvIDEwO1xuXG4gICAgICBmb3IgKGkgPSB1bmlxdWUubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHYgPSB1bmlxdWVbaSAtIDFdO1xuICAgICAgICBvID0gb2JqW3ZdO1xuICAgICAgICBwcmV2ID0gdW5pcXVlWyQkMS5pbkFycmF5KHYsIHVuaXF1ZSkgLSAxXTtcblxuICAgICAgICBpZiAob2JqW3ByZXZdICYmIHJldFt2XSA8IDApIHtcbiAgICAgICAgICByZXRbcHJldl0tLTtcbiAgICAgICAgICByZXRbdl0gKz0gcHJldiA9PSAnbW9udGhzJyA/IDMyIC0gbmV3IERhdGUoZDIuZ2V0RnVsbFllYXIoKSwgZDIuZ2V0TW9udGgoKSwgMzIpLmdldERhdGUoKSA6IG8udW50aWwgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggPT0gJ21vbnRocycpIHtcbiAgICAgICAgcmV0Lm1vbnRocyArPSByZXQueWVhcnMgKiAxMjtcbiAgICAgICAgZGVsZXRlIHJldC55ZWFycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJCQxKHVuaXF1ZSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICBpZiAob2JqW3ZdLmluZGV4IDw9IG9ialttYXhdLmluZGV4KSB7XG4gICAgICAgICAgcmV0W3ZdID0gTWF0aC5mbG9vcih0aW1lIC8gb2JqW3ZdLmxpbWl0KTtcbiAgICAgICAgICB0aW1lIC09IHJldFt2XSAqIG9ialt2XS5saW1pdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgc3BlY2lmaWMgd2hlZWxcbiAgICogQHBhcmFtICAgdiAgIChTdHJpbmcpICBVbmlxdWUgaWRlbnRpZmllclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdlbldoZWVsKHYpIHtcbiAgICB2YXIgc3QgPSAxLFxuICAgICAgICBvID0gb2JqW3ZdLFxuICAgICAgICB3aCA9IG8ud2hlZWwsXG4gICAgICAgIHByZWZpeCA9IG8ucHJlZml4LFxuICAgICAgICBmcm9tID0gMCxcbiAgICAgICAgdW50aWwgPSBvLnVudGlsLFxuICAgICAgICBuZXh0ID0gb2JqW3VuaXF1ZVskJDEuaW5BcnJheSh2LCB1bmlxdWUpIC0gMV1dO1xuXG4gICAgaWYgKG8uaW5kZXggPD0gb2JqW21heF0uaW5kZXggJiYgKCFuZXh0IHx8IG5leHQubGltaXQgPiBzdGVwKSkge1xuICAgICAgaWYgKCF3aGVlbHNbdl0pIHtcbiAgICAgICAgd1swXS5wdXNoKHdoKTtcbiAgICAgIH1cblxuICAgICAgd2hlZWxzW3ZdID0gMTtcbiAgICAgIHdoLmRhdGEgPSBbXTtcbiAgICAgIHdoLmxhYmVsID0gby5sYWJlbCB8fCAnJztcbiAgICAgIHdoLmNzc0NsYXNzID0gJ21ic2MtdGltZXItd2hsLScgKyB2O1xuXG4gICAgICBpZiAoc3RlcCA+PSBvLmxpbWl0KSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBzdGVwcyBvbiBsYXN0IHdoZWVsXG4gICAgICAgIHN0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZChzdGVwIC8gby5saW1pdCksIDEpO1xuICAgICAgICB0c3RlcCA9IHN0ICogby5saW1pdDsgLy8gVGltZXIgaXMgY2FsY3VsYXRlZCB3aXRoIHJvdW5kZWQgc3RlcFxuICAgICAgfVxuXG4gICAgICBpZiAodiA9PSBtYXgpIHtcbiAgICAgICAgd2gubWluID0gMDtcblxuICAgICAgICB3aC5kYXRhID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICBkaXNwbGF5OiBnZW5WYWx1ZShpLCBwcmVmaXgsIG8ubGFiZWwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB3aC5nZXRJbmRleCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBmcm9tOyBpIDw9IHVudGlsOyBpICs9IHN0KSB7XG4gICAgICAgICAgd2guZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgZGlzcGxheTogZ2VuVmFsdWUoaSwgcHJlZml4LCBvLmxhYmVsKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVmFsdWUoaSwgcHJlZml4LCBsYmwpIHtcbiAgICByZXR1cm4gKHByZWZpeCB8fCAnJykgKyAoaSA8IDEwID8gJzAnIDogJycpICsgaSArICc8c3BhbiBjbGFzcz1cIm1ic2MtdGltZXItbGJsXCI+JyArIGxibCArICc8L3NwYW4+JztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRpbWUgaW50byBhcnJheSBjb250YWluaW5nIHRoZSBwYXJ0c1xuICAgKiBAcGFyYW0gICB0aW1lICAgIChJbnRlZ2VyKSAgIFRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4gICAgICAgICAgKEFycmF5KSAgICAgVGltZSBzcGxpdHRlZCB0byB0aGUgcmVxdWlyZWQgcGFydHMgKHllYXJzLCBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFycmF5KHRpbWUpIHtcbiAgICB2YXIgYXJyID0gW10sXG4gICAgICAgIHN0LFxuICAgICAgICBwID0gZ2V0UGFydHModGltZSk7XG4gICAgJCQxKHVuaXF1ZSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgaWYgKHdoZWVsc1t2XSkge1xuICAgICAgICBzdCA9IE1hdGgubWF4KE1hdGgucm91bmQoc3RlcCAvIG9ialt2XS5saW1pdCksIDEpO1xuICAgICAgICBhcnIucHVzaChNYXRoLnJvdW5kKHBbdl0gLyBzdCkgKiBzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgdGltZVxuICAgKiBAcGFyYW0gICByZXNldCAgIChCb29sZWFuKSAgIFJlc2V0IHRoZSB0aW1lciBvciBub3RcbiAgICovXG5cblxuICBmdW5jdGlvbiBjYWxjVGltZShyZXNldCkge1xuICAgIGlmIChkYXRlTW9kZSkge1xuICAgICAgdGltZSA9IG9yaWdUaW1lIC0gbmV3IERhdGUoKTtcblxuICAgICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAgIHRpbWUgKj0gLTE7XG4gICAgICAgIHVwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRpbWVyID0gMDtcbiAgICAgIGluZmluaXQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAob3JpZ1RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5maW5pdCA9IGZhbHNlO1xuICAgICAgdGltZSA9IG9yaWdUaW1lICogMTAwMDtcbiAgICAgIHVwID0gcy5tb2RlICE9ICdjb3VudGRvd24nO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgdGltZXIgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lID0gMDtcbiAgICAgIHVwID0gcy5tb2RlICE9ICdjb3VudGRvd24nO1xuICAgICAgaW5maW5pdCA9IHVwO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgdGltZXIgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAkJDEoJy5tYnNjLWZyLXcnLCBjdHgpLmFkZENsYXNzKCdtYnNjLXRpbWVyLXJ1bm5pbmcgbWJzYy10aW1lci1sb2NrZWQnKTtcbiAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXRvZ2dsZS1jID4gZGl2JywgY3R4KS50ZXh0KHMuc3RvcFRleHQpO1xuXG4gICAgICBpZiAoaW5zdC5idXR0b25zLnN0YXJ0Lmljb24pIHtcbiAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tdG9nZ2xlLWMgPiBkaXYnLCBjdHgpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMuc3RhcnQuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnN0LmJ1dHRvbnMuc3RvcC5pY29uKSB7XG4gICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXRvZ2dsZS1jID4gZGl2JywgY3R4KS5hZGRDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLnN0b3AuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLm1vZGUgPT0gJ3N0b3B3YXRjaCcpIHtcbiAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tcmVzZXRsYXAtYyA+IGRpdicsIGN0eCkudGV4dChzLmxhcFRleHQpO1xuXG4gICAgICAgIGlmIChpbnN0LmJ1dHRvbnMucmVzZXQuaWNvbikge1xuICAgICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXJlc2V0bGFwLWMgPiBkaXYnLCBjdHgpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMucmVzZXQuaWNvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdC5idXR0b25zLmxhcC5pY29uKSB7XG4gICAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tcmVzZXRsYXAtYyA+IGRpdicsIGN0eCkuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGluc3QuYnV0dG9ucy5sYXAuaWNvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy10aW1lci1ydW5uaW5nJyk7XG4gICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi10b2dnbGUtYyA+IGRpdicsIGN0eCkudGV4dChzLnN0YXJ0VGV4dCk7XG5cbiAgICAgIGlmIChpbnN0LmJ1dHRvbnMuc3RhcnQuaWNvbikge1xuICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi10b2dnbGUtYyA+IGRpdicsIGN0eCkuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGluc3QuYnV0dG9ucy5zdGFydC5pY29uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3QuYnV0dG9ucy5zdG9wLmljb24pIHtcbiAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tdG9nZ2xlLWMgPiBkaXYnLCBjdHgpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMuc3RvcC5pY29uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubW9kZSA9PSAnc3RvcHdhdGNoJykge1xuICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi1yZXNldGxhcC1jID4gZGl2JywgY3R4KS50ZXh0KHMucmVzZXRUZXh0KTtcblxuICAgICAgICBpZiAoaW5zdC5idXR0b25zLnJlc2V0Lmljb24pIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi1yZXNldGxhcC1jID4gZGl2JywgY3R4KS5hZGRDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLnJlc2V0Lmljb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3QuYnV0dG9ucy5sYXAuaWNvbikge1xuICAgICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXJlc2V0bGFwLWMgPiBkaXYnLCBjdHgpLnJlbW92ZUNsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMubGFwLmljb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGksXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIHRzdGVwLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgc3RhcnRlZCxcbiAgICAgIGVsbGFwc2VkLFxuICAgICAgdGltZSxcbiAgICAgIHRpbWVyLFxuICAgICAgdXAsXG4gICAgICBjdHgsXG4gICAgICBsYXAsXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJGUsIG9yaWcpLFxuICAgICAgbGJscyA9IHMudXNlU2hvcnRMYWJlbHMgPyBzLmxhYmVsc1Nob3J0IDogcy5sYWJlbHMsXG4gICAgICBhbmltVGltZSA9IDEwMDAsXG4gICAgICBidXR0b25zID0gWydyZXNldGxhcCcsICd0b2dnbGUnXSxcbiAgICAgIHVuaXF1ZSA9IFsneWVhcnMnLCAnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJywgJ2ZyYWN0J10sXG4gICAgICBvYmogPSB7XG4gICAgJ3llYXJzJzoge1xuICAgICAgaW5kZXg6IDYsXG4gICAgICB1bnRpbDogMTAsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NSxcbiAgICAgIGxhYmVsOiBsYmxzWzBdLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnbW9udGhzJzoge1xuICAgICAgaW5kZXg6IDUsXG4gICAgICB1bnRpbDogMTEsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwLFxuICAgICAgbGFiZWw6IGxibHNbMV0sXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdkYXlzJzoge1xuICAgICAgaW5kZXg6IDQsXG4gICAgICB1bnRpbDogMzEsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICAgIGxhYmVsOiBsYmxzWzJdLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnaG91cnMnOiB7XG4gICAgICBpbmRleDogMyxcbiAgICAgIHVudGlsOiAyMyxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAgKiA2MCxcbiAgICAgIGxhYmVsOiBsYmxzWzNdLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnbWludXRlcyc6IHtcbiAgICAgIGluZGV4OiAyLFxuICAgICAgdW50aWw6IDU5LFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCxcbiAgICAgIGxhYmVsOiBsYmxzWzRdLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnc2Vjb25kcyc6IHtcbiAgICAgIGluZGV4OiAxLFxuICAgICAgdW50aWw6IDU5LFxuICAgICAgbGltaXQ6IDEwMDAsXG4gICAgICBsYWJlbDogbGJsc1s1XSxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ2ZyYWN0Jzoge1xuICAgICAgaW5kZXg6IDAsXG4gICAgICB1bnRpbDogOTksXG4gICAgICBsaW1pdDogMTAsXG4gICAgICBsYWJlbDogbGJsc1s2XSxcbiAgICAgIHByZWZpeDogJy4nLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfVxuICB9LFxuICAgICAgd2hlZWxzID0ge30sXG4gICAgICBsYXBzID0gW10sXG4gICAgICBsYXN0TGFwID0gMCxcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZSxcbiAgICAgIHN0b3BwZWQgPSB0cnVlLFxuICAgICAgaW5maW5pdCA9IGZhbHNlLFxuICAgICAgc3RlcCA9IE1hdGgubWF4KDEwLCBzLnN0ZXAgKiAxMDAwKSxcbiAgICAgIG1heCA9IHMubWF4V2hlZWwsXG4gICAgICBsb2NrZWQgPSBzLm1vZGUgPT0gJ3N0b3B3YXRjaCcgfHwgZGF0ZU1vZGUsXG4gICAgICBvcmlnVGltZSA9IHMudGFyZ2V0VGltZSxcbiAgICAgIGRhdGVNb2RlID0gb3JpZ1RpbWUgJiYgb3JpZ1RpbWUuZ2V0VGltZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgdyA9IFtbXV07IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG4gIC8vIFN0YXJ0IHRoZSBjb3VudGVyXG5cbiAgaW5zdC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgaW5zdC5yZXNldCgpO1xuICAgIH1cblxuICAgIGlmICghcnVubmluZykge1xuICAgICAgY2FsY1RpbWUoKTtcblxuICAgICAgaWYgKCFpbmZpbml0ICYmIHRpbWVyID49IHRpbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhcnRUaW1lID0gdGltZXI7XG4gICAgICBzLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgIGluc3Quc2V0VmFsKGdldEFycmF5KHVwID8gdGltZXIgOiB0aW1lIC0gdGltZXIpLCB0cnVlLCB0cnVlLCBmYWxzZSwgMTAwKTtcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW1lciA9IG5ldyBEYXRlKCkgLSBzdGFydGVkICsgc3RhcnRUaW1lO1xuICAgICAgICBpbnN0LnNldFZhbChnZXRBcnJheSh1cCA/IHRpbWVyIDogdGltZSAtIHRpbWVyKSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIE1hdGgubWluKDEwMCwgdHN0ZXAgLSAxMCkpO1xuXG4gICAgICAgIGlmICghaW5maW5pdCAmJiB0aW1lciArIHRzdGVwID49IHRpbWUpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERvIGxhc3QgdGljayB3aXRoIHByZWNpc2lvblxuICAgICAgICAgICAgaW5zdC5zdG9wKCk7XG4gICAgICAgICAgICB0aW1lciA9IHRpbWU7XG4gICAgICAgICAgICBpbnN0LnNldFZhbChnZXRBcnJheSh1cCA/IHRpbWVyIDogMCksIHRydWUsIHRydWUsIGZhbHNlLCAxMDApO1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdvbkZpbmlzaCcsIHtcbiAgICAgICAgICAgICAgdGltZTogdGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB0aW1lIC0gdGltZXIpO1xuICAgICAgICB9XG4gICAgICB9LCB0c3RlcCk7XG4gICAgICB1cGRhdGVVSSgpO1xuICAgICAgaW5zdC50cmlnZ2VyKCdvblN0YXJ0Jyk7XG4gICAgfVxuICB9OyAvLyBTdG9wIHRoZSBjb3VudGVyXG5cblxuICBpbnN0LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOyAvLyBUaW1lIGNvcnJlY3Rpb25cblxuICAgICAgdGltZXIgPSBuZXcgRGF0ZSgpIC0gc3RhcnRlZCArIHN0YXJ0VGltZTtcbiAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICBpbnN0LnRyaWdnZXIoJ29uU3RvcCcsIHtcbiAgICAgICAgZWxsYXBzZWQ6IHRpbWVyXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaW5zdC50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIGluc3Quc3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0LnN0YXJ0KCk7XG4gICAgfVxuICB9OyAvLyBSZXNldCB0aGUgY291bnRlclxuXG5cbiAgaW5zdC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0LnN0b3AoKTtcbiAgICB0aW1lciA9IDA7XG4gICAgbGFwcyA9IFtdO1xuICAgIGxhc3RMYXAgPSAwO1xuICAgIGluc3Quc2V0VmFsKGdldEFycmF5KHVwID8gMCA6IHRpbWUpLCB0cnVlLCB0cnVlLCBmYWxzZSwgYW5pbVRpbWUpO1xuICAgIGluc3Quc2V0dGluZ3MucmVhZG9ubHkgPSBsb2NrZWQ7XG4gICAgc3RvcHBlZCA9IHRydWU7XG5cbiAgICBpZiAoIWxvY2tlZCkge1xuICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy10aW1lci1sb2NrZWQnKTtcbiAgICB9XG5cbiAgICBpbnN0LnRyaWdnZXIoJ29uUmVzZXQnKTtcbiAgfTsgLy8gTGFwXG5cblxuICBpbnN0LmxhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocnVubmluZykge1xuICAgICAgZWxsYXBzZWQgPSBuZXcgRGF0ZSgpIC0gc3RhcnRlZCArIHN0YXJ0VGltZTtcbiAgICAgIGxhcCA9IGVsbGFwc2VkIC0gbGFzdExhcDtcbiAgICAgIGxhc3RMYXAgPSBlbGxhcHNlZDtcbiAgICAgIGxhcHMucHVzaChlbGxhcHNlZCk7XG4gICAgICBpbnN0LnRyaWdnZXIoJ29uTGFwJywge1xuICAgICAgICBlbGxhcHNlZDogZWxsYXBzZWQsXG4gICAgICAgIGxhcDogbGFwLFxuICAgICAgICBsYXBzOiBsYXBzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgaW5zdC5yZXNldGxhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocnVubmluZyAmJiBzLm1vZGUgPT0gJ3N0b3B3YXRjaCcpIHtcbiAgICAgIGluc3QubGFwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3QucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgaW5zdC5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIGluc3Quc2V0VGltZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgb3JpZ1RpbWUgPSB0IC8gMTAwMDtcbiAgICB0aW1lID0gdDtcbiAgfTtcblxuICBpbnN0LmdldEVsbGFwc2VkVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RvcHBlZCA/IDAgOiBydW5uaW5nID8gbmV3IERhdGUoKSAtIHN0YXJ0ZWQgKyBzdGFydFRpbWUgOiB0aW1lcjtcbiAgfTtcblxuICBpbnN0LnNldEVsbGFwc2VkVGltZSA9IGZ1bmN0aW9uICh0LCBjaGFuZ2UpIHtcbiAgICBpZiAoIXN0b3BwZWQpIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVyID0gdDtcbiAgICAgIHN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgaW5zdC5zZXRWYWwoZ2V0QXJyYXkodXAgPyB0aW1lciA6IHRpbWUgLSB0aW1lciksIHRydWUsIGNoYW5nZSwgZmFsc2UsIGFuaW1UaW1lKTtcbiAgICB9XG4gIH07IC8vIC0tLVxuICAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgY2FsY1RpbWUodHJ1ZSk7XG5cbiAgaWYgKCFtYXggJiYgIXRpbWUpIHtcbiAgICBtYXggPSAnbWludXRlcyc7XG4gIH1cblxuICBpZiAocy5kaXNwbGF5ICE9PSAnaW5saW5lJykge1xuICAgIGJ1dHRvbnMudW5zaGlmdCgnaGlkZScpO1xuICB9IC8vIERldGVybWluZSBtYXhpbXVtIHdoZWVsXG5cblxuICBpZiAoIW1heCkge1xuICAgICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgIGlmICghbWF4ICYmIHRpbWUgPj0gb2JqW3ZdLmxpbWl0KSB7XG4gICAgICAgIG1heCA9IHY7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBHZW5lcmF0ZSB3aGVlbHNcblxuXG4gICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICBnZW5XaGVlbCh2KTtcbiAgfSk7XG4gIHRzdGVwID0gTWF0aC5tYXgoOTcsIHRzdGVwKTsgLy8gdGltZXIgc3RlcCBjYW5ub3QgYmUgbGVzcyB0aGVuIDEwMCBtc1xuXG4gIGlmIChzLmF1dG9zdGFydCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaW5zdC5zdGFydCgpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgaW5zdC5oYW5kbGVycy50b2dnbGUgPSBpbnN0LnRvZ2dsZTtcbiAgaW5zdC5oYW5kbGVycy5zdGFydCA9IGluc3Quc3RhcnQ7XG4gIGluc3QuaGFuZGxlcnMuc3RvcCA9IGluc3Quc3RvcDtcbiAgaW5zdC5oYW5kbGVycy5yZXNldGxhcCA9IGluc3QucmVzZXRsYXA7XG4gIGluc3QuaGFuZGxlcnMucmVzZXQgPSBpbnN0LnJlc2V0O1xuICBpbnN0LmhhbmRsZXJzLmxhcCA9IGluc3QubGFwO1xuICBpbnN0LmJ1dHRvbnMudG9nZ2xlID0ge1xuICAgIHBhcmVudENsYXNzOiAnbWJzYy10aW1lci1idG4tdG9nZ2xlLWMnLFxuICAgIHRleHQ6IHMuc3RhcnRUZXh0LFxuICAgIGljb246IHMuc3RhcnRJY29uLFxuICAgIGhhbmRsZXI6ICd0b2dnbGUnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5zdGFydCA9IHtcbiAgICB0ZXh0OiBzLnN0YXJ0VGV4dCxcbiAgICBpY29uOiBzLnN0YXJ0SWNvbixcbiAgICBoYW5kbGVyOiAnc3RhcnQnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5zdG9wID0ge1xuICAgIHRleHQ6IHMuc3RvcFRleHQsXG4gICAgaWNvbjogcy5zdG9wSWNvbixcbiAgICBoYW5kbGVyOiAnc3RvcCdcbiAgfTtcbiAgaW5zdC5idXR0b25zLnJlc2V0ID0ge1xuICAgIHRleHQ6IHMucmVzZXRUZXh0LFxuICAgIGljb246IHMucmVzZXRJY29uLFxuICAgIGhhbmRsZXI6ICdyZXNldCdcbiAgfTtcbiAgaW5zdC5idXR0b25zLmxhcCA9IHtcbiAgICB0ZXh0OiBzLmxhcFRleHQsXG4gICAgaWNvbjogcy5sYXBJY29uLFxuICAgIGhhbmRsZXI6ICdsYXAnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5yZXNldGxhcCA9IHtcbiAgICBwYXJlbnRDbGFzczogJ21ic2MtdGltZXItYnRuLXJlc2V0bGFwLWMnLFxuICAgIHRleHQ6IHMucmVzZXRUZXh0LFxuICAgIGljb246IHMucmVzZXRJY29uLFxuICAgIGhhbmRsZXI6ICdyZXNldGxhcCdcbiAgfTtcbiAgaW5zdC5idXR0b25zLmhpZGUgPSB7XG4gICAgcGFyZW50Q2xhc3M6ICdtYnNjLXRpbWVyLWJ0bi1oaWRlLWMnLFxuICAgIHRleHQ6IHMuaGlkZVRleHQsXG4gICAgaWNvbjogcy5jbG9zZUljb24sXG4gICAgaGFuZGxlcjogJ2NhbmNlbCdcbiAgfTsgLy8gUmV0dXJuIHNldHRpbmdzXG5cbiAgcmV0dXJuIHtcbiAgICBtaW5XaWR0aDogMTAwLFxuICAgIHdoZWVsczogdyxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICByZWFkb25seTogbG9ja2VkLFxuICAgIGJ1dHRvbnM6IGJ1dHRvbnMsXG4gICAgY29tcENsYXNzOiAnbWJzYy10aW1lciBtYnNjLXNjJyxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgICAgcmV0dXJuIGdldEFycmF5KHVwID8gMCA6IHRpbWUpO1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGQpIHtcbiAgICAgIHZhciByZXQgPSAnJyxcbiAgICAgICAgICBqID0gMDtcbiAgICAgICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgaWYgKHYgPT0gJ2ZyYWN0Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbHNbdl0pIHtcbiAgICAgICAgICByZXQgKz0gZFtqXSArICh2ID09ICdzZWNvbmRzJyAmJiB3aGVlbHMuZnJhY3QgPyAnLicgKyBkW2ogKyAxXSA6ICcnKSArICcgJyArIGxibHNbaV0gKyAnICc7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIHZhbHVlcyA9IGRhdGEudmFsdWVzLFxuICAgICAgICAgIGkgPSBkYXRhLmluZGV4LFxuICAgICAgICAgIGogPSAwO1xuXG4gICAgICBpZiAoc3RvcHBlZCAmJiBpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3JpZ1RpbWUgPSAwO1xuICAgICAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgaWYgKHdoZWVsc1t2XSkge1xuICAgICAgICAgICAgb3JpZ1RpbWUgKz0gb2JqW3ZdLmxpbWl0ICogdmFsdWVzW2pdO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdUaW1lIC89IDEwMDA7XG4gICAgICAgIGNhbGNUaW1lKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25CZWZvcmVTaG93OiBmdW5jdGlvbiBvbkJlZm9yZVNob3coKSB7XG4gICAgICBzLnNob3dMYWJlbCA9IHRydWU7XG4gICAgfSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgICBjdHggPSAkJDEoZXYudGFyZ2V0KTtcbiAgICAgIHVwZGF0ZVVJKCk7XG5cbiAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5hZGRDbGFzcygnbWJzYy10aW1lci1sb2NrZWQnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uUG9zaXRpb246IGZ1bmN0aW9uIG9uUG9zaXRpb24oZXYpIHtcbiAgICAgIC8vIEZvcmNlIHdpZHRoIHRvIGZpdCBidXR0b25zXG4gICAgICAkJDEoJy5tYnNjLWZyLXcnLCBldi50YXJnZXQpLmNzcygnbWluLXdpZHRoJywgMCkuY3NzKCdtaW4td2lkdGgnLCAkJDEoJy5tYnNjLWZyLWJ0bi1jb250JywgZXYudGFyZ2V0KVswXS5vZmZzZXRXaWR0aCk7XG4gICAgfSxcbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBNYnNjVGltZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1RpbWVyKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLm9uTGFwID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vbkZpbmlzaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25SZXNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25TdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMub25TdG9wID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1RpbWVyLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UuX3RpbWVyIHx8IE1hdGguYWJzKHRoaXMuaW5zdGFuY2UuX3RpbWVyIC0gdikgPiAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0RWxsYXBzZWRUaW1lKHYsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1RpbWVyLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgJCQxKHRoaXMuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5zdGFuY2UuX3RpbWVyID0gdGhhdC5pbnN0YW5jZS5nZXRFbGxhcHNlZFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5jb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udHJvbC5jb250cm9sLnBhdGNoVmFsdWUodGhhdC5pbnN0YW5jZS5fdGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkNoYW5nZUVtaXR0ZXIuZW1pdCh0aGF0Lmluc3RhbmNlLl90aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWJzY1RpbWVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ3RpbWVyJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBUaW1lcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1RpbWVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXRpbWVyXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUaW1lci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUaW1lci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2F1dG9zdGFydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4V2hlZWwnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ21vZGUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0ZXAnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3RhcmdldFRpbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3VzZVNob3J0TGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdoaWRlVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdsYWJlbHNTaG9ydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFwVGV4dCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncmVzZXRUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzdGFydFRleHQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0b3BUZXh0JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvbkxhcCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvbkZpbmlzaCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgICAgICdvblJlc2V0JzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29uU3RhcnQnOiBbeyB0eXBlOiBPdXRwdXQgfSxdLFxuICAgICAgICAnb25TdG9wJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2Mtb3B0aW9ucycsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy10aW1lcicsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy10aW1lckNoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1RpbWVyO1xufShNYnNjU2Nyb2xsZXJCYXNlKSk7XG52YXIgTWJzY1RpbWVyQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1RpbWVyQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NUaW1lckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1ic2NUaW1lckNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xuICAgIH07XG4gICAgTWJzY1RpbWVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtdGltZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUaW1lckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgXTsgfTtcbiAgICBNYnNjVGltZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdpbnB1dEljb24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24nLF0gfSxdLFxuICAgICAgICAnaWNvbkFsaWduJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uLWFsaWduJyxdIH0sXSxcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvck1lc3NhZ2UnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1RpbWVyQ29tcG9uZW50O1xufShNYnNjVGltZXIpKTtcbnZhciBNYnNjVGltZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NUaW1lck1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY1RpbWVyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NUaW1lciwgTWJzY1RpbWVyQ29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01ic2NUaW1lciwgTWJzY1RpbWVyQ29tcG9uZW50XVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1RpbWVyTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NUaW1lck1vZHVsZTtcbn0oKSk7XG5cbnZhciBUaW1lc3BhbiA9IFNjcm9sbGVyO1xudmFyIGRlZmF1bHRzJGYgPSB7XG4gIHdoZWVsT3JkZXI6ICdoaGlpc3MnLFxuICB1c2VTaG9ydExhYmVsczogZmFsc2UsXG4gIG1pbjogMCxcbiAgbWF4OiBJbmZpbml0eSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGxhYmVsczogWydZZWFycycsICdNb250aHMnLCAnRGF5cycsICdIb3VycycsICdNaW51dGVzJywgJ1NlY29uZHMnXSxcbiAgLy8sICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnWXJzJywgJ010aHMnLCAnRGF5cycsICdIcnMnLCAnTWlucycsICdTZWNzJ10gLy8sICcnXVxuXG59O1xuXG5wcmVzZXRzLnRpbWVzcGFuID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHBhcnRzIG9mIHRoZSB0aW1lIGRpZmZlcm5jZS5cbiAgICogQHBhcmFtIHtJbnRlZ2VyfSB0aW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBUaW1lIHNwbGl0dGVkIHRvIHRoZSByZXF1aXJlZCBwYXJ0cyAoeWVhcnMsIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGFydHModGltZSkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICByZXRbdl0gPSB3aGVlbHNbdl0gPyBNYXRoLmZsb29yKHRpbWUgLyBvYmpbdl0ubGltaXQpIDogMDtcbiAgICAgIHRpbWUgLT0gcmV0W3ZdICogb2JqW3ZdLmxpbWl0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNwZWNpZmljIHdoZWVsLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdiAtIFVuaXF1ZSBpZGVudGlmaWVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdlbldoZWVsKHYpIHtcbiAgICB2YXIgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICBzdCA9IHN0ZXBzW3doZWVsc1t2XSAtIDFdIHx8IDEsXG4gICAgICAgIG8gPSBvYmpbdl0sXG4gICAgICAgIGxibCA9IG8ubGFiZWwsXG4gICAgICAgIHcgPSBvLndoZWVsO1xuICAgIHcuZGF0YSA9IFtdO1xuICAgIHcubGFiZWwgPSBvLmxhYmVsO1xuXG4gICAgaWYgKG9yZC5tYXRjaChuZXcgUmVnRXhwKG8ucmUgKyBvLnJlLCAnaScpKSkge1xuICAgICAgbGVhZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHYgPT0gbWF4KSB7XG4gICAgICB3Lm1pbiA9IG1pblBhcnRzW3ZdO1xuICAgICAgdy5tYXggPSBtYXhQYXJ0c1t2XTtcblxuICAgICAgdy5kYXRhID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogaSAqIHN0LFxuICAgICAgICAgIGRpc3BsYXk6IGdlblZhbHVlKGkgKiBzdCwgbGVhZGluZywgbGJsKVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdy5nZXRJbmRleCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYgLyBzdCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IG8udW50aWw7IGkgKz0gc3QpIHtcbiAgICAgICAgdy5kYXRhLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgIGRpc3BsYXk6IGdlblZhbHVlKGksIGxlYWRpbmcsIGxibClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVmFsdWUoaSwgbGVhZGluZywgbGJsKSB7XG4gICAgcmV0dXJuIChpIDwgMTAgJiYgbGVhZGluZyA/ICcwJyA6ICcnKSArIGkgKyAnPHNwYW4gY2xhc3M9XCJtYnNjLXRzLWxibFwiPicgKyBsYmwgKyAnPC9zcGFuPic7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjVGltZShhcnIpIHtcbiAgICB2YXIgaiA9IDAsXG4gICAgICAgIHRpbWUgPSAwO1xuICAgICQkMS5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICBpZiAoIWlzTmFOKCthcnJbal0pKSB7XG4gICAgICAgIHRpbWUgKz0gb2JqW3Yudl0ubGltaXQgKiBhcnJbaV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwKHYsIHN0KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodiAvIHN0KSAqIHN0O1xuICB9XG5cbiAgdmFyIGksXG4gICAgICBqLFxuICAgICAgcCxcbiAgICAgIG1pblBhcnRzLFxuICAgICAgbWF4UGFydHMsXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJGYsIG9yaWcpLFxuICAgICAgb3JkID0gcy53aGVlbE9yZGVyLFxuICAgICAgbGJscyA9IHMudXNlU2hvcnRMYWJlbHMgPyBzLmxhYmVsc1Nob3J0IDogcy5sYWJlbHMsXG4gICAgICB1bmlxdWUgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddLFxuICAgICAgLy8sICdmcmFjdCddLFxuICBvYmogPSB7XG4gICAgJ3llYXJzJzoge1xuICAgICAgb3JkOiAwLFxuICAgICAgaW5kZXg6IDYsXG4gICAgICB1bnRpbDogMTAsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NSxcbiAgICAgIGxhYmVsOiBsYmxzWzBdLFxuICAgICAgcmU6ICd5JyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ21vbnRocyc6IHtcbiAgICAgIG9yZDogMSxcbiAgICAgIGluZGV4OiA1LFxuICAgICAgdW50aWw6IDExLFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCxcbiAgICAgIGxhYmVsOiBsYmxzWzFdLFxuICAgICAgcmU6ICdtJyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ2RheXMnOiB7XG4gICAgICBvcmQ6IDIsXG4gICAgICBpbmRleDogNCxcbiAgICAgIHVudGlsOiAzMSxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAgKiA2MCAqIDI0LFxuICAgICAgbGFiZWw6IGxibHNbMl0sXG4gICAgICByZTogJ2QnLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnaG91cnMnOiB7XG4gICAgICBvcmQ6IDMsXG4gICAgICBpbmRleDogMyxcbiAgICAgIHVudGlsOiAyMyxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAgKiA2MCxcbiAgICAgIGxhYmVsOiBsYmxzWzNdLFxuICAgICAgcmU6ICdoJyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ21pbnV0ZXMnOiB7XG4gICAgICBvcmQ6IDQsXG4gICAgICBpbmRleDogMixcbiAgICAgIHVudGlsOiA1OSxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAsXG4gICAgICBsYWJlbDogbGJsc1s0XSxcbiAgICAgIHJlOiAnaScsXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdzZWNvbmRzJzoge1xuICAgICAgb3JkOiA1LFxuICAgICAgaW5kZXg6IDEsXG4gICAgICB1bnRpbDogNTksXG4gICAgICBsaW1pdDogMTAwMCxcbiAgICAgIGxhYmVsOiBsYmxzWzVdLFxuICAgICAgcmU6ICdzJyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0gLy8sXG4gICAgLy8nZnJhY3QnOiB7IGluZGV4OiAwLCB1bnRpbDogOTksIGxpbWl0OiAxMCwgbGFiZWw6IGxibHNbNl0sIHByZWZpeDogJy4nLCBzaG9ydDogJ3UnIH1cblxuICB9LFxuICAgICAgbyA9IFtdLFxuICAgICAgc3RlcHMgPSBzLnN0ZXBzIHx8IFtdLFxuICAgICAgd2hlZWxzID0ge30sXG4gICAgICBtYXggPSAnc2Vjb25kcycsXG4gICAgICBkZWZhdWx0VmFsID0gcy5kZWZhdWx0VmFsdWUgfHwgTWF0aC5tYXgocy5taW4sIE1hdGgubWluKDAsIHMubWF4KSksXG4gICAgICB3ID0gW1tdXTsgLy8gQ29uc3RydWN0b3JcbiAgLy8gR2VuZXJhdGUgd2hlZWxzXG5cbiAgJCQxKHVuaXF1ZSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgIGogPSBvcmQuc2VhcmNoKG5ldyBSZWdFeHAob2JqW3ZdLnJlLCAnaScpKTtcblxuICAgIGlmIChqID4gLTEpIHtcbiAgICAgIG8ucHVzaCh7XG4gICAgICAgIG86IGosXG4gICAgICAgIHY6IHZcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob2JqW3ZdLmluZGV4ID4gb2JqW21heF0uaW5kZXgpIHtcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBvLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5vID4gYi5vID8gMSA6IC0xO1xuICB9KTtcbiAgJCQxLmVhY2gobywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICB3aGVlbHNbdi52XSA9IGkgKyAxO1xuICAgIHdbMF0ucHVzaChvYmpbdi52XS53aGVlbCk7XG4gIH0pO1xuICBtaW5QYXJ0cyA9IGdldFBhcnRzKHMubWluKTtcbiAgbWF4UGFydHMgPSBnZXRQYXJ0cyhzLm1heCk7XG4gICQkMS5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgZ2VuV2hlZWwodi52KTtcbiAgfSk7IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCwgZm9ybWF0dGVkKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlZCA/IGluc3QuX2dldFZhbCh0ZW1wKSA6IGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBjYWxjVGltZShpbnN0LmdldEFycmF5VmFsKHRlbXApKSA6IG51bGw7XG4gIH07IC8vIC0tLVxuICAvLyBSZXR1cm4gc2V0dGluZ3NcblxuXG4gIHJldHVybiB7XG4gICAgbWluV2lkdGg6IDEwMCxcbiAgICBzaG93TGFiZWw6IHRydWUsXG4gICAgd2hlZWxzOiB3LFxuICAgIGNvbXBDbGFzczogJ21ic2MtdHMgbWJzYy1zYycsXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWwpIHtcbiAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICBtO1xuXG4gICAgICBpZiAoaXNOdW1lcmljKHZhbCkgfHwgIXZhbCkge1xuICAgICAgICBwID0gZ2V0UGFydHModmFsIHx8IGRlZmF1bHRWYWwpO1xuICAgICAgICAkJDEuZWFjaChvLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgIHJldC5wdXNoKHBbdi52XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQxLmVhY2gobywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBtID0gbmV3IFJlZ0V4cCgnKFxcXFxkKylcXFxccz8oJyArIHMubGFiZWxzW29ialt2LnZdLm9yZF0gKyAnfCcgKyBzLmxhYmVsc1Nob3J0W29ialt2LnZdLm9yZF0gKyAnKScsICdnaScpLmV4ZWModmFsKTtcbiAgICAgICAgICByZXQucHVzaChtID8gbVsxXSA6IDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgJCQxKHJldCkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAvLyBTdGVwc1xuICAgICAgICByZXRbaV0gPSBzdGVwKHYsIHN0ZXBzW2ldIHx8IDEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGQpIHtcbiAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICQkMS5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIHJldCArPSArZFtpXSA/IGRbaV0gKyAnICcgKyBvYmpbdi52XS5sYWJlbCArICcgJyA6ICcnO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0ID8gcmV0LnJlcGxhY2UoL1xccyskL2csICcnKSA6IDA7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIHAsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBkaXMsXG4gICAgICAgICAgdmFsdWVzID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgZGlyID0gZGF0YS5kaXJlY3Rpb24sXG4gICAgICAgICAgZGlzYWJsZWQgPSBbXSxcbiAgICAgICAgICBtYXhwcm9wID0gdHJ1ZSxcbiAgICAgICAgICBtaW5wcm9wID0gdHJ1ZTtcbiAgICAgICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKHgsIHYpIHtcbiAgICAgICAgaWYgKHdoZWVsc1t2XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSB3aGVlbHNbdl0gLSAxO1xuICAgICAgICAgIGRpc2FibGVkW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGRpcyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHYgIT0gbWF4KSB7XG4gICAgICAgICAgICBpZiAobWF4cHJvcCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSBtYXhQYXJ0c1t2XSArIDE7IGkgPD0gb2JqW3ZdLnVudGlsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaXNbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW5wcm9wKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5QYXJ0c1t2XTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlzW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBpbnN0LmdldFZhbGlkVmFsdWUoaW5kZXgsIHZhbHVlc1tpbmRleF0sIGRpciwgZGlzKTtcbiAgICAgICAgICBwID0gZ2V0UGFydHMoY2FsY1RpbWUodmFsdWVzKSk7XG4gICAgICAgICAgbWF4cHJvcCA9IG1heHByb3AgJiYgcFt2XSA9PSBtYXhQYXJ0c1t2XTtcbiAgICAgICAgICBtaW5wcm9wID0gbWlucHJvcCAmJiBwW3ZdID09IG1pblBhcnRzW3ZdO1xuICAgICAgICAgICQkMS5lYWNoKGRpcywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGRpc2FibGVkW2luZGV4XS5wdXNoKGkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgTWJzY1RpbWVzcGFuID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1RpbWVzcGFuLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NUaW1lc3Bhbihpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1RpbWVzcGFuLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWJzY1RpbWVzcGFuLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1RpbWVzcGFuLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ3RpbWVzcGFuJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBUaW1lc3Bhbih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWJzY1RpbWVzcGFuLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXRpbWVzcGFuXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIE1ic2NUaW1lc3Bhbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBFbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NJbnB1dFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IE1ic2NPcHRpb25zU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUaW1lc3Bhbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2RlZmF1bHRWYWx1ZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbWF4JzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdtaW4nOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3N0ZXBzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd1c2VTaG9ydExhYmVscyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnd2hlZWxPcmRlcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnbGFiZWxzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdsYWJlbHNTaG9ydCc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy1vcHRpb25zJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLXRpbWVzcGFuJyxdIH0sXSxcbiAgICAgICAgJ29uQ2hhbmdlRW1pdHRlcic6IFt7IHR5cGU6IE91dHB1dCwgYXJnczogWydtYnNjLXRpbWVzcGFuQ2hhbmdlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjVGltZXNwYW47XG59KE1ic2NTY3JvbGxlckJhc2UpKTtcbnZhciBNYnNjVGltZXNwYW5Db21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYnNjVGltZXNwYW5Db21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWJzY1RpbWVzcGFuQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWJzY1RpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XG4gICAgfTtcbiAgICBNYnNjVGltZXNwYW5Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy10aW1lc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1RpbWVzcGFuQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICBdOyB9O1xuICAgIE1ic2NUaW1lc3BhbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2lucHV0SWNvbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbicsXSB9LF0sXG4gICAgICAgICdpY29uQWxpZ24nOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ2ljb24tYWxpZ24nLF0gfSxdLFxuICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3InOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ2Vycm9yTWVzc2FnZSc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAncGxhY2Vob2xkZXInOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBNYnNjVGltZXNwYW5Db21wb25lbnQ7XG59KE1ic2NUaW1lc3BhbikpO1xudmFyIE1ic2NUaW1lc3Bhbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWJzY1RpbWVzcGFuTW9kdWxlKCkge1xuICAgIH1cbiAgICBNYnNjVGltZXNwYW5Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnRdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnRdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjVGltZXNwYW5Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gTWJzY1RpbWVzcGFuTW9kdWxlO1xufSgpKTtcblxudmFyIFRyZWVsaXN0ID0gU2Nyb2xsZXI7XG5wcmVzZXRzLnRyZWVsaXN0ID0gTGlzdDtcblxudmFyIE1ic2NUcmVlbGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ic2NUcmVlbGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYnNjVHJlZWxpc3QoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NUcmVlbGlzdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnICYmIHRhcmdldC5fZWxlbWVudFJlZiAmJiB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LmdldElucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5nZXRJbnB1dEVsZW1lbnQoKS50aGVuKGZ1bmN0aW9uIChpbnApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlT3B0aW9ucyh7IGlucHV0OiBpbnAgfSwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAndHJlZWxpc3QnLCBpbnB1dDogdGFyZ2V0IH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFRyZWVsaXN0KHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjVHJlZWxpc3QucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYnNjVHJlZWxpc3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtdHJlZWxpc3RdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1RyZWVsaXN0LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IEVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY0lucHV0U2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogTWJzY09wdGlvbnNTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgIF07IH07XG4gICAgTWJzY1RyZWVsaXN0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnZGVmYXVsdFZhbHVlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpbnB1dENsYXNzJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdpbnZhbGlkJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdsYWJlbHMnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdzaG93SW5wdXQnOiBbeyB0eXBlOiBJbnB1dCQxIH0sXSxcbiAgICAgICAgJ3doZWVsQXJyYXknOiBbeyB0eXBlOiBJbnB1dCQxLCBhcmdzOiBbJ21ic2MtZGF0YScsXSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLW9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAndGFyZ2V0JzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydtYnNjLXRhcmdldCcsXSB9LF0sXG4gICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnbWJzYy10cmVlbGlzdCcsXSB9LF0sXG4gICAgICAgICdvbkNoYW5nZUVtaXR0ZXInOiBbeyB0eXBlOiBPdXRwdXQsIGFyZ3M6IFsnbWJzYy10cmVlbGlzdENoYW5nZScsXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1RyZWVsaXN0O1xufShNYnNjU2Nyb2xsZXJCYXNlKSk7XG52YXIgTWJzY1RyZWVsaXN0Q29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWJzY1RyZWVsaXN0Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ic2NUcmVlbGlzdENvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICBfdGhpcy5zaG93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaW5saW5lT3B0aW9uc09iaiA9IHtcbiAgICAgICAgICAgIHNob3dJbnB1dDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYnNjVHJlZWxpc3RDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcbiAgICB9O1xuICAgIE1ic2NUcmVlbGlzdENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRyZWVsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjVHJlZWxpc3RDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjSW5wdXRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBNYnNjT3B0aW9uc1NlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIF07IH07XG4gICAgTWJzY1RyZWVsaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5wdXRJY29uJzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydpY29uJyxdIH0sXSxcbiAgICAgICAgJ2ljb25BbGlnbic6IFt7IHR5cGU6IElucHV0JDEsIGFyZ3M6IFsnaWNvbi1hbGlnbicsXSB9LF0sXG4gICAgICAgICduYW1lJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdlcnJvcic6IFt7IHR5cGU6IElucHV0JDEgfSxdLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgICAgICd3aGVlbEFycmF5JzogW3sgdHlwZTogSW5wdXQkMSwgYXJnczogWydkYXRhJyxdIH0sXSxcbiAgICAgICAgJ3BsYWNlaG9sZGVyJzogW3sgdHlwZTogSW5wdXQkMSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTWJzY1RyZWVsaXN0Q29tcG9uZW50O1xufShNYnNjVHJlZWxpc3QpKTtcbnZhciBNYnNjVHJlZWxpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NUcmVlbGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWJzY1RyZWVsaXN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NUcmVlbGlzdCwgTWJzY1RyZWVsaXN0Q29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01ic2NUcmVlbGlzdCwgTWJzY1RyZWVsaXN0Q29tcG9uZW50XVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWJzY1RyZWVsaXN0TW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NUcmVlbGlzdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBkaXJlY3RpdmVzID0gW1xuICAgIE1ic2NJbnB1dCxcbiAgICBNYnNjQ2FsZW5kYXIsIE1ic2NDYWxlbmRhckNvbXBvbmVudCxcbiAgICBNYnNjQ2FyZCwgTWJzY0NhcmRDb21wb25lbnQsIE1ic2NDYXJkQ29udGVudCwgTWJzY0NhcmRGb290ZXIsIE1ic2NDYXJkSGVhZGVyLCBNYnNjQ2FyZFN1YnRpdGxlLCBNYnNjQ2FyZFRpdGxlLFxuICAgIE1ic2NDb2xvciwgTWJzY0NvbG9yQ29tcG9uZW50LFxuICAgIE1ic2NEYXRlLCBNYnNjVGltZSwgTWJzY0RhdGV0aW1lLCBNYnNjRGF0ZUNvbXBvbmVudCwgTWJzY1RpbWVDb21wb25lbnQsIE1ic2NEYXRldGltZUNvbXBvbmVudCxcbiAgICBNYnNjRXZlbnRjYWxlbmRhciwgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsXG4gICAgTWJzY0Zvcm0sIE1ic2NSYXRpbmcsIE1ic2NEcm9wZG93biwgTWJzY1RleHRhcmVhLCBNYnNjQnV0dG9uLCBNYnNjQ2hlY2tib3gsIE1ic2NTd2l0Y2gsIE1ic2NTdGVwcGVyLCBNYnNjUHJvZ3Jlc3MsIE1ic2NTbGlkZXIsIE1ic2NSYWRpbywgTWJzY1JhZGlvR3JvdXAsIE1ic2NTZWdtZW50ZWRHcm91cCwgTWJzY1NlZ21lbnRlZCwgTWJzY0Zvcm1Hcm91cCwgTWJzY0Zvcm1Hcm91cFRpdGxlLCBNYnNjRm9ybUdyb3VwQ29udGVudCwgTWJzY0FjY29yZGlvbixcbiAgICBNYnNjSW1hZ2UsIE1ic2NJbWFnZUNvbXBvbmVudCwgTWJzY0ltYWdlSXRlbSxcbiAgICBNYnNjTGlzdHZpZXcsIE1ic2NMaXN0dmlld1N1Ymxpc3QsIE1ic2NMaXN0dmlld0l0ZW0sIE1ic2NMaXN0dmlld0hlYWRlcixcbiAgICBNYnNjTWVhc3VyZW1lbnQsIE1ic2NEaXN0YW5jZSwgTWJzY0ZvcmNlLCBNYnNjTWFzcywgTWJzY1NwZWVkLCBNYnNjVGVtcGVyYXR1cmUsIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudCwgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LCBNYnNjRm9yY2VDb21wb25lbnQsIE1ic2NTcGVlZENvbXBvbmVudCwgTWJzY01hc3NDb21wb25lbnQsIE1ic2NEaXN0YW5jZUNvbXBvbmVudCxcbiAgICBNYnNjTmF2LCBNYnNjQm90dG9tTmF2LCBNYnNjSGFtYnVyZ2VyTmF2LCBNYnNjVGFiTmF2LCBNYnNjTmF2SXRlbSxcbiAgICBNYnNjTnVtYmVyLCBNYnNjTnVtYmVyQ29tcG9uZW50LFxuICAgIE1ic2NOdW1wYWQsIE1ic2NOdW1wYWREZWNpbWFsLCBNYnNjTnVtcGFkRGF0ZSwgTWJzY051bXBhZFRpbWUsIE1ic2NOdW1wYWRUaW1lc3BhbiwgTWJzY051bXBhZENvbXBvbmVudCwgTWJzY051bXBhZERhdGVDb21wb25lbnQsIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50LCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudCwgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LFxuICAgIE1ic2NPcHRpb25saXN0LCBNYnNjT3B0aW9uSXRlbSxcbiAgICBNYnNjUGFnZSwgTWJzY05vdGUsIE1ic2NBdmF0YXIsXG4gICAgTWJzY1BvcHVwLCBNYnNjV2lkZ2V0LFxuICAgIE1ic2NSYW5nZSwgTWJzY1JhbmdlQ29tcG9uZW50LCBNYnNjUmFuZ2VTdGFydENvbXBvbmVudCwgTWJzY1JhbmdlRW5kQ29tcG9uZW50LFxuICAgIE1ic2NTY3JvbGxlciwgTWJzY1Njcm9sbGVyQ29tcG9uZW50LFxuICAgIE1ic2NTY3JvbGxWaWV3LCBNYnNjU2Nyb2xsVmlld0l0ZW0sIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50LCBNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnQsXG4gICAgTWJzY1NlbGVjdCwgTWJzY1NlbGVjdENvbXBvbmVudCxcbiAgICBNYnNjVGltZXIsIE1ic2NUaW1lckNvbXBvbmVudCxcbiAgICBNYnNjVGltZXNwYW4sIE1ic2NUaW1lc3BhbkNvbXBvbmVudCxcbiAgICBNYnNjVHJlZWxpc3QsIE1ic2NUcmVlbGlzdENvbXBvbmVudCxcbl07XG52YXIgbW9kdWxlcyA9IFtcbiAgICBNYnNjSW5wdXRNb2R1bGUsXG4gICAgTWJzY0NhbGVuZGFyTW9kdWxlLFxuICAgIE1ic2NDYXJkTW9kdWxlLFxuICAgIE1ic2NDb2xvck1vZHVsZSxcbiAgICBNYnNjRGF0ZXRpbWVNb2R1bGUsXG4gICAgTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUsXG4gICAgTWJzY0Zvcm1zTW9kdWxlLFxuICAgIE1ic2NJbWFnZU1vZHVsZSxcbiAgICBNYnNjTGlzdHZpZXdNb2R1bGUsXG4gICAgTWJzY01lYXN1cmVtZW50TW9kdWxlLFxuICAgIE1ic2NOYXZpZ2F0aW9uTW9kdWxlLFxuICAgIE1ic2NOdW1iZXJNb2R1bGUsXG4gICAgTWJzY051bXBhZE1vZHVsZSxcbiAgICBNYnNjT3B0aW9ubGlzdE1vZHVsZSxcbiAgICBNYnNjUGFnZU1vZHVsZSxcbiAgICBNYnNjUG9wdXBNb2R1bGUsXG4gICAgTWJzY1JhbmdlTW9kdWxlLFxuICAgIE1ic2NTY3JvbGxlck1vZHVsZSxcbiAgICBNYnNjU2Nyb2xsVmlld01vZHVsZSxcbiAgICBNYnNjU2VsZWN0TW9kdWxlLFxuICAgIE1ic2NUaW1lck1vZHVsZSxcbiAgICBNYnNjVGltZXNwYW5Nb2R1bGUsXG4gICAgTWJzY1RyZWVsaXN0TW9kdWxlXG5dO1xudmFyIE1ic2NNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1ic2NNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1ic2NNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYnNjTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNYnNjUm91dGVyVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBjb25maWcuYW5ndWxhclJvdXRlclxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNYnNjTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZSwgQ29tbW9uTW9kdWxlLCBtb2R1bGVzXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW2RpcmVjdGl2ZXMsIG1vZHVsZXNdXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBNYnNjTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1ic2NNb2R1bGU7XG59KCkpO1xuXG4vLyBBcmFiaWNcblxuZnVuY3Rpb24gaW50UGFydChmbG9hdE51bSkge1xuICBpZiAoZmxvYXROdW0gPCAtMC4wMDAwMDAxKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChmbG9hdE51bSAtIDAuMDAwMDAwMSk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcihmbG9hdE51bSArIDAuMDAwMDAwMSk7XG59XG5cbmZ1bmN0aW9uIGhpanJpVG9HcmVnb3JpYW4oaFksIGhNLCBoRCkge1xuICBoWSA9IHBhcnNlSW50KGhZKTtcbiAgaE0gPSBwYXJzZUludChoTSk7XG4gIGhEID0gcGFyc2VJbnQoaEQpO1xuICB2YXIgamQsXG4gICAgICBsLFxuICAgICAgaixcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgayxcbiAgICAgIGdyZWdEYXRlID0gbmV3IEFycmF5KDMpO1xuICBqZCA9IGludFBhcnQoKDExICogaFkgKyAzKSAvIDMwKSArIDM1NCAqIGhZICsgMzAgKiBoTSAtIGludFBhcnQoKGhNIC0gMSkgLyAyKSArIGhEICsgMTk0ODQ0MCAtIDM4NTtcblxuICBpZiAoamQgPiAyMjk5MTYwKSB7XG4gICAgbCA9IGpkICsgNjg1Njk7XG4gICAgbiA9IGludFBhcnQoNCAqIGwgLyAxNDYwOTcpO1xuICAgIGwgPSBsIC0gaW50UGFydCgoMTQ2MDk3ICogbiArIDMpIC8gNCk7XG4gICAgaSA9IGludFBhcnQoNDAwMCAqIChsICsgMSkgLyAxNDYxMDAxKTtcbiAgICBsID0gbCAtIGludFBhcnQoMTQ2MSAqIGkgLyA0KSArIDMxO1xuICAgIGogPSBpbnRQYXJ0KDgwICogbCAvIDI0NDcpO1xuICAgIGhEID0gbCAtIGludFBhcnQoMjQ0NyAqIGogLyA4MCk7XG4gICAgbCA9IGludFBhcnQoaiAvIDExKTtcbiAgICBoTSA9IGogKyAyIC0gMTIgKiBsO1xuICAgIGhZID0gMTAwICogKG4gLSA0OSkgKyBpICsgbDtcbiAgfSBlbHNlIHtcbiAgICBqID0gamQgKyAxNDAyO1xuICAgIGsgPSBpbnRQYXJ0KChqIC0gMSkgLyAxNDYxKTtcbiAgICBsID0gaiAtIDE0NjEgKiBrO1xuICAgIG4gPSBpbnRQYXJ0KChsIC0gMSkgLyAzNjUpIC0gaW50UGFydChsIC8gMTQ2MSk7XG4gICAgaSA9IGwgLSAzNjUgKiBuICsgMzA7XG4gICAgaiA9IGludFBhcnQoODAgKiBpIC8gMjQ0Nyk7XG4gICAgaEQgPSBpIC0gaW50UGFydCgyNDQ3ICogaiAvIDgwKTtcbiAgICBpID0gaW50UGFydChqIC8gMTEpO1xuICAgIGhNID0gaiArIDIgLSAxMiAqIGk7XG4gICAgaFkgPSA0ICogayArIG4gKyBpIC0gNDcxNjtcbiAgfVxuXG4gIGdyZWdEYXRlWzJdID0gaEQ7XG4gIGdyZWdEYXRlWzFdID0gaE07XG4gIGdyZWdEYXRlWzBdID0gaFk7XG4gIHJldHVybiBncmVnRGF0ZTtcbn1cblxuZnVuY3Rpb24gZ3JlZ29yaWFuVG9IaWpyaShnWSwgZ00sIGdEKSB7XG4gIGdZID0gcGFyc2VJbnQoZ1kpO1xuICBnTSA9IHBhcnNlSW50KGdNKTtcbiAgZ0QgPSBwYXJzZUludChnRCk7XG4gIHZhciBqZCxcbiAgICAgIGwsXG4gICAgICBqLFxuICAgICAgbixcbiAgICAgIGhpanJpRGF0ZSA9IG5ldyBBcnJheSgwLCAwLCAwKTtcblxuICBpZiAoZ1kgPiAxNTgyIHx8IGdZID09IDE1ODIgJiYgZ00gPiAxMCB8fCBnWSA9PSAxNTgyICYmIGdNID09IDEwICYmIGdEID4gMTQpIHtcbiAgICBqZCA9IGludFBhcnQoMTQ2MSAqIChnWSArIDQ4MDAgKyBpbnRQYXJ0KChnTSAtIDE0KSAvIDEyKSkgLyA0KSArIGludFBhcnQoMzY3ICogKGdNIC0gMiAtIDEyICogaW50UGFydCgoZ00gLSAxNCkgLyAxMikpIC8gMTIpIC0gaW50UGFydCgzICogaW50UGFydCgoZ1kgKyA0OTAwICsgaW50UGFydCgoZ00gLSAxNCkgLyAxMikpIC8gMTAwKSAvIDQpICsgZ0QgLSAzMjA3NTtcbiAgfSBlbHNlIHtcbiAgICBqZCA9IDM2NyAqIGdZIC0gaW50UGFydCg3ICogKGdZICsgNTAwMSArIGludFBhcnQoKGdNIC0gOSkgLyA3KSkgLyA0KSArIGludFBhcnQoMjc1ICogZ00gLyA5KSArIGdEICsgMTcyOTc3NztcbiAgfVxuXG4gIGwgPSBqZCAtIDE5NDg0NDAgKyAxMDYzMjtcbiAgbiA9IGludFBhcnQoKGwgLSAxKSAvIDEwNjMxKTtcbiAgbCA9IGwgLSAxMDYzMSAqIG4gKyAzNTQ7XG4gIGogPSBpbnRQYXJ0KCgxMDk4NSAtIGwpIC8gNTMxNikgKiBpbnRQYXJ0KDUwICogbCAvIDE3NzE5KSArIGludFBhcnQobCAvIDU2NzApICogaW50UGFydCg0MyAqIGwgLyAxNTIzOCk7XG4gIGwgPSBsIC0gaW50UGFydCgoMzAgLSBqKSAvIDE1KSAqIGludFBhcnQoMTc3MTkgKiBqIC8gNTApIC0gaW50UGFydChqIC8gMTYpICogaW50UGFydCgxNTIzOCAqIGogLyA0MykgKyAyOTtcbiAgZ00gPSBpbnRQYXJ0KDI0ICogbCAvIDcwOSk7XG4gIGdEID0gbCAtIGludFBhcnQoNzA5ICogZ00gLyAyNCk7XG4gIGdZID0gMzAgKiBuICsgaiAtIDMwO1xuICBoaWpyaURhdGVbMl0gPSBnRDtcbiAgaGlqcmlEYXRlWzFdID0gZ007XG4gIGhpanJpRGF0ZVswXSA9IGdZO1xuICByZXR1cm4gaGlqcmlEYXRlO1xufVxuXG5jYWxlbmRhcnMuaGlqcmkgPSB7XG4gIGdldFllYXI6IGZ1bmN0aW9uIGdldFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBncmVnb3JpYW5Ub0hpanJpKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgZGF0ZS5nZXREYXRlKCkpWzBdO1xuICB9LFxuICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoZGF0ZSkge1xuICAgIHJldHVybiAtLWdyZWdvcmlhblRvSGlqcmkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCBkYXRlLmdldERhdGUoKSlbMV07XG4gIH0sXG4gIGdldERheTogZnVuY3Rpb24gZ2V0RGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZ3JlZ29yaWFuVG9IaWpyaShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIGRhdGUuZ2V0RGF0ZSgpKVsyXTtcbiAgfSxcbiAgZ2V0RGF0ZTogZnVuY3Rpb24gZ2V0RGF0ZSh5LCBtLCBkLCBoLCBpLCBzLCB1KSB7XG4gICAgaWYgKG0gPCAwKSB7XG4gICAgICB5ICs9IE1hdGguZmxvb3IobSAvIDEyKTtcbiAgICAgIG0gPSBtICUgMTIgPyAxMiArIG0gJSAxMiA6IDA7XG4gICAgfVxuXG4gICAgaWYgKG0gPiAxMSkge1xuICAgICAgeSArPSBNYXRoLmZsb29yKG0gLyAxMik7XG4gICAgICBtID0gbSAlIDEyO1xuICAgIH1cblxuICAgIHZhciBncmVnb3JpYW5EYXRlID0gaGlqcmlUb0dyZWdvcmlhbih5LCArbSArIDEsIGQpO1xuICAgIHJldHVybiBuZXcgRGF0ZShncmVnb3JpYW5EYXRlWzBdLCBncmVnb3JpYW5EYXRlWzFdIC0gMSwgZ3JlZ29yaWFuRGF0ZVsyXSwgaCB8fCAwLCBpIHx8IDAsIHMgfHwgMCwgdSB8fCAwKTtcbiAgfSxcbiAgZ2V0TWF4RGF5T2ZNb250aDogZnVuY3Rpb24gZ2V0TWF4RGF5T2ZNb250aChoWSwgaE0pIHtcbiAgICBpZiAoaE0gPCAwKSB7XG4gICAgICBoWSArPSBNYXRoLmZsb29yKGhNIC8gMTIpO1xuICAgICAgaE0gPSBoTSAlIDEyID8gMTIgKyBoTSAlIDEyIDogMDtcbiAgICB9XG5cbiAgICBpZiAoaE0gPiAxMSkge1xuICAgICAgaFkgKz0gTWF0aC5mbG9vcihoTSAvIDEyKTtcbiAgICAgIGhNID0gaE0gJSAxMjtcbiAgICB9XG5cbiAgICB2YXIgZGF5c1Blck1vbnRoID0gWzMwLCAyOSwgMzAsIDI5LCAzMCwgMjksIDMwLCAyOSwgMzAsIDI5LCAzMCwgMjldLFxuICAgICAgICBsZWFwWWVhciA9IChoWSAqIDExICsgMTQpICUgMzAgPCAxMTtcbiAgICByZXR1cm4gZGF5c1Blck1vbnRoW2hNXSArIChoTSA9PT0gMTEgJiYgbGVhcFllYXIgPyAxIDogMCk7XG4gIH1cbn07XG5cbi8vIEFyYWJpY1xubW9iaXNjcm9sbC5pMThuLmFyID0ge1xuICAvLyBDb3JlXG4gIHJ0bDogdHJ1ZSxcbiAgLy8gUmlnaHQgdG8gbGVmdCBtb2RlXG4gIHNldFRleHQ6ICfYqti52YrZitmGJyxcbiAgY2FuY2VsVGV4dDogJ9il2YTYutin2KEnLFxuICBjbGVhclRleHQ6ICfZhdiz2K0nLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9INin2YTZhdit2K/YrycsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuICBkYXlOYW1lczogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcbiAgZGF5TmFtZXNTaG9ydDogWyfYo9it2K8nLCAn2KfYq9mG2YrZhicsICfYq9mE2KfYq9in2KEnLCAn2KPYsdio2LnYp9ihJywgJ9iu2YXZitizJywgJ9is2YXYudipJywgJ9iz2KjYqiddLFxuICBkYXlOYW1lc01pbjogWyfYrScsICfZhicsICfYqycsICfYsScsICfYricsICfYrCcsICfYsyddLFxuICBkYXlUZXh0OiAn2YrZiNmFJyxcbiAgaG91clRleHQ6ICfYs9in2LnYp9iqJyxcbiAgbWludXRlVGV4dDogJ9in2YTYr9mC2KfYptmCJyxcbiAgbW9udGhOYW1lczogWyfZitmG2KfZitixJywgJ9mB2KjYsdin2YrYsScsICfZhdin2LHYsycsICfYp9io2LHZitmEJywgJ9mF2KfZitmIJywgJ9mK2YjZhtmK2YgnLCAn2YrZiNmE2YrZiCcsICfYo9i62LPYt9izJywgJ9iz2KjYqtmF2KjYsScsICfYo9mD2KrZiNio2LEnLCAn2YbZiNmB2YXYqNixJywgJ9iv2YrYs9mF2KjYsSddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsn2YrZhtin2YrYsScsICfZgdio2LHYp9mK2LEnLCAn2YXYp9ix2LMnLCAn2KfYqNix2YrZhCcsICfZhdin2YrZiCcsICfZitmI2YbZitmIJywgJ9mK2YjZhNmK2YgnLCAn2KPYutiz2LfYsycsICfYs9io2KrZhdio2LEnLCAn2KPZg9iq2YjYqNixJywgJ9mG2YjZgdmF2KjYsScsICfYr9mK2LPZhdio2LEnXSxcbiAgbW9udGhUZXh0OiAn2LTZh9ixJyxcbiAgc2VjVGV4dDogJ9ir2YjYp9mG2YonLFxuICBhbVRleHQ6ICfYtScsXG4gIHBtVGV4dDogJ9mFJyxcbiAgdGltZUZvcm1hdDogJ2hoOmlpIEEnLFxuICB5ZWFyVGV4dDogJ9i52KfZhScsXG4gIG5vd1RleHQ6ICfYp9mE2KLZhicsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMCxcbiAgZGF0ZVRleHQ6ICfYqtin2LHZitiuJyxcbiAgdGltZVRleHQ6ICfZiNmC2KonLFxuICBjbG9zZVRleHQ6ICfYpdi62YTYp9mCJyxcbiAgdG9kYXlUZXh0OiAn2KfZhNmK2YjZhScsXG4gIHByZXZNb250aFRleHQ6ICfYp9mE2LTZh9ixINin2YTYs9in2KjZgicsXG4gIG5leHRNb250aFRleHQ6ICfYp9mE2LTZh9ixINin2YTZgtin2K/ZhScsXG4gIHByZXZZZWFyVGV4dDogJ9in2YTYs9mG2Ycg2KfZhNiz2KfYqNmC2KknLFxuICBuZXh0WWVhclRleHQ6ICfYp9mE2LnYp9mFINin2YTZgtin2K/ZhScsXG4gIGFsbERheVRleHQ6ICfYp9mE2YrZiNmFINmD2YTZhycsXG4gIG5vRXZlbnRzVGV4dDogJ9mE2Kcg2KrZiNis2K8g2KfYrdiv2KfYqycsXG4gIC8vIEV2ZW50IGNhbGVuZGFyXG4gIGV2ZW50VGV4dDogJ9in2YTYrdiv2KsnLFxuICBldmVudHNUZXh0OiAn2KPYrdiv2KfYqycsXG4gIG1vcmVFdmVudHNUZXh0OiAn2YjYp9it2K8g2KLYrtixJyxcbiAgbW9yZUV2ZW50c1BsdXJhbFRleHQ6ICfYp9ir2YbYp9mGINii2K7Ysdin2YYge2NvdW50fScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfZitio2K/YpycsXG4gIHRvVGV4dDogJ9mK2YbYqtmH2YonLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ9mD2KfZhdmEJyxcbiAgZnJhY3Rpb25UZXh0OiAn2KzYstihJyxcbiAgdW5pdFRleHQ6ICfZiNit2K/YqScsXG4gIC8vIE51bXBhZCBkYXRlXG4gIGRlbGltaXRlcjogJy8nLFxuICAvLyBOdW1wYWQgZGVjaW1hbFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJywnLFxuICAvLyBUaW1lciAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn2LPZhtmI2KfYqicsICfYo9i02YfYsScsICfYo9mK2KfZhScsICfYs9in2LnYqScsICfYr9mC2KfYptmCJywgJ9ir2YjYp9mG2YonLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ9iz2YbZiNin2KonLCAn2KPYtNmH2LEnLCAn2KPZitin2YUnLCAn2LPYp9i52KknLCAn2K/Zgtin2KbZgicsICfYq9mI2KfZhtmKJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn2KjYr9ihJyxcbiAgc3RvcFRleHQ6ICfYpdmK2YLYp9mBJyxcbiAgcmVzZXRUZXh0OiAn2KXYudin2K/YqSDYttio2LcnLFxuICBsYXBUZXh0OiAn2KfZhNiv2YjYsdipJyxcbiAgaGlkZVRleHQ6ICfYpdiu2YHYp9ihJyxcbiAgLy8gRm9ybXNcbiAgb2ZmVGV4dDogJ9il2YrZgtin2YEnLFxuICBvblRleHQ6ICfYqti02LrZitmEJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfYsdis2YjYuScsXG4gIHVuZG9UZXh0OiAn2KrYsdin2KzYuSdcbn07XG5cbi8vIEJ1bGdhcmlhblxubW9iaXNjcm9sbC5pMThuLmJnID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfQl9Cw0LTQsNCy0LDQvdC1JyxcbiAgY2FuY2VsVGV4dDogJ9Ce0YLQvNGP0L3QsCcsXG4gIGNsZWFyVGV4dDogJ9CY0LfRh9C40YHRgtCy0LDQvdC1JyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDQv9C+0LTQsdGA0LDQvScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWyfQndC10LTQtdC70Y8nLCAn0J/QvtC90LXQtNC10LvQvdC40LonLCAn0JLRgtC+0YDQvdC40LonLCAn0KHRgNGP0LTQsCcsICfQp9C10YLQstGK0YDRgtGK0LonLCAn0J/QtdGC0YrQuicsICfQodGK0LHQvtGC0LAnXSxcbiAgZGF5TmFtZXNTaG9ydDogWyfQndC10LQnLCAn0J/QvtC9JywgJ9CS0YLQvicsICfQodGA0Y8nLCAn0KfQtdGCJywgJ9Cf0LXRgicsICfQodGK0LEnXSxcbiAgZGF5TmFtZXNNaW46IFsn0J3QtScsICfQn9C+JywgJ9CS0YInLCAn0KHRgCcsICfQp9C1JywgJ9Cf0LUnLCAn0KHRiiddLFxuICBkYXlUZXh0OiAn0LTQtdC9JyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAn0YfQsNGBJyxcbiAgbWludXRlVGV4dDogJ9C80LjQvdGD0YLQsCcsXG4gIG1vbnRoTmFtZXM6IFsn0K/QvdGD0LDRgNC4JywgJ9Ck0LXQstGA0YPQsNGA0LgnLCAn0JzQsNGA0YInLCAn0JDQv9GA0LjQuycsICfQnNCw0LknLCAn0K7QvdC4JywgJ9Cu0LvQuCcsICfQkNCy0LPRg9GB0YInLCAn0KHQtdC/0YLQtdC80LLRgNC4JywgJ9Ce0LrRgtC+0LzQstGA0LgnLCAn0J3QvtC10LzQstGA0LgnLCAn0JTQtdC60LXQvNCy0YDQuCddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsn0K/QvdGDJywgJ9Ck0LXQsicsICfQnNCw0YAnLCAn0JDQv9GAJywgJ9Cc0LDQuScsICfQrtC90LgnLCAn0K7Qu9C4JywgJ9CQ0LLQsycsICfQodC10L8nLCAn0J7QutGCJywgJ9Cd0L7QsicsICfQlNC10LonXSxcbiAgbW9udGhUZXh0OiAn0LzQtdGB0LXRhicsXG4gIHNlY1RleHQ6ICfRgdC10LrRg9C90LTQuCcsXG4gIHRpbWVGb3JtYXQ6ICdIOmlpJyxcbiAgeWVhclRleHQ6ICfQs9C+0LTQuNC90LAnLFxuICBub3dUZXh0OiAn0KHQtdCz0LAnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ9CU0LDRgtCwJyxcbiAgdGltZVRleHQ6ICfQv9GK0YInLFxuICB0b2RheVRleHQ6ICfQtNC90LXRgScsXG4gIHByZXZNb250aFRleHQ6ICfQn9GA0LXQtNC40YjQvdC40Y8g0LzQtdGB0LXRhicsXG4gIG5leHRNb250aFRleHQ6ICfQodC70LXQtNCy0LDRidC40Y/RgiDQvNC10YHQtdGGJyxcbiAgcHJldlllYXJUZXh0OiAn0J/RgNC10LTRhdC+0LTQvdCw0YLQsCDQs9C+0LTQuNC90LAnLFxuICBuZXh0WWVhclRleHQ6ICfQodC70LXQtNCy0LDRidCw0YLQsCDQs9C+0LTQuNC90LAnLFxuICBjbG9zZVRleHQ6ICfQt9Cw0YLQstC+0YDQuCcsXG4gIGV2ZW50VGV4dDogJ9Ch0YrQsdC40YLQuNC1JyxcbiAgZXZlbnRzVGV4dDogJ9Ch0YrQsdC40YLQuNGPJyxcbiAgYWxsRGF5VGV4dDogJ9Cm0Y/QuyDQtNC10L0nLFxuICBub0V2ZW50c1RleHQ6ICfQndGP0LzQsCDRgdGK0LHQuNGC0LjRjycsXG4gIG1vcmVFdmVudHNUZXh0OiAn0J7RidC1IHtjb3VudH0nLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAn0J7QoicsXG4gIHRvVGV4dDogJ9CU0J4nLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ9GG0Y/Qu9C+JyxcbiAgZnJhY3Rpb25UZXh0OiAn0YTRgNCw0LrRhtC40Y8nLFxuICB1bml0VGV4dDogJ9C10LTQuNC90LjRhtCwJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn0JPQvtC00LjQvdC4JywgJ9C80LXRgdC10YbQsCcsICfQtNC90LgnLCAn0YfQsNGB0LAnLCAn0LzQuNC90YPRgtC4JywgJ9GB0LXQutGD0L3QtNC4JywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfQk9C+0LTQuNC90LgnLCAn0LzQtdGB0LXRhtCwJywgJ9C00L3QuCcsICfRh9Cw0YHQsCcsICfQvNC40L3Rg9GC0LgnLCAn0YHQtdC60YPQvdC00LgnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICfQodGC0LDRgNGCJyxcbiAgc3RvcFRleHQ6ICfQodGC0L7QvycsXG4gIHJlc2V0VGV4dDogJ9Cd0YPQu9C40YDQsNC90LUnLFxuICBsYXBUZXh0OiAn0J7QsdC40LrQvtC70LrQsCcsXG4gIGhpZGVUZXh0OiAn0LrRgNC40Y8nLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ9Cy0YDRitGJ0LDQvdC1JyxcbiAgdW5kb1RleHQ6ICfQntCi0JzQr9Cd0JAnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICfQmNCX0JrQmycsXG4gIG9uVGV4dDogJ9CS0JrQmycsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBDYXRhbMOgXG5tb2Jpc2Nyb2xsLmkxOG4uY2EgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ0FjY2VwdGFyJyxcbiAgY2FuY2VsVGV4dDogJ0NhbmNlbMK3bGFyJyxcbiAgY2xlYXJUZXh0OiAnRXNib3JyYXInLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IHNlbGVjY2lvbmF0JyxcbiAgc2VsZWN0ZWRQbHVyYWxUZXh0OiAne2NvdW50fSBzZWxlY2Npb25hdHMnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ2RkL21tL3l5JyxcbiAgZGF5TmFtZXM6IFsnRGl1bWVuZ2UnLCAnRGlsbHVucycsICdEaW1hcnRzJywgJ0RpbWVjcmVzJywgJ0Rpam91cycsICdEaXZlbmRyZXMnLCAnRGlzc2FidGUnXSxcbiAgZGF5TmFtZXNTaG9ydDogWydEZycsICdEbCcsICdEdCcsICdEYycsICdEaicsICdEdicsICdEcyddLFxuICBkYXlOYW1lc01pbjogWydEZycsICdEbCcsICdEdCcsICdEYycsICdEaicsICdEdicsICdEcyddLFxuICBkYXlUZXh0OiAnRGlhJyxcbiAgaG91clRleHQ6ICdIb3JlcycsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dHMnLFxuICBtb250aE5hbWVzOiBbJ0dlbmVyJywgJ0ZlYnJlcicsICdNYXLDpycsICdBYnJpbCcsICdNYWlnJywgJ0p1bnknLCAnSnVsaW9sJywgJ0Fnb3N0JywgJ1NldGVtYnJlJywgJ09jdHVicmUnLCAnTm92ZW1icmUnLCAnRGVzZW1icmUnXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ0dlbicsICdGZWInLCAnTWFyJywgJ0FicicsICdNYWknLCAnSnVuJywgJ0p1bCcsICdBZ28nLCAnU2V0JywgJ09jdCcsICdOb3YnLCAnRGVzJ10sXG4gIG1vbnRoVGV4dDogJ01lcycsXG4gIHNlY1RleHQ6ICdTZWdvbnMnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ0FueScsXG4gIG5vd1RleHQ6ICdBcmEnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgdG9kYXlUZXh0OiAnQXZ1aScsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICdEYXRhJyxcbiAgdGltZVRleHQ6ICdUZW1wcycsXG4gIGNsb3NlVGV4dDogJ1RhbmNhcicsXG4gIGFsbERheVRleHQ6ICdUb3QgZWwgZGlhJyxcbiAgbm9FdmVudHNUZXh0OiAnQ2FwIGVzZGV2ZW5pbWVudCcsXG4gIGV2ZW50VGV4dDogJ0VzZGV2ZW5pbWVudHMnLFxuICBldmVudHNUZXh0OiAnRXNkZXZlbmltZW50cycsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBtw6lzJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0luaWNpYXInLFxuICB0b1RleHQ6ICdGaW5hbCcsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnU2VuY2VyJyxcbiAgZnJhY3Rpb25UZXh0OiAnRnJhY2Npw7MnLFxuICB1bml0VGV4dDogJ1VuaXRhdCcsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ0FueXMnLCAnTWVzb3MnLCAnRGllcycsICdIb3JlcycsICdNaW51dHMnLCAnU2Vnb25zJywgJyddLFxuICBsYWJlbHNTaG9ydDogWydBbnlzJywgJ01lc29zJywgJ0RpZXMnLCAnSHJzJywgJ01pbnMnLCAnU2VjcycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ0luaWNpYXInLFxuICBzdG9wVGV4dDogJ0F0dXJhcicsXG4gIHJlc2V0VGV4dDogJ1JlaW5pY2lhcicsXG4gIGxhcFRleHQ6ICdWb2x0YScsXG4gIGhpZGVUZXh0OiAnQW1hZ2FyJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdFbnJlcmUnLFxuICB1bmRvVGV4dDogJ0Rlc2bDqXMnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdObycsXG4gIG9uVGV4dDogJ1NpJ1xufTtcblxuLy8gQ2VzdGluYVxubW9iaXNjcm9sbC5pMThuLmNzID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICdaYWRlaicsXG4gIGNhbmNlbFRleHQ6ICdTdG9ybm8nLFxuICBjbGVhclRleHQ6ICdWeW1hemF0JyxcbiAgc2VsZWN0ZWRUZXh0OiAnT3puYcSNZW7DvToge2NvdW50fScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWydOZWTEm2xlJywgJ1BvbmTEm2zDrScsICfDmnRlcsO9JywgJ1N0xZllZGEnLCAnxIx0dnJ0ZWsnLCAnUMOhdGVrJywgJ1NvYm90YSddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ05lJywgJ1BvJywgJ8OadCcsICdTdCcsICfEjHQnLCAnUMOhJywgJ1NvJ10sXG4gIGRheU5hbWVzTWluOiBbJ04nLCAnUCcsICfDmicsICdTJywgJ8SMJywgJ1AnLCAnUyddLFxuICBkYXlUZXh0OiAnRGVuJyxcbiAgaG91clRleHQ6ICdIb2RpbnknLFxuICBtaW51dGVUZXh0OiAnTWludXR5JyxcbiAgbW9udGhOYW1lczogWydMZWRlbicsICfDmm5vcicsICdCxZllemVuJywgJ0R1YmVuJywgJ0t2xJt0ZW4nLCAnxIxlcnZlbicsICfEjGVydmVuZWMnLCAnU3JwZW4nLCAnWsOhxZnDrScsICfFmMOtamVuJywgJ0xpc3RvcGFkJywgJ1Byb3NpbmVjJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydMZWQnLCAnw5pubycsICdCxZllJywgJ0R1YicsICdLdsSbJywgJ8SMZXInLCAnxIx2YycsICdTcHInLCAnWsOhxZknLCAnxZjDrWonLCAnTGlzJywgJ1BybyddLFxuICBtb250aFRleHQ6ICdNxJtzw61jJyxcbiAgc2VjVGV4dDogJ1Nla3VuZHknLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ1JvaycsXG4gIG5vd1RleHQ6ICdUZcSPJyxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbScsXG4gIHRvZGF5VGV4dDogJ0RuZXMnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0dW0nLFxuICB0aW1lVGV4dDogJ8SMYXMnLFxuICBjbG9zZVRleHQ6ICdaYXbFmcOtdCcsXG4gIGFsbERheVRleHQ6ICdDZWzDvSBkZW4nLFxuICBub0V2ZW50c1RleHQ6ICfFvcOhZG7DqSB1ZMOhbG9zdGknLFxuICBldmVudFRleHQ6ICdVZMOhbG9zdMOtJyxcbiAgZXZlbnRzVGV4dDogJ1Vkw6Fsb3N0aScsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBkYWzFocOtJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ1phxI3DoXRlaycsXG4gIHRvVGV4dDogJ0tvbmVjJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdDZWzDvScsXG4gIGZyYWN0aW9uVGV4dDogJ8SMw6FzdCcsXG4gIHVuaXRUZXh0OiAnSmVkbm90a2EnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydSb2t5JywgJ03Em3PDrWNlJywgJ0RueScsICdIb2RpbnknLCAnTWludXR5JywgJ1Nla3VuZHknLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ1JvaycsICdNxJtzJywgJ0RueScsICdIb2QnLCAnTWluJywgJ1NlYycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ1N0YXJ0JyxcbiAgc3RvcFRleHQ6ICdTdG9wJyxcbiAgcmVzZXRUZXh0OiAnUmVzZXRvdmF0JyxcbiAgbGFwVGV4dDogJ0V0YXBhJyxcbiAgaGlkZVRleHQ6ICdTY2hvdmF0JyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdacMSbdCcsXG4gIHVuZG9UZXh0OiAnWnDEm3QnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdPJyxcbiAgb25UZXh0OiAnSScsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBEYW5za1xubW9iaXNjcm9sbC5pMThuLmRhID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICdTw6Z0JyxcbiAgY2FuY2VsVGV4dDogJ0FubnVsbGVyJyxcbiAgY2xlYXJUZXh0OiAnUnlkJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSB2YWxndCcsXG4gIHNlbGVjdGVkUGx1cmFsVGV4dDogJ3tjb3VudH0gdmFsZ3QnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ2RkL21tL3l5JyxcbiAgZGF5TmFtZXM6IFsnU8O4bmRhZycsICdNYW5kYWcnLCAnVGlyc2RhZycsICdPbnNkYWcnLCAnVG9yc2RhZycsICdGcmVkYWcnLCAnTMO4cmRhZyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ1PDuG4nLCAnTWFuJywgJ1RpcicsICdPbnMnLCAnVG9yJywgJ0ZyZScsICdMw7hyJ10sXG4gIGRheU5hbWVzTWluOiBbJ1MnLCAnTScsICdUJywgJ08nLCAnVCcsICdGJywgJ0wnXSxcbiAgZGF5VGV4dDogJ0RhZycsXG4gIGhvdXJUZXh0OiAnVGltZXInLFxuICBtaW51dGVUZXh0OiAnTWludXR0ZXInLFxuICBtb250aE5hbWVzOiBbJ0phbnVhcicsICdGZWJydWFyJywgJ01hcnRzJywgJ0FwcmlsJywgJ01haicsICdKdW5pJywgJ0p1bGknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWFqJywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPa3QnLCAnTm92JywgJ0RlYyddLFxuICBtb250aFRleHQ6ICdNw6VuZWQnLFxuICBzZWNUZXh0OiAnU2VrdW5kZXInLFxuICBhbVRleHQ6ICdhbScsXG4gIHBtVGV4dDogJ3BtJyxcbiAgdGltZUZvcm1hdDogJ0hILmlpJyxcbiAgeWVhclRleHQ6ICfDhXInLFxuICBub3dUZXh0OiAnTnUnLFxuICB0b2RheVRleHQ6ICdJIGRhZycsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICdEYXRvJyxcbiAgdGltZVRleHQ6ICdUaWQnLFxuICBjbG9zZVRleHQ6ICdMdWsnLFxuICBhbGxEYXlUZXh0OiAnSGVsZSBkYWdlbicsXG4gIG5vRXZlbnRzVGV4dDogJ0luZ2VuIGJlZ2l2ZW5oZWRlcicsXG4gIGV2ZW50VGV4dDogJ0JlZ2l2ZW5oZWRlcicsXG4gIGV2ZW50c1RleHQ6ICdCZWdpdmVuaGVkZXInLFxuICBtb3JlRXZlbnRzVGV4dDogJ3tjb3VudH0gbWVyZScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICdTdGFydCcsXG4gIHRvVGV4dDogJ1NsdXQnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0hlbGUnLFxuICBmcmFjdGlvblRleHQ6ICdEZWxlJyxcbiAgdW5pdFRleHQ6ICdFbmhlZCcsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ8OFcicsICdNw6VuZWRlcicsICdEYWdlJywgJ1RpbWVyJywgJ01pbnV0dGVyJywgJ1Nla3VuZGVyJywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfDhXInLCAnTWRyJywgJ0RnJywgJ1RpbWVyJywgJ01pbicsICdTZWsnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdTdGFydCcsXG4gIHN0b3BUZXh0OiAnU3RvcCcsXG4gIHJlc2V0VGV4dDogJ051bHN0aWwnLFxuICBsYXBUZXh0OiAnT21nYW5nJyxcbiAgaGlkZVRleHQ6ICdTa2p1bCcsXG4gIC8vIEZvcm1zXG4gIG9mZlRleHQ6ICdGcmEnLFxuICBvblRleHQ6ICdUaWwnLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ1RpbGJhZ2UnLFxuICB1bmRvVGV4dDogJ0ZvcnRyeWQnXG59O1xuXG4vLyBEZXV0c2NoXG5tb2Jpc2Nyb2xsLmkxOG4uZGUgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ09LJyxcbiAgY2FuY2VsVGV4dDogJ0FiYnJlY2hlbicsXG4gIGNsZWFyVGV4dDogJ0zDtnNjaGVuJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBhdXNnZXfDpGhsdCcsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWydTb25udGFnJywgJ01vbnRhZycsICdEaWVuc3RhZycsICdNaXR0d29jaCcsICdEb25uZXJzdGFnJywgJ0ZyZWl0YWcnLCAnU2Ftc3RhZyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ1NvJywgJ01vJywgJ0RpJywgJ01pJywgJ0RvJywgJ0ZyJywgJ1NhJ10sXG4gIGRheU5hbWVzTWluOiBbJ1MnLCAnTScsICdEJywgJ00nLCAnRCcsICdGJywgJ1MnXSxcbiAgZGF5VGV4dDogJ1RhZycsXG4gIGRlbGltaXRlcjogJy4nLFxuICBob3VyVGV4dDogJ1N0dW5kZScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dGVuJyxcbiAgbW9udGhOYW1lczogWydKYW51YXInLCAnRmVicnVhcicsICdNw6RyeicsICdBcHJpbCcsICdNYWknLCAnSnVuaScsICdKdWxpJywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2t0b2JlcicsICdOb3ZlbWJlcicsICdEZXplbWJlciddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNw6RyJywgJ0FwcicsICdNYWknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09rdCcsICdOb3YnLCAnRGV6J10sXG4gIG1vbnRoVGV4dDogJ01vbmF0JyxcbiAgc2VjVGV4dDogJ1Nla3VuZGVuJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICdKYWhyJyxcbiAgbm93VGV4dDogJ0pldHp0JyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIHRvZGF5VGV4dDogJ0hldXRlJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0RhdHVtJyxcbiAgdGltZVRleHQ6ICdaZWl0JyxcbiAgY2xvc2VUZXh0OiAnU2NobGllw59lbicsXG4gIGFsbERheVRleHQ6ICdHYW56dMOkZ2lnJyxcbiAgbm9FdmVudHNUZXh0OiAnS2VpbmUgRXJlaWduaXNzZScsXG4gIGV2ZW50VGV4dDogJ0VyZWlnbmlzJyxcbiAgZXZlbnRzVGV4dDogJ0VyZWlnbmlzc2UnLFxuICBtb3JlRXZlbnRzVGV4dDogJ3tjb3VudH0gd2VpdGVyZXMgRWxlbWVudCcsXG4gIG1vcmVFdmVudHNQbHVyYWxUZXh0OiAne2NvdW50fSB3ZWl0ZXJlIEVsZW1lbnRlJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ1ZvbicsXG4gIHRvVGV4dDogJ0JpcycsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnR2FuemUgWmFobCcsXG4gIGZyYWN0aW9uVGV4dDogJ0JydWNoemFobCcsXG4gIHVuaXRUZXh0OiAnTWHDn2VpbmhlaXQnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydKYWhyZScsICdNb25hdGUnLCAnVGFnZScsICdTdHVuZGVuJywgJ01pbnV0ZW4nLCAnU2VrdW5kZW4nLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ0phaHIuJywgJ01vbi4nLCAnVGFnLicsICdTdGQuJywgJ01pbi4nLCAnU2VrLicsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ1N0YXJ0ZW4nLFxuICBzdG9wVGV4dDogJ1N0b3BwZW4nLFxuICByZXNldFRleHQ6ICdadXLDvGNrc2V0emVuJyxcbiAgbGFwVGV4dDogJ0xhcCcsXG4gIGhpZGVUZXh0OiAnQXVzYmxlbmRlbicsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnWnVyw7xjaycsXG4gIHVuZG9UZXh0OiAnUsO8Y2tnw6RuZ2lnIG1hY2hlbicsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ0F1cycsXG4gIG9uVGV4dDogJ0VpbicsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBHcmVla1xubW9iaXNjcm9sbC5pMThuLmVsID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfOn8+BzrnPg868zr/PgicsXG4gIGNhbmNlbFRleHQ6ICfOkc66z4XPgc+Jz4POtycsXG4gIGNsZWFyVGV4dDogJ86UzrnOsc6zz4HOsc+GzrcnLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IM61z4DOuc67zrXOs868zq3Ovc6xJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG4gIGRheU5hbWVzOiBbJ86az4XPgc65zrHOus6uJywgJ86UzrXPhc+Ezq3Pgc6xJywgJ86kz4HOr8+EzrcnLCAnzqTOtc+EzqzPgc+EzrcnLCAnzqDOrc68z4DPhM63JywgJ86gzrHPgc6xz4POus61z4XOricsICfOo86szrLOss6xz4TOvyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ86az4XPgScsICfOlM61z4UnLCAnzqTPgc65JywgJ86kzrXPhCcsICfOoM61zrwnLCAnzqDOsc+BJywgJ86jzrHOsiddLFxuICBkYXlOYW1lc01pbjogWyfOms+FJywgJ86UzrUnLCAnzqTPgScsICfOpM61JywgJ86gzrUnLCAnzqDOsScsICfOo86xJ10sXG4gIGRheVRleHQ6ICfOt868zq3Pgc6xJyxcbiAgZGVsaW1pdGVyOiAnLycsXG4gIGhvdXJUZXh0OiAnz47Pgc6xJyxcbiAgbWludXRlVGV4dDogJ867zrXPgM+Ez4wnLFxuICBtb250aE5hbWVzOiBbJ86ZzrHOvc6/z4XOrM+BzrnOv8+CJywgJ86mzrXOss+Bzr/Phc6sz4HOuc6/z4InLCAnzpzOrM+Bz4TOuc6/z4InLCAnzpHPgM+Bzq/Ou865zr/PgicsICfOnM6szrnOv8+CJywgJ86Zzr/Pjc69zrnOv8+CJywgJ86Zzr/Pjc67zrnOv8+CJywgJ86Rz43Os86/z4XPg8+Ezr/PgicsICfOo861z4DPhM6tzrzOss+BzrnOv8+CJywgJ86fzrrPhM+OzrLPgc65zr/PgicsICfOnc6/zq3OvM6yz4HOuc6/z4InLCAnzpTOtc66zq3OvM6yz4HOuc6/z4InXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ86ZzrHOvScsICfOps61zrInLCAnzpzOsc+BJywgJ86Rz4DPgScsICfOnM6xzrknLCAnzpnOv8+Fzr0nLCAnzpnOv8+FzrsnLCAnzpHPhc6zJywgJ86jzrXPgCcsICfOn866z4QnLCAnzp3Ov861JywgJ86UzrXOuiddLFxuICBtb250aFRleHQ6ICfOnM6uzr3Osc+CJyxcbiAgc2VjVGV4dDogJ860zrXPhc+EzrXPgc+MzrvOtc+Az4TOsScsXG4gIHRpbWVGb3JtYXQ6ICdIOmlpJyxcbiAgeWVhclRleHQ6ICfOrc+Ezr/PgicsXG4gIG5vd1RleHQ6ICfPhM+Oz4HOsScsXG4gIHBtVGV4dDogJ868zrwnLFxuICBhbVRleHQ6ICfPgM68JyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ86XzrzOtc+Bzr/OvM63zr3Or86xJyxcbiAgdGltZVRleHQ6ICfPhs6/z4HOrCcsXG4gIHRvZGF5VGV4dDogJ86jzq7OvM61z4HOsScsXG4gIHByZXZNb250aFRleHQ6ICfOoM+Bzr/Ot86zzr/Pjc68zrXOvc6/IM68zq7Ovc6xJyxcbiAgbmV4dE1vbnRoVGV4dDogJ86Vz4DPjM68zrXOvc6/IM68zq7Ovc6xJyxcbiAgcHJldlllYXJUZXh0OiAnzqDPgc6/zrfOs86/z43OvM61zr3OvyDOrc+Ezr/PgicsXG4gIG5leHRZZWFyVGV4dDogJ86Vz4DPjM68zrXOvc6/IM6tz4TOv8+CJyxcbiAgY2xvc2VUZXh0OiAnzprOu861zq/Pg865zrzOvycsXG4gIGV2ZW50VGV4dDogJ86TzrXOs86/zr3PjM+EzrEnLFxuICBldmVudHNUZXh0OiAnzpPOtc6zzr/Ovc+Mz4TOsScsXG4gIGFsbERheVRleHQ6ICfOn867zr/Ors68zrXPgc6/JyxcbiAgbm9FdmVudHNUZXh0OiAnzpTOtc69IM+Fz4DOrM+Bz4fOv8+Fzr0gzrPOtc6zzr/Ovc+Mz4TOsScsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSDOsc66z4zOvM63JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ86Rz4HPh86uJyxcbiAgdG9UZXh0OiAnzqTOrc67zr/PgicsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnzp/Ou8+MzrrOu863z4HOv8+CJyxcbiAgZnJhY3Rpb25UZXh0OiAnzrrOu86sz4POvM6xJyxcbiAgdW5pdFRleHQ6ICfOnM6/zr3OrM60zrEnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyfOp8+Bz4zOvc65zrEnLCAnzpzOrs69zrXPgicsICfOl868zq3Pgc61z4InLCAnzqnPgc61z4InLCAnzpvOtc+Az4TOrCcsICfOtM61z4XPhM61z4HPjM67zrXPgM+EzrEnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ86nz4HPjM69zrnOsScsICfOnM6uzr3Otc+CJywgJ86XzrzOrc+BzrXPgicsICfOqc+BzrXPgicsICfOm861z4DPhM6sJywgJ860zrXPhc+EJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnzoTOlc69zrHPgc6+zrcnLFxuICBzdG9wVGV4dDogJ86UzrnOsc66zr/PgM6uJyxcbiAgcmVzZXRUZXh0OiAnzpXPgM6xzr3Osc+Gzr/Pgc6sJyxcbiAgbGFwVGV4dDogJ86Tz43Pgc6/z4InLFxuICBoaWRlVGV4dDogJ866z4HPjc6yz4knLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ86gzq/Pg8+JJyxcbiAgdW5kb1RleHQ6ICfOkc69zrHOuc+BzrXPg863JyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnzpHOvc61zr3Otc+BzrPPjCcsXG4gIG9uVGV4dDogJ86Vzr3Otc+BzrPPjCcsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBFbmdsaXNoIChVSylcbm1vYmlzY3JvbGwuaTE4blsnZW4tR0InXSA9IG1vYmlzY3JvbGwuaTE4blsnZW4tVUsnXSA9IHtcbiAgZGF0ZUZvcm1hdDogJ2RkL21tL3l5JyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJ1xufTtcblxuLy8gRXNwYcOxb2xcbm1vYmlzY3JvbGwuaTE4bi5lcyA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnQWNlcHRhcicsXG4gIGNhbmNlbFRleHQ6ICdDYW5jZWxhcicsXG4gIGNsZWFyVGV4dDogJ0JvcnJhcicsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gc2VsZWNjaW9uYWRvJyxcbiAgc2VsZWN0ZWRQbHVyYWxUZXh0OiAne2NvdW50fSBzZWxlY2Npb25hZG9zJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG4gIGRheU5hbWVzOiBbJ0RvbWluZ28nLCAnTHVuZXMnLCAnTWFydGVzJywgJ01pw6lyY29sZXMnLCAnSnVldmVzJywgJ1ZpZXJuZXMnLCAnU8OhYmFkbyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ0RvJywgJ0x1JywgJ01hJywgJ01pJywgJ0p1JywgJ1ZpJywgJ1PDoSddLFxuICBkYXlOYW1lc01pbjogWydEJywgJ0wnLCAnTScsICdNJywgJ0onLCAnVicsICdTJ10sXG4gIGRheVRleHQ6ICdEw61hJyxcbiAgaG91clRleHQ6ICdIb3JhcycsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dG9zJyxcbiAgbW9udGhOYW1lczogWydFbmVybycsICdGZWJyZXJvJywgJ01hcnpvJywgJ0FicmlsJywgJ01heW8nLCAnSnVuaW8nLCAnSnVsaW8nLCAnQWdvc3RvJywgJ1NlcHRpZW1icmUnLCAnT2N0dWJyZScsICdOb3ZpZW1icmUnLCAnRGljaWVtYnJlJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydFbmUnLCAnRmViJywgJ01hcicsICdBYnInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQWdvJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RpYyddLFxuICBtb250aFRleHQ6ICdNZXMnLFxuICBzZWNUZXh0OiAnU2VndW5kb3MnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ0EmbnRpbGRlO28nLFxuICBub3dUZXh0OiAnQWhvcmEnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgdG9kYXlUZXh0OiAnSG95JyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0ZlY2hhJyxcbiAgdGltZVRleHQ6ICdUaWVtcG8nLFxuICBjbG9zZVRleHQ6ICdDZXJyYXInLFxuICBhbGxEYXlUZXh0OiAnVG9kbyBlbCBkw61hJyxcbiAgbm9FdmVudHNUZXh0OiAnTm8gaGF5IGV2ZW50b3MnLFxuICBldmVudFRleHQ6ICdFdmVudG8nLFxuICBldmVudHNUZXh0OiAnRXZlbnRvcycsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBtw6FzJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0luaWNpYXInLFxuICB0b1RleHQ6ICdGaW5hbCcsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnRW50ZXJvJyxcbiAgZnJhY3Rpb25UZXh0OiAnRnJhY2Npw7NuJyxcbiAgdW5pdFRleHQ6ICdVbmlkYWQnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydBw7FvcycsICdNZXNlcycsICdEw61hcycsICdIb3JhcycsICdNaW51dG9zJywgJ1NlZ3VuZG9zJywgJyddLFxuICBsYWJlbHNTaG9ydDogWydBw7FvJywgJ01lcycsICdEw61hJywgJ0hvcmEnLCAnTWluJywgJ1NlZycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ0luaWNpYXInLFxuICBzdG9wVGV4dDogJ0RldMOpbmdhc2UnLFxuICByZXNldFRleHQ6ICdSZWluaWNpYWxpemFyJyxcbiAgbGFwVGV4dDogJ0xhcCcsXG4gIGhpZGVUZXh0OiAnRXNjb25kZXInLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ0F0csOhcycsXG4gIHVuZG9UZXh0OiAnRGVzaGFjZXInLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdObycsXG4gIG9uVGV4dDogJ1PDrScsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyDZgdin2LHYs9uMXG52YXIgZ0RheXNJbk1vbnRoID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgIGpEYXlzSW5Nb250aCA9IFszMSwgMzEsIDMxLCAzMSwgMzEsIDMxLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDI5XTtcblxuZnVuY3Rpb24gamFsYWxpVG9HcmVnb3JpYW4oalksIGpNLCBqRCkge1xuICBqWSA9IHBhcnNlSW50KGpZKTtcbiAgak0gPSBwYXJzZUludChqTSk7XG4gIGpEID0gcGFyc2VJbnQoakQpO1xuICB2YXIgaTtcbiAgdmFyIGp5ID0galkgLSA5Nzk7XG4gIHZhciBqbSA9IGpNIC0gMTtcbiAgdmFyIGpkID0gakQgLSAxO1xuICB2YXIgakRheU5vID0gMzY1ICogankgKyBwYXJzZUludChqeSAvIDMzKSAqIDggKyBwYXJzZUludCgoankgJSAzMyArIDMpIC8gNCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGptOyArK2kpIHtcbiAgICBqRGF5Tm8gKz0gakRheXNJbk1vbnRoW2ldO1xuICB9XG5cbiAgakRheU5vICs9IGpkO1xuICB2YXIgZ0RheU5vID0gakRheU5vICsgNzk7XG4gIHZhciBneSA9IDE2MDAgKyA0MDAgKiBwYXJzZUludChnRGF5Tm8gLyAxNDYwOTcpO1xuICBnRGF5Tm8gPSBnRGF5Tm8gJSAxNDYwOTc7XG4gIHZhciBsZWFwID0gdHJ1ZTtcblxuICBpZiAoZ0RheU5vID49IDM2NTI1KSB7XG4gICAgZ0RheU5vLS07XG4gICAgZ3kgKz0gMTAwICogcGFyc2VJbnQoZ0RheU5vIC8gMzY1MjQpO1xuICAgIGdEYXlObyA9IGdEYXlObyAlIDM2NTI0O1xuXG4gICAgaWYgKGdEYXlObyA+PSAzNjUpIHtcbiAgICAgIGdEYXlObysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWFwID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZ3kgKz0gNCAqIHBhcnNlSW50KGdEYXlObyAvIDE0NjEpO1xuICBnRGF5Tm8gJT0gMTQ2MTtcblxuICBpZiAoZ0RheU5vID49IDM2Nikge1xuICAgIGxlYXAgPSBmYWxzZTtcbiAgICBnRGF5Tm8tLTtcbiAgICBneSArPSBwYXJzZUludChnRGF5Tm8gLyAzNjUpO1xuICAgIGdEYXlObyA9IGdEYXlObyAlIDM2NTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGdEYXlObyA+PSBnRGF5c0luTW9udGhbaV0gKyAoaSA9PSAxICYmIGxlYXApOyBpKyspIHtcbiAgICBnRGF5Tm8gLT0gZ0RheXNJbk1vbnRoW2ldICsgKGkgPT0gMSAmJiBsZWFwKTtcbiAgfVxuXG4gIHZhciBnbSA9IGkgKyAxO1xuICB2YXIgZ2QgPSBnRGF5Tm8gKyAxO1xuICByZXR1cm4gW2d5LCBnbSwgZ2RdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RhdGUoalksIGpNLCBqRCkge1xuICByZXR1cm4gIShqWSA8IDAgfHwgalkgPiAzMjc2NyB8fCBqTSA8IDEgfHwgak0gPiAxMiB8fCBqRCA8IDEgfHwgakQgPiBqRGF5c0luTW9udGhbak0gLSAxXSArIChqTSA9PSAxMiAmJiAoalkgLSA5NzkpICUgMzMgJSA0ID09PSAwKSk7XG59XG5cbmZ1bmN0aW9uIGdyZWdvcmlhblRvSmFsYWxpKGdZLCBnTSwgZ0QpIHtcbiAgZ1kgPSBwYXJzZUludChnWSk7XG4gIGdNID0gcGFyc2VJbnQoZ00pO1xuICBnRCA9IHBhcnNlSW50KGdEKTtcbiAgdmFyIGk7XG4gIHZhciBneSA9IGdZIC0gMTYwMDtcbiAgdmFyIGdtID0gZ00gLSAxO1xuICB2YXIgZ2QgPSBnRCAtIDE7XG4gIHZhciBnRGF5Tm8gPSAzNjUgKiBneSArIHBhcnNlSW50KChneSArIDMpIC8gNCkgLSBwYXJzZUludCgoZ3kgKyA5OSkgLyAxMDApICsgcGFyc2VJbnQoKGd5ICsgMzk5KSAvIDQwMCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGdtOyArK2kpIHtcbiAgICBnRGF5Tm8gKz0gZ0RheXNJbk1vbnRoW2ldO1xuICB9XG5cbiAgaWYgKGdtID4gMSAmJiAoZ3kgJSA0ID09PSAwICYmIGd5ICUgMTAwICE9PSAwIHx8IGd5ICUgNDAwID09PSAwKSkge1xuICAgICsrZ0RheU5vO1xuICB9XG5cbiAgZ0RheU5vICs9IGdkO1xuICB2YXIgakRheU5vID0gZ0RheU5vIC0gNzk7XG4gIHZhciBqTnAgPSBwYXJzZUludChqRGF5Tm8gLyAxMjA1Myk7XG4gIGpEYXlObyAlPSAxMjA1MztcbiAgdmFyIGp5ID0gOTc5ICsgMzMgKiBqTnAgKyA0ICogcGFyc2VJbnQoakRheU5vIC8gMTQ2MSk7XG4gIGpEYXlObyAlPSAxNDYxO1xuXG4gIGlmIChqRGF5Tm8gPj0gMzY2KSB7XG4gICAgankgKz0gcGFyc2VJbnQoKGpEYXlObyAtIDEpIC8gMzY1KTtcbiAgICBqRGF5Tm8gPSAoakRheU5vIC0gMSkgJSAzNjU7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTEgJiYgakRheU5vID49IGpEYXlzSW5Nb250aFtpXTsgKytpKSB7XG4gICAgakRheU5vIC09IGpEYXlzSW5Nb250aFtpXTtcbiAgfVxuXG4gIHZhciBqbSA9IGkgKyAxO1xuICB2YXIgamQgPSBqRGF5Tm8gKyAxO1xuICByZXR1cm4gW2p5LCBqbSwgamRdO1xufVxuXG5jYWxlbmRhcnMuamFsYWxpID0ge1xuICBnZXRZZWFyOiBmdW5jdGlvbiBnZXRZZWFyKGRhdGUpIHtcbiAgICByZXR1cm4gZ3JlZ29yaWFuVG9KYWxhbGkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCBkYXRlLmdldERhdGUoKSlbMF07XG4gIH0sXG4gIGdldE1vbnRoOiBmdW5jdGlvbiBnZXRNb250aChkYXRlKSB7XG4gICAgcmV0dXJuIC0tZ3JlZ29yaWFuVG9KYWxhbGkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCBkYXRlLmdldERhdGUoKSlbMV07XG4gIH0sXG4gIGdldERheTogZnVuY3Rpb24gZ2V0RGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZ3JlZ29yaWFuVG9KYWxhbGkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCBkYXRlLmdldERhdGUoKSlbMl07XG4gIH0sXG4gIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoeSwgbSwgZCwgaCwgaSwgcywgdSkge1xuICAgIGlmIChtIDwgMCkge1xuICAgICAgeSArPSBNYXRoLmZsb29yKG0gLyAxMik7XG4gICAgICBtID0gbSAlIDEyID8gMTIgKyBtICUgMTIgOiAwO1xuICAgIH1cblxuICAgIGlmIChtID4gMTEpIHtcbiAgICAgIHkgKz0gTWF0aC5mbG9vcihtIC8gMTIpO1xuICAgICAgbSA9IG0gJSAxMjtcbiAgICB9XG5cbiAgICB2YXIgZ3JlZ29yaWFuRGF0ZSA9IGphbGFsaVRvR3JlZ29yaWFuKHksICttICsgMSwgZCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGdyZWdvcmlhbkRhdGVbMF0sIGdyZWdvcmlhbkRhdGVbMV0gLSAxLCBncmVnb3JpYW5EYXRlWzJdLCBoIHx8IDAsIGkgfHwgMCwgcyB8fCAwLCB1IHx8IDApO1xuICB9LFxuICBnZXRNYXhEYXlPZk1vbnRoOiBmdW5jdGlvbiBnZXRNYXhEYXlPZk1vbnRoKHksIG0pIHtcbiAgICB2YXIgbWF4ZGF5cyA9IDMxO1xuXG4gICAgaWYgKG0gPCAwKSB7XG4gICAgICB5ICs9IE1hdGguZmxvb3IobSAvIDEyKTtcbiAgICAgIG0gPSBtICUgMTIgPyAxMiArIG0gJSAxMiA6IDA7XG4gICAgfVxuXG4gICAgaWYgKG0gPiAxMSkge1xuICAgICAgeSArPSBNYXRoLmZsb29yKG0gLyAxMik7XG4gICAgICBtID0gbSAlIDEyO1xuICAgIH1cblxuICAgIHdoaWxlIChjaGVja0RhdGUoeSwgbSArIDEsIG1heGRheXMpID09PSBmYWxzZSkge1xuICAgICAgbWF4ZGF5cy0tO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhkYXlzO1xuICB9XG59O1xuXG4vLyDZgdin2LHYs9uMXG5tb2Jpc2Nyb2xsLmkxOG4uZmEgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ9iq2KfZitmK2K8nLFxuICBjYW5jZWxUZXh0OiAn2KfZhti12LHYp9mBJyxcbiAgY2xlYXJUZXh0OiAn2YjYp9i22K0gJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDZhdmG2KrYrtioJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGNhbGVuZGFyU3lzdGVtOiAnamFsYWxpJyxcbiAgZGF0ZUZvcm1hdDogJ3l5L21tL2RkJyxcbiAgZGF5TmFtZXM6IFsn2Yraqdi02YbYqNmHJywgJ9iv2YjYtNmG2KjZhycsICfYs9mH4oCM2LTZhtio2YcnLCAn2obZh9in2LHYtNmG2KjZhycsICfZvtmG2KzigIzYtNmG2KjZhycsICfYrNmF2LnZhycsICfYtNmG2KjZhyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ9uMJywgJ9ivJywgJ9izJywgJ9qGJywgJ9m+JywgJ9isJywgJ9i0J10sXG4gIGRheU5hbWVzTWluOiBbJ9uMJywgJ9ivJywgJ9izJywgJ9qGJywgJ9m+JywgJ9isJywgJ9i0J10sXG4gIGRheVRleHQ6ICfYsdmI2LInLFxuICBob3VyVGV4dDogJ9iz2KfYudiqJyxcbiAgbWludXRlVGV4dDogJ9iv2YLZitmC2YcnLFxuICBtb250aE5hbWVzOiBbJ9mB2LHZiNix2K/ZitmGJywgJ9in2LHYr9mK2KjZh9i02KonLCAn2K7Ysdiv2KfYrycsICfYqtmK2LEnLCAn2YXYsdiv2KfYrycsICfYtNmH2LHZitmI2LEnLCAn2YXZh9ixJywgJ9ii2KjYp9mGJywgJ9ii2LDYsScsICfYr9uMJywgJ9io2YfZhdmGJywgJ9in2LPZgdmG2K8nXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ9mB2LHZiNix2K/ZitmGJywgJ9in2LHYr9mK2KjZh9i02KonLCAn2K7Ysdiv2KfYrycsICfYqtmK2LEnLCAn2YXYsdiv2KfYrycsICfYtNmH2LHZitmI2LEnLCAn2YXZh9ixJywgJ9ii2KjYp9mGJywgJ9ii2LDYsScsICfYr9uMJywgJ9io2YfZhdmGJywgJ9in2LPZgdmG2K8nXSxcbiAgbW9udGhUZXh0OiAn2YXYp9mHJyxcbiAgc2VjVGV4dDogJ9ir2KfZhtmK2YcnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB0aW1lV2hlZWxzOiAnaWlISCcsXG4gIC8vIE5lZWQgdGhpcyBmb3IgY29ycmVjdCBSVEwgZGlzcGxheVxuICB5ZWFyVGV4dDogJ9iz2KfZhCcsXG4gIG5vd1RleHQ6ICfYp9qp2YbZiNmGJyxcbiAgYW1UZXh0OiAn2KgnLFxuICBwbVRleHQ6ICfYtScsXG4gIHRvZGF5VGV4dDogJ9in2YXYsdmI2LInLFxuICAvL2dldE51bWJlcjogZnVuY3Rpb24gKG4pIHtcbiAgLy8gICAgdmFyIGksXG4gIC8vICAgICAgICBudW1zID0gW1wi27BcIiwgXCLbsVwiLCBcItuyXCIsIFwi27NcIiwgXCLbtFwiLCBcItu1XCIsIFwi27ZcIiwgXCLbt1wiLCBcItu4XCIsIFwi27lcIl0sXG4gIC8vICAgICAgICByZXMgPSAnJztcbiAgLy8gICAgbiA9IG4gKyAnJztcbiAgLy8gICAgZm9yIChpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgICAgIHJlcyArPSBudW1zWytuW2ldXTtcbiAgLy8gICAgfVxuICAvLyAgICByZXR1cm4gcmVzO1xuICAvL30sXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogNixcbiAgcnRsOiB0cnVlLFxuICBkYXRlVGV4dDogJ9iq2KfYsduM2K4gJyxcbiAgdGltZVRleHQ6ICfYstmF2KfZhiAnLFxuICBjbG9zZVRleHQ6ICfZhtiy2K/bjNqpJyxcbiAgYWxsRGF5VGV4dDogJ9iq2YXYp9mFINix2YjYsicsXG4gIG5vRXZlbnRzVGV4dDogJ9mH24zahiDYsdmI24zYr9in2K8nLFxuICBldmVudFRleHQ6ICfYsdmI24zYr9in2K8nLFxuICBldmVudHNUZXh0OiAn2LHZiNuM2K/Yp9iv2YfYpycsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSDZhdmI2LHYryDYr9uM2q/YsScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfYtNix2YjYuSAnLFxuICB0b1RleHQ6ICfZvtin24zYp9mGJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICfYqtmF2KfZhScsXG4gIGZyYWN0aW9uVGV4dDogJ9qp2LPYsScsXG4gIHVuaXRUZXh0OiAn2YjYp9it2K8nLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyfYs9in2YQnLCAn2YXYp9mHJywgJ9ix2YjYsicsICfYs9in2LnYqicsICfYr9mC24zZgtmHJywgJ9ir2KfZhtuM2YcnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ9iz2KfZhCcsICfZhdin2YcnLCAn2LHZiNiyJywgJ9iz2KfYudiqJywgJ9iv2YLbjNmC2YcnLCAn2KvYp9mG24zZhycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ9i02LHZiNi5JyxcbiAgc3RvcFRleHQ6ICfZvtin2YrYp9mGJyxcbiAgcmVzZXRUZXh0OiAn2KrZhti424zZhSDZhdis2K/YrycsXG4gIGxhcFRleHQ6ICdMYXAnLFxuICBoaWRlVGV4dDogJ9m+2YbZh9in2YYg2qnYsdiv2YYnLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ9m+2LTYqicsXG4gIHVuZG9UZXh0OiAn2YjYp9qG24zYr9mGJ1xufTtcblxuLy8gU3VvbWlcbm1vYmlzY3JvbGwuaTE4bi5maSA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnQXNldGEnLFxuICBjYW5jZWxUZXh0OiAnUGVydXV0YScsXG4gIGNsZWFyVGV4dDogJ1R5aGplbm7DpCcsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gdmFsaXRhJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkLiBNTSB5eScsXG4gIGRheU5hbWVzOiBbJ1N1bm51bnRhaScsICdNYWFuYW50YWknLCAnVGlpc3RhaScsICdLZXNraXZpaWtvJywgJ1RvcnN0YWknLCAnUGVyamFudGFpJywgJ0xhdWFudGFpJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnU3UnLCAnTWEnLCAnVGknLCAnS2UnLCAnVG8nLCAnUGUnLCAnTGEnXSxcbiAgZGF5TmFtZXNNaW46IFsnUycsICdNJywgJ1QnLCAnSycsICdUJywgJ1AnLCAnTCddLFxuICBkYXlUZXh0OiAnUMOkaXbDpCcsXG4gIGRlbGltaXRlcjogJy4nLFxuICBob3VyVGV4dDogJ1R1bnRpYScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dXR0aScsXG4gIG1vbnRoTmFtZXM6IFsnVGFtbWlrdXUnLCAnSGVsbWlrdXUnLCAnTWFhbGlza3V1JywgJ0h1aHRpa3V1JywgJ1RvdWtva3V1JywgJ0tlc8Oka3V1JywgJ0hlaW7DpGt1dScsICdFbG9rdXUnLCAnU3l5c2t1dScsICdMb2tha3V1JywgJ01hcnJhc2t1dScsICdKb3VsdWt1dSddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnVGFtJywgJ0hlbCcsICdNYWEnLCAnSHVoJywgJ1RvdScsICdLZXMnLCAnSGVpJywgJ0VsbycsICdTeXknLCAnTG9rJywgJ01hcicsICdKb3UnXSxcbiAgbW9udGhUZXh0OiAnS3V1a2F1c2knLFxuICBzZWNUZXh0OiAnU2VrdW5kYScsXG4gIHRpbWVGb3JtYXQ6ICdIOmlpJyxcbiAgeWVhclRleHQ6ICdWdW9zaScsXG4gIG5vd1RleHQ6ICdOeXQnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ1DDpGl2w6R5cycsXG4gIHRpbWVUZXh0OiAnQWlrYScsXG4gIHRvZGF5VGV4dDogJ1TDpG7DpMOkbicsXG4gIHByZXZNb250aFRleHQ6ICdFZGVsbGluZW4ga3V1a2F1c2knLFxuICBuZXh0TW9udGhUZXh0OiAnRW5zaSBrdXVzc2EnLFxuICBwcmV2WWVhclRleHQ6ICdFZGVsbGluZW4gdnVvc2knLFxuICBuZXh0WWVhclRleHQ6ICdFbnNpIHZ1b3NpJyxcbiAgY2xvc2VUZXh0OiAnU3VsamUnLFxuICBldmVudFRleHQ6ICdUYXBhaHR1bWlhJyxcbiAgZXZlbnRzVGV4dDogJ1RhcGFodHVtaWEnLFxuICBhbGxEYXlUZXh0OiAnS29rbyBww6RpdsOkJyxcbiAgbm9FdmVudHNUZXh0OiAnRWkgdGFwYWh0dW1pYScsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBtdXUnLFxuICBtb3JlRXZlbnRzUGx1cmFsVGV4dDogJ3tjb3VudH0gbXV1dGEnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnQWxrYWEnLFxuICB0b1RleHQ6ICdQw6TDpHR0eXknLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0tva29uYWluZW4nLFxuICBmcmFjdGlvblRleHQ6ICdNdXJ0b2x1a3UnLFxuICB1bml0VGV4dDogJ1lrc2lra8O2JyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsnVnVvc2knLCAnS3V1a2F1c2knLCAnUMOkaXbDpCcsICdUdW5uaW4nLCAnTWludXV0dGknLCAnc2VrdW50aWEnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ1Z1bycsICdLdXUnLCAnUMOkaScsICdUdW4nLCAnTWluJywgJ1NlaycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ0vDpHlubmlzdHlzJyxcbiAgc3RvcFRleHQ6ICdTZWlzJyxcbiAgcmVzZXRUZXh0OiAnQXNldGEgdXVkZWxsZWVuJyxcbiAgbGFwVGV4dDogJ0tpZXJyb3MnLFxuICBoaWRlVGV4dDogJ1Z1b3RhJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdFZGVsbGluZW4nLFxuICB1bmRvVGV4dDogJ0t1bW9hJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnUG9pcycsXG4gIG9uVGV4dDogJ1DDpMOkbGzDpCcsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBGcmFuw6dhaXNcbm1vYmlzY3JvbGwuaTE4bi5mciA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnVGVybWluZXInLFxuICBjYW5jZWxUZXh0OiAnQW5udWxlcicsXG4gIGNsZWFyVGV4dDogJ0VmZmFjZXInLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IHPDqWxlY3Rpb25uw6knLFxuICBzZWxlY3RlZFBsdXJhbFRleHQ6ICd7Y291bnR9IHPDqWxlY3Rpb25uw6lzJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG4gIGRheU5hbWVzOiBbJ0RpbWFuY2hlJywgJ0x1bmRpJywgJ01hcmRpJywgJ01lcmNyZWRpJywgJ0pldWRpJywgJ1ZlbmRyZWRpJywgJ1NhbWVkaSddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ0RpbS4nLCAnTHVuLicsICdNYXIuJywgJ01lci4nLCAnSmV1LicsICdWZW4uJywgJ1NhbS4nXSxcbiAgZGF5TmFtZXNNaW46IFsnRCcsICdMJywgJ00nLCAnTScsICdKJywgJ1YnLCAnUyddLFxuICBkYXlUZXh0OiAnSm91cicsXG4gIG1vbnRoVGV4dDogJ01vaXMnLFxuICBtb250aE5hbWVzOiBbJ0phbnZpZXInLCAnRsOpdnJpZXInLCAnTWFycycsICdBdnJpbCcsICdNYWknLCAnSnVpbicsICdKdWlsbGV0JywgJ0Fvw7t0JywgJ1NlcHRlbWJyZScsICdPY3RvYnJlJywgJ05vdmVtYnJlJywgJ0TDqWNlbWJyZSddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFudi4nLCAnRsOpdnIuJywgJ01hcnMnLCAnQXZyaWwnLCAnTWFpJywgJ0p1aW4nLCAnSnVpbC4nLCAnQW/Du3QnLCAnU2VwdC4nLCAnT2N0LicsICdOb3YuJywgJ0TDqWMuJ10sXG4gIGhvdXJUZXh0OiAnSGV1cmVzJyxcbiAgbWludXRlVGV4dDogJ01pbnV0ZXMnLFxuICBzZWNUZXh0OiAnU2Vjb25kZXMnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ0FubsOpZScsXG4gIG5vd1RleHQ6ICdNYWludGVuYW50JyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIHRvZGF5VGV4dDogXCJBdWpvdXJkJ2h1aVwiLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0ZScsXG4gIHRpbWVUZXh0OiAnSGV1cmUnLFxuICBjbG9zZVRleHQ6ICdGZXJtZXInLFxuICBhbGxEYXlUZXh0OiAnVG91dGUgbGEgam91cm7DqWUnLFxuICBub0V2ZW50c1RleHQ6ICdBdWN1biDDqXbDqW5lbWVudCcsXG4gIGV2ZW50VGV4dDogJ8OJdsOpbmVtZW50JyxcbiAgZXZlbnRzVGV4dDogJ8OJdsOpbmVtZW50cycsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSBhdXRyZScsXG4gIG1vcmVFdmVudHNQbHVyYWxUZXh0OiAne2NvdW50fSBhdXRyZXMnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnRMOpbWFycmVyJyxcbiAgdG9UZXh0OiAnRmluJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdFbnRpZXInLFxuICBmcmFjdGlvblRleHQ6ICdGcmFjdGlvbicsXG4gIHVuaXRUZXh0OiAnVW5pdMOpJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsnQW5zJywgJ01vaXMnLCAnSm91cnMnLCAnSGV1cmVzJywgJ01pbnV0ZXMnLCAnU2Vjb25kZXMnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ0FucycsICdNb2lzJywgJ0pvdXJzJywgJ0hycycsICdNaW4nLCAnU2VjJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnRMOpbWFycmVyJyxcbiAgc3RvcFRleHQ6ICdBcnLDqnRlcicsXG4gIHJlc2V0VGV4dDogJ1LDqWluaXRpYWxpc2VyJyxcbiAgbGFwVGV4dDogJ0xhcCcsXG4gIGhpZGVUZXh0OiAnQ2FjaGV6JyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdSZXRvdXInLFxuICB1bmRvVGV4dDogJ0FubnVsZXInLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdOb24nLFxuICBvblRleHQ6ICdPdWknLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gSGVicmV3XG5tb2Jpc2Nyb2xsLmkxOG4uaGUgPSB7XG4gIC8vIENvcmVcbiAgcnRsOiB0cnVlLFxuICAvLyBSaWdodCB0byBsZWZ0IG1vZGVcbiAgc2V0VGV4dDogJ9ep157Xmdeo15QnLFxuICBjYW5jZWxUZXh0OiAn15HXmdeY15XXnCcsXG4gIGNsZWFyVGV4dDogJ9eg16fXlCcsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0g16DXkdeX16gnLFxuICBzZWxlY3RlZFBsdXJhbFRleHQ6ICd7Y291bnR9INeg15HXl9eo15UnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ2RkL21tL3l5JyxcbiAgZGF5TmFtZXM6IFsn16jXkNep15XXnycsICfXqdeg15knLCAn16nXnNeZ16nXmScsICfXqNeR15nXoteZJywgJ9eX157Xmdep15knLCAn16nXmdep15knLCAn16nXkdeqJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFtcIteQJ1wiLCBcIteRJ1wiLCBcIteSJ1wiLCBcIteTJ1wiLCBcIteUJ1wiLCBcIteVJ1wiLCBcItepJ1wiXSxcbiAgZGF5TmFtZXNNaW46IFsn15AnLCAn15EnLCAn15InLCAn15MnLCAn15QnLCAn15UnLCAn16knXSxcbiAgZGF5VGV4dDogJ9eZ15XXnScsXG4gIGhvdXJUZXh0OiAn16nXoteV16onLFxuICBtaW51dGVUZXh0OiAn15PXp9eV16onLFxuICBtb250aE5hbWVzOiBbJ9eZ16DXldeQ16gnLCAn16TXkdeo15XXkNeoJywgJ9ee16jXpScsICfXkNek16jXmdecJywgJ9ee15DXmScsICfXmdeV16DXmScsICfXmdeV15zXmScsICfXkNeV15LXldeh15gnLCAn16HXpNeY157XkdeoJywgJ9eQ15XXp9eY15XXkdeoJywgJ9eg15XXkdee15HXqCcsICfXk9em157XkdeoJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogW1wi15nXoNeVXCIsIFwi16TXkdeoXCIsIFwi157XqNelXCIsIFwi15DXpNeoXCIsIFwi157XkNeZXCIsIFwi15nXldegXCIsIFwi15nXldecXCIsIFwi15DXldeSXCIsIFwi16HXpNeYXCIsIFwi15DXldenXCIsIFwi16DXldeRXCIsIFwi15PXpteeXCJdLFxuICBtb250aFRleHQ6ICfXl9eV15PXqScsXG4gIHNlY1RleHQ6ICfXqdeg15nXldeqJyxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbScsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHRpbWVXaGVlbHM6ICdpaUhIJyxcbiAgLy8gTmVlZCB0aGlzIGZvciBjb3JyZWN0IFJUTCBkaXNwbGF5XG4gIHllYXJUZXh0OiAn16nXoNeUJyxcbiAgbm93VGV4dDogJ9ei15vXqdeZ15UnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDAsXG4gIGRhdGVUZXh0OiAn16rXkNeo15nXmicsXG4gIHRpbWVUZXh0OiAn15bXntefJyxcbiAgY2xvc2VUZXh0OiAn16HXkteZ16jXlCcsXG4gIHRvZGF5VGV4dDogJ9eU15nXldedJyxcbiAgYWxsRGF5VGV4dDogJ9eb15wg15TXmdeV150nLFxuICBub0V2ZW50c1RleHQ6ICfXkNeZ158g15DXmdeo15XXoteZ150nLFxuICAvLyBFdmVudCBjYWxlbmRhclxuICBldmVudFRleHQ6ICfXnta016fXqNa215QnLFxuICBldmVudHNUZXh0OiAn157WtNen16jWtteUJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICfXkNeZ16jXldeiINeQ15fXkyDXoNeV16HXoycsXG4gIG1vcmVFdmVudHNQbHVyYWxUZXh0OiAne2NvdW50fSDXkNeZ16jXldei15nXnSDXoNeV16HXpNeZ150nLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAn15TXqteX15zXlCcsXG4gIHRvVGV4dDogJ9eh15nXldedJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICfXm9a81rnXnCcsXG4gIGZyYWN0aW9uVGV4dDogJ9ep15HXqNeZ16gnLFxuICB1bml0VGV4dDogJ9eZ15fXmdeT15QnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyfXqdeg15nXnScsICfXl9eV15PXqdeZ150nLCAn15nXnteZ150nLCAn16nXoteV16onLCAn15PXp9eV16onLCAn16nXoNeZ15nXnScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsn16nXoNeZ150nLCAn15fXldeT16nXmdedJywgJ9eZ157XmdedJywgJ9ep16LXldeqJywgJ9eT16fXldeqJywgJ9ep16DXmdeZ150nLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICfXlNeq15fXnCcsXG4gIHN0b3BUZXh0OiAn16LXpteV16gnLFxuICByZXNldFRleHQ6ICfXkNeq15fXldecJyxcbiAgbGFwVGV4dDogJ9eU16fXpNeUJyxcbiAgaGlkZVRleHQ6ICfXlNeh16rXqCcsXG4gIC8vIEZvcm1zXG4gIG9mZlRleHQ6ICfXm9eZ15HXldeZJyxcbiAgb25UZXh0OiAn15TXpNei15zXlCcsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAn15fXlteV16gnLFxuICB1bmRvVGV4dDogJ9eR15nXmNeV15wg16TXoteV15zXlCdcbn07XG5cbi8vIEhpbmRpXG5tb2Jpc2Nyb2xsLmkxOG4uaGkgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ+CkuOCliOCknyDgpJXgpLDgpYfgpIInLFxuICBjYW5jZWxUZXh0OiAn4KSw4KSm4KWN4KSmIOCkleCksOClh+CkgicsXG4gIGNsZWFyVGV4dDogJ+CkuOCkvuClniDgpJXgpYsnLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IOCkmuCkr+CkqOCkv+CkpCcsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuICBkYXlOYW1lczogWyfgpLDgpLXgpL/gpLXgpL7gpLAnLCAn4KS44KWL4KSu4KS14KS+4KSwJywgJ+CkruCkguCkl+CksuCkteCkvuCksCcsICfgpKzgpYHgpKfgpLXgpL7gpLAnLCAn4KSX4KWB4KSw4KWB4KS14KS+4KSwJywgJ+CktuClgeCkleCljeCksOCkteCkvuCksCcsICfgpLbgpKjgpL/gpLXgpL7gpLAnXSxcbiAgZGF5TmFtZXNTaG9ydDogWyfgpLDgpLXgpL8nLCAn4KS44KWL4KSuJywgJ+CkruCkguCkl+CksicsICfgpKzgpYHgpKcnLCAn4KSX4KWB4KSw4KWBJywgJ+CktuClgeCkleCljeCksCcsICfgpLbgpKjgpL8nXSxcbiAgZGF5TmFtZXNNaW46IFsn4KSw4KS14KS/JywgJ+CkuOCli+CkricsICfgpK7gpILgpJfgpLInLCAn4KSs4KWB4KSnJywgJ+Ckl+ClgeCksOClgScsICfgpLbgpYHgpJXgpY3gpLAnLCAn4KS24KSo4KS/J10sXG4gIGRheVRleHQ6ICfgpKbgpL/gpKgnLFxuICBkZWxpbWl0ZXI6ICcuJyxcbiAgaG91clRleHQ6ICfgpJjgpILgpJ/gpL4nLFxuICBtaW51dGVUZXh0OiAn4KSu4KS/4KSo4KSfJyxcbiAgbW9udGhOYW1lczogWyfgpJzgpKjgpLXgpLDgpYAgJywgJ+Ckq+CksOCkteCksOClgCcsICfgpK7gpL7gpLDgpY3gpJonLCAn4KSF4KSq4KWN4KSw4KWH4KSyJywgJ+CkruCkiCcsICfgpJzgpYLgpKgnLCAn4KSc4KWC4KSy4KS+4KSIJywgJ+CkheCkl+CkuOCljeCkpCAnLCAn4KS44KS/4KSk4KSu4KWN4KSs4KSwJywgJ+CkheCkleCljeCkn+ClguCkrOCksCcsICfgpKjgpLXgpK7gpY3gpKzgpLAnLCAn4KSm4KS/4KS44KSu4KWN4KSs4KSwJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWyfgpJzgpKgnLCAn4KSr4KSwJywgJ+CkruCkvuCksOCljeCkmicsICfgpIXgpKrgpY3gpLDgpYfgpLInLCAn4KSu4KSIJywgJ+CknOClguCkqCcsICfgpJzgpYLgpLLgpL7gpIgnLCAn4KSF4KSXJywgJ+CkuOCkv+CkpCcsICfgpIXgpJXgpY3gpJ8nLCAn4KSo4KS1JywgJ+CkpuCkvyddLFxuICBtb250aFRleHQ6ICfgpK7gpLngpYDgpKjgpL4nLFxuICBzZWNUZXh0OiAn4KS44KWH4KSV4KSC4KShJyxcbiAgdGltZUZvcm1hdDogJ0g6aWknLFxuICB5ZWFyVGV4dDogJ+CkuOCkvuCksicsXG4gIG5vd1RleHQ6ICfgpIXgpKwnLFxuICBwbVRleHQ6ICfgpIXgpKrgpLDgpL7gpLngpY3gpKgnLFxuICBhbVRleHQ6ICfgpKrgpYLgpLDgpY3gpLXgpL7gpLngpY3gpKgnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAn4KSk4KS/4KSl4KS/JyxcbiAgdGltZVRleHQ6ICfgpLjgpK7gpK8nLFxuICB0b2RheVRleHQ6ICfgpIbgpJwnLFxuICBwcmV2TW9udGhUZXh0OiAn4KSq4KS/4KSb4KWN4KSy4KS+IOCkruCkueCkv+CkqOCkvicsXG4gIG5leHRNb250aFRleHQ6ICfgpIXgpJfgpLLgpYcg4KSu4KS54KWA4KSo4KWHJyxcbiAgcHJldlllYXJUZXh0OiAn4KSq4KS/4KSb4KSy4KS+IOCkuOCkvuCksicsXG4gIG5leHRZZWFyVGV4dDogJ+CkheCkl+CksuClhyDgpLXgpLDgpY3gpLcnLFxuICBjbG9zZVRleHQ6ICfgpKzgpILgpKYnLFxuICBldmVudFRleHQ6ICfgpIfgpLXgpYfgpJ/gpaknLFxuICBldmVudHNUZXh0OiAn4KSH4KS14KWH4KSf4KWpJyxcbiAgYWxsRGF5VGV4dDogJ+CkquClguCksOClhyDgpKbgpL/gpKgnLFxuICBub0V2ZW50c1RleHQ6ICdFaSB0YXBhaHR1bWlhJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IOCklOCksCcsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfgpLjgpYcnLFxuICB0b1RleHQ6ICfgpKTgpJUnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ+CkuOCkruClguCkmuCkvicsXG4gIGZyYWN0aW9uVGV4dDogJ+CkheCkguCkticsXG4gIHVuaXRUZXh0OiAn4KSH4KSV4KS+4KSIJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn4KS44KS+4KSyJywgJ+CkruCkueClgOCkqOClhycsICfgpKbgpL/gpKgnLCAn4KSY4KSC4KSf4KWHJywgJ+CkruCkv+CkqOCknycsICfgpLjgpYfgpJXgpILgpKEnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ+CkuOCkvuCksicsICfgpK7gpLngpYDgpKjgpYcnLCAn4KSm4KS/4KSoJywgJ+CkmOCkguCkn+ClhycsICfgpK7gpL/gpKjgpJ8nLCAn4KS44KWH4KSV4KSC4KShJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn4KSq4KWN4KSw4KS+4KSw4KSC4KStJyxcbiAgc3RvcFRleHQ6ICfgpLDgpYvgpJXgpYfgpIInLFxuICByZXNldFRleHQ6ICfgpLDgpYDgpLjgpYfgpJ8g4KSV4KSw4KWH4KSCJyxcbiAgbGFwVGV4dDogJ+CksuCliOCkqicsXG4gIGhpZGVUZXh0OiAn4KSb4KS/4KSq4KS+4KSo4KS+JyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfgpLXgpL7gpKrgpLgnLFxuICAvLyBjaGVja1xuICB1bmRvVGV4dDogJ+CkteCkvuCkquCkuCDgpLLgpL7gpI/gpIInLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICfgpKzgpILgpKYnLFxuICBvblRleHQ6ICfgpJrgpL7gpLLgpYInLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gQ3JvYXRpYW5cbm1vYmlzY3JvbGwuaTE4bi5ociA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnUG9zdGF2aScsXG4gIGNhbmNlbFRleHQ6ICdJemxheicsXG4gIGNsZWFyVGV4dDogJ0l6YnJpxaFpJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBvZGFicmFuJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG4gIGRheU5hbWVzOiBbJ05lZGplbGphJywgJ1BvbmVkamVsamFrJywgJ1V0b3JhaycsICdTcmlqZWRhJywgJ8SMZXR2cnRhaycsICdQZXRhaycsICdTdWJvdGEnXSxcbiAgZGF5TmFtZXNTaG9ydDogWydOZWQnLCAnUG9uJywgJ1V0bycsICdTcmknLCAnxIxldCcsICdQZXQnLCAnU3ViJ10sXG4gIGRheU5hbWVzTWluOiBbJ05lJywgJ1BvJywgJ1V0JywgJ1NyJywgJ8SMZScsICdQZScsICdTdSddLFxuICBkYXlUZXh0OiAnRGFuJyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAnU2F0JyxcbiAgbWludXRlVGV4dDogJ01pbnV0YScsXG4gIG1vbnRoTmFtZXM6IFsnU2lqZcSNYW5qJywgJ1ZlbGphxI1hJywgJ0/FvnVqYWsnLCAnVHJhdmFuaicsICdTdmliYW5qJywgJ0xpcGFuaicsICdTcnBhbmonLCAnS29sb3ZveicsICdSdWphbicsICdMaXN0b3BhZCcsICdTdHVkZW5pJywgJ1Byb3NpbmFjJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydTaWonLCAnVmVsaicsICdPxb51JywgJ1RyYScsICdTdmknLCAnTGlwJywgJ1NycCcsICdLb2wnLCAnUnVqJywgJ0xpcycsICdTdHUnLCAnUHJvJ10sXG4gIG1vbnRoVGV4dDogJ01qZXNlYycsXG4gIHNlY1RleHQ6ICdTZWt1bmRhJyxcbiAgdGltZUZvcm1hdDogJ0g6aWknLFxuICB5ZWFyVGV4dDogJ0dvZGluYScsXG4gIG5vd1RleHQ6ICdTYWRhJyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICdEYXR1bScsXG4gIHRpbWVUZXh0OiAnVnJpamVtZScsXG4gIHRvZGF5VGV4dDogJ0RhbmFzJyxcbiAgcHJldk1vbnRoVGV4dDogJ1ByZXRob2RuaSBtamVzZWMnLFxuICBuZXh0TW9udGhUZXh0OiAnU2xqZWRlxIdpIG1qZXNlYycsXG4gIHByZXZZZWFyVGV4dDogJ1ByZXRob2RuaSBnb2RpbmEnLFxuICBuZXh0WWVhclRleHQ6ICdTbGlqZWRlxIdlIGdvZGluZScsXG4gIGNsb3NlVGV4dDogJ1phdHZvcmknLFxuICBldmVudFRleHQ6ICdEb2dhxJFhaicsXG4gIGV2ZW50c1RleHQ6ICdkb2dhxJFhamEnLFxuICBhbGxEYXlUZXh0OiAnQ2lqZWxpIGRhbicsXG4gIG5vRXZlbnRzVGV4dDogJ0JleiBkb2dhxJFhamEnLFxuICBtb3JlRXZlbnRzVGV4dDogJ0pvxaEge2NvdW50fScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICdQb8SNaW5qZScsXG4gIHRvVGV4dDogJ1phdnLFoWF2YScsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnQ2plbGluYScsXG4gIGZyYWN0aW9uVGV4dDogJ0ZyYWtjaWphJyxcbiAgdW5pdFRleHQ6ICdKZWRpbmljYScsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ2dvZGluYScsICdtamVzZWMnLCAnZGFuJywgJ3NhdCcsICdtaW51dGEnLCAnc2VrdW5kYScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnZ29kJywgJ21qZScsICdkYW4nLCAnc2F0JywgJ21pbicsICdzZWMnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdQb8SNZXRhaycsXG4gIHN0b3BUZXh0OiAnUHJla2lkJyxcbiAgcmVzZXRUZXh0OiAnUmVzZXRpcmFqJyxcbiAgbGFwVGV4dDogJ0Npa2x1cycsXG4gIGhpZGVUZXh0OiAnU2Frcml0aScsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnTmF0cmFnJyxcbiAgdW5kb1RleHQ6ICdQb25pxaF0YXZhbmplJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnVWtsai4nLFxuICBvblRleHQ6ICdJc2tsai4nLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gTWFneWFyXG5tb2Jpc2Nyb2xsLmkxOG4uaHUgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ09LJyxcbiAgY2FuY2VsVGV4dDogJ03DqWdzZScsXG4gIGNsZWFyVGV4dDogJ1TDtnJsw6lzJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBraXbDoWxhc3p0dmEnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ3l5Lm1tLmRkLicsXG4gIGRheU5hbWVzOiBbJ1Zhc8Ohcm5hcCcsICdIw6l0ZsWRJywgJ0tlZGQnLCAnU3plcmRhJywgJ0Nzw7x0w7ZydMO2aycsICdQw6ludGVrJywgJ1N6b21iYXQnXSxcbiAgZGF5TmFtZXNTaG9ydDogWydWYScsICdIw6knLCAnS2UnLCAnU3plJywgJ0Nzw7wnLCAnUMOpJywgJ1N6byddLFxuICBkYXlOYW1lc01pbjogWydWJywgJ0gnLCAnSycsICdTeicsICdDcycsICdQJywgJ1N6J10sXG4gIGRheVRleHQ6ICdOYXAnLFxuICBkZWxpbWl0ZXI6ICcuJyxcbiAgaG91clRleHQ6ICfDk3JhJyxcbiAgbWludXRlVGV4dDogJ1BlcmMnLFxuICBtb250aE5hbWVzOiBbJ0phbnXDoXInLCAnRmVicnXDoXInLCAnTcOhcmNpdXMnLCAnw4FwcmlsaXMnLCAnTcOhanVzJywgJ0rDum5pdXMnLCAnSsO6bGl1cycsICdBdWd1c3p0dXMnLCAnU3plcHRlbWJlcicsICdPa3TDs2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNw6FyJywgJ8OBcHInLCAnTcOhaicsICdKw7puJywgJ0rDumwnLCAnQXVnJywgJ1N6ZXAnLCAnT2t0JywgJ05vdicsICdEZWMnXSxcbiAgbW9udGhUZXh0OiAnSMOzbmFwJyxcbiAgc2VjVGV4dDogJ03DoXNvZHBlcmMnLFxuICB0aW1lRm9ybWF0OiAnSDppaScsXG4gIHllYXJUZXh0OiAnw4l2JyxcbiAgbm93VGV4dDogJ01vc3QnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0TDoXR1bScsXG4gIHRpbWVUZXh0OiAnSWTFkScsXG4gIHRvZGF5VGV4dDogJ01hJyxcbiAgcHJldk1vbnRoVGV4dDogJ0VsxZF6xZEgaMOzbmFwJyxcbiAgbmV4dE1vbnRoVGV4dDogJ0vDtnZldGtlesWRIGjDs25hcCcsXG4gIHByZXZZZWFyVGV4dDogJ0VsxZF6xZEgw6l2JyxcbiAgbmV4dFllYXJUZXh0OiAnS8O2dmV0a2V6xZEgw6l2JyxcbiAgY2xvc2VUZXh0OiAnQmV6w6FyJyxcbiAgZXZlbnRUZXh0OiAnZXNlbcOpbnknLFxuICBldmVudHNUZXh0OiAnZXNlbcOpbnknLFxuICBhbGxEYXlUZXh0OiAnRWfDqXN6IG5hcCcsXG4gIG5vRXZlbnRzVGV4dDogJ05pbmNzIGVzZW3DqW55JyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IHRvdsOhYmJpJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0VsZWplJyxcbiAgdG9UZXh0OiAnVsOpZ2UnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0Vnw6lzeicsXG4gIGZyYWN0aW9uVGV4dDogJ1TDtnJ0JyxcbiAgdW5pdFRleHQ6ICdFZ3lzw6lnJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsnw4l2JywgJ0jDs25hcCcsICdOYXAnLCAnw5NyYScsICdQZXJjJywgJ03DoXNvZHBlcmMnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ8OJdicsICdIw7MuJywgJ05hcCcsICfDk3JhJywgJ1BlcmMnLCAnTXAuJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnSW5kw610JyxcbiAgc3RvcFRleHQ6ICdNZWfDoWxsw610JyxcbiAgcmVzZXRUZXh0OiAnVmlzc3phw6FsbMOtdCcsXG4gIGxhcFRleHQ6ICdMYXAnLFxuICBoaWRlVGV4dDogJ0VscmVqdCcsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnVmlzc3phJyxcbiAgdW5kb1RleHQ6ICdWaXNzemF2b24nLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdLaScsXG4gIG9uVGV4dDogJ0JlJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vIEl0YWxpYW5vIFxubW9iaXNjcm9sbC5pMThuLml0ID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICdPSycsXG4gIGNhbmNlbFRleHQ6ICdBbm51bGxhJyxcbiAgY2xlYXJUZXh0OiAnQ2hpYXJpcmUnLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IHNlbGV6aW9uYXRvJyxcbiAgc2VsZWN0ZWRQbHVyYWxUZXh0OiAne2NvdW50fSBzZWxlemlvbmF0aScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuICBkYXlOYW1lczogWydEb21lbmljYScsICdMdW5lZMOsJywgJ01hcnRlZMOsJywgJ01lcmNvbGVkw6wnLCAnR2lvdmVkw6wnLCAnVmVuZXJkw6wnLCAnU2FiYXRvJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnRG8nLCAnTHUnLCAnTWEnLCAnTWUnLCAnR2knLCAnVmUnLCAnU2EnXSxcbiAgZGF5TmFtZXNNaW46IFsnRCcsICdMJywgJ00nLCAnTScsICdHJywgJ1YnLCAnUyddLFxuICBkYXlUZXh0OiAnR2lvcm5vJyxcbiAgaG91clRleHQ6ICdPcmUnLFxuICBtaW51dGVUZXh0OiAnTWludXRpJyxcbiAgbW9udGhOYW1lczogWydHZW5uYWlvJywgJ0ZlYmJyYWlvJywgJ01hcnpvJywgJ0FwcmlsZScsICdNYWdnaW8nLCAnR2l1Z25vJywgJ0x1Z2xpbycsICdBZ29zdG8nLCAnU2V0dGVtYnJlJywgJ090dG9icmUnLCAnTm92ZW1icmUnLCAnRGljZW1icmUnXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ0dlbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYWcnLCAnR2l1JywgJ0x1ZycsICdBZ28nLCAnU2V0JywgJ090dCcsICdOb3YnLCAnRGljJ10sXG4gIG1vbnRoVGV4dDogJ01lc2UnLFxuICBzZWNUZXh0OiAnU2Vjb25kaScsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHllYXJUZXh0OiAnQW5ubycsXG4gIG5vd1RleHQ6ICdPcmEnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgdG9kYXlUZXh0OiAnT2dnaScsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICdEYXRhJyxcbiAgdGltZVRleHQ6ICdWb2x0YScsXG4gIGNsb3NlVGV4dDogJ0NoaXVkZXJlJyxcbiAgYWxsRGF5VGV4dDogJ1R1dHRvIGlsIGdpb3JubycsXG4gIG5vRXZlbnRzVGV4dDogJ05lc3N1biBldmVudG8nLFxuICBldmVudFRleHQ6ICdFdmVudG8nLFxuICBldmVudHNUZXh0OiAnRXZlbnRpJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IGFsdHJvJyxcbiAgbW9yZUV2ZW50c1BsdXJhbFRleHQ6ICdhbHRyaSB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0luaXppbycsXG4gIHRvVGV4dDogJ0ZpbmUnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0ludGVybycsXG4gIGZyYWN0aW9uVGV4dDogJ0ZyYXppb25lJyxcbiAgdW5pdFRleHQ6ICdVbml0w6AnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydBbm5pJywgJ01lc2knLCAnR2lvcm5pJywgJ09yZScsICdNaW51dGknLCAnU2Vjb25kaScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnQW5uaScsICdNZXNpJywgJ0dpbycsICdPcmUnLCAnTWluJywgJ1NlYycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ0luaXppbycsXG4gIHN0b3BUZXh0OiAnQXJyZXN0bycsXG4gIHJlc2V0VGV4dDogJ1JpcHJpc3RpbmEnLFxuICBsYXBUZXh0OiAnTGFwJyxcbiAgaGlkZVRleHQ6ICdOYXNjb25kaScsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnSW5kaWV0cm8nLFxuICB1bmRvVGV4dDogJ0FubnVsbGEnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdWaWEnLFxuICBvblRleHQ6ICdTdScsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyDml6XmnKzoqp4gLSBKYXBhbmVzZVxubW9iaXNjcm9sbC5pMThuLmphID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfjgrvjg4Pjg4gnLFxuICBjYW5jZWxUZXh0OiAn44Kt44Oj44Oz44K744OrJyxcbiAgY2xlYXJUZXh0OiAn44Kv44Oq44KiJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDpgbjmip4nLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ3l55bm0bW3mnIhkZOaXpScsXG4gIGRheU5hbWVzOiBbJ+aXpScsICfmnIgnLCAn54GrJywgJ+awtCcsICfmnKgnLCAn6YeRJywgJ+WcnyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ+aXpScsICfmnIgnLCAn54GrJywgJ+awtCcsICfmnKgnLCAn6YeRJywgJ+WcnyddLFxuICBkYXlOYW1lc01pbjogWyfml6UnLCAn5pyIJywgJ+eBqycsICfmsLQnLCAn5pyoJywgJ+mHkScsICflnJ8nXSxcbiAgZGF5VGV4dDogJ+aXpScsXG4gIGhvdXJUZXh0OiAn5pmCJyxcbiAgbWludXRlVGV4dDogJ+WIhicsXG4gIG1vbnRoTmFtZXM6IFsnMeaciCcsICcy5pyIJywgJzPmnIgnLCAnNOaciCcsICc15pyIJywgJzbmnIgnLCAnN+aciCcsICc45pyIJywgJznmnIgnLCAnMTDmnIgnLCAnMTHmnIgnLCAnMTLmnIgnXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJzHmnIgnLCAnMuaciCcsICcz5pyIJywgJzTmnIgnLCAnNeaciCcsICc25pyIJywgJzfmnIgnLCAnOOaciCcsICc55pyIJywgJzEw5pyIJywgJzEx5pyIJywgJzEy5pyIJ10sXG4gIG1vbnRoVGV4dDogJ+aciCcsXG4gIHNlY1RleHQ6ICfnp5InLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ+W5tCcsXG4gIG5vd1RleHQ6ICfku4onLFxuICBwbVRleHQ6ICfljYjlvownLFxuICBhbVRleHQ6ICfljYjliY0nLFxuICB5ZWFyU3VmZml4OiAn5bm0JyxcbiAgbW9udGhTdWZmaXg6ICfmnIgnLFxuICBkYXlTdWZmaXg6ICfml6UnLFxuICB0b2RheVRleHQ6ICfku4rml6UnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZGF0ZVRleHQ6ICfml6Xku5gnLFxuICB0aW1lVGV4dDogJ+aZgumWkycsXG4gIGNsb3NlVGV4dDogJ+OCr+ODreODvOOCuicsXG4gIGFsbERheVRleHQ6ICfntYLml6UnLFxuICBub0V2ZW50c1RleHQ6ICfjgqTjg5njg7Pjg4jjga/jgYLjgorjgb7jgZvjgpMnLFxuICBldmVudFRleHQ6ICfjgqTjg5njg7Pjg4gnLFxuICBldmVudHNUZXh0OiAn44Kk44OZ44Oz44OIJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICfku5Yge2NvdW50fSDku7YnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAn6ZaL5aeLJyxcbiAgdG9UZXh0OiAn57WC44KP44KKJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICflhajmlbAnLFxuICBmcmFjdGlvblRleHQ6ICfliIbmlbAnLFxuICB1bml0VGV4dDogJ+WNmOS9jScsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ+W5tOmWkycsICfmnIjplpMnLCAn5pel6ZaTJywgJ+aZgumWkycsICfliIYnLCAn56eSJywgJyddLFxuICBsYWJlbHNTaG9ydDogWyflubTplpMnLCAn5pyI6ZaTJywgJ+aXpemWkycsICfmmYLplpMnLCAn5YiGJywgJ+enkicsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ+mWi+WniycsXG4gIHN0b3BUZXh0OiAn5YGc5q2iJyxcbiAgcmVzZXRUZXh0OiAn44Oq44K744OD44OIJyxcbiAgbGFwVGV4dDogJ+ODqeODg+ODlycsXG4gIGhpZGVUZXh0OiAn6Zqg44GZJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfjg5Djg4Pjgq8nLFxuICB1bmRvVGV4dDogJ+OCouODs+ODieOCpSdcbn07XG5cbi8vIEtvcmVhblxubW9iaXNjcm9sbC5pMThuLmtvID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfshKTsoJUnLFxuICBjYW5jZWxUZXh0OiAn7Leo7IaMJyxcbiAgY2xlYXJUZXh0OiAn7IKt7KCcJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDshKDtg53rkJwnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ3l564WEbW3sm5RkZOydvCcsXG4gIGRheU5hbWVzOiBbJ+ydvOyalOydvCcsICfsm5TsmpTsnbwnLCAn7ZmU7JqU7J28JywgJ+yImOyalOydvCcsICfrqqnsmpTsnbwnLCAn6riI7JqU7J28JywgJ+2GoOyalOydvCddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ+ydvCcsICfsm5QnLCAn7ZmUJywgJ+yImCcsICfrqqknLCAn6riIJywgJ+2GoCddLFxuICBkYXlOYW1lc01pbjogWyfsnbwnLCAn7JuUJywgJ+2ZlCcsICfsiJgnLCAn66qpJywgJ+q4iCcsICfthqAnXSxcbiAgZGF5VGV4dDogJ+ydvCcsXG4gIGRlbGltaXRlcjogJy0nLFxuICBob3VyVGV4dDogJ+yLnOqwhCcsXG4gIG1pbnV0ZVRleHQ6ICfrtoQnLFxuICBtb250aE5hbWVzOiBbJzHsm5QnLCAnMuyblCcsICcz7JuUJywgJzTsm5QnLCAnNeyblCcsICc27JuUJywgJzfsm5QnLCAnOOyblCcsICc57JuUJywgJzEw7JuUJywgJzEx7JuUJywgJzEy7JuUJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWycx7JuUJywgJzLsm5QnLCAnM+yblCcsICc07JuUJywgJzXsm5QnLCAnNuyblCcsICc37JuUJywgJzjsm5QnLCAnOeyblCcsICcxMOyblCcsICcxMeyblCcsICcxMuyblCddLFxuICBtb250aFRleHQ6ICfri6wnLFxuICBzZWNUZXh0OiAn7LSIJyxcbiAgdGltZUZvcm1hdDogJ0g6aWknLFxuICB5ZWFyVGV4dDogJ+uFhCcsXG4gIG5vd1RleHQ6ICfsp4DquIgnLFxuICBwbVRleHQ6ICfsmKTtm4QnLFxuICBhbVRleHQ6ICfsmKTsoIQnLFxuICB5ZWFyU3VmZml4OiAn64WEJyxcbiAgbW9udGhTdWZmaXg6ICfsm5QnLFxuICBkYXlTdWZmaXg6ICfsnbwnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDAsXG4gIGRhdGVUZXh0OiAn64Kg7KecJyxcbiAgdGltZVRleHQ6ICfsi5zqsIQnLFxuICB0b2RheVRleHQ6ICfsmKTripgnLFxuICBwcmV2TW9udGhUZXh0OiAn7J207KCEIOuLrCcsXG4gIG5leHRNb250aFRleHQ6ICfri6TsnYwg64usJyxcbiAgcHJldlllYXJUZXh0OiAn7J207KCEIOuFhCcsXG4gIG5leHRZZWFyVGV4dDogJ+uLpOydjCDrhYQnLFxuICBjbG9zZVRleHQ6ICfri6vquLAnLFxuICBldmVudFRleHQ6ICfsnbTrsqTtirgnLFxuICBldmVudHNUZXh0OiAn7J2067Kk7Yq4JyxcbiAgYWxsRGF5VGV4dDogJ+yiheydvCcsXG4gIG5vRXZlbnRzVGV4dDogJ+ydtOuypO2KuCDsl4bsnYwnLFxuICBtb3JlRXZlbnRzVGV4dDogJ3tjb3VudH3qsJwg642U67O06riwJyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ+yLnOyekScsXG4gIHRvVGV4dDogJ+yiheujjCcsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAn7KCV7IiYJyxcbiAgZnJhY3Rpb25UZXh0OiAn67aE7IiYJyxcbiAgdW5pdFRleHQ6ICfri6jsnIQnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyfrhYQnLCAn64usJywgJ+ydvCcsICfsi5zqsIQnLCAn67aEJywgJ+y0iCcsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsn64WEJywgJ+uLrCcsICfsnbwnLCAn7Iuc6rCEJywgJ+u2hCcsICfstIgnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICfsi5zsnpEnLFxuICBzdG9wVGV4dDogJ+ykkeyngCAnLFxuICByZXNldFRleHQ6ICfstIjquLDtmZQnLFxuICBsYXBUZXh0OiAn6riw66GdJyxcbiAgaGlkZVRleHQ6ICfsiKjripQg7J6l7IaMJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfrkqTroZwnLFxuICB1bmRvVGV4dDogJ+yLpO2Wiey3qOyGjCcsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ+uBlCcsXG4gIG9uVGV4dDogJ+y8rCcsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBMaWV0dXZpxbNcbm1vYmlzY3JvbGwuaTE4bi5sdCA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnT0snLFxuICBjYW5jZWxUZXh0OiAnQXTFoWF1a3RpJyxcbiAgY2xlYXJUZXh0OiAnScWhdmFseXRpJyxcbiAgc2VsZWN0ZWRUZXh0OiAnUGFzaXJpbmt0YXMge2NvdW50fScsXG4gIHNlbGVjdGVkUGx1cmFsVGV4dDogJ1Bhc2lyaW5rdGkge2NvdW50fScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAneXktbW0tZGQnLFxuICBkYXlOYW1lczogWydTZWttYWRpZW5pcycsICdQaXJtYWRpZW5pcycsICdBbnRyYWRpZW5pcycsICdUcmXEjWlhZGllbmlzJywgJ0tldHZpcnRhZGllbmlzJywgJ1Blbmt0YWRpZW5pcycsICfFoGXFoXRhZGllbmlzJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnUycsICdQcicsICdBJywgJ1QnLCAnSycsICdQbicsICfFoCddLFxuICBkYXlOYW1lc01pbjogWydTJywgJ1ByJywgJ0EnLCAnVCcsICdLJywgJ1BuJywgJ8WgJ10sXG4gIGRheVRleHQ6ICdEaWVuYScsXG4gIGhvdXJUZXh0OiAnVmFsYW5kYScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dGVzJyxcbiAgbW9udGhOYW1lczogWydTYXVzaXMnLCAnVmFzYXJpcycsICdLb3ZhcycsICdCYWxhbmRpcycsICdHZWd1xb7ElycsICdCaXLFvmVsaXMnLCAnTGllcGEnLCAnUnVncGrFq3RpcycsICdSdWdzxJdqaXMnLCAnU3BhbGlzJywgJ0xhcGtyaXRpcycsICdHcnVvZGlzJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydTYXUnLCAnVmFzJywgJ0tvdicsICdCYWwnLCAnR2VnJywgJ0JpcicsICdMaWUnLCAnUnVncCcsICdSdWdzJywgJ1NwYScsICdMYXAnLCAnR3J1byddLFxuICBtb250aFRleHQ6ICdNxJdudW8nLFxuICBzZWNUZXh0OiAnU2VrdW5kZXMnLFxuICBhbVRleHQ6ICdhbScsXG4gIHBtVGV4dDogJ3BtJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICdNZXRhaScsXG4gIG5vd1RleHQ6ICdEYWJhcicsXG4gIHRvZGF5VGV4dDogJ8WgaWFuZGllbicsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICdEYXRhJyxcbiAgdGltZVRleHQ6ICdMYWlrYXMnLFxuICBjbG9zZVRleHQ6ICdVxb5kYXJ5dGknLFxuICBhbGxEYXlUZXh0OiAnVmlzxIUgZGllbsSFJyxcbiAgbm9FdmVudHNUZXh0OiAnTsSXcmEgxK92eWtpxbMnLFxuICBldmVudFRleHQ6ICfErnZ5a2nFsycsXG4gIGV2ZW50c1RleHQ6ICfErnZ5a2lhaScsXG4gIG1vcmVFdmVudHNUZXh0OiAnRGFyIHtjb3VudH0nLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnTnVvJyxcbiAgdG9UZXh0OiAnSWtpJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdWaXNhcycsXG4gIGZyYWN0aW9uVGV4dDogJ0ZyYWtjaWphJyxcbiAgdW5pdFRleHQ6ICdWaWVuZXRhcycsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ01ldGFpJywgJ03El25lc2lhaScsICdEaWVub3MnLCAnVmFsYW5kb3MnLCAnTWludXRlcycsICdTZWt1bmRlcycsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnbScsICdtxJduLicsICdkJywgJ2gnLCAnbWluJywgJ3MnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdQcmFkxJd0aScsXG4gIHN0b3BUZXh0OiAnU3VzdGFiZHl0aScsXG4gIHJlc2V0VGV4dDogJ0nFoW5hdWpvJyxcbiAgbGFwVGV4dDogJ1JhdGFzJyxcbiAgaGlkZVRleHQ6ICdTbMSXcHRpJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdBdGdhbCcsXG4gIHVuZG9UZXh0OiAnQW51bGl1b3RpJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnScWhai4nLFxuICBvblRleHQ6ICfErmouJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vIE5lZGVybGFuZHNcbm1vYmlzY3JvbGwuaTE4bi5ubCA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnSW5zdGVsbGVuJyxcbiAgY2FuY2VsVGV4dDogJ0FubnVsZXJlbicsXG4gIGNsZWFyVGV4dDogJ0xlZWdtYWtlbicsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gZ2Vrb3plbicsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuICBkYXlOYW1lczogWydab25kYWcnLCAnTWFhbmRhZycsICdEaW5zZGFnJywgJ1dvZW5zZGFnJywgJ0RvbmRlcmRhZycsICdWcmlqZGFnJywgJ1phdGVyZGFnJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnem8nLCAnbWEnLCAnZGknLCAnd28nLCAnZG8nLCAndnInLCAnemEnXSxcbiAgZGF5TmFtZXNNaW46IFsneicsICdtJywgJ2QnLCAndycsICdkJywgJ3YnLCAneiddLFxuICBkYXlUZXh0OiAnRGFnJyxcbiAgaG91clRleHQ6ICdVdXInLFxuICBtaW51dGVUZXh0OiAnTWludXRlbicsXG4gIG1vbnRoTmFtZXM6IFsnamFudWFyaScsICdmZWJydWFyaScsICdtYWFydCcsICdhcHJpbCcsICdtZWknLCAnanVuaScsICdqdWxpJywgJ2F1Z3VzdHVzJywgJ3NlcHRlbWJlcicsICdva3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydqYW4nLCAnZmViJywgJ21ydCcsICdhcHInLCAnbWVpJywgJ2p1bicsICdqdWwnLCAnYXVnJywgJ3NlcCcsICdva3QnLCAnbm92JywgJ2RlYyddLFxuICBtb250aFRleHQ6ICdNYWFuZCcsXG4gIHNlY1RleHQ6ICdTZWNvbmRlbicsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHllYXJUZXh0OiAnSmFhcicsXG4gIG5vd1RleHQ6ICdOdScsXG4gIHBtVGV4dDogJ3BtJyxcbiAgYW1UZXh0OiAnYW0nLFxuICB0b2RheVRleHQ6ICdWYW5kYWFnJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0RhdHVtJyxcbiAgdGltZVRleHQ6ICdUaWpkJyxcbiAgY2xvc2VUZXh0OiAnU2x1aXRlbicsXG4gIGFsbERheVRleHQ6ICdIZWxlIGRhZycsXG4gIG5vRXZlbnRzVGV4dDogJ0dlZW4gYWN0aXZpdGVpdGVuJyxcbiAgZXZlbnRUZXh0OiAnQWN0aXZpdGVpdCcsXG4gIGV2ZW50c1RleHQ6ICdBY3Rpdml0ZWl0ZW4nLFxuICBtb3JlRXZlbnRzVGV4dDogJ25vZyB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ1N0YXJ0JyxcbiAgdG9UZXh0OiAnRWluZGUnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ2dlaGVlbCcsXG4gIGZyYWN0aW9uVGV4dDogJ2ZyYWN0aWUnLFxuICB1bml0VGV4dDogJ2VlbmhlaWQnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydKYXJlbicsICdNYWFuZGVuJywgJ0RhZ2VuJywgJ1VyZW4nLCAnTWludXRlbicsICdTZWNvbmRlbicsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnaicsICdtJywgJ2QnLCAndScsICdtaW4nLCAnc2VjJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnU3RhcnQnLFxuICBzdG9wVGV4dDogJ1N0b3AnLFxuICByZXNldFRleHQ6ICdSZXNldCcsXG4gIGxhcFRleHQ6ICdSb25kZScsXG4gIGhpZGVUZXh0OiAnVmVyYmVyZ2VuJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdUZXJ1ZycsXG4gIHVuZG9UZXh0OiAnT25nZWQuIG1ha2VuJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnVWl0JyxcbiAgb25UZXh0OiAnQWFuJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vIE5vcnNrXG5tb2Jpc2Nyb2xsLmkxOG4ubm8gPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ09LJyxcbiAgY2FuY2VsVGV4dDogJ0F2YnJ5dCcsXG4gIGNsZWFyVGV4dDogJ1TDuG1tZScsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gdmFsZ3QnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ2RkLm1tLnl5JyxcbiAgZGF5TmFtZXM6IFsnU8O4bmRhZycsICdNYW5kYWcnLCAnVGlyc2RhZycsICdPbnNkYWcnLCAnVG9yc2RhZycsICdGcmVkYWcnLCAnTMO4cmRhZyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ1PDuCcsICdNYScsICdUaScsICdPbicsICdUbycsICdGcicsICdMw7gnXSxcbiAgZGF5TmFtZXNNaW46IFsnUycsICdNJywgJ1QnLCAnTycsICdUJywgJ0YnLCAnTCddLFxuICBkYXlUZXh0OiAnRGFnJyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAnVGltZScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dHQnLFxuICBtb250aE5hbWVzOiBbJ0phbnVhcicsICdGZWJydWFyJywgJ01hcnMnLCAnQXByaWwnLCAnTWFpJywgJ0p1bmknLCAnSnVsaScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09rdG9iZXInLCAnTm92ZW1iZXInLCAnRGVzZW1iZXInXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYWknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09rdCcsICdOb3YnLCAnRGVzJ10sXG4gIG1vbnRoVGV4dDogJ03DpW5lZCcsXG4gIHNlY1RleHQ6ICdTZWt1bmQnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ8OFcicsXG4gIG5vd1RleHQ6ICdOw6UnLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgdG9kYXlUZXh0OiAnSSBkYWcnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0bycsXG4gIHRpbWVUZXh0OiAnVGlkJyxcbiAgY2xvc2VUZXh0OiAnTHVraycsXG4gIGFsbERheVRleHQ6ICdIZWxlIGRhZ2VuJyxcbiAgbm9FdmVudHNUZXh0OiAnSW5nZW4gaGVuZGVsc2VyJyxcbiAgZXZlbnRUZXh0OiAnSGVuZGVsc2UnLFxuICBldmVudHNUZXh0OiAnSGVuZGVsc2VyJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IG1lcmUnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnU3RhcnQnLFxuICB0b1RleHQ6ICdFbmQnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0hlbGUnLFxuICBmcmFjdGlvblRleHQ6ICdGcmFrc2pvbicsXG4gIHVuaXRUZXh0OiAnRW5oZXQnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyfDhXInLCAnTcOlbmVkZXInLCAnRGFnZXInLCAnVGltZXInLCAnTWludXR0ZXInLCAnU2VrdW5kZXInLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ8OFcicsICdNw6VuJywgJ0RhZycsICdUaW1lJywgJ01pbicsICdTZWsnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdTdGFydCcsXG4gIHN0b3BUZXh0OiAnU3RvcHAnLFxuICByZXNldFRleHQ6ICdUaWxiYWtlc3RpbGxlJyxcbiAgbGFwVGV4dDogJ1J1bmRlJyxcbiAgaGlkZVRleHQ6ICdTa2p1bCcsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnVGlsYmFrZScsXG4gIHVuZG9UZXh0OiAnQW5ncmUnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdBdicsXG4gIG9uVGV4dDogJ1DDpScsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBQb2xza2lcbm1vYmlzY3JvbGwuaTE4bi5wbCA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnWmVzdGF3JyxcbiAgY2FuY2VsVGV4dDogJ0FudWx1aicsXG4gIGNsZWFyVGV4dDogJ09jennFm2NpxIcnLFxuICBzZWxlY3RlZFRleHQ6ICdXeWLDs3I6IHtjb3VudH0nLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ3l5LW1tLWRkJyxcbiAgZGF5TmFtZXM6IFsnTmllZHppZWxhJywgJ1BvbmllZHppYcWCZWsnLCAnV3RvcmVrJywgJ8Wacm9kYScsICdDendhcnRlaycsICdQacSFdGVrJywgJ1NvYm90YSddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ05pZWR6LicsICdQb24uJywgJ1d0LicsICfFmnIuJywgJ0N6dy4nLCAnUHQuJywgJ1NvYi4nXSxcbiAgZGF5TmFtZXNNaW46IFsnTicsICdQJywgJ1cnLCAnxZonLCAnQycsICdQJywgJ1MnXSxcbiAgZGF5VGV4dDogJ0R6aWXFhCcsXG4gIGhvdXJUZXh0OiAnR29kemlueScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dHknLFxuICBtb250aE5hbWVzOiBbJ1N0eWN6ZcWEJywgJ0x1dHknLCAnTWFyemVjJywgJ0t3aWVjaWXFhCcsICdNYWonLCAnQ3plcndpZWMnLCAnTGlwaWVjJywgJ1NpZXJwaWXFhCcsICdXcnplc2llxYQnLCAnUGHFumR6aWVybmlrJywgJ0xpc3RvcGFkJywgJ0dydWR6aWXFhCddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnU3R5JywgJ0x1dCcsICdNYXInLCAnS3dpJywgJ01haicsICdDemUnLCAnTGlwJywgJ1NpZScsICdXcnonLCAnUGHFuicsICdMaXMnLCAnR3J1J10sXG4gIG1vbnRoVGV4dDogJ01pZXNpxIVjJyxcbiAgc2VjVGV4dDogJ1Nla3VuZHknLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ1JvaycsXG4gIG5vd1RleHQ6ICdUZXJheicsXG4gIGFtVGV4dDogJ2FtJyxcbiAgcG1UZXh0OiAncG0nLFxuICB0b2RheVRleHQ6ICdEemlzaWFqJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0RhdGEnLFxuICB0aW1lVGV4dDogJ0N6YXMnLFxuICBjbG9zZVRleHQ6ICdaYWtvxYRjemVuaWUnLFxuICBhbGxEYXlUZXh0OiAnQ2HFgnkgZHppZcWEJyxcbiAgbm9FdmVudHNUZXh0OiAnQnJhayB3eWRhcnplxYQnLFxuICBldmVudFRleHQ6ICdXeWRhcnplxYQnLFxuICBldmVudHNUZXh0OiAnV3lkYXJ6ZW5pYScsXG4gIG1vcmVFdmVudHNUZXh0OiAnSmVzemN6ZSB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ1JvenBvY3rEmWNpZScsXG4gIHRvVGV4dDogJ0tvbmllYycsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAnQ2HFgnknLFxuICBmcmFjdGlvblRleHQ6ICdVxYJhbWVrJyxcbiAgdW5pdFRleHQ6ICdKZWRub3N0a2EnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydMYXRhJywgJ01pZXNpxIVjJywgJ0RuaScsICdHb2R6aW55JywgJ01pbnV0eScsICdTZWt1bmR5JywgJyddLFxuICBsYWJlbHNTaG9ydDogWydSJywgJ00nLCAnRHonLCAnR29keicsICdNaW4nLCAnU2VrJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnUm96cG9jesSZY2llJyxcbiAgc3RvcFRleHQ6ICdaYXRyenltYcSHJyxcbiAgcmVzZXRUZXh0OiAnWnJlc2V0b3dhxIcnLFxuICBsYXBUZXh0OiAnWmFrxYJhZGthJyxcbiAgaGlkZVRleHQ6ICdVa3J5xIcnLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ1dyw7PEhycsXG4gIHVuZG9UZXh0OiAnQ29mbmlqJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnV3nFgicsXG4gIG9uVGV4dDogJ1fFgicsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBQb3J0dWd1w6pzIEJyYXNpbGVpcm9cbm1vYmlzY3JvbGwuaTE4blsncHQtQlInXSA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnU2VsZWNpb25hcicsXG4gIGNhbmNlbFRleHQ6ICdDYW5jZWxhcicsXG4gIGNsZWFyVGV4dDogJ0NsYXJvJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBzZWxlY2lvbmFkbycsXG4gIHNlbGVjdGVkUGx1cmFsVGV4dDogJ3tjb3VudH0gc2VsZWNpb25hZG9zJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC9tbS95eScsXG4gIGRheU5hbWVzOiBbJ0RvbWluZ28nLCAnU2VndW5kYS1mZWlyYScsICdUZXLDp2EtZmVpcmEnLCAnUXVhcnRhLWZlaXJhJywgJ1F1aW50YS1mZWlyYScsICdTZXh0YS1mZWlyYScsICdTw6FiYWRvJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnRG9tJywgJ1NlZycsICdUZXInLCAnUXVhJywgJ1F1aScsICdTZXgnLCAnU8OhYiddLFxuICBkYXlOYW1lc01pbjogWydEJywgJ1MnLCAnVCcsICdRJywgJ1EnLCAnUycsICdTJ10sXG4gIGRheVRleHQ6ICdEaWEnLFxuICBob3VyVGV4dDogJ0hvcmEnLFxuICBtaW51dGVUZXh0OiAnTWludXRvcycsXG4gIG1vbnRoTmFtZXM6IFsnSmFuZWlybycsICdGZXZlcmVpcm8nLCAnTWFyw6dvJywgJ0FicmlsJywgJ01haW8nLCAnSnVuaG8nLCAnSnVsaG8nLCAnQWdvc3RvJywgJ1NldGVtYnJvJywgJ091dHVicm8nLCAnTm92ZW1icm8nLCAnRGV6ZW1icm8nXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZXYnLCAnTWFyJywgJ0FicicsICdNYWknLCAnSnVuJywgJ0p1bCcsICdBZ28nLCAnU2V0JywgJ091dCcsICdOb3YnLCAnRGV6J10sXG4gIG1vbnRoVGV4dDogJ03DqnMnLFxuICBzZWNUZXh0OiAnU2VndW5kbycsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHllYXJUZXh0OiAnQW5vJyxcbiAgbm93VGV4dDogJ0Fnb3JhJyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIHRvZGF5VGV4dDogJ0hvamUnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZGF0ZVRleHQ6ICdEYXRhJyxcbiAgdGltZVRleHQ6ICdUZW1wbycsXG4gIGNsb3NlVGV4dDogJ0ZlY2hhcicsXG4gIGFsbERheVRleHQ6ICdEaWEgaW50ZWlybycsXG4gIG5vRXZlbnRzVGV4dDogJ05lbmh1bSBldmVudG8nLFxuICBldmVudFRleHQ6ICdFdmVudG8nLFxuICBldmVudHNUZXh0OiAnRXZlbnRvcycsXG4gIG1vcmVFdmVudHNUZXh0OiAnTWFpcyB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0luJmlhY3V0ZTtjaW8nLFxuICB0b1RleHQ6ICdGaW0nLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0ludGVpcm8nLFxuICBmcmFjdGlvblRleHQ6ICdGcmHDp8OjbycsXG4gIHVuaXRUZXh0OiAnVW5pZGFkZScsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ0Fub3MnLCAnTWVzZXMnLCAnRGlhcycsICdIb3JhcycsICdNaW51dG9zJywgJ1NlZ3VuZG9zJywgJyddLFxuICBsYWJlbHNTaG9ydDogWydBbm8nLCAnTSZlY2lyYztzJywgJ0RpYScsICdIb3JhJywgJ01pbicsICdTZWcnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdDb21lw6dhcicsXG4gIHN0b3BUZXh0OiAnUGFyZScsXG4gIHJlc2V0VGV4dDogJ1JlaW5pY2lhbGl6YXInLFxuICBsYXBUZXh0OiAnTGFwJyxcbiAgaGlkZVRleHQ6ICdFc2NvbmRlcicsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnQW50ZXJpb3InLFxuICB1bmRvVGV4dDogJ0Rlc2ZhemVyJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnRGVzbCcsXG4gIG9uVGV4dDogJ0xpZycsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBQb3J0dWd1w6pzIEV1cm9wZXVcbm1vYmlzY3JvbGwuaTE4blsncHQtUFQnXSA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnU2VsZWNjaW9uYXInLFxuICBjYW5jZWxUZXh0OiAnQ2FuY2VsYXInLFxuICBjbGVhclRleHQ6ICdDbGFybycsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gc2VsZWNpb25hZG8nLFxuICBzZWxlY3RlZFBsdXJhbFRleHQ6ICd7Y291bnR9IHNlbGVjaW9uYWRvcycsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQtbW0teXknLFxuICBkYXlOYW1lczogWydEb21pbmdvJywgJ1NlZ3VuZGEtZmVpcmEnLCAnVGVyw6dhLWZlaXJhJywgJ1F1YXJ0YS1mZWlyYScsICdRdWludGEtZmVpcmEnLCAnU2V4dGEtZmVpcmEnLCAnU8OhYmFkbyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ0RvbScsICdTZWcnLCAnVGVyJywgJ1F1YScsICdRdWknLCAnU2V4JywgJ1PDoWInXSxcbiAgZGF5TmFtZXNNaW46IFsnRCcsICdTJywgJ1QnLCAnUScsICdRJywgJ1MnLCAnUyddLFxuICBkYXlUZXh0OiAnRGlhJyxcbiAgaG91clRleHQ6ICdIb3JhcycsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dG9zJyxcbiAgbW9udGhOYW1lczogWydKYW5laXJvJywgJ0ZldmVyZWlybycsICdNYXLDp28nLCAnQWJyaWwnLCAnTWFpbycsICdKdW5obycsICdKdWxobycsICdBZ29zdG8nLCAnU2V0ZW1icm8nLCAnT3V0dWJybycsICdOb3ZlbWJybycsICdEZXplbWJybyddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZldicsICdNYXInLCAnQWJyJywgJ01haScsICdKdW4nLCAnSnVsJywgJ0FnbycsICdTZXQnLCAnT3V0JywgJ05vdicsICdEZXonXSxcbiAgbW9udGhUZXh0OiAnTcOqcycsXG4gIHNlY1RleHQ6ICdTZWd1bmRvJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICdBbm8nLFxuICBub3dUZXh0OiAnQWN0dWFsaXphcicsXG4gIHBtVGV4dDogJ3BtJyxcbiAgYW1UZXh0OiAnYW0nLFxuICB0b2RheVRleHQ6ICdIb3knLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0YScsXG4gIHRpbWVUZXh0OiAnVGVtcG8nLFxuICBjbG9zZVRleHQ6ICdGZWNoYXInLFxuICBhbGxEYXlUZXh0OiAnVG9kbyBvIGRpYScsXG4gIG5vRXZlbnRzVGV4dDogJ05lbmh1bSBldmVudG8nLFxuICBldmVudFRleHQ6ICdFdmVudG8nLFxuICBldmVudHNUZXh0OiAnRXZlbnRvcycsXG4gIG1vcmVFdmVudHNUZXh0OiAnbWFpcyB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ0luw61jaW8nLFxuICB0b1RleHQ6ICdGaW0nLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0ludGVpcm8nLFxuICBmcmFjdGlvblRleHQ6ICdGcmFjw6fDo28nLFxuICB1bml0VGV4dDogJ1VuaWRhZGUnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydBbm9zJywgJ01lc2VzJywgJ0RpYXMnLCAnSG9yYXMnLCAnTWludXRvcycsICdTZWd1bmRvcycsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnQW5vJywgJ03DqnMnLCAnRGlhJywgJ0hvcmEnLCAnTWluJywgJ1NlZycsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ0NvbWXDp2FyJyxcbiAgc3RvcFRleHQ6ICdQYXJhcicsXG4gIHJlc2V0VGV4dDogJ1JlaW5pY2lhbGl6YXInLFxuICBsYXBUZXh0OiAnTGFwJyxcbiAgaGlkZVRleHQ6ICdFc2NvbmRlcicsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnQW50ZXJpb3InLFxuICB1bmRvVGV4dDogJ0FudWxhcicsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ0Rlc2wnLFxuICBvblRleHQ6ICdMaWcnLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gUm9tw6JuxINcbm1vYmlzY3JvbGwuaTE4bi5ybyA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnU2V0YXJlJyxcbiAgY2FuY2VsVGV4dDogJ0FudWxhcmUnLFxuICBjbGVhclRleHQ6ICfFnnRlcmdlcmUnLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IHNlbGVjdGF0JyxcbiAgc2VsZWN0ZWRQbHVyYWxUZXh0OiAne2NvdW50fSBzZWxlY3RhdGUnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogJ2RkLm1tLnl5JyxcbiAgZGF5TmFtZXM6IFsnRHVtaW5pY8SDJywgJ0x1bmknLCAnTWFyyJtpJywgJ01pZXJjdXJpJywgJ0pvaScsICdWaW5lcmknLCAnU8OibWLEg3TEgyddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ0R1JywgJ0x1JywgJ01hJywgJ01pJywgJ0pvJywgJ1ZpJywgJ1PDoiddLFxuICBkYXlOYW1lc01pbjogWydEJywgJ0wnLCAnTScsICdNJywgJ0onLCAnVicsICdTJ10sXG4gIGRheVRleHQ6ICcgWml1YScsXG4gIGRlbGltaXRlcjogJy4nLFxuICBob3VyVGV4dDogJyBPcmUgJyxcbiAgbWludXRlVGV4dDogJ01pbnV0ZScsXG4gIG1vbnRoTmFtZXM6IFsnSWFudWFyaWUnLCAnRmVicnVhcmllJywgJ01hcnRpZScsICdBcHJpbGllJywgJ01haScsICdJdW5pZScsICdJdWxpZScsICdBdWd1c3QnLCAnU2VwdGVtYnJpZScsICdPY3RvbWJyaWUnLCAnTm9pZW1icmllJywgJ0RlY2VtYnJpZSddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSWFuLicsICdGZWIuJywgJ01hci4nLCAnQXByLicsICdNYWknLCAnSXVuLicsICdJdWwuJywgJ0F1Zy4nLCAnU2VwdC4nLCAnT2N0LicsICdOb3YuJywgJ0RlYy4nXSxcbiAgbW9udGhUZXh0OiAnTHVuYScsXG4gIHNlY1RleHQ6ICdTZWN1bmRlJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICdBbnVsJyxcbiAgbm93VGV4dDogJ0FjdW0nLFxuICBhbVRleHQ6ICdhbScsXG4gIHBtVGV4dDogJ3BtJyxcbiAgdG9kYXlUZXh0OiAnQXN0xIN6aScsXG4gIHByZXZNb250aFRleHQ6ICdMdW5hIGFudGVyaW9hcsSDJyxcbiAgbmV4dE1vbnRoVGV4dDogJ0x1bmEgdXJtxIN0b2FyZScsXG4gIHByZXZZZWFyVGV4dDogJ0FudWwgYW50ZXJpb3InLFxuICBuZXh0WWVhclRleHQ6ICdBbnVsIHVybcSDdG9yJyxcbiAgZXZlbnRUZXh0OiAnRXZlbmltZW50JyxcbiAgZXZlbnRzVGV4dDogJ0V2ZW5pbWVudGUnLFxuICBhbGxEYXlUZXh0OiAnVG9hdMSDIHppdWEnLFxuICBub0V2ZW50c1RleHQ6ICdOaWNpdW4gZXZlbmltZW50JyxcbiAgbW9yZUV2ZW50c1RleHQ6ICfDjm5jxIMgdW51bCcsXG4gIG1vcmVFdmVudHNQbHVyYWxUZXh0OiAnw45uY8SDIHtjb3VudH0nLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0YScsXG4gIHRpbWVUZXh0OiAnT3JhJyxcbiAgY2xvc2VUZXh0OiAnw45uY2hpZGVyZScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICdTdGFydCcsXG4gIHRvVGV4dDogJ0ZpbmFsJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdDb21wbGV0JyxcbiAgZnJhY3Rpb25UZXh0OiAnUGFyxaNpYWwnLFxuICB1bml0VGV4dDogJ1VuaXRhdGUnLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydBbmknLCAnTHVuaScsICdaaWxlJywgJ09yZScsICdNaW51dGUnLCAnU2VjdW5kZScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnQW5pJywgJ0x1bmknLCAnWmlsZScsICdPcmUnLCAnTWluLicsICdTZWMuJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAnU3RhcnQnLFxuICBzdG9wVGV4dDogJ1N0b3AnLFxuICByZXNldFRleHQ6ICdSZXNldGFyZScsXG4gIGxhcFRleHQ6ICdUdXLEgycsXG4gIGhpZGVUZXh0OiAnQXNjdW5kZXJlJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfDjm5hcG9pJyxcbiAgdW5kb1RleHQ6ICdBbnVsZWF6xIMnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdOdScsXG4gIG9uVGV4dDogJ0RhJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vINCg0YPRgdGB0LrQuNC5IChVQSlcbm1vYmlzY3JvbGwuaTE4blsncnUtVUEnXSA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAn0KPRgdGC0LDQvdC+0LLQuNGC0YwnLFxuICBjYW5jZWxUZXh0OiAn0J7RgtC80LXQvdC40YLRjCcsXG4gIGNsZWFyVGV4dDogJ9Ce0YfQuNGB0YLQuNGC0YxyJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDQktGW0LHRgNCw0YLRjCcsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWyfQstC+0YHQutGA0LXRgdC10L3RjNC1JywgJ9C/0L7QvdC10LTQtdC70YzQvdC40LonLCAn0LLRgtC+0YDQvdC40LonLCAn0YHRgNC10LTQsCcsICfRh9C10YLQstC10YDQsycsICfQv9GP0YLQvdC40YbQsCcsICfRgdGD0LHQsdC+0YLQsCddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ9Cy0YEnLCAn0L/QvScsICfQstGCJywgJ9GB0YAnLCAn0YfRgicsICfQv9GCJywgJ9GB0LEnXSxcbiAgZGF5TmFtZXNNaW46IFsn0LInLCAn0L8nLCAn0LInLCAn0YEnLCAn0YcnLCAn0L8nLCAn0YEnXSxcbiAgZGF5VGV4dDogJ9CU0LXQvdGMJyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAn0KfQsNGB0YsnLFxuICBtaW51dGVUZXh0OiAn0JzQuNC90YPRgtGLJyxcbiAgbW9udGhOYW1lczogWyfQr9C90LLQsNGA0YwnLCAn0KTQtdCy0YDQsNC70YwnLCAn0JzQsNGA0YInLCAn0JDQv9GA0LXQu9GMJywgJ9Cc0LDQuScsICfQmNGO0L3RjCcsICfQmNGO0LvRjCcsICfQkNCy0LPRg9GB0YInLCAn0KHQtdC90YLRj9Cx0YDRjCcsICfQntC60YLRj9Cx0YDRjCcsICfQndC+0Y/QsdGA0YwnLCAn0JTQtdC60LDQsdGA0YwnXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ9Cv0L3Qsi4nLCAn0KTQtdCy0YAuJywgJ9Cc0LDRgNGCJywgJ9CQ0L/RgC4nLCAn0JzQsNC5JywgJ9CY0Y7QvdGMJywgJ9CY0Y7Qu9GMJywgJ9CQ0LLQsy4nLCAn0KHQtdC90YIuJywgJ9Ce0LrRgi4nLCAn0J3QvtGP0LEuJywgJ9CU0LXQui4nXSxcbiAgbW9udGhUZXh0OiAn0JzQtdGB0Y/RhtGLJyxcbiAgc2VjVGV4dDogJ9Ch0LjQutGD0L3QtNGLJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICfQk9C+0LQnLFxuICBub3dUZXh0OiAn0KHQtdC50YfQsNGBJyxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbScsXG4gIHRvZGF5VGV4dDogJ0PQtdCz0L7QtNC90Y8nLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAn0JTQsNGC0LAnLFxuICB0aW1lVGV4dDogJ9CS0YDQtdC80Y8nLFxuICBjbG9zZVRleHQ6ICfQl9Cw0LrRgNGL0YLRjCcsXG4gIGFsbERheVRleHQ6ICfQktC10YHRjCDQtNC10L3RjCcsXG4gIG5vRXZlbnRzVGV4dDogJ9Cd0LXRgiDRgdC+0LHRi9GC0LjQuScsXG4gIGV2ZW50VGV4dDogJ9Cc0LXRgNC+0L/RgNC40Y/RgtC40Y8nLFxuICBldmVudHNUZXh0OiAn0JzQtdGA0L7Qv9GA0LjRj9GC0LjRjycsXG4gIG1vcmVFdmVudHNUZXh0OiAn0JXRidGRIHtjb3VudH0nLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAn0J3QsNGH0LDQu9C+JyxcbiAgdG9UZXh0OiAn0JrQvtC90LXRhicsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAn0JLQtdGB0YwnLFxuICBmcmFjdGlvblRleHQ6ICfQp9Cw0YHRgtGMJyxcbiAgdW5pdFRleHQ6ICfQldC00LjQvdC40YbQsCcsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ9CT0L7QtNGLJywgJyDQnNC10YHRj9GG0YsgJywgJyDQlNC90LggJywgJyDQp9Cw0YHRiyAnLCAnINCc0LjQvdGD0YLRiyAnLCAnINCh0LXQutGD0L3QtNGLJywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfQk9C+0LQnLCAn0JzQtdGBLicsICfQlNC9LicsICfQpy4nLCAn0JzQuNC9LicsICfQodC10LouJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn0KHRgtCw0YDRgicsXG4gIHN0b3BUZXh0OiAn0KHRgtC+0L8nLFxuICByZXNldFRleHQ6ICcg0KHQsdGA0L7RgSAnLFxuICBsYXBUZXh0OiAnINCt0YLQsNC/ICcsXG4gIGhpZGVUZXh0OiAnINCh0LrRgNGL0YLRjCAnLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ9C90LDQt9Cw0LQnLFxuICB1bmRvVGV4dDogJ9Ce0YLQvNC10L3QuNGC0KwnLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICdPJyxcbiAgb25UZXh0OiAnSScsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyDQoNGD0YHRgdC60LjQuVxubW9iaXNjcm9sbC5pMThuWydydS1SVSddID0gbW9iaXNjcm9sbC5pMThuLnJ1ID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfQo9GB0YLQsNC90L7QstC40YLRjCcsXG4gIGNhbmNlbFRleHQ6ICfQntGC0LzQtdC90LAnLFxuICBjbGVhclRleHQ6ICfQntGH0LjRgdGC0LjRgtGMJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDQktGL0LHRgNCw0YLRjCcsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWyfQstC+0YHQutGA0LXRgdC10L3RjNC1JywgJ9C/0L7QvdC10LTQtdC70YzQvdC40LonLCAn0LLRgtC+0YDQvdC40LonLCAn0YHRgNC10LTQsCcsICfRh9C10YLQstC10YDQsycsICfQv9GP0YLQvdC40YbQsCcsICfRgdGD0LHQsdC+0YLQsCddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ9Cy0YEnLCAn0L/QvScsICfQstGCJywgJ9GB0YAnLCAn0YfRgicsICfQv9GCJywgJ9GB0LEnXSxcbiAgZGF5TmFtZXNNaW46IFsn0LInLCAn0L8nLCAn0LInLCAn0YEnLCAn0YcnLCAn0L8nLCAn0YEnXSxcbiAgZGF5VGV4dDogJ9CU0LXQvdGMJyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAn0KfQsNGBJyxcbiAgbWludXRlVGV4dDogJ9Cc0LjQvdGD0YInLFxuICBtb250aE5hbWVzOiBbJ9Cv0L3QstCw0YDRjCcsICfQpNC10LLRgNCw0LvRjCcsICfQnNCw0YDRgicsICfQkNC/0YDQtdC70YwnLCAn0JzQsNC5JywgJ9CY0Y7QvdGMJywgJ9CY0Y7Qu9GMJywgJ9CQ0LLQs9GD0YHRgicsICfQodC10L3RgtGP0LHRgNGMJywgJ9Ce0LrRgtGP0LHRgNGMJywgJ9Cd0L7Rj9Cx0YDRjCcsICfQlNC10LrQsNCx0YDRjCddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsn0K/QvdCyJywgJ9Ck0LXQsicsICfQnNCw0YAnLCAn0JDQv9GAJywgJ9Cc0LDQuScsICfQmNGO0L0nLCAn0JjRjtC7JywgJ9CQ0LLQsycsICfQodC10L0nLCAn0J7QutGCJywgJ9Cd0L7RjycsICfQlNC10LonXSxcbiAgbW9udGhUZXh0OiAn0JzQtdGB0Y/RhicsXG4gIHNlY1RleHQ6ICfQodC10LrRg9C90LQnLFxuICB0aW1lRm9ybWF0OiAnSEg6aWknLFxuICB5ZWFyVGV4dDogJ9CT0L7QtCcsXG4gIG5vd1RleHQ6ICfQodC10LnRh9Cw0YEnLFxuICBhbVRleHQ6ICdhbScsXG4gIHBtVGV4dDogJ3BtJyxcbiAgdG9kYXlUZXh0OiAnQ9C10LPQvtC00L3RjycsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMSxcbiAgZGF0ZVRleHQ6ICfQlNCw0YLQsCcsXG4gIHRpbWVUZXh0OiAn0JLRgNC10LzRjycsXG4gIGNsb3NlVGV4dDogJ9CX0LDQutGA0YvRgtGMJyxcbiAgYWxsRGF5VGV4dDogJ9CS0LXRgdGMINC00LXQvdGMJyxcbiAgbm9FdmVudHNUZXh0OiAn0J3QtdGCINGB0L7QsdGL0YLQuNC5JyxcbiAgZXZlbnRUZXh0OiAn0JzQtdGA0L7Qv9GA0LjRj9GC0LjRjycsXG4gIGV2ZW50c1RleHQ6ICfQnNC10YDQvtC/0YDQuNGP0YLQuNGPJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICfQldGJ0ZEge2NvdW50fScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfQndCw0YfQsNC70L4nLFxuICB0b1RleHQ6ICfQmtC+0L3QtdGGJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICfQptC10LvQvtC1JyxcbiAgZnJhY3Rpb25UZXh0OiAn0JTRgNC+0LHQvdC+0LUnLFxuICB1bml0VGV4dDogJ9CV0LTQuNC90LjRhtCwJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn0JvQtdGCJywgJ9Cc0LXRgdGP0YbQtdCyJywgJ9CU0L3QtdC5JywgJ9Cn0LDRgdC+0LInLCAn0JzQuNC90YPRgicsICfQodC10LrRg9C90LQnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ9Cb0LXRgicsICfQnNC10YEnLCAn0JTQvScsICfQp9Cw0YEnLCAn0JzQuNC9JywgJ9Ch0LXQuicsICcnXSxcbiAgLy8gVGltZXIgY29tcG9uZW50XG4gIHN0YXJ0VGV4dDogJ9Ch0YLQsNGA0YInLFxuICBzdG9wVGV4dDogJ9Ch0YLQvtC/JyxcbiAgcmVzZXRUZXh0OiAn0KHQsdGA0L7RgdC40YLRjCcsXG4gIGxhcFRleHQ6ICfQmtGA0YPQsycsXG4gIGhpZGVUZXh0OiAn0KHQutGA0YvRgtGMJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfQvdCw0LfQsNC0JyxcbiAgdW5kb1RleHQ6ICfQntGC0LzQtdC90LjRgtCsJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnTycsXG4gIG9uVGV4dDogJ0knLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gU2xvdmVuY2luYVxubW9iaXNjcm9sbC5pMThuLnNrID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICdaYWRhaicsXG4gIGNhbmNlbFRleHQ6ICdacnXFoWnFpScsXG4gIGNsZWFyVGV4dDogJ1Z5bWF6YcWlJyxcbiAgc2VsZWN0ZWRUZXh0OiAnT3puYcSNZW7DvToge2NvdW50fScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZC5tLnl5JyxcbiAgZGF5TmFtZXM6IFsnTmVkZcS+YScsICdQb25kZWxvaycsICdVdG9yb2snLCAnU3RyZWRhJywgJ8WgdHZydG9rJywgJ1BpYXRvaycsICdTb2JvdGEnXSxcbiAgZGF5TmFtZXNTaG9ydDogWydOZScsICdQbycsICdVdCcsICdTdCcsICfFoHQnLCAnUGknLCAnU28nXSxcbiAgZGF5TmFtZXNNaW46IFsnTicsICdQJywgJ1UnLCAnUycsICfFoCcsICdQJywgJ1MnXSxcbiAgZGF5VGV4dDogJ8SOZcWIJyxcbiAgaG91clRleHQ6ICdIb2RpbnknLFxuICBtaW51dGVUZXh0OiAnTWluw7p0eScsXG4gIG1vbnRoTmFtZXM6IFsnSmFudcOhcicsICdGZWJydcOhcicsICdNYXJlYycsICdBcHLDrWwnLCAnTcOhaicsICdKw7puJywgJ0rDumwnLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPa3TDs2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ03DoWonLCAnSsO6bicsICdKw7psJywgJ0F1ZycsICdTZXAnLCAnT2t0JywgJ05vdicsICdEZWMnXSxcbiAgbW9udGhUZXh0OiAnTWVzaWFjJyxcbiAgc2VjVGV4dDogJ1Nla3VuZHknLFxuICB0aW1lRm9ybWF0OiAnSDppaScsXG4gIHllYXJUZXh0OiAnUm9rJyxcbiAgbm93VGV4dDogJ1RlcmF6JyxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbScsXG4gIHRvZGF5VGV4dDogJ0RuZXMnLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAnRGF0dW0nLFxuICB0aW1lVGV4dDogJ8SMYXMnLFxuICBjbG9zZVRleHQ6ICdaYXZyaWXFpScsXG4gIGFsbERheVRleHQ6ICdDZWzDvSBkZcWIJyxcbiAgbm9FdmVudHNUZXh0OiAnxb1pYWRuZSB1ZGFsb3N0aScsXG4gIGV2ZW50VGV4dDogJ1VkYWxvc3TDrScsXG4gIGV2ZW50c1RleHQ6ICdVZGFsb3N0aScsXG4gIG1vcmVFdmVudHNUZXh0OiAne2NvdW50fSDEj2FsxaFpYScsXG4gIG1vcmVFdmVudHNQbHVyYWxUZXh0OiAne2NvdW50fSDEj2FsxaFpZScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICdaYcSNaWF0b2snLFxuICB0b1RleHQ6ICdLb25pZWMnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ0NlbMO9JyxcbiAgZnJhY3Rpb25UZXh0OiAnxIxhc8WlJyxcbiAgdW5pdFRleHQ6ICdKZWRub3RrYScsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ1Jva3knLCAnTWVzaWFjZScsICdEbmknLCAnSG9kaW55JywgJ01pbsO6dHknLCAnU2VrdW5keScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnUm9rJywgJ01lcycsICdEbmknLCAnSG9kJywgJ01pbicsICdTZWMnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdTdGFydCcsXG4gIHN0b3BUZXh0OiAnU3RvcCcsXG4gIHJlc2V0VGV4dDogJ1Jlc2V0b3ZhxaUnLFxuICBsYXBUZXh0OiAnRXRhcGEnLFxuICBoaWRlVGV4dDogJ1NjaG92YcWlJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdTcMOkxaUnLFxuICB1bmRvVGV4dDogJ1Nww6TFpScsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ08nLFxuICBvblRleHQ6ICdJJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vIFNlcmJpYW5cbm1vYmlzY3JvbGwuaTE4bi5zciA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAn0J/QvtGB0YLQsNCy0LgnLFxuICBjYW5jZWxUZXh0OiAn0J7RgtC60LDQttC4JyxcbiAgY2xlYXJUZXh0OiAn0J7QsdGA0LjRiNC4JyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDQuNC30LDQsdGA0LDQvdCwJyxcbiAgLy8gRGF0ZXRpbWUgY29tcG9uZW50XG4gIGRhdGVGb3JtYXQ6ICdkZC5tbS55eScsXG4gIGRheU5hbWVzOiBbJ9Cd0LXQtNC10ZnQsCcsICfQn9C+0L3QtdC00LXRmdCw0LonLCAn0KPRgtC+0YDQsNC6JywgJ9Ch0YDQtdC00LAnLCAn0KfQtdGC0LLRgNGC0LDQuicsICfQn9C10YLQsNC6JywgJ9Ch0YPQsdC+0YLQsCddLFxuICBkYXlOYW1lc1Nob3J0OiBbJ9Cd0LXQtCcsICfQn9C+0L0nLCAn0KPRgtC+JywgJ9Ch0YDQtScsICfQp9C10YInLCAn0J/QtdGCJywgJ9Ch0YPQsSddLFxuICBkYXlOYW1lc01pbjogWyfQndC1JywgJ9Cf0L4nLCAn0KPRgicsICfQodGAJywgJ9Cn0LUnLCAn0J/QtScsICfQodGDJ10sXG4gIGRheVRleHQ6ICfQlNCw0L0nLFxuICBkZWxpbWl0ZXI6ICcuJyxcbiAgaG91clRleHQ6ICfQp9Cw0YEnLFxuICBtaW51dGVUZXh0OiAn0JzQuNC90YPRgicsXG4gIG1vbnRoTmFtZXM6IFsn0IjQsNC90YPQsNGAJywgJ9Ck0LXQsdGA0YPQsNGAJywgJ9Cc0LDRgNGCJywgJ9CQ0L/RgNC40LsnLCAn0JzQsNGYJywgJ9CI0YPQvScsICfQiNGD0LsnLCAn0JDQstCz0YPRgdGCJywgJ9Ch0LXQv9GC0LXQvNCx0LDRgCcsICfQntC60YLQvtCx0LDRgCcsICfQndC+0LLQtdC80LHQsNGAJywgJ9CU0LXRhtC10LzQsdCw0YAnXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ9CI0LDQvScsICfQpNC10LEnLCAn0JzQsNGAJywgJ9CQ0L/RgCcsICfQnNCw0ZgnLCAn0IjRg9C9JywgJ9CI0YPQuycsICfQkNCy0LMnLCAn0KHQtdC/JywgJ9Ce0LrRgicsICfQndC+0LInLCAn0JTQtdGGJ10sXG4gIG1vbnRoVGV4dDogJ9C80LXRgdC10YYnLFxuICBzZWNUZXh0OiAn0KHQtdC60YPQvdC0JyxcbiAgdGltZUZvcm1hdDogJ0g6aWknLFxuICB5ZWFyVGV4dDogJ9Cz0L7QtNC40L3QsCcsXG4gIG5vd1RleHQ6ICfRgdCw0LTQsCcsXG4gIHBtVGV4dDogJ3BtJyxcbiAgYW1UZXh0OiAnYW0nLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAn0JTQsNGC0YPQvCcsXG4gIHRpbWVUZXh0OiAn0LLRgNC10LzQtScsXG4gIHRvZGF5VGV4dDogJ9CU0LDQvdCw0YEnLFxuICBwcmV2TW9udGhUZXh0OiAn0J/RgNC10YLRhdC+0LTQvdC4INC80ZjQtdGB0LXRhicsXG4gIG5leHRNb250aFRleHQ6ICfQodC70LXQtNC10ZvQtdCzINC80LXRgdC10YbQsCcsXG4gIHByZXZZZWFyVGV4dDogJ9Cf0YDQtdGC0YXQvtC00L3QsCDQs9C+0LTQuNC90LUnLFxuICBuZXh0WWVhclRleHQ6ICfQodC70LXQtNC10ZvQtSDQs9C+0LTQuNC90LUnLFxuICBjbG9zZVRleHQ6ICfQl9Cw0YLQstC+0YDQuCcsXG4gIGV2ZW50VGV4dDogJ9CU0L7Qs9Cw0ZLQsNGYJyxcbiAgZXZlbnRzVGV4dDogJ9CU0L7Qs9Cw0ZLQsNGY0LgnLFxuICBhbGxEYXlUZXh0OiAn0KbQtdC+INC00LDQvScsXG4gIG5vRXZlbnRzVGV4dDogJ9Cd0LXQvNCwINC00L7Qs9Cw0ZLQsNGY0LAnLFxuICBtb3JlRXZlbnRzVGV4dDogJ9CI0L7RiCB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ9Ce0LQnLFxuICB0b1RleHQ6ICfQlNC+JyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICfRhtC10L4nLFxuICBmcmFjdGlvblRleHQ6ICfQpNGA0LDQutGG0LjRmNCwJyxcbiAgdW5pdFRleHQ6ICfQtdC00LjQvdC40YbQsCcsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ9CT0L7QtNC40L3QtScsICfQnNC10YHQtdGG0LgnLCAn0JTQsNC90LAnLCAn0KHQsNGC0LgnLCAn0JzQuNC90YPRgtCwJywgJ9Ch0LXQutGD0L3QtNC4JywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfQk9C+0LQnLCAn0JzQtdGBJywgJ9CU0LDQvdCwJywgJ9Ch0LDRgtC4JywgJ9Cc0LjQvdGDJywgJ9Ch0LXQutGDJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn0JfQsNC/0L7Rh9C90LgnLFxuICBzdG9wVGV4dDogJ9Ch0YLQvtC/JyxcbiAgcmVzZXRUZXh0OiAn0KDQtdGB0LXRgtGD0ZgnLFxuICBsYXBUZXh0OiAn0JrRgNGD0LMnLFxuICBoaWRlVGV4dDogJ9Ch0LDQutGA0LjRgtC4JyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfQn9C+0LLRgNCw0YLQsNC6JyxcbiAgdW5kb1RleHQ6ICfQntC/0L7Qt9C+0LLQuCcsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ9C9ZScsXG4gIG9uVGV4dDogJ9C00LAnLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gU3ZlbnNrYVxubW9iaXNjcm9sbC5pMThuLnN2ID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICdPSycsXG4gIGNhbmNlbFRleHQ6ICdBdmJyeXQnLFxuICBjbGVhclRleHQ6ICdLbGFyYScsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gdmFsZCcsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAneXktbW0tZGQnLFxuICBkYXlOYW1lczogWydTw7ZuZGFnJywgJ03DpW5kYWcnLCAnVGlzZGFnJywgJ09uc2RhZycsICdUb3JzZGFnJywgJ0ZyZWRhZycsICdMw7ZyZGFnJ10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnU8O2JywgJ03DpScsICdUaScsICdPbicsICdUbycsICdGcicsICdMw7YnXSxcbiAgZGF5TmFtZXNNaW46IFsnUycsICdNJywgJ1QnLCAnTycsICdUJywgJ0YnLCAnTCddLFxuICBkYXlUZXh0OiAnRGFnJyxcbiAgaG91clRleHQ6ICdUaW1tZScsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dCcsXG4gIG1vbnRoTmFtZXM6IFsnSmFudWFyaScsICdGZWJydWFyaScsICdNYXJzJywgJ0FwcmlsJywgJ01haicsICdKdW5pJywgJ0p1bGknLCAnQXVndXN0aScsICdTZXB0ZW1iZXInLCAnT2t0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01haicsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2t0JywgJ05vdicsICdEZWMnXSxcbiAgbW9udGhUZXh0OiAnTcOlbmFkJyxcbiAgc2VjVGV4dDogJ1Nla3VuZCcsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHllYXJUZXh0OiAnw4VyJyxcbiAgbm93VGV4dDogJ051JyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIHRvZGF5VGV4dDogJ0kgZGFnJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ0RhdHVtJyxcbiAgdGltZVRleHQ6ICdUaWQnLFxuICBjbG9zZVRleHQ6ICdTdMOkbmcnLFxuICBhbGxEYXlUZXh0OiAnSGVsZGFnJyxcbiAgbm9FdmVudHNUZXh0OiAnSW5nYSBha3Rpdml0ZXRlcicsXG4gIGV2ZW50VGV4dDogJ0jDpG5kZWxzZScsXG4gIGV2ZW50c1RleHQ6ICdIw6RuZGVsc2VyJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IHRpbGwnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnU3RhcnQnLFxuICB0b1RleHQ6ICdTbHV0JyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdIZWxhJyxcbiAgZnJhY3Rpb25UZXh0OiAnQnLDpWsnLFxuICB1bml0VGV4dDogJ0VuaGV0JyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsnw4VyJywgJ03DpW5hZGVyJywgJ0RhZ2FyJywgJ1RpbW1hcicsICdNaW51dGVyJywgJ1Nla3VuZGVyJywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfDhXInLCAnTcOlbicsICdEYWcnLCAnVGltJywgJ01pbicsICdTZWsnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdTdGFydCcsXG4gIHN0b3BUZXh0OiAnU3RvcHAnLFxuICByZXNldFRleHQ6ICfDhXRlcnN0w6RsbCcsXG4gIGxhcFRleHQ6ICdWYXJ2JyxcbiAgaGlkZVRleHQ6ICdEw7ZsaicsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAnVGlsbGJha2EnLFxuICB1bmRvVGV4dDogJ8OFbmdyYScsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ0F2JyxcbiAgb25UZXh0OiAnUMOlJ1xufTtcblxuLy8gVGhhaVxubW9iaXNjcm9sbC5pMThuLnRoID0ge1xuICAvLyBDb3JlXG4gIHNldFRleHQ6ICfguJXguLHguYnguIfguITguYjguLInLFxuICBjYW5jZWxUZXh0OiAn4Lii4LiB4LmA4Lil4Li04LiBJyxcbiAgY2xlYXJUZXh0OiAn4Lil4LmJ4Liy4LiHJyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSDguYDguKXguLfguK3guIEnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogXCJkZC9tbS95eVwiLFxuICBkYXlOYW1lczogW1wi4Lit4Liy4LiX4Li04LiV4Lii4LmMXCIsIFwi4LiI4Lix4LiZ4LiX4Lij4LmMXCIsIFwi4Lit4Lix4LiH4LiE4Liy4LijXCIsIFwi4Lie4Li44LiYXCIsIFwi4Lie4Lik4Lir4Lix4Liq4Lia4LiU4Li1XCIsIFwi4Lio4Li44LiB4Lij4LmMXCIsIFwi4LmA4Liq4Liy4Lij4LmMXCJdLFxuICBkYXlOYW1lc1Nob3J0OiBbXCLguK3guLIuXCIsIFwi4LiILlwiLCBcIuC4rS5cIiwgXCLguJ4uXCIsIFwi4Lie4LikLlwiLCBcIuC4qC5cIiwgXCLguKouXCJdLFxuICBkYXlOYW1lc01pbjogW1wi4Lit4LiyLlwiLCBcIuC4iC5cIiwgXCLguK0uXCIsIFwi4LieLlwiLCBcIuC4nuC4pC5cIiwgXCLguKguXCIsIFwi4LiqLlwiXSxcbiAgZGF5VGV4dDogJ+C4p+C4seC4mScsXG4gIGRlbGltaXRlcjogJy4nLFxuICBob3VyVGV4dDogJ+C4iuC4seC5iOC4p+C5guC4oeC4hycsXG4gIG1pbnV0ZVRleHQ6ICfguJnguLLguJfguLUnLFxuICBtb250aE5hbWVzOiBbXCLguKHguIHguKPguLLguITguKFcIiwgXCLguIHguLjguKHguKDguLLguJ7guLHguJnguJjguYxcIiwgXCLguKHguLXguJnguLLguITguKFcIiwgXCLguYDguKHguKnguLLguKLguJlcIiwgXCLguJ7guKTguKnguKDguLLguITguKFcIiwgXCLguKHguLTguJbguLjguJnguLLguKLguJlcIiwgXCLguIHguKPguIHguI7guLLguITguKFcIiwgXCLguKrguLTguIfguKvguLLguITguKFcIiwgXCLguIHguLHguJnguKLguLLguKLguJlcIiwgXCLguJXguLjguKXguLLguITguKFcIiwgXCLguJ7guKTguKjguIjguLTguIHguLLguKLguJlcIiwgXCLguJjguLHguJnguKfguLLguITguKFcIl0sXG4gIG1vbnRoTmFtZXNTaG9ydDogW1wi4LihLuC4hC5cIiwgXCLguIEu4LieLlwiLCBcIuC4oeC4tS7guIQuXCIsIFwi4LmA4LihLuC4oi5cIiwgXCLguJ4u4LiELlwiLCBcIuC4oeC4tC7guKIuXCIsIFwi4LiBLuC4hC5cIiwgXCLguKou4LiELlwiLCBcIuC4gS7guKIuXCIsIFwi4LiVLuC4hC5cIiwgXCLguJ4u4LiiLlwiLCBcIuC4mC7guIQuXCJdLFxuICBtb250aFRleHQ6ICfguYDguJTguLfguK3guJknLFxuICBzZWNUZXh0OiAn4Lin4Li04LiZ4Liy4LiX4Li1JyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICfguJvguLUnLFxuICBub3dUZXh0OiAn4LiV4Lit4LiZ4LiZ4Li14LmJJyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMCxcbiAgZGF0ZVRleHQ6ICfguKfguLHguJknLFxuICB0aW1lVGV4dDogJ+C5gOC4p+C4peC4sicsXG4gIHRvZGF5OiBcIuC4p+C4seC4meC4meC4teC5iVwiLFxuICBwcmV2TW9udGhUZXh0OiAn4LmA4LiU4Li34Lit4LiZ4LiB4LmI4Lit4LiZ4Lir4LiZ4LmJ4LiyJyxcbiAgbmV4dE1vbnRoVGV4dDogJ+C5gOC4lOC4t+C4reC4meC4luC4seC4lOC5hOC4mycsXG4gIHByZXZZZWFyVGV4dDogJ+C4m+C4teC4geC5iOC4reC4meC4q+C4meC5ieC4sicsXG4gIG5leHRZZWFyVGV4dDogJ+C4m+C4teC4luC4seC4lOC5hOC4mycsXG4gIGNsb3NlVGV4dDogXCLguJvguLTguJRcIixcbiAgZXZlbnRUZXh0OiAn4LmA4Lir4LiV4Li44LiB4Liy4Lij4LiT4LmMJyxcbiAgZXZlbnRzVGV4dDogJ+C5gOC4q+C4leC4uOC4geC4suC4o+C4k+C5jCcsXG4gIGFsbERheVRleHQ6ICfguJXguKXguK3guJTguKfguLHguJknLFxuICBub0V2ZW50c1RleHQ6ICfguYTguKHguYjguKHguLXguIHguLTguIjguIHguKPguKPguKEnLFxuICBtb3JlRXZlbnRzVGV4dDogJ+C4reC4teC4gSB7Y291bnR9IOC4geC4tOC4iOC4geC4o+C4o+C4oScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfguIjguLLguIEnLFxuICB0b1RleHQ6ICfguJbguLbguIcnLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ+C4l+C4seC5ieC4h+C4q+C4oeC4lCcsXG4gIGZyYWN0aW9uVGV4dDogJ+C5gOC4qOC4qeC4quC5iOC4p+C4mScsXG4gIHVuaXRUZXh0OiAn4Lir4LiZ4LmI4Lin4LiiJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn4Lib4Li1JywgJ+C5gOC4lOC4t+C4reC4mScsICfguKfguLHguJknLCAn4LiK4Lix4LmI4Lin4LmC4Lih4LiHJywgJ+C4meC4suC4l+C4tScsICfguKfguLTguJnguLLguJfguLUnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ+C4m+C4tScsICfguYDguJTguLfguK3guJknLCAn4Lin4Lix4LiZJywgJ+C4iuC4seC5iOC4p+C5guC4oeC4hycsICfguJnguLLguJfguLUnLCAn4Lin4Li04LiZ4Liy4LiX4Li1JywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn4LmA4Lij4Li04LmI4LihJyxcbiAgc3RvcFRleHQ6ICfguKvguKLguLjguJQnLFxuICByZXNldFRleHQ6ICfguKPguLXguYDguIvguYfguJUnLFxuICBsYXBUZXh0OiAn4Lij4Lit4LiaJyxcbiAgaGlkZVRleHQ6ICfguIvguYjguK3guJknLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ+C4ouC5ieC4reC4meC4geC4peC4seC4micsXG4gIHVuZG9UZXh0OiAn4LmA4Lil4Li04LiB4LiX4LiyJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAn4Lib4Li04LiUJyxcbiAgb25UZXh0OiAn4LmA4Lib4Li04LiUJyxcbiAgLy8gTnVtcGFkXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcsJyxcbiAgdGhvdXNhbmRzU2VwYXJhdG9yOiAnICdcbn07XG5cbi8vIFTDvHJrw6dlXG5tb2Jpc2Nyb2xsLmkxOG4udHIgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ1Nlw6cnLFxuICBjYW5jZWxUZXh0OiAnxLBwdGFsJyxcbiAgY2xlYXJUZXh0OiAnVGVtaXpsZXlpbicsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0gc2XDp2lsbWnFnycsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQubW0ueXknLFxuICBkYXlOYW1lczogWydQYXphcicsICdQYXphcnRlc2knLCAnU2FsxLEnLCAnw4dhcsWfYW1iYScsICdQZXLFn2VtYmUnLCAnQ3VtYScsICdDdW1hcnRlc2knXSxcbiAgZGF5TmFtZXNTaG9ydDogWydQYXonLCAnUHp0JywgJ1NhbCcsICfDh2FyJywgJ1BlcicsICdDdW0nLCAnQ210J10sXG4gIGRheU5hbWVzTWluOiBbJ1AnLCAnUCcsICdTJywgJ8OHJywgJ1AnLCAnQycsICdDJ10sXG4gIGRheVRleHQ6ICdHw7xuJyxcbiAgZGVsaW1pdGVyOiAnLicsXG4gIGhvdXJUZXh0OiAnU2FhdCcsXG4gIG1pbnV0ZVRleHQ6ICdEYWtpa2EnLFxuICBtb250aE5hbWVzOiBbJ09jYWsnLCAnxZ51YmF0JywgJ01hcnQnLCAnTmlzYW4nLCAnTWF5xLFzJywgJ0hhemlyYW4nLCAnVGVtbXV6JywgJ0HEn3VzdG9zJywgJ0V5bMO8bCcsICdFa2ltJywgJ0thc8SxbScsICdBcmFsxLFrJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydPY2EnLCAnxZ51YicsICdNYXInLCAnTmlzJywgJ01heScsICdIYXonLCAnVGVtJywgJ0HEn3UnLCAnRXlsJywgJ0VraScsICdLYXMnLCAnQXJhJ10sXG4gIG1vbnRoVGV4dDogJ0F5JyxcbiAgc2VjVGV4dDogJ1Nhbml5ZScsXG4gIHRpbWVGb3JtYXQ6ICdISDppaScsXG4gIHllYXJUZXh0OiAnWcSxbCcsXG4gIG5vd1RleHQ6ICfFnmltZGknLFxuICBwbVRleHQ6ICdwbScsXG4gIGFtVGV4dDogJ2FtJyxcbiAgdG9kYXlUZXh0OiAnQnVnw7xuJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGZpcnN0RGF5OiAxLFxuICBkYXRlVGV4dDogJ1RhcmloJyxcbiAgdGltZVRleHQ6ICdaYW1hbicsXG4gIGNsb3NlVGV4dDogJ0thcGF0bWFrJyxcbiAgYWxsRGF5VGV4dDogJ1TDvG0gZ8O8bicsXG4gIG5vRXZlbnRzVGV4dDogJ0V0a2lubGlrIFlvaycsXG4gIGV2ZW50VGV4dDogJ0V0a2lubGlrJyxcbiAgZXZlbnRzVGV4dDogJ0V0a2lubGlrbGVyJyxcbiAgbW9yZUV2ZW50c1RleHQ6ICd7Y291bnR9IHRhbmUgZGFoYScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICdCYcWfbGEnLFxuICB0b1RleHQ6ICdTb24nLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ1RhbScsXG4gIGZyYWN0aW9uVGV4dDogJ0tlc2lyJyxcbiAgdW5pdFRleHQ6ICdCaXJpbScsXG4gIC8vIFRpbWUgLyBUaW1lc3BhbiBjb21wb25lbnRcbiAgbGFiZWxzOiBbJ1nEsWwnLCAnQXknLCAnR8O8bicsICdTYWF0JywgJ0Rha2lrYScsICdTYW5peWUnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ1nEsWwnLCAnQXknLCAnR8O8bicsICdTYScsICdEYWsnLCAnU24nLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdCYcWfbGEnLFxuICBzdG9wVGV4dDogJ0R1cmR1cicsXG4gIHJlc2V0VGV4dDogJ1PEsWbEsXJsYScsXG4gIGxhcFRleHQ6ICdUdXInLFxuICBoaWRlVGV4dDogJ0dpemxlJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdHZXJpJyxcbiAgdW5kb1RleHQ6ICdHZXJpIEFsJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnTycsXG4gIG9uVGV4dDogJ0knLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcuJ1xufTtcblxuLy8gVWtyYWluaWFuXG5tb2Jpc2Nyb2xsLmkxOG4udWEgPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ9Cy0YHRgtCw0L3QvtCy0LjRgtC4JyxcbiAgY2FuY2VsVGV4dDogJ9Cy0ZbQtNC80ZbQvdCwJyxcbiAgY2xlYXJUZXh0OiAn0L7Rh9C40YHRgtC40YLQuCcsXG4gIHNlbGVjdGVkVGV4dDogJ3tjb3VudH0g0LLQuNCx0YDQsNC90ZYnLFxuICAvLyBEYXRldGltZSBjb21wb25lbnRcbiAgZGF0ZUZvcm1hdDogXCJkZC5tbS55eVwiLFxuICBkYXlOYW1lczogW1wi0L3QtdC00ZbQu9GPXCIsIFwi0L/QvtC90LXQtNGW0LvQvtC6XCIsIFwi0LLRltCy0YLQvtGA0L7QulwiLCBcItGB0LXRgNC10LTQsFwiLCBcItGH0LXRgtCy0LXRgFwiLCBcItC/4oCZ0Y/RgtC90LjRhtGPXCIsIFwi0YHRg9Cx0L7RgtCwXCJdLFxuICBkYXlOYW1lc1Nob3J0OiBbXCLQvdC10LRcIiwgXCLQv9C90LRcIiwgXCLQstGW0LJcIiwgXCLRgdGA0LRcIiwgXCLRh9GC0LJcIiwgXCLQv9GC0L1cIiwgXCLRgdCx0YJcIl0sXG4gIGRheU5hbWVzTWluOiBbXCLQndC0XCIsIFwi0J/QvVwiLCBcItCS0YJcIiwgXCLQodGAXCIsIFwi0KfRglwiLCBcItCf0YJcIiwgXCLQodCxXCJdLFxuICBkYXlUZXh0OiAn0JTQtdC90YwnLFxuICBkZWxpbWl0ZXI6ICcuJyxcbiAgaG91clRleHQ6ICfQs9C+0LTQuNC90LAnLFxuICBtaW51dGVUZXh0OiAn0YXQstC40LvQuNC90LAnLFxuICBtb250aE5hbWVzOiBbXCLQodGW0YfQtdC90YxcIiwgXCLQm9GO0YLQuNC5XCIsIFwi0JHQtdGA0LXQt9C10L3RjFwiLCBcItCa0LLRltGC0LXQvdGMXCIsIFwi0KLRgNCw0LLQtdC90YxcIiwgXCLQp9C10YDQstC10L3RjFwiLCBcItCb0LjQv9C10L3RjFwiLCBcItCh0LXRgNC/0LXQvdGMXCIsIFwi0JLQtdGA0LXRgdC10L3RjFwiLCBcItCW0L7QstGC0LXQvdGMXCIsIFwi0JvQuNGB0YLQvtC/0LDQtFwiLCBcItCT0YDRg9C00LXQvdGMXCJdLFxuICBtb250aE5hbWVzU2hvcnQ6IFtcItCh0ZbRh1wiLCBcItCb0Y7RglwiLCBcItCR0LXRgFwiLCBcItCa0LLRllwiLCBcItCi0YDQsFwiLCBcItCn0LXRgFwiLCBcItCb0LjQv1wiLCBcItCh0LXRgFwiLCBcItCS0LXRgFwiLCBcItCW0L7QslwiLCBcItCb0LjRgVwiLCBcItCT0YDRg1wiXSxcbiAgbW9udGhUZXh0OiAn0JzRltGB0Y/RhtGMJyxcbiAgc2VjVGV4dDogJ9Ch0LXQutGD0L3QtCcsXG4gIHRpbWVGb3JtYXQ6ICdIOmlpJyxcbiAgeWVhclRleHQ6ICfQoNGW0LonLFxuICBub3dUZXh0OiAn0JfQsNGA0LDQtycsXG4gIHBtVGV4dDogJ3BtJyxcbiAgYW1UZXh0OiAnYW0nLFxuICAvLyBDYWxlbmRhciBjb21wb25lbnRcbiAgZmlyc3REYXk6IDEsXG4gIGRhdGVUZXh0OiAn0LTQsNGC0LAnLFxuICB0aW1lVGV4dDogJ9Cn0LDRgScsXG4gIHRvZGF5VGV4dDogJ9Ch0YzQvtCz0L7QtNC90ZYnLFxuICBwcmV2TW9udGhUZXh0OiAn0J/QvtC/0LXRgNC10LTQvdGW0Lkg0LzRltGB0Y/RhtGMJyxcbiAgbmV4dE1vbnRoVGV4dDogJ9Cd0LDRgdGC0YPQv9C90L7Qs9C+INC80ZbRgdGP0YbRjycsXG4gIHByZXZZZWFyVGV4dDogJ9Cf0L7Qv9C10YDQtdC00L3RltC5INGA0ZbQuicsXG4gIG5leHRZZWFyVGV4dDogJ9Cd0LDRgdGC0YPQv9C90L7Qs9C+INGA0L7QutGDJyxcbiAgY2xvc2VUZXh0OiBcItCX0LDQutGA0LjRgtC4XCIsXG4gIGV2ZW50VGV4dDogJ9C/0L7QtNGW0Y8nLFxuICBldmVudHNUZXh0OiAn0L/QvtC00ZbRlycsXG4gIGFsbERheVRleHQ6ICfQo9Cy0LXRgdGMINC00LXQvdGMJyxcbiAgbm9FdmVudHNUZXh0OiAn0JbQvtC00L3QvtGXINC/0L7QtNGW0ZcnLFxuICBtb3JlRXZlbnRzVGV4dDogJ9GC0LAg0YnQtSB7Y291bnR9JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ9Cy0ZbQtCcsXG4gIHRvVGV4dDogJ9C60ZbQvdC10YbRjCcsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAn0LLRgdGWJyxcbiAgZnJhY3Rpb25UZXh0OiAn0YTRgNCw0LrRhtGW0Y8nLFxuICB1bml0VGV4dDogJ9C+0LTQuNC90LjRhtGPJyxcbiAgLy8gVGltZSAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn0KDRltC6JywgJ9Cc0ZbRgdGP0YbRjCcsICfQlNC10L3RjCcsICfQs9C+0LTQuNC90LAnLCAn0YXQstC40LvQuNC90LAnLCAn0KHQtdC60YPQvdC0JywgJyddLFxuICBsYWJlbHNTaG9ydDogWyfQoNGW0LonLCAn0JzRltGB0Y/RhtGMJywgJ9CU0LXQvdGMJywgJ9Cz0L7QtNC40L3QsCcsICfRhdCy0LjQu9C40L3QsCcsICfQodC10LrRg9C90LQnLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICfQn9C+0YfQsNGC0L7QuicsXG4gIHN0b3BUZXh0OiAn0KHQotCe0J8nLFxuICByZXNldFRleHQ6ICfRgdC60LjQvdGD0YLQuCcsXG4gIGxhcFRleHQ6ICfQutC+0LvQvicsXG4gIGhpZGVUZXh0OiAn0YHRhdC+0LLQsNGC0LgnLFxuICAvLyBMaXN0dmlld1xuICBiYWNrVGV4dDogJ9C90LDQt9Cw0LQnLFxuICB1bmRvVGV4dDogJ9Cy0ZbQtNC80ZbQvdC40YLQuCcsXG4gIC8vIEZvcm1cbiAgb2ZmVGV4dDogJ9CS0LjQvNC40LrQsNGC0LgnLFxuICBvblRleHQ6ICfQo9Cy0ZbQvNC60L3Rg9GC0LgnLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxuLy8gVmlldG5hbWVzZSBcbm1vYmlzY3JvbGwuaTE4bi52aSA9IHtcbiAgLy8gQ29yZVxuICBzZXRUZXh0OiAnxJDhurd0JyxcbiAgY2FuY2VsVGV4dDogJ0jhu6d5IGLDsicsXG4gIGNsZWFyVGV4dDogJ1jDs2EnLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IGNo4buNbicsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuICBkYXlOYW1lczogWydDaOG7pyBOaOG6rXQnLCAnVGjhu6kgSGFpJywgJ1Ro4bupIEJhJywgJ1Ro4bupIFTGsCcsICdUaOG7qSBOxINtJywgJ1Ro4bupIFPDoXUnLCAnVGjhu6kgQuG6o3knXSxcbiAgZGF5TmFtZXNTaG9ydDogWydDTicsICdUMicsICdUMycsICdUNCcsICdUNScsICdUNicsICdUNyddLFxuICBkYXlOYW1lc01pbjogWydDTicsICdUMicsICdUMycsICdUNCcsICdUNScsICdUNicsICdUNyddLFxuICBkYXlUZXh0OiAnJyxcbiAgZGVsaW1pdGVyOiAnLycsXG4gIGhvdXJUZXh0OiAnR2nhu50nLFxuICBtaW51dGVUZXh0OiAnUGjDunQnLFxuICBtb250aE5hbWVzOiBbJ1Row6FuZyBN4buZdCcsICdUaMOhbmcgSGFpJywgJ1Row6FuZyBCYScsICdUaMOhbmcgVMawJywgJ1Row6FuZyBOxINtJywgJ1Row6FuZyBTw6F1JywgJ1Row6FuZyBC4bqjeScsICdUaMOhbmcgVMOhbScsICdUaMOhbmcgQ2jDrW4nLCAnVGjDoW5nIE3GsOG7nWknLCAnVGjDoW5nIE3GsOG7nWkgTeG7mXQnLCAnVGjDoW5nIE3GsOG7nWkgSGFpJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWydUaMOhbmcgMScsICdUaMOhbmcgMicsICdUaMOhbmcgMycsICdUaMOhbmcgNCcsICdUaMOhbmcgNScsICdUaMOhbmcgNicsICdUaMOhbmcgNycsICdUaMOhbmcgOCcsICdUaMOhbmcgOScsICdUaMOhbmcgMTAnLCAnVGjDoW5nIDExJywgJ1Row6FuZyAxMiddLFxuICBtb250aFRleHQ6ICdUaMOhbmcnLFxuICBzZWNUZXh0OiAnR2nDonknLFxuICB0aW1lRm9ybWF0OiAnSDppaScsXG4gIHllYXJUZXh0OiAnTsSDbScsXG4gIG5vd1RleHQ6ICdCw6J5IGdp4budJyxcbiAgcG1UZXh0OiAncG0nLFxuICBhbVRleHQ6ICdhbScsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMCxcbiAgZGF0ZVRleHQ6ICdOZ8OgeScsXG4gIHRpbWVUZXh0OiAnSMO0zYBpJyxcbiAgdG9kYXlUZXh0OiAnSMO0bSBuYXknLFxuICBwcmV2TW9udGhUZXh0OiAnVGjDoW5nIHRyxrDhu5tjJyxcbiAgbmV4dE1vbnRoVGV4dDogJ1Row6FuZyB04bubaScsXG4gIHByZXZZZWFyVGV4dDogJ03Eg20gdHLGsOG7m2MnLFxuICBuZXh0WWVhclRleHQ6ICdOxINtIHThu5tpJyxcbiAgY2xvc2VUZXh0OiAnxJDDs25nJyxcbiAgZXZlbnRUZXh0OiAnU+G7sSBraeG7h24nLFxuICBldmVudHNUZXh0OiAnU+G7sSBraeG7h24nLFxuICBhbGxEYXlUZXh0OiAnQ+G6oyBuZ8OgeScsXG4gIG5vRXZlbnRzVGV4dDogJ0tow7RuZyBjw7Mgc+G7sSBraeG7h24nLFxuICBtb3JlRXZlbnRzVGV4dDogJ3tjb3VudH0gdGjhursga2jDoWMnLFxuICAvLyBEYXRlcmFuZ2UgY29tcG9uZW50XG4gIGZyb21UZXh0OiAnVOG7qycsXG4gIHRvVGV4dDogJ1Thu5tpJyxcbiAgLy8gTWVhc3VyZW1lbnQgY29tcG9uZW50c1xuICB3aG9sZVRleHQ6ICdUb8OgbiB0aOG7gycsXG4gIGZyYWN0aW9uVGV4dDogJ1Bow6JuIHPhu5EnLFxuICB1bml0VGV4dDogJ8SRxqFuIHbhu4snLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWydOxINtJywgJ1Row6FuZycsICdOZ8OgeScsICdHaeG7nScsICdQaMO6dCcsICdHacOieScsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsnTsSDbScsICdUaMOhbmcnLCAnTmfDoHknLCAnR2nhu50nLCAnUGjDunQnLCAnR2nDonknLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICdC4bqvdCDEkeG6p3UnLFxuICBzdG9wVGV4dDogJ0Thu6tuZycsXG4gIHJlc2V0VGV4dDogJ8SQ4bq3dCBs4bqhaScsXG4gIGxhcFRleHQ6ICdWw7JuZycsXG4gIGhpZGVUZXh0OiAnR2nhuqV1JyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICdRdWF5IGzhuqFpJyxcbiAgdW5kb1RleHQ6ICdIb8OgbiB0w6FjJyxcbiAgLy8gRm9ybVxuICBvZmZUZXh0OiAnVOG6pXQnLFxuICBvblRleHQ6ICdC4bqtdCcsXG4gIC8vIE51bXBhZFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLCcsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJyAnXG59O1xuXG4vLyBDaGluZXNlXG5tb2Jpc2Nyb2xsLmkxOG4uemggPSB7XG4gIC8vIENvcmVcbiAgc2V0VGV4dDogJ+ehruWumicsXG4gIGNhbmNlbFRleHQ6ICflj5bmtognLFxuICBjbGVhclRleHQ6ICfmmI7noa4nLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9IOmAiScsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAneXnlubRtbeaciGTml6UnLFxuICBkYXlOYW1lczogWyflkajml6UnLCAn5ZGo5LiAJywgJ+WRqOS6jCcsICflkajkuIknLCAn5ZGo5ZubJywgJ+WRqOS6lCcsICflkajlha0nXSxcbiAgZGF5TmFtZXNTaG9ydDogWyfml6UnLCAn5LiAJywgJ+S6jCcsICfkuIknLCAn5ZubJywgJ+S6lCcsICflha0nXSxcbiAgZGF5TmFtZXNNaW46IFsn5pelJywgJ+S4gCcsICfkuownLCAn5LiJJywgJ+WbmycsICfkupQnLCAn5YWtJ10sXG4gIGRheVRleHQ6ICfml6UnLFxuICBob3VyVGV4dDogJ+aXticsXG4gIG1pbnV0ZVRleHQ6ICfliIYnLFxuICBtb250aE5hbWVzOiBbJzHmnIgnLCAnMuaciCcsICcz5pyIJywgJzTmnIgnLCAnNeaciCcsICc25pyIJywgJzfmnIgnLCAnOOaciCcsICc55pyIJywgJzEw5pyIJywgJzEx5pyIJywgJzEy5pyIJ10sXG4gIG1vbnRoTmFtZXNTaG9ydDogWyfkuIAnLCAn5LqMJywgJ+S4iScsICflm5snLCAn5LqUJywgJ+WFrScsICfkuIMnLCAn5YWrJywgJ+S5nScsICfljYEnLCAn5Y2B5LiAJywgJ+WNgeS6jCddLFxuICBtb250aFRleHQ6ICfmnIgnLFxuICBzZWNUZXh0OiAn56eSJyxcbiAgdGltZUZvcm1hdDogJ0hIOmlpJyxcbiAgeWVhclRleHQ6ICflubQnLFxuICBub3dUZXh0OiAn5b2T5YmNJyxcbiAgcG1UZXh0OiAn5LiL5Y2IJyxcbiAgYW1UZXh0OiAn5LiK5Y2IJyxcbiAgeWVhclN1ZmZpeDogJ+W5tCcsXG4gIG1vbnRoU3VmZml4OiAn5pyIJyxcbiAgZGF5U3VmZml4OiAn5pelJyxcbiAgdG9kYXlUZXh0OiAn5LuK5aSpJyxcbiAgLy8gQ2FsZW5kYXIgY29tcG9uZW50XG4gIGRhdGVUZXh0OiAn5pelJyxcbiAgdGltZVRleHQ6ICfml7bpl7QnLFxuICBjbG9zZVRleHQ6ICflhbPpl60nLFxuICBhbGxEYXlUZXh0OiAn5YWo5aSpJyxcbiAgbm9FdmVudHNUZXh0OiAn5peg5LqL5Lu2JyxcbiAgZXZlbnRUZXh0OiAn5rS75YqoJyxcbiAgZXZlbnRzVGV4dDogJ+a0u+WKqCcsXG4gIG1vcmVFdmVudHNUZXh0OiAn5LuWIHtjb3VudH0g5Lu2JyxcbiAgLy8gRGF0ZXJhbmdlIGNvbXBvbmVudFxuICBmcm9tVGV4dDogJ+W8gOWni+aXtumXtCcsXG4gIHRvVGV4dDogJ+e7k+adn+aXtumXtCcsXG4gIC8vIE1lYXN1cmVtZW50IGNvbXBvbmVudHNcbiAgd2hvbGVUZXh0OiAn5ZCI6K6hJyxcbiAgZnJhY3Rpb25UZXh0OiAn5YiG5pWwJyxcbiAgdW5pdFRleHQ6ICfljZXkvY0nLFxuICAvLyBUaW1lIC8gVGltZXNwYW4gY29tcG9uZW50XG4gIGxhYmVsczogWyflubQnLCAn5pyIJywgJ+aXpScsICflsI/ml7YnLCAn5YiG6ZKfJywgJ+enkicsICcnXSxcbiAgbGFiZWxzU2hvcnQ6IFsn5bm0JywgJ+aciCcsICfml6UnLCAn54K5JywgJ+WIhicsICfnp5InLCAnJ10sXG4gIC8vIFRpbWVyIGNvbXBvbmVudFxuICBzdGFydFRleHQ6ICflvIDlp4snLFxuICBzdG9wVGV4dDogJ+WBnOatoicsXG4gIHJlc2V0VGV4dDogJ+mHjee9ricsXG4gIGxhcFRleHQ6ICflnIgnLFxuICBoaWRlVGV4dDogJ+makOiXjycsXG4gIC8vIExpc3R2aWV3XG4gIGJhY2tUZXh0OiAn6L+U5ZueJyxcbiAgdW5kb1RleHQ6ICflpI3ljp8nLFxuICAvLyBGb3JtXG4gIG9mZlRleHQ6ICflhbPpl60nLFxuICBvblRleHQ6ICflvIDlkK8nLFxuICAvLyBOdW1wYWRcbiAgZGVjaW1hbFNlcGFyYXRvcjogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcgJ1xufTtcblxudmFyIHRoZW1lcyQxID0gbW9iaXNjcm9sbC50aGVtZXM7XG50aGVtZXMkMS5mcmFtZS5ib290c3RyYXAgPSB7XG4gIGRpc2FibGVkQ2xhc3M6ICdkaXNhYmxlZCcsXG4gIHNlbGVjdGVkQ2xhc3M6ICdidG4tcHJpbWFyeScsXG4gIHNlbGVjdGVkVGFiQ2xhc3M6ICdhY3RpdmUnLFxuICB0YWJMaW5rOiB0cnVlLFxuICB0b2RheUNsYXNzOiAndGV4dC1wcmltYXJ5IG1ic2MtY2FsLXRvZGF5JyxcbiAgb25NYXJrdXBJbnNlcnRlZDogZnVuY3Rpb24gb25NYXJrdXBJbnNlcnRlZChldikge1xuICAgIHZhciBkdyA9ICQkMShldi50YXJnZXQpLFxuICAgICAgICBjYWxUYWJzID0gJCQxKCcubWJzYy1jYWwtdGFicycsIGR3KTtcbiAgICAkJDEoJy5tYnNjLWZyLXBvcHVwJywgZHcpLmFkZENsYXNzKCdwb3BvdmVyJyk7XG4gICAgJCQxKCcubWJzYy1mci13JywgZHcpLmFkZENsYXNzKCdwb3BvdmVyLWNvbnRlbnQnKTtcbiAgICAkJDEoJy5tYnNjLWZyLWhkcicsIGR3KS5hZGRDbGFzcygncG9wb3Zlci10aXRsZSBwb3BvdmVyLWhlYWRlcicpO1xuICAgICQkMSgnLm1ic2MtZnItYXJyLWknLCBkdykuYWRkQ2xhc3MoJ3BvcG92ZXInKTtcbiAgICAkJDEoJy5tYnNjLWZyLWFycicsIGR3KS5hZGRDbGFzcygnYXJyb3cnKTtcbiAgICAkJDEoJy5tYnNjLWZyLWJ0bicsIGR3KS5hZGRDbGFzcygnYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zZWNvbmRhcnknKTtcbiAgICAkJDEoJy5tYnNjLWZyLWJ0bi1zIC5tYnNjLWZyLWJ0bicsIGR3KS5yZW1vdmVDbGFzcygnYnRuLWRlZmF1bHQgYnRuLXNlY29uZGFyeScpLmFkZENsYXNzKCdidG4gYnRuLXByaW1hcnknKTsgLy8gQ2FsZW5kYXIgdGFic1xuXG4gICAgY2FsVGFicy5hZGRDbGFzcygnbmF2IG5hdi10YWJzJyk7XG4gICAgY2FsVGFicy5maW5kKCcubWJzYy1jYWwtdGFiJykuYWRkQ2xhc3MoJ25hdi1pdGVtJyk7IC8vIDQueFxuXG4gICAgY2FsVGFicy5maW5kKCdhJykuYWRkQ2xhc3MoJ25hdi1saW5rJyk7IC8vIDQueFxuXG4gICAgY2FsVGFicy5maW5kKCcubWJzYy1jYWwtdGFiLmFjdGl2ZSAubmF2LWxpbmsnKS5hZGRDbGFzcygnYWN0aXZlJyk7IC8vIDQueFxuICAgIC8vIENhbGVuZGFyIHllYXIvbW9udGggc2VsZWN0b3JcblxuICAgICQkMSgnLm1ic2MtY2FsLXBpY2tlcicsIGR3KS5hZGRDbGFzcygncG9wb3ZlcicpOyAvLyBSYW5nZXBpY2tlciBzdGFydC9lbmQgYnV0dG9uc1xuXG4gICAgJCQxKCcubWJzYy1yYW5nZS1idG4nLCBkdykuYWRkQ2xhc3MoJ2J0biBidG4tc20gYnRuLXNtYWxsIGJ0bi1kZWZhdWx0Jyk7IC8vIE51bXBhZCBcblxuICAgICQkMSgnLm1ic2MtbnAtYnRuJywgZHcpLmFkZENsYXNzKCdidG4gYnRuLWRlZmF1bHQnKTsgLy8gU2VsZWN0IGZpbHRlclxuXG4gICAgJCQxKCcubWJzYy1zZWwtZmlsdGVyLWNvbnQnLCBkdykucmVtb3ZlQ2xhc3MoJ21ic2MtaW5wdXQnKTtcbiAgICAkJDEoJy5tYnNjLXNlbC1maWx0ZXItaW5wdXQnLCBkdykuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICB9LFxuICBvblRhYkNoYW5nZTogZnVuY3Rpb24gb25UYWJDaGFuZ2UoZXYsIGluc3QpIHtcbiAgICAkJDEoJy5tYnNjLWNhbC10YWJzIC5uYXYtbGluaycsIGluc3QuX21hcmt1cCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICQkMSgnLm1ic2MtY2FsLXRhYi5hY3RpdmUgLm5hdi1saW5rJywgaW5zdC5fbWFya3VwKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gIH0sXG4gIG9uUG9zaXRpb246IGZ1bmN0aW9uIG9uUG9zaXRpb24oZXYpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICQkMSgnLm1ic2MtZnItYnViYmxlLXRvcCwgLm1ic2MtZnItYnViYmxlLXRvcCAubWJzYy1mci1hcnItaScsIGV2LnRhcmdldCkucmVtb3ZlQ2xhc3MoJ2JvdHRvbSBicy1wb3BvdmVyLWJvdHRvbScpLmFkZENsYXNzKCd0b3AgYnMtcG9wb3Zlci10b3AnKTtcbiAgICAgICQkMSgnLm1ic2MtZnItYnViYmxlLWJvdHRvbSwgLm1ic2MtZnItYnViYmxlLWJvdHRvbSAubWJzYy1mci1hcnItaScsIGV2LnRhcmdldCkucmVtb3ZlQ2xhc3MoJ3RvcCBicy1wb3BvdmVyLXRvcCcpLmFkZENsYXNzKCdib3R0b20gIGJzLXBvcG92ZXItYm90dG9tJyk7XG4gICAgfSwgMTApO1xuICB9XG59O1xudGhlbWVzJDEuc2Nyb2xsZXIuYm9vdHN0cmFwID0gZXh0ZW5kJDEoe30sIHRoZW1lcyQxLmZyYW1lLmJvb3RzdHJhcCwge1xuICBkYXRlRGlzcGxheTogJ01kZHl5JyxcbiAgYnRuQ2FsUHJldkNsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWxlZnQ1JyxcbiAgLy8gY2FsZW5kYXJcbiAgYnRuQ2FsTmV4dENsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LXJpZ2h0NScsXG4gIC8vIGNhbGVuZGFyXG4gIGJ0blBsdXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNSBidG4tbGlnaHQnLFxuICAvLyBzY3JvbGxlclxuICBidG5NaW51c0NsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LXVwNSBidG4tbGlnaHQnLFxuICAvLyBzY3JvbGxlclxuICBzZWxlY3RlZExpbmVIZWlnaHQ6IHRydWUsXG4gIG9uRXZlbnRCdWJibGVTaG93OiBmdW5jdGlvbiBvbkV2ZW50QnViYmxlU2hvdyhldikge1xuICAgIHZhciBldmMgPSAkJDEoZXYuZXZlbnRMaXN0KTtcbiAgICAkJDEoJy5tYnNjLWNhbC1ldmVudC1saXN0JywgZXZjKS5hZGRDbGFzcygnbGlzdC1ncm91cCcpO1xuICAgICQkMSgnLm1ic2MtY2FsLWV2ZW50JywgZXZjKS5hZGRDbGFzcygnbGlzdC1ncm91cC1pdGVtJyk7XG4gIH1cbn0pO1xudGhlbWVzJDEubmF2aWdhdGlvbi5ib290c3RyYXAgPSB7XG4gIHdyYXBwZXJDbGFzczogJ3BvcG92ZXIgcGFuZWwgcGFuZWwtZGVmYXVsdCcsXG4gIGdyb3VwQ2xhc3M6ICdidG4tZ3JvdXAnLFxuICBhY3RpdmVDbGFzczogJ2J0bi1wcmltYXJ5JyxcbiAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcbiAgaXRlbUNsYXNzOiAnYnRuIGJ0bi1kZWZhdWx0J1xufTtcbnRoZW1lcyQxLmZvcm0uYm9vdHN0cmFwID0ge307XG5cbnZhciB0aGVtZXMkMiA9IG1vYmlzY3JvbGwudGhlbWVzO1xudGhlbWVzJDIuZnJhbWUuaW9zID0ge1xuICBkaXNwbGF5OiAnYm90dG9tJyxcbiAgLy8gZnJhbWVcbiAgaGVhZGVyVGV4dDogZmFsc2UsXG4gIC8vIGZyYW1lXG4gIGJ0bldpZHRoOiBmYWxzZSxcbiAgLy8gZnJhbWVcbiAgZGVsZXRlSWNvbjogJ2lvcy1iYWNrc3BhY2UnLFxuICAvLyBudW1wYWRcbiAgc2Nyb2xsM2Q6IG9zICE9ICd3cCcgJiYgKG9zICE9ICdhbmRyb2lkJyB8fCBtYWpvclZlcnNpb24gPiA3KVxufTtcbnRoZW1lcyQyLnNjcm9sbGVyLmlvcyA9IGV4dGVuZCQxKHt9LCB0aGVtZXMkMi5mcmFtZS5pb3MsIHtcbiAgcm93czogNSxcbiAgLy8gc2Nyb2xsZXJcbiAgaGVpZ2h0OiAzNCxcbiAgLy8gc2Nyb2xsZXJcbiAgbWluV2lkdGg6IDU1LFxuICAvLyBzY3JvbGxlclxuICBzZWxlY3RlZExpbmVIZWlnaHQ6IHRydWUsXG4gIC8vIHNjcm9sbGVyXG4gIHNlbGVjdGVkTGluZUJvcmRlcjogMSxcbiAgLy8gc2Nyb2xsZXJcbiAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgLy8gc2Nyb2xsZXJcbiAgdXNlU2hvcnRMYWJlbHM6IHRydWUsXG4gIC8vIHRpbWVzcGFuL3RpbWVyXG4gIGJ0blBsdXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNScsXG4gIC8vIHNjcm9sbGVyXG4gIGJ0bk1pbnVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctdXA1JyxcbiAgLy8gc2Nyb2xsZXJcbiAgY2hlY2tJY29uOiAnaW9uLWlvczctY2hlY2ttYXJrLWVtcHR5JyxcbiAgLy8gc2VsZWN0XG4gIGZpbHRlckNsZWFySWNvbjogJ2lvbi1jbG9zZS1jaXJjbGVkJyxcbiAgLy8gc2VsZWN0XG4gIGRhdGVEaXNwbGF5OiAnTU1keXknLFxuICAvLyBkYXRlXG4gIGJ0bkNhbFByZXZDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1sZWZ0NScsXG4gIC8vIGNhbGVuZGFyXG4gIGJ0bkNhbE5leHRDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1yaWdodDUnIC8vIGNhbGVuZGFyXG5cbn0pO1xudGhlbWVzJDIubGlzdHZpZXcuaW9zID0ge1xuICBsZWZ0QXJyb3dDbGFzczogJ21ic2MtaWMtaW9uLWlvczctYXJyb3ctYmFjaycsXG4gIHJpZ2h0QXJyb3dDbGFzczogJ21ic2MtaWMtaW9uLWlvczctYXJyb3ctZm9yd2FyZCdcbn07XG50aGVtZXMkMi5mb3JtLmlvcyA9IHt9O1xuXG5mdW5jdGlvbiBfYWRkUmlwcGxlKCRjb250cm9sLCBldikge1xuICB2YXIgeCA9IGdldENvb3JkKGV2LCAnWCcsIHRydWUpLFxuICAgICAgeSA9IGdldENvb3JkKGV2LCAnWScsIHRydWUpLFxuICAgICAgY29udHJvbCA9ICRjb250cm9sWzBdLFxuICAgICAgcmVjdCA9ICRjb250cm9sLm9mZnNldCgpLFxuICAgICAgbGVmdCA9IHggLSByZWN0LmxlZnQsXG4gICAgICB0b3AgPSB5IC0gcmVjdC50b3AsXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGxlZnQsIGNvbnRyb2wub2Zmc2V0V2lkdGggLSBsZWZ0KSxcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KHRvcCwgY29udHJvbC5vZmZzZXRIZWlnaHQgLSB0b3ApLFxuICAgICAgc2l6ZSA9IDIgKiBNYXRoLnNxcnQoTWF0aC5wb3cod2lkdGgsIDIpICsgTWF0aC5wb3coaGVpZ2h0LCAyKSk7XG5cbiAgX3JlbW92ZVJpcHBsZSgkcmlwcGxlKTtcblxuICAkcmlwcGxlID0gJCQxKCc8c3BhbiBjbGFzcz1cIm1ic2MtcmlwcGxlXCI+PC9zcGFuPicpLmNzcyh7XG4gICAgYmFja2dyb3VuZENvbG9yOiBnZXRDb21wdXRlZFN0eWxlKGNvbnRyb2wpLmNvbG9yLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIGhlaWdodDogc2l6ZSxcbiAgICB0b3A6IHkgLSByZWN0LnRvcCAtIHNpemUgLyAyLFxuICAgIGxlZnQ6IHggLSByZWN0LmxlZnQgLSBzaXplIC8gMlxuICB9KS5hcHBlbmRUbygkY29udHJvbCk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICRyaXBwbGUuYWRkQ2xhc3MoJ21ic2MtcmlwcGxlLXNjYWxlZCBtYnNjLXJpcHBsZS12aXNpYmxlJyk7XG4gIH0sIDEwKTtcbn1cblxuZnVuY3Rpb24gX3JlbW92ZVJpcHBsZSgkcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJHIpIHtcbiAgICAgICRyLnJlbW92ZUNsYXNzKCdtYnNjLXJpcHBsZS12aXNpYmxlJyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHIucmVtb3ZlKCk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9XG4gIH0sIDEwMCk7XG59XG5cbmZ1bmN0aW9uIGluaXRSaXBwbGUoJG1hcmt1cCwgc2VsZWN0b3IsIGRpc2FibGVkLCBub2hsKSB7XG4gIHZhciBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICBtYXJrdXAgPSAkbWFya3VwWzBdO1xuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoZXYpIHtcbiAgICB2YXIgdGFyZ2V0ID0gY2xvc2VzdChtYXJrdXAsIGV2LnRhcmdldCwgc2VsZWN0b3IpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0ZXN0VG91Y2goZXYsIHRhcmdldCkpIHtcbiAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICAkYWN0aXZlJDEgPSAkJDEodGFyZ2V0KTtcblxuICAgICAgaWYgKCEkYWN0aXZlJDEuaGFzQ2xhc3MoZGlzYWJsZWQpICYmICEkYWN0aXZlJDEuaGFzQ2xhc3Mobm9obCkpIHtcbiAgICAgICAgX2FkZFJpcHBsZSgkYWN0aXZlJDEsIGV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhY3RpdmUkMSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgaWYgKCRhY3RpdmUkMSAmJiBNYXRoLmFicyhnZXRDb29yZChldiwgJ1gnKSAtIHN0YXJ0WCkgPiA5IHx8IE1hdGguYWJzKGdldENvb3JkKGV2LCAnWScpIC0gc3RhcnRZKSA+IDkpIHtcbiAgICAgIF9yZW1vdmVSaXBwbGUoJHJpcHBsZSk7XG5cbiAgICAgICRhY3RpdmUkMSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgaWYgKCRhY3RpdmUkMSkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9yZW1vdmVSaXBwbGUoJHJpcHBsZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgJGFjdGl2ZSQxID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAobWFya3VwKSB7XG4gICAgaWYgKG1hcmt1cC5fX21ic2NSaXBwbGVPZmYpIHtcbiAgICAgIG1hcmt1cC5fX21ic2NSaXBwbGVPZmYoKTtcbiAgICB9XG5cbiAgICBsaXN0ZW4obWFya3VwLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4obWFya3VwLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgbGlzdGVuKG1hcmt1cCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxpc3RlbihtYXJrdXAsICdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgIGxpc3RlbihtYXJrdXAsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICBsaXN0ZW4obWFya3VwLCAndG91Y2hjYW5jZWwnLCBvbkVuZCk7XG4gICAgbGlzdGVuKG1hcmt1cCwgJ21vdXNlbGVhdmUnLCBvbkVuZCk7XG4gICAgbGlzdGVuKG1hcmt1cCwgJ21vdXNldXAnLCBvbkVuZCk7XG5cbiAgICBtYXJrdXAuX19tYnNjUmlwcGxlT2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4obWFya3VwLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICdtb3VzZWRvd24nLCBvblN0YXJ0KTtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgICAgdW5saXN0ZW4obWFya3VwLCAnbW91c2VsZWF2ZScsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICBkZWxldGUgbWFya3VwLl9fbWJzY1JpcHBsZU9mZjtcbiAgICB9O1xuICB9XG59XG5cbnZhciAkYWN0aXZlJDEsXG4gICAgJHJpcHBsZSxcbiAgICB0aGVtZXMkMyA9IG1vYmlzY3JvbGwudGhlbWVzO1xudGhlbWVzJDMuZnJhbWUubWF0ZXJpYWwgPSB7XG4gIGhlYWRlclRleHQ6IGZhbHNlLFxuICBidG5XaWR0aDogZmFsc2UsXG4gIGRlbGV0ZUljb246ICdtYXRlcmlhbC1iYWNrc3BhY2UnLFxuICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgaW5pdFJpcHBsZSgkJDEoZXYudGFyZ2V0KSwgJy5tYnNjLWZyLWJ0bi1lJywgJ21ic2MtZGlzYWJsZWQnLCAnbWJzYy1mci1idG4tbmhsJyk7XG4gIH1cbn07XG50aGVtZXMkMy5zY3JvbGxlci5tYXRlcmlhbCA9IGV4dGVuZCQxKHt9LCB0aGVtZXMkMy5mcmFtZS5tYXRlcmlhbCwge1xuICBzaG93TGFiZWw6IGZhbHNlLFxuICBzZWxlY3RlZExpbmVCb3JkZXI6IDIsXG4gIHdlZWtEYXlzOiAnbWluJyxcbiAgaWNvbjoge1xuICAgIGZpbGxlZDogJ21hdGVyaWFsLXN0YXInLFxuICAgIGVtcHR5OiAnbWF0ZXJpYWwtc3Rhci1vdXRsaW5lJ1xuICB9LFxuICBjaGVja0ljb246ICdtYXRlcmlhbC1jaGVjaycsXG4gIGJ0blBsdXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy1kb3duJyxcbiAgYnRuTWludXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy11cCcsXG4gIGJ0bkNhbFByZXZDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy1sZWZ0JyxcbiAgYnRuQ2FsTmV4dENsYXNzOiAnbWJzYy1pYyBtYnNjLWljLW1hdGVyaWFsLWtleWJvYXJkLWFycm93LXJpZ2h0J1xufSk7XG50aGVtZXMkMy5saXN0dmlldy5tYXRlcmlhbCA9IHtcbiAgbGVmdEFycm93Q2xhc3M6ICdtYnNjLWljLW1hdGVyaWFsLWtleWJvYXJkLWFycm93LWxlZnQnLFxuICByaWdodEFycm93Q2xhc3M6ICdtYnNjLWljLW1hdGVyaWFsLWtleWJvYXJkLWFycm93LXJpZ2h0JyxcbiAgb25JdGVtQWN0aXZhdGU6IGZ1bmN0aW9uIG9uSXRlbUFjdGl2YXRlKGV2KSB7XG4gICAgX2FkZFJpcHBsZSgkJDEoZXYudGFyZ2V0KSwgZXYuZG9tRXZlbnQpO1xuICB9LFxuICBvbkl0ZW1EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkl0ZW1EZWFjdGl2YXRlKCkge1xuICAgIF9yZW1vdmVSaXBwbGUoJHJpcHBsZSk7XG4gIH0sXG4gIG9uU2xpZGVTdGFydDogZnVuY3Rpb24gb25TbGlkZVN0YXJ0KGV2KSB7XG4gICAgJCQxKCcubWJzYy1yaXBwbGUnLCBldi50YXJnZXQpLnJlbW92ZSgpO1xuICB9LFxuICBvblNvcnRTdGFydDogZnVuY3Rpb24gb25Tb3J0U3RhcnQoZXYpIHtcbiAgICAkJDEoJy5tYnNjLXJpcHBsZScsIGV2LnRhcmdldCkucmVtb3ZlKCk7XG4gIH1cbn07XG50aGVtZXMkMy5uYXZpZ2F0aW9uLm1hdGVyaWFsID0ge1xuICBvbkluaXQ6IGZ1bmN0aW9uIG9uSW5pdCgpIHtcbiAgICBpbml0UmlwcGxlKCQkMSh0aGlzKSwgJy5tYnNjLW1zLWl0ZW0ubWJzYy1idG4tZScsICdtYnNjLWRpc2FibGVkJywgJ21ic2MtYnRuLW5obCcpO1xuICB9LFxuICBvbk1hcmt1cEluaXQ6IGZ1bmN0aW9uIG9uTWFya3VwSW5pdCgpIHtcbiAgICAkJDEoJy5tYnNjLXJpcHBsZScsIHRoaXMpLnJlbW92ZSgpO1xuICB9LFxuICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fX21ic2NSaXBwbGVPZmYpIHtcbiAgICAgIHRoaXMuX19tYnNjUmlwcGxlT2ZmKCk7XG4gICAgfVxuICB9XG59O1xudGhlbWVzJDMuZm9ybS5tYXRlcmlhbCA9IHtcbiAgYWRkUmlwcGxlOiBmdW5jdGlvbiBhZGRSaXBwbGUoZWxtLCBldikge1xuICAgIF9hZGRSaXBwbGUoZWxtLCBldik7XG4gIH0sXG4gIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24gcmVtb3ZlUmlwcGxlKCkge1xuICAgIF9yZW1vdmVSaXBwbGUoJHJpcHBsZSk7XG4gIH1cbn07XG5cbnZhciB0aGVtZXMkNCA9IG1vYmlzY3JvbGwudGhlbWVzO1xudGhlbWVzJDQuZnJhbWUud2luZG93cyA9IHtcbiAgaGVhZGVyVGV4dDogZmFsc2UsXG4gIGRlbGV0ZUljb246ICdiYWNrc3BhY2U0JyxcbiAgLy9zZXRJY29uOiAnbWF0ZXJpYWwtY2hlY2snLFxuICAvL2NhbmNlbEljb246ICdtYXRlcmlhbC1jbG9zZScsXG4gIC8vY2xvc2VJY29uOiAnbWF0ZXJpYWwtY2xvc2UnLFxuICAvL2NsZWFySWNvbjogJ21hdGVyaWFsLWNsb3NlJyxcbiAgLy9va0ljb246ICdtYXRlcmlhbC1jaGVjaycsXG4gIC8vbm93SWNvbjogJ2xvb3AyJyxcbiAgLy9zdGFydEljb246ICdwbGF5MycsXG4gIC8vc3RvcEljb246ICdwYXVzZTInLFxuICAvL3Jlc2V0SWNvbjogJ3N0b3AyJyxcbiAgLy9sYXBJY29uOiAnbG9vcDInLFxuICAvL2J0bldpZHRoOiBmYWxzZSxcbiAgYnRuUmV2ZXJzZTogdHJ1ZVxufTtcbnRoZW1lcyQ0LnNjcm9sbGVyLndpbmRvd3MgPSBleHRlbmQkMSh7fSwgdGhlbWVzJDQuZnJhbWUud2luZG93cywge1xuICByb3dzOiA2LFxuICAvLyBzY3JvbGxlclxuICBtaW5XaWR0aDogODgsXG4gIGhlaWdodDogNDQsXG4gIGJ0blBsdXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNScsXG4gIGJ0bk1pbnVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctdXA1JyxcbiAgY2hlY2tJY29uOiAnbWF0ZXJpYWwtY2hlY2snLFxuICBkYXRlRGlzcGxheTogJ01NZHl5JyxcbiAgLy8gZGF0ZVxuICBzaG93TGFiZWw6IGZhbHNlLFxuICBzaG93U2Nyb2xsQXJyb3dzOiB0cnVlLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctbGVmdDUnLFxuICAvLyBjYWxlbmRhclxuICBidG5DYWxOZXh0Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctcmlnaHQ1JyxcbiAgLy8gY2FsZW5kYXJcbiAgZGF5TmFtZXNTaG9ydDogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddLFxuICB1c2VTaG9ydExhYmVsczogdHJ1ZSAvLyB0aW1lc3Bhbi90aW1lclxuXG59KTtcbnRoZW1lcyQ0LmZvcm0ud2luZG93cyA9IHt9O1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCdpb3MtZGFyaycsICdpb3MnKTtcblxubW9iaXNjcm9sbC5jdXN0b21UaGVtZSgnbWF0ZXJpYWwtZGFyaycsICdtYXRlcmlhbCcpO1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCdtb2Jpc2Nyb2xsLWRhcmsnLCAnbW9iaXNjcm9sbCcpO1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCd3aW5kb3dzLWRhcmsnLCAnd2luZG93cycpO1xuXG52YXIgdGhlbWVzJDUgPSBtb2Jpc2Nyb2xsLnRoZW1lcztcbnZhciB0aGVtZSA9ICdtb2Jpc2Nyb2xsJztcblxuaWYgKG9zID09ICdhbmRyb2lkJykge1xuICB0aGVtZSA9ICdtYXRlcmlhbCc7XG59IGVsc2UgaWYgKG9zID09ICdpb3MnKSB7XG4gIHRoZW1lID0gJ2lvcyc7XG59IGVsc2UgaWYgKG9zID09ICd3cCcpIHtcbiAgdGhlbWUgPSAnd2luZG93cyc7XG59XG5cbiQkMS5lYWNoKHRoZW1lcyQ1LmZyYW1lLCBmdW5jdGlvbiAoa2V5LCBzZXR0aW5ncykge1xuICAvLyBTdG9wIGF0IHRoZSBmaXJzdCBjdXN0b20gdGhlbWUgd2l0aCB0aGUgT1MgYmFzZSB0aGVtZVxuICBpZiAodGhlbWUgJiYgc2V0dGluZ3MuYmFzZVRoZW1lID09IHRoZW1lICYmIGtleSAhPSB0aGVtZSArICctZGFyaycpIHtcbiAgICBtb2Jpc2Nyb2xsLmF1dG9UaGVtZSA9IGtleTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoa2V5ID09IHRoZW1lKSB7XG4gICAgbW9iaXNjcm9sbC5hdXRvVGhlbWUgPSBrZXk7XG4gIH1cbn0pO1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCdpb3MtZ3JheScsICdpb3MnKTtcbm1vYmlzY3JvbGwuY3VzdG9tVGhlbWUoJ21hdGVyaWFsLWluZGlnbycsICdtYXRlcmlhbCcpO1xubW9iaXNjcm9sbC5jdXN0b21UaGVtZSgnbW9iaXNjcm9sbC1saW1lJywgJ21vYmlzY3JvbGwnKTtcbm1vYmlzY3JvbGwuY3VzdG9tVGhlbWUoJ3dpbmRvd3MteWVsbG93JywgJ3dpbmRvd3MnKTtcblxubW9iaXNjcm9sbC5hcGlLZXkgPSAnZjkwYzg3NTInO1xubW9iaXNjcm9sbC5hcGlVcmwgPSAnaHR0cHM6Ly90cmlhbC5tb2Jpc2Nyb2xsLmNvbS8nO1xubW9iaXNjcm9sbC5mdyA9ICdhbmd1bGFyJztcblxuZXhwb3J0IHsgTWJzY0FjY29yZGlvbiwgTWJzY0F2YXRhciwgTWJzY0JvdHRvbU5hdiwgTWJzY0J1dHRvbiwgTWJzY0NhbGVuZGFyLCBNYnNjQ2FsZW5kYXJDb21wb25lbnQsIE1ic2NDYWxlbmRhck1vZHVsZSwgTWJzY0NhcmQsIE1ic2NDYXJkQ29tcG9uZW50LCBNYnNjQ2FyZENvbnRlbnQsIE1ic2NDYXJkRm9vdGVyLCBNYnNjQ2FyZEhlYWRlciwgTWJzY0NhcmRNb2R1bGUsIE1ic2NDYXJkU3VidGl0bGUsIE1ic2NDYXJkVGl0bGUsIE1ic2NDaGVja2JveCwgTWJzY0NvbG9yLCBNYnNjQ29sb3JDb21wb25lbnQsIE1ic2NDb2xvck1vZHVsZSwgTWJzY0RhdGUsIE1ic2NEYXRlQ29tcG9uZW50LCBNYnNjRGF0ZXRpbWUsIE1ic2NEYXRldGltZUNvbXBvbmVudCwgTWJzY0RhdGV0aW1lTW9kdWxlLCBNYnNjRGlzdGFuY2UsIE1ic2NEaXN0YW5jZUNvbXBvbmVudCwgTWJzY0Ryb3Bkb3duLCBNYnNjRXZlbnRjYWxlbmRhciwgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsIE1ic2NFdmVudGNhbGVuZGFyTW9kdWxlLCBNYnNjRm9yY2UsIE1ic2NGb3JjZUNvbXBvbmVudCwgTWJzY0Zvcm0sIE1ic2NGb3JtR3JvdXAsIE1ic2NGb3JtR3JvdXBDb250ZW50LCBNYnNjRm9ybUdyb3VwVGl0bGUsIE1ic2NGb3Jtc01vZHVsZSwgTWJzY0hhbWJ1cmdlck5hdiwgTWJzY0ltYWdlLCBNYnNjSW1hZ2VDb21wb25lbnQsIE1ic2NJbWFnZUl0ZW0sIE1ic2NJbWFnZU1vZHVsZSwgTWJzY0lucHV0LCBNYnNjSW5wdXRNb2R1bGUsIE1ic2NMaXN0dmlldywgTWJzY0xpc3R2aWV3SGVhZGVyLCBNYnNjTGlzdHZpZXdJdGVtLCBNYnNjTGlzdHZpZXdNb2R1bGUsIE1ic2NMaXN0dmlld1N1Ymxpc3QsIE1ic2NNYXNzLCBNYnNjTWFzc0NvbXBvbmVudCwgTWJzY01lYXN1cmVtZW50LCBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQsIE1ic2NNZWFzdXJlbWVudE1vZHVsZSwgTWJzY01vZHVsZSwgTWJzY05hdiwgTWJzY05hdkl0ZW0sIE1ic2NOYXZpZ2F0aW9uTW9kdWxlLCBNYnNjTm90ZSwgTWJzY051bWJlciwgTWJzY051bWJlckNvbXBvbmVudCwgTWJzY051bWJlck1vZHVsZSwgTWJzY051bXBhZCwgTWJzY051bXBhZENvbXBvbmVudCwgTWJzY051bXBhZERhdGUsIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LCBNYnNjTnVtcGFkRGVjaW1hbCwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQsIE1ic2NOdW1wYWRNb2R1bGUsIE1ic2NOdW1wYWRUaW1lLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudCwgTWJzY051bXBhZFRpbWVzcGFuLCBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQsIE1ic2NPcHRpb25JdGVtLCBNYnNjT3B0aW9ubGlzdCwgTWJzY09wdGlvbmxpc3RNb2R1bGUsIE1ic2NQYWdlLCBNYnNjUGFnZU1vZHVsZSwgTWJzY1BvcHVwLCBNYnNjUG9wdXBNb2R1bGUsIE1ic2NQcm9ncmVzcywgTWJzY1JhZGlvLCBNYnNjUmFkaW9Hcm91cCwgTWJzY1JhbmdlLCBNYnNjUmFuZ2VDb21wb25lbnQsIE1ic2NSYW5nZUVuZENvbXBvbmVudCwgTWJzY1JhbmdlTW9kdWxlLCBNYnNjUmFuZ2VTdGFydENvbXBvbmVudCwgTWJzY1JhdGluZywgTWJzY1JvdXRlclRva2VuLCBNYnNjU2Nyb2xsVmlldywgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIE1ic2NTY3JvbGxWaWV3SXRlbSwgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50LCBNYnNjU2Nyb2xsVmlld01vZHVsZSwgTWJzY1Njcm9sbGVyLCBNYnNjU2Nyb2xsZXJDb21wb25lbnQsIE1ic2NTY3JvbGxlck1vZHVsZSwgTWJzY1NlZ21lbnRlZCwgTWJzY1NlZ21lbnRlZEdyb3VwLCBNYnNjU2VsZWN0LCBNYnNjU2VsZWN0Q29tcG9uZW50LCBNYnNjU2VsZWN0TW9kdWxlLCBNYnNjU2xpZGVyLCBNYnNjU3BlZWQsIE1ic2NTcGVlZENvbXBvbmVudCwgTWJzY1N0ZXBwZXIsIE1ic2NTd2l0Y2gsIE1ic2NUYWJOYXYsIE1ic2NUZW1wZXJhdHVyZSwgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LCBNYnNjVGV4dGFyZWEsIE1ic2NUaW1lLCBNYnNjVGltZUNvbXBvbmVudCwgTWJzY1RpbWVyLCBNYnNjVGltZXJDb21wb25lbnQsIE1ic2NUaW1lck1vZHVsZSwgTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnQsIE1ic2NUaW1lc3Bhbk1vZHVsZSwgTWJzY1RyZWVsaXN0LCBNYnNjVHJlZWxpc3RDb21wb25lbnQsIE1ic2NUcmVlbGlzdE1vZHVsZSwgTWJzY1dpZGdldCwgbW9iaXNjcm9sbCwgTWJzY09wdGlvbnNTZXJ2aWNlIGFzIMm1YSwgTWJzY0lucHV0U2VydmljZSBhcyDJtWIsIE1ic2NDYWxCYXNlTW9kdWxlIGFzIMm1YmEsIE1ic2NEYXRldGltZUJhc2UgYXMgybViYiwgTWJzY0RhdGV0aW1lQmFzZU1vZHVsZSBhcyDJtWJjLCBNYnNjTmF2SXRlbUJhc2UgYXMgybViZCwgTWJzY05hdmlnYXRpb25CYXNlIGFzIMm1YmUsIE1ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZSBhcyDJtWJmLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2UgYXMgybViZywgTWJzY1Njcm9sbEl0ZW1CYXNlIGFzIMm1YmgsIE1ic2NTY3JvbGxWaWV3QmFzZSBhcyDJtWJpLCBNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGUgYXMgybViaiwgTWJzY0xpc3RTZXJ2aWNlIGFzIMm1YywgTWJzY0Jhc2UgYXMgybVkLCBNYnNjVmFsdWVCYXNlIGFzIMm1ZSwgTWJzY0Nsb25lQmFzZSBhcyDJtWYsIE1ic2NDb250cm9sQmFzZSBhcyDJtWcsIE1ic2NGcmFtZUJhc2UgYXMgybVoLCBNYnNjU2Nyb2xsZXJCYXNlIGFzIMm1aSwgTWJzY0Jhc2VNb2R1bGUgYXMgybVqLCBNYnNjRnJhbWVCYXNlTW9kdWxlIGFzIMm1aywgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSBhcyDJtWwsIElOUFVUX1RFTVBMQVRFIGFzIMm1bSwgTWJzY0RhdGVCYXNlIGFzIMm1biwgTWJzY0Zvcm1CYXNlIGFzIMm1bywgTWJzY0Zvcm1WYWx1ZUJhc2UgYXMgybVwLCBNYnNjSW5wdXRCYXNlIGFzIMm1cSwgTWJzY1JhZGlvU2VydmljZSBhcyDJtXIsIE1ic2NSYWRpb0dyb3VwQmFzZSBhcyDJtXMsIE1ic2NMaXN0dmlld1NlcnZpY2UgYXMgybV0LCBNYnNjU3VibGlzdFNlcnZpY2UgYXMgybV1LCBNYnNjTGlzdGl0ZW1TZXJ2aWNlIGFzIMm1diwgTWJzY01lYXN1cmVtZW50QmFzZSBhcyDJtXcsIE1ic2NNZWFzdXJlbWVudENoaWxkIGFzIMm1eCwgTWJzY051bXBhZEJhc2UgYXMgybV5LCBNYnNjQ2FsQmFzZSBhcyDJtXogfTtcbiJdfQ==